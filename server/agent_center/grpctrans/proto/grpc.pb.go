// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: grpc.proto

package grpc

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// pb for config refresh
type ConfigStatusCode int32

const (
	ConfigStatusCode_SUCCESS ConfigStatusCode = 0
	ConfigStatusCode_FAILED  ConfigStatusCode = 1
)

var ConfigStatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED",
}

var ConfigStatusCode_value = map[string]int32{
	"SUCCESS": 0,
	"FAILED":  1,
}

func (x ConfigStatusCode) String() string {
	return proto.EnumName(ConfigStatusCode_name, int32(x))
}

func (ConfigStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{0}
}

type ConfigTypeCode int32

const (
	ConfigTypeCode_File   ConfigTypeCode = 0
	ConfigTypeCode_Config ConfigTypeCode = 1
	ConfigTypeCode_Remove ConfigTypeCode = 2
)

var ConfigTypeCode_name = map[int32]string{
	0: "File",
	1: "Config",
	2: "Remove",
}

var ConfigTypeCode_value = map[string]int32{
	"File":   0,
	"Config": 1,
	"Remove": 2,
}

func (x ConfigTypeCode) String() string {
	return proto.EnumName(ConfigTypeCode_name, int32(x))
}

func (ConfigTypeCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{1}
}

type ConfigFPStatusCode int32

const (
	ConfigFPStatusCode_Exist       ConfigFPStatusCode = 0
	ConfigFPStatusCode_Nonexistent ConfigFPStatusCode = 1
)

var ConfigFPStatusCode_name = map[int32]string{
	0: "Exist",
	1: "Nonexistent",
}

var ConfigFPStatusCode_value = map[string]int32{
	"Exist":       0,
	"Nonexistent": 1,
}

func (x ConfigFPStatusCode) String() string {
	return proto.EnumName(ConfigFPStatusCode_name, int32(x))
}

func (ConfigFPStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{2}
}

// 定义代理连接状态枚举
type ProxyStatus int32

const (
	ProxyStatus_CONNECTED              ProxyStatus = 0
	ProxyStatus_CONNECTION_HTTP_FAILED ProxyStatus = 1
	ProxyStatus_UNKNOWN_ERROR          ProxyStatus = 2
)

var ProxyStatus_name = map[int32]string{
	0: "CONNECTED",
	1: "CONNECTION_HTTP_FAILED",
	2: "UNKNOWN_ERROR",
}

var ProxyStatus_value = map[string]int32{
	"CONNECTED":              0,
	"CONNECTION_HTTP_FAILED": 1,
	"UNKNOWN_ERROR":          2,
}

func (x ProxyStatus) String() string {
	return proto.EnumName(ProxyStatus_name, int32(x))
}

func (ProxyStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{3}
}

type UploadResponse_StatusCode int32

const (
	UploadResponse_SUCCESS UploadResponse_StatusCode = 0
	UploadResponse_FAILED  UploadResponse_StatusCode = 1
)

var UploadResponse_StatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED",
}

var UploadResponse_StatusCode_value = map[string]int32{
	"SUCCESS": 0,
	"FAILED":  1,
}

func (x UploadResponse_StatusCode) String() string {
	return proto.EnumName(UploadResponse_StatusCode_name, int32(x))
}

func (UploadResponse_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{11, 0}
}

// pb for rawdata
// agent --> server
type RawData struct {
	Data                 []*Record `protobuf:"bytes,1,rep,name=Data,proto3" json:"Data,omitempty"`
	AgentID              string    `protobuf:"bytes,2,opt,name=AgentID,proto3" json:"AgentID,omitempty"`
	IntranetIPv4         []string  `protobuf:"bytes,3,rep,name=IntranetIPv4,proto3" json:"IntranetIPv4,omitempty"`
	ExtranetIPv4         []string  `protobuf:"bytes,4,rep,name=ExtranetIPv4,proto3" json:"ExtranetIPv4,omitempty"`
	IntranetIPv6         []string  `protobuf:"bytes,5,rep,name=IntranetIPv6,proto3" json:"IntranetIPv6,omitempty"`
	ExtranetIPv6         []string  `protobuf:"bytes,6,rep,name=ExtranetIPv6,proto3" json:"ExtranetIPv6,omitempty"`
	Hostname             string    `protobuf:"bytes,7,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	Version              string    `protobuf:"bytes,8,opt,name=Version,proto3" json:"Version,omitempty"`
	Product              string    `protobuf:"bytes,9,opt,name=Product,proto3" json:"Product,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RawData) Reset()         { *m = RawData{} }
func (m *RawData) String() string { return proto.CompactTextString(m) }
func (*RawData) ProtoMessage()    {}
func (*RawData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{0}
}
func (m *RawData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawData.Merge(m, src)
}
func (m *RawData) XXX_Size() int {
	return m.Size()
}
func (m *RawData) XXX_DiscardUnknown() {
	xxx_messageInfo_RawData.DiscardUnknown(m)
}

var xxx_messageInfo_RawData proto.InternalMessageInfo

func (m *RawData) GetData() []*Record {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *RawData) GetAgentID() string {
	if m != nil {
		return m.AgentID
	}
	return ""
}

func (m *RawData) GetIntranetIPv4() []string {
	if m != nil {
		return m.IntranetIPv4
	}
	return nil
}

func (m *RawData) GetExtranetIPv4() []string {
	if m != nil {
		return m.ExtranetIPv4
	}
	return nil
}

func (m *RawData) GetIntranetIPv6() []string {
	if m != nil {
		return m.IntranetIPv6
	}
	return nil
}

func (m *RawData) GetExtranetIPv6() []string {
	if m != nil {
		return m.ExtranetIPv6
	}
	return nil
}

func (m *RawData) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *RawData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *RawData) GetProduct() string {
	if m != nil {
		return m.Product
	}
	return ""
}

type Record struct {
	DataType             int32    `protobuf:"varint,1,opt,name=DataType,proto3" json:"DataType,omitempty"`
	Timestamp            int64    `protobuf:"varint,2,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Body                 []byte   `protobuf:"bytes,3,opt,name=Body,proto3" json:"Body,omitempty"`
	AppendedBody         []byte   `protobuf:"bytes,4,opt,name=AppendedBody,proto3" json:"AppendedBody,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Record) Reset()         { *m = Record{} }
func (m *Record) String() string { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()    {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{1}
}
func (m *Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Record.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return m.Size()
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

func (m *Record) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *Record) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Record) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Record) GetAppendedBody() []byte {
	if m != nil {
		return m.AppendedBody
	}
	return nil
}

type Item struct {
	Fields               map[string]string `protobuf:"bytes,1,rep,name=Fields,proto3" json:"Fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{2}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Field struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{3}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Field) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type ItemArray struct {
	Fields               []*Field `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ItemArray) Reset()         { *m = ItemArray{} }
func (m *ItemArray) String() string { return proto.CompactTextString(m) }
func (*ItemArray) ProtoMessage()    {}
func (*ItemArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{4}
}
func (m *ItemArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemArray.Merge(m, src)
}
func (m *ItemArray) XXX_Size() int {
	return m.Size()
}
func (m *ItemArray) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemArray.DiscardUnknown(m)
}

var xxx_messageInfo_ItemArray proto.InternalMessageInfo

func (m *ItemArray) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// server --> agent
type Command struct {
	AgentCtrl            int32         `protobuf:"varint,1,opt,name=AgentCtrl,proto3" json:"AgentCtrl,omitempty"`
	Task                 *PluginTask   `protobuf:"bytes,2,opt,name=Task,proto3" json:"Task,omitempty"`
	Config               []*ConfigItem `protobuf:"bytes,3,rep,name=Config,proto3" json:"Config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{5}
}
func (m *Command) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Command.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return m.Size()
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

func (m *Command) GetAgentCtrl() int32 {
	if m != nil {
		return m.AgentCtrl
	}
	return 0
}

func (m *Command) GetTask() *PluginTask {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *Command) GetConfig() []*ConfigItem {
	if m != nil {
		return m.Config
	}
	return nil
}

type PluginTask struct {
	// 新增DataType对Data进行控制
	DataType int32 `protobuf:"varint,1,opt,name=DataType,proto3" json:"DataType,omitempty"`
	// 插件名字
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// JSON
	Data string `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	// 对账
	Token                string   `protobuf:"bytes,4,opt,name=Token,proto3" json:"Token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginTask) Reset()         { *m = PluginTask{} }
func (m *PluginTask) String() string { return proto.CompactTextString(m) }
func (*PluginTask) ProtoMessage()    {}
func (*PluginTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{6}
}
func (m *PluginTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginTask.Merge(m, src)
}
func (m *PluginTask) XXX_Size() int {
	return m.Size()
}
func (m *PluginTask) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginTask.DiscardUnknown(m)
}

var xxx_messageInfo_PluginTask proto.InternalMessageInfo

func (m *PluginTask) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *PluginTask) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PluginTask) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *PluginTask) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type ConfigItem struct {
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type                 string   `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Version              string   `protobuf:"bytes,3,opt,name=Version,proto3" json:"Version,omitempty"`
	SHA256               string   `protobuf:"bytes,4,opt,name=SHA256,proto3" json:"SHA256,omitempty"`
	Signature            string   `protobuf:"bytes,5,opt,name=Signature,proto3" json:"Signature,omitempty"`
	DownloadURL          []string `protobuf:"bytes,6,rep,name=DownloadURL,proto3" json:"DownloadURL,omitempty"`
	Detail               string   `protobuf:"bytes,7,opt,name=Detail,proto3" json:"Detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigItem) Reset()         { *m = ConfigItem{} }
func (m *ConfigItem) String() string { return proto.CompactTextString(m) }
func (*ConfigItem) ProtoMessage()    {}
func (*ConfigItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{7}
}
func (m *ConfigItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigItem.Merge(m, src)
}
func (m *ConfigItem) XXX_Size() int {
	return m.Size()
}
func (m *ConfigItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigItem.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigItem proto.InternalMessageInfo

func (m *ConfigItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigItem) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ConfigItem) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ConfigItem) GetSHA256() string {
	if m != nil {
		return m.SHA256
	}
	return ""
}

func (m *ConfigItem) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *ConfigItem) GetDownloadURL() []string {
	if m != nil {
		return m.DownloadURL
	}
	return nil
}

func (m *ConfigItem) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

// server -> bmq
type MQData struct {
	DataType     int32  `protobuf:"varint,1,opt,name=DataType,proto3" json:"DataType,omitempty"`
	AgentTime    int64  `protobuf:"varint,2,opt,name=AgentTime,proto3" json:"AgentTime,omitempty"`
	Body         []byte `protobuf:"bytes,3,opt,name=Body,proto3" json:"Body,omitempty"`
	AgentID      string `protobuf:"bytes,4,opt,name=AgentID,proto3" json:"AgentID,omitempty"`
	IntranetIPv4 string `protobuf:"bytes,5,opt,name=IntranetIPv4,proto3" json:"IntranetIPv4,omitempty"`
	ExtranetIPv4 string `protobuf:"bytes,6,opt,name=ExtranetIPv4,proto3" json:"ExtranetIPv4,omitempty"`
	IntranetIPv6 string `protobuf:"bytes,7,opt,name=IntranetIPv6,proto3" json:"IntranetIPv6,omitempty"`
	ExtranetIPv6 string `protobuf:"bytes,8,opt,name=ExtranetIPv6,proto3" json:"ExtranetIPv6,omitempty"`
	Hostname     string `protobuf:"bytes,9,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	Version      string `protobuf:"bytes,10,opt,name=Version,proto3" json:"Version,omitempty"`
	Product      string `protobuf:"bytes,11,opt,name=Product,proto3" json:"Product,omitempty"`
	// server端补全字段
	SvrTime              int64    `protobuf:"varint,12,opt,name=SvrTime,proto3" json:"SvrTime,omitempty"`
	PSMName              string   `protobuf:"bytes,13,opt,name=PSMName,proto3" json:"PSMName,omitempty"`
	PSMPath              string   `protobuf:"bytes,14,opt,name=PSMPath,proto3" json:"PSMPath,omitempty"`
	Tag                  string   `protobuf:"bytes,15,opt,name=Tag,proto3" json:"Tag,omitempty"`
	Enhanced             string   `protobuf:"bytes,16,opt,name=Enhanced,proto3" json:"Enhanced,omitempty"`
	IsHoneypot           string   `protobuf:"bytes,17,opt,name=IsHoneypot,proto3" json:"IsHoneypot,omitempty"`
	AppendedBody         []byte   `protobuf:"bytes,18,opt,name=AppendedBody,proto3" json:"AppendedBody,omitempty"`
	AccountID            string   `protobuf:"bytes,19,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MQData) Reset()         { *m = MQData{} }
func (m *MQData) String() string { return proto.CompactTextString(m) }
func (*MQData) ProtoMessage()    {}
func (*MQData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{8}
}
func (m *MQData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MQData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MQData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MQData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MQData.Merge(m, src)
}
func (m *MQData) XXX_Size() int {
	return m.Size()
}
func (m *MQData) XXX_DiscardUnknown() {
	xxx_messageInfo_MQData.DiscardUnknown(m)
}

var xxx_messageInfo_MQData proto.InternalMessageInfo

func (m *MQData) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *MQData) GetAgentTime() int64 {
	if m != nil {
		return m.AgentTime
	}
	return 0
}

func (m *MQData) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *MQData) GetAgentID() string {
	if m != nil {
		return m.AgentID
	}
	return ""
}

func (m *MQData) GetIntranetIPv4() string {
	if m != nil {
		return m.IntranetIPv4
	}
	return ""
}

func (m *MQData) GetExtranetIPv4() string {
	if m != nil {
		return m.ExtranetIPv4
	}
	return ""
}

func (m *MQData) GetIntranetIPv6() string {
	if m != nil {
		return m.IntranetIPv6
	}
	return ""
}

func (m *MQData) GetExtranetIPv6() string {
	if m != nil {
		return m.ExtranetIPv6
	}
	return ""
}

func (m *MQData) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *MQData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *MQData) GetProduct() string {
	if m != nil {
		return m.Product
	}
	return ""
}

func (m *MQData) GetSvrTime() int64 {
	if m != nil {
		return m.SvrTime
	}
	return 0
}

func (m *MQData) GetPSMName() string {
	if m != nil {
		return m.PSMName
	}
	return ""
}

func (m *MQData) GetPSMPath() string {
	if m != nil {
		return m.PSMPath
	}
	return ""
}

func (m *MQData) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *MQData) GetEnhanced() string {
	if m != nil {
		return m.Enhanced
	}
	return ""
}

func (m *MQData) GetIsHoneypot() string {
	if m != nil {
		return m.IsHoneypot
	}
	return ""
}

func (m *MQData) GetAppendedBody() []byte {
	if m != nil {
		return m.AppendedBody
	}
	return nil
}

func (m *MQData) GetAccountID() string {
	if m != nil {
		return m.AccountID
	}
	return ""
}

// bmq --> Rule engine
type MQRawData struct {
	DataType     int32  `protobuf:"varint,1,opt,name=DataType,proto3" json:"DataType,omitempty"`
	AgentTime    int64  `protobuf:"varint,2,opt,name=AgentTime,proto3" json:"AgentTime,omitempty"`
	Body         *Item  `protobuf:"bytes,3,opt,name=Body,proto3" json:"Body,omitempty"`
	AgentID      string `protobuf:"bytes,4,opt,name=AgentID,proto3" json:"AgentID,omitempty"`
	IntranetIPv4 string `protobuf:"bytes,5,opt,name=IntranetIPv4,proto3" json:"IntranetIPv4,omitempty"`
	ExtranetIPv4 string `protobuf:"bytes,6,opt,name=ExtranetIPv4,proto3" json:"ExtranetIPv4,omitempty"`
	IntranetIPv6 string `protobuf:"bytes,7,opt,name=IntranetIPv6,proto3" json:"IntranetIPv6,omitempty"`
	ExtranetIPv6 string `protobuf:"bytes,8,opt,name=ExtranetIPv6,proto3" json:"ExtranetIPv6,omitempty"`
	Hostname     string `protobuf:"bytes,9,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	Version      string `protobuf:"bytes,10,opt,name=Version,proto3" json:"Version,omitempty"`
	Product      string `protobuf:"bytes,11,opt,name=Product,proto3" json:"Product,omitempty"`
	// server端补全字段
	SvrTime    int64  `protobuf:"varint,12,opt,name=SvrTime,proto3" json:"SvrTime,omitempty"`
	PSMName    string `protobuf:"bytes,13,opt,name=PSMName,proto3" json:"PSMName,omitempty"`
	PSMPath    string `protobuf:"bytes,14,opt,name=PSMPath,proto3" json:"PSMPath,omitempty"`
	Tag        string `protobuf:"bytes,15,opt,name=Tag,proto3" json:"Tag,omitempty"`
	Enhanced   string `protobuf:"bytes,16,opt,name=Enhanced,proto3" json:"Enhanced,omitempty"`
	IsHoneypot string `protobuf:"bytes,17,opt,name=IsHoneypot,proto3" json:"IsHoneypot,omitempty"`
	// agent appended字段
	AppendedBody         *ItemArray `protobuf:"bytes,18,opt,name=AppendedBody,proto3" json:"AppendedBody,omitempty"`
	AccountID            string     `protobuf:"bytes,19,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MQRawData) Reset()         { *m = MQRawData{} }
func (m *MQRawData) String() string { return proto.CompactTextString(m) }
func (*MQRawData) ProtoMessage()    {}
func (*MQRawData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{9}
}
func (m *MQRawData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MQRawData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MQRawData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MQRawData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MQRawData.Merge(m, src)
}
func (m *MQRawData) XXX_Size() int {
	return m.Size()
}
func (m *MQRawData) XXX_DiscardUnknown() {
	xxx_messageInfo_MQRawData.DiscardUnknown(m)
}

var xxx_messageInfo_MQRawData proto.InternalMessageInfo

func (m *MQRawData) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *MQRawData) GetAgentTime() int64 {
	if m != nil {
		return m.AgentTime
	}
	return 0
}

func (m *MQRawData) GetBody() *Item {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *MQRawData) GetAgentID() string {
	if m != nil {
		return m.AgentID
	}
	return ""
}

func (m *MQRawData) GetIntranetIPv4() string {
	if m != nil {
		return m.IntranetIPv4
	}
	return ""
}

func (m *MQRawData) GetExtranetIPv4() string {
	if m != nil {
		return m.ExtranetIPv4
	}
	return ""
}

func (m *MQRawData) GetIntranetIPv6() string {
	if m != nil {
		return m.IntranetIPv6
	}
	return ""
}

func (m *MQRawData) GetExtranetIPv6() string {
	if m != nil {
		return m.ExtranetIPv6
	}
	return ""
}

func (m *MQRawData) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *MQRawData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *MQRawData) GetProduct() string {
	if m != nil {
		return m.Product
	}
	return ""
}

func (m *MQRawData) GetSvrTime() int64 {
	if m != nil {
		return m.SvrTime
	}
	return 0
}

func (m *MQRawData) GetPSMName() string {
	if m != nil {
		return m.PSMName
	}
	return ""
}

func (m *MQRawData) GetPSMPath() string {
	if m != nil {
		return m.PSMPath
	}
	return ""
}

func (m *MQRawData) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *MQRawData) GetEnhanced() string {
	if m != nil {
		return m.Enhanced
	}
	return ""
}

func (m *MQRawData) GetIsHoneypot() string {
	if m != nil {
		return m.IsHoneypot
	}
	return ""
}

func (m *MQRawData) GetAppendedBody() *ItemArray {
	if m != nil {
		return m.AppendedBody
	}
	return nil
}

func (m *MQRawData) GetAccountID() string {
	if m != nil {
		return m.AccountID
	}
	return ""
}

// pb for file upload
type UploadRequest struct {
	Token                string   `protobuf:"bytes,1,opt,name=Token,proto3" json:"Token,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadRequest) Reset()         { *m = UploadRequest{} }
func (m *UploadRequest) String() string { return proto.CompactTextString(m) }
func (*UploadRequest) ProtoMessage()    {}
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{10}
}
func (m *UploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest.Merge(m, src)
}
func (m *UploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest proto.InternalMessageInfo

func (m *UploadRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UploadRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type UploadResponse struct {
	Status               UploadResponse_StatusCode `protobuf:"varint,1,opt,name=Status,proto3,enum=grpc.UploadResponse_StatusCode" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *UploadResponse) Reset()         { *m = UploadResponse{} }
func (m *UploadResponse) String() string { return proto.CompactTextString(m) }
func (*UploadResponse) ProtoMessage()    {}
func (*UploadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{11}
}
func (m *UploadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadResponse.Merge(m, src)
}
func (m *UploadResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadResponse proto.InternalMessageInfo

func (m *UploadResponse) GetStatus() UploadResponse_StatusCode {
	if m != nil {
		return m.Status
	}
	return UploadResponse_SUCCESS
}

type DownloadRequest struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadRequest) Reset()         { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()    {}
func (*DownloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{12}
}
func (m *DownloadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadRequest.Merge(m, src)
}
func (m *DownloadRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadRequest proto.InternalMessageInfo

func (m *DownloadRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type DownloadResponse struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadResponse) Reset()         { *m = DownloadResponse{} }
func (m *DownloadResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadResponse) ProtoMessage()    {}
func (*DownloadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{13}
}
func (m *DownloadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadResponse.Merge(m, src)
}
func (m *DownloadResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadResponse proto.InternalMessageInfo

func (m *DownloadResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ConfigRefreshRequest struct {
	AgentID              string               `protobuf:"bytes,1,opt,name=AgentID,proto3" json:"agent_id,omitempty"`
	PluginName           string               `protobuf:"bytes,2,opt,name=PluginName,proto3" json:"plugin,omitempty"`
	Fingerprint          []*ConfigFingerPrint `protobuf:"bytes,3,rep,name=Fingerprint,proto3" json:"configs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ConfigRefreshRequest) Reset()         { *m = ConfigRefreshRequest{} }
func (m *ConfigRefreshRequest) String() string { return proto.CompactTextString(m) }
func (*ConfigRefreshRequest) ProtoMessage()    {}
func (*ConfigRefreshRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{14}
}
func (m *ConfigRefreshRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigRefreshRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigRefreshRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigRefreshRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigRefreshRequest.Merge(m, src)
}
func (m *ConfigRefreshRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConfigRefreshRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigRefreshRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigRefreshRequest proto.InternalMessageInfo

func (m *ConfigRefreshRequest) GetAgentID() string {
	if m != nil {
		return m.AgentID
	}
	return ""
}

func (m *ConfigRefreshRequest) GetPluginName() string {
	if m != nil {
		return m.PluginName
	}
	return ""
}

func (m *ConfigRefreshRequest) GetFingerprint() []*ConfigFingerPrint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

type ConfigFingerPrint struct {
	Path                 string             `protobuf:"bytes,1,opt,name=Path,proto3" json:"path,omitempty"`
	Hash                 string             `protobuf:"bytes,2,opt,name=Hash,proto3" json:"hash,omitempty"`
	Status               ConfigFPStatusCode `protobuf:"varint,3,opt,name=Status,proto3,enum=grpc.ConfigFPStatusCode" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ConfigFingerPrint) Reset()         { *m = ConfigFingerPrint{} }
func (m *ConfigFingerPrint) String() string { return proto.CompactTextString(m) }
func (*ConfigFingerPrint) ProtoMessage()    {}
func (*ConfigFingerPrint) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{15}
}
func (m *ConfigFingerPrint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigFingerPrint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigFingerPrint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigFingerPrint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigFingerPrint.Merge(m, src)
}
func (m *ConfigFingerPrint) XXX_Size() int {
	return m.Size()
}
func (m *ConfigFingerPrint) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigFingerPrint.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigFingerPrint proto.InternalMessageInfo

func (m *ConfigFingerPrint) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ConfigFingerPrint) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ConfigFingerPrint) GetStatus() ConfigFPStatusCode {
	if m != nil {
		return m.Status
	}
	return ConfigFPStatusCode_Exist
}

type ConfigRefreshResponse struct {
	PluginName           string           `protobuf:"bytes,1,opt,name=PluginName,proto3" json:"PluginName,omitempty"`
	SecretKey            string           `protobuf:"bytes,2,opt,name=SecretKey,proto3" json:"SecretKey,omitempty"`
	Version              string           `protobuf:"bytes,3,opt,name=Version,proto3" json:"Version,omitempty"`
	Release              uint64           `protobuf:"varint,4,opt,name=Release,proto3" json:"Release,omitempty"`
	Status               ConfigStatusCode `protobuf:"varint,5,opt,name=Status,proto3,enum=grpc.ConfigStatusCode" json:"Status,omitempty"`
	Config               []*ConfigDetail  `protobuf:"bytes,6,rep,name=Config,proto3" json:"Config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ConfigRefreshResponse) Reset()         { *m = ConfigRefreshResponse{} }
func (m *ConfigRefreshResponse) String() string { return proto.CompactTextString(m) }
func (*ConfigRefreshResponse) ProtoMessage()    {}
func (*ConfigRefreshResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{16}
}
func (m *ConfigRefreshResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigRefreshResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigRefreshResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigRefreshResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigRefreshResponse.Merge(m, src)
}
func (m *ConfigRefreshResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConfigRefreshResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigRefreshResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigRefreshResponse proto.InternalMessageInfo

func (m *ConfigRefreshResponse) GetPluginName() string {
	if m != nil {
		return m.PluginName
	}
	return ""
}

func (m *ConfigRefreshResponse) GetSecretKey() string {
	if m != nil {
		return m.SecretKey
	}
	return ""
}

func (m *ConfigRefreshResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ConfigRefreshResponse) GetRelease() uint64 {
	if m != nil {
		return m.Release
	}
	return 0
}

func (m *ConfigRefreshResponse) GetStatus() ConfigStatusCode {
	if m != nil {
		return m.Status
	}
	return ConfigStatusCode_SUCCESS
}

func (m *ConfigRefreshResponse) GetConfig() []*ConfigDetail {
	if m != nil {
		return m.Config
	}
	return nil
}

type ConfigDetail struct {
	Path                 string           `protobuf:"bytes,1,opt,name=Path,proto3" json:"path,omitempty"`
	Status               ConfigStatusCode `protobuf:"varint,2,opt,name=Status,proto3,enum=grpc.ConfigStatusCode" json:"status,omitempty"`
	Data                 string           `protobuf:"bytes,3,opt,name=Data,proto3" json:"data,omitempty"`
	Type                 ConfigTypeCode   `protobuf:"varint,4,opt,name=Type,proto3,enum=grpc.ConfigTypeCode" json:"type,omitempty"`
	Hash                 string           `protobuf:"bytes,5,opt,name=Hash,proto3" json:"hash,omitempty"`
	Detail               string           `protobuf:"bytes,6,opt,name=Detail,proto3" json:"detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ConfigDetail) Reset()         { *m = ConfigDetail{} }
func (m *ConfigDetail) String() string { return proto.CompactTextString(m) }
func (*ConfigDetail) ProtoMessage()    {}
func (*ConfigDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{17}
}
func (m *ConfigDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigDetail.Merge(m, src)
}
func (m *ConfigDetail) XXX_Size() int {
	return m.Size()
}
func (m *ConfigDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigDetail proto.InternalMessageInfo

func (m *ConfigDetail) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ConfigDetail) GetStatus() ConfigStatusCode {
	if m != nil {
		return m.Status
	}
	return ConfigStatusCode_SUCCESS
}

func (m *ConfigDetail) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ConfigDetail) GetType() ConfigTypeCode {
	if m != nil {
		return m.Type
	}
	return ConfigTypeCode_File
}

func (m *ConfigDetail) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ConfigDetail) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

// 定义心跳请求消息
type HeartbeatRequest struct {
	ProxyID              string            `protobuf:"bytes,1,opt,name=ProxyID,proto3" json:"proxy_id,omitempty"`
	ProxyLocalID         string            `protobuf:"bytes,2,opt,name=ProxyLocalID,proto3" json:"proxy_local_id,omitempty"`
	IntranetIPv4         []string          `protobuf:"bytes,3,rep,name=IntranetIPv4,proto3" json:"intranet_ipv4,omitempty"`
	ExtranetIPv4         []string          `protobuf:"bytes,4,rep,name=ExtranetIPv4,proto3" json:"extranet_ipv4,omitempty"`
	IntranetIPv6         []string          `protobuf:"bytes,5,rep,name=IntranetIPv6,proto3" json:"intranet_ipv6,omitempty"`
	ExtranetIPv6         []string          `protobuf:"bytes,6,rep,name=ExtranetIPv6,proto3" json:"extranet_ipv6,omitempty"`
	Hostname             string            `protobuf:"bytes,7,opt,name=Hostname,proto3" json:"hostname,omitempty"`
	Version              string            `protobuf:"bytes,8,opt,name=Version,proto3" json:"version,omitempty"`
	ConnectedAgents      []string          `protobuf:"bytes,9,rep,name=ConnectedAgents,proto3" json:"connected_agents,omitempty"`
	ProxyStartTime       int64             `protobuf:"varint,10,opt,name=ProxyStartTime,proto3" json:"proxy_start_time,omitempty"`
	ProxyStatus          ProxyStatus       `protobuf:"varint,11,opt,name=ProxyStatus,proto3,enum=grpc.ProxyStatus" json:"proxy_status,omitempty"`
	StatusMessage        string            `protobuf:"bytes,12,opt,name=StatusMessage,proto3" json:"status_message,omitempty"`
	DetailedStatus       map[string]string `protobuf:"bytes,13,rep,name=DetailedStatus,proto3" json:"detailed_status,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HeartbeatRequest) Reset()         { *m = HeartbeatRequest{} }
func (m *HeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*HeartbeatRequest) ProtoMessage()    {}
func (*HeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{18}
}
func (m *HeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatRequest.Merge(m, src)
}
func (m *HeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatRequest proto.InternalMessageInfo

func (m *HeartbeatRequest) GetProxyID() string {
	if m != nil {
		return m.ProxyID
	}
	return ""
}

func (m *HeartbeatRequest) GetProxyLocalID() string {
	if m != nil {
		return m.ProxyLocalID
	}
	return ""
}

func (m *HeartbeatRequest) GetIntranetIPv4() []string {
	if m != nil {
		return m.IntranetIPv4
	}
	return nil
}

func (m *HeartbeatRequest) GetExtranetIPv4() []string {
	if m != nil {
		return m.ExtranetIPv4
	}
	return nil
}

func (m *HeartbeatRequest) GetIntranetIPv6() []string {
	if m != nil {
		return m.IntranetIPv6
	}
	return nil
}

func (m *HeartbeatRequest) GetExtranetIPv6() []string {
	if m != nil {
		return m.ExtranetIPv6
	}
	return nil
}

func (m *HeartbeatRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *HeartbeatRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *HeartbeatRequest) GetConnectedAgents() []string {
	if m != nil {
		return m.ConnectedAgents
	}
	return nil
}

func (m *HeartbeatRequest) GetProxyStartTime() int64 {
	if m != nil {
		return m.ProxyStartTime
	}
	return 0
}

func (m *HeartbeatRequest) GetProxyStatus() ProxyStatus {
	if m != nil {
		return m.ProxyStatus
	}
	return ProxyStatus_CONNECTED
}

func (m *HeartbeatRequest) GetStatusMessage() string {
	if m != nil {
		return m.StatusMessage
	}
	return ""
}

func (m *HeartbeatRequest) GetDetailedStatus() map[string]string {
	if m != nil {
		return m.DetailedStatus
	}
	return nil
}

// 定义心跳响应消息
type HeartbeatResponse struct {
	Status               string   `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartbeatResponse) Reset()         { *m = HeartbeatResponse{} }
func (m *HeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatResponse) ProtoMessage()    {}
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{19}
}
func (m *HeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatResponse.Merge(m, src)
}
func (m *HeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatResponse proto.InternalMessageInfo

func (m *HeartbeatResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// 定义安装密钥校验请求消息
type VerifyInstallRequest struct {
	AgentID              string   `protobuf:"bytes,1,opt,name=AgentID,proto3" json:"agent_id,omitempty"`
	InstallKey           string   `protobuf:"bytes,2,opt,name=InstallKey,proto3" json:"install_key,omitempty"`
	InstallType          string   `protobuf:"bytes,3,opt,name=InstallType,proto3" json:"install_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyInstallRequest) Reset()         { *m = VerifyInstallRequest{} }
func (m *VerifyInstallRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyInstallRequest) ProtoMessage()    {}
func (*VerifyInstallRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{20}
}
func (m *VerifyInstallRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyInstallRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyInstallRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyInstallRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyInstallRequest.Merge(m, src)
}
func (m *VerifyInstallRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyInstallRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyInstallRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyInstallRequest proto.InternalMessageInfo

func (m *VerifyInstallRequest) GetAgentID() string {
	if m != nil {
		return m.AgentID
	}
	return ""
}

func (m *VerifyInstallRequest) GetInstallKey() string {
	if m != nil {
		return m.InstallKey
	}
	return ""
}

func (m *VerifyInstallRequest) GetInstallType() string {
	if m != nil {
		return m.InstallType
	}
	return ""
}

// 定义安装密钥校验响应消息
type VerifyInstallResponse struct {
	Success              bool              `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	AccountID            string            `protobuf:"bytes,2,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,3,rep,name=Metadata,proto3" json:"Metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *VerifyInstallResponse) Reset()         { *m = VerifyInstallResponse{} }
func (m *VerifyInstallResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyInstallResponse) ProtoMessage()    {}
func (*VerifyInstallResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bedfbfc9b54e5600, []int{21}
}
func (m *VerifyInstallResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyInstallResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyInstallResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyInstallResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyInstallResponse.Merge(m, src)
}
func (m *VerifyInstallResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyInstallResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyInstallResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyInstallResponse proto.InternalMessageInfo

func (m *VerifyInstallResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *VerifyInstallResponse) GetAccountID() string {
	if m != nil {
		return m.AccountID
	}
	return ""
}

func (m *VerifyInstallResponse) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func init() {
	proto.RegisterEnum("grpc.ConfigStatusCode", ConfigStatusCode_name, ConfigStatusCode_value)
	proto.RegisterEnum("grpc.ConfigTypeCode", ConfigTypeCode_name, ConfigTypeCode_value)
	proto.RegisterEnum("grpc.ConfigFPStatusCode", ConfigFPStatusCode_name, ConfigFPStatusCode_value)
	proto.RegisterEnum("grpc.ProxyStatus", ProxyStatus_name, ProxyStatus_value)
	proto.RegisterEnum("grpc.UploadResponse_StatusCode", UploadResponse_StatusCode_name, UploadResponse_StatusCode_value)
	proto.RegisterType((*RawData)(nil), "grpc.RawData")
	proto.RegisterType((*Record)(nil), "grpc.Record")
	proto.RegisterType((*Item)(nil), "grpc.Item")
	proto.RegisterMapType((map[string]string)(nil), "grpc.Item.FieldsEntry")
	proto.RegisterType((*Field)(nil), "grpc.Field")
	proto.RegisterType((*ItemArray)(nil), "grpc.ItemArray")
	proto.RegisterType((*Command)(nil), "grpc.Command")
	proto.RegisterType((*PluginTask)(nil), "grpc.PluginTask")
	proto.RegisterType((*ConfigItem)(nil), "grpc.ConfigItem")
	proto.RegisterType((*MQData)(nil), "grpc.MQData")
	proto.RegisterType((*MQRawData)(nil), "grpc.MQRawData")
	proto.RegisterType((*UploadRequest)(nil), "grpc.UploadRequest")
	proto.RegisterType((*UploadResponse)(nil), "grpc.UploadResponse")
	proto.RegisterType((*DownloadRequest)(nil), "grpc.DownloadRequest")
	proto.RegisterType((*DownloadResponse)(nil), "grpc.DownloadResponse")
	proto.RegisterType((*ConfigRefreshRequest)(nil), "grpc.ConfigRefreshRequest")
	proto.RegisterType((*ConfigFingerPrint)(nil), "grpc.ConfigFingerPrint")
	proto.RegisterType((*ConfigRefreshResponse)(nil), "grpc.ConfigRefreshResponse")
	proto.RegisterType((*ConfigDetail)(nil), "grpc.ConfigDetail")
	proto.RegisterType((*HeartbeatRequest)(nil), "grpc.HeartbeatRequest")
	proto.RegisterMapType((map[string]string)(nil), "grpc.HeartbeatRequest.DetailedStatusEntry")
	proto.RegisterType((*HeartbeatResponse)(nil), "grpc.HeartbeatResponse")
	proto.RegisterType((*VerifyInstallRequest)(nil), "grpc.VerifyInstallRequest")
	proto.RegisterType((*VerifyInstallResponse)(nil), "grpc.VerifyInstallResponse")
	proto.RegisterMapType((map[string]string)(nil), "grpc.VerifyInstallResponse.MetadataEntry")
}

func init() { proto.RegisterFile("grpc.proto", fileDescriptor_bedfbfc9b54e5600) }

var fileDescriptor_bedfbfc9b54e5600 = []byte{
	// 1883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x18, 0x4b, 0x6f, 0xe3, 0xc6,
	0x79, 0xa9, 0xa7, 0xf5, 0xc9, 0xb2, 0xe5, 0x59, 0x5b, 0xcb, 0x28, 0xa9, 0x65, 0xb0, 0x6d, 0xea,
	0x3a, 0xa9, 0xd6, 0x50, 0x36, 0x6a, 0x37, 0x09, 0xb0, 0xb1, 0x64, 0x19, 0x36, 0x76, 0x6d, 0x2b,
	0x94, 0x36, 0x45, 0x7b, 0x11, 0xb8, 0xe2, 0x58, 0x22, 0x2c, 0x91, 0x5a, 0x72, 0xe4, 0xb5, 0x0a,
	0xf4, 0xe7, 0xf4, 0x54, 0xa0, 0xe7, 0x9e, 0x0a, 0xf4, 0xd6, 0x43, 0x51, 0x04, 0xe8, 0x5d, 0x28,
	0x16, 0xe8, 0x45, 0xbf, 0xa2, 0x98, 0x07, 0xc9, 0x21, 0x25, 0x3b, 0xd9, 0x3d, 0xf5, 0x90, 0x13,
	0xe7, 0x7b, 0xce, 0x37, 0xf3, 0x3d, 0x87, 0x00, 0x03, 0x77, 0xd2, 0xaf, 0x4e, 0x5c, 0x87, 0x38,
	0x28, 0x45, 0xd7, 0xe5, 0x5f, 0x0d, 0x2c, 0x32, 0x9c, 0xbe, 0xaa, 0xf6, 0x9d, 0xf1, 0xe3, 0x81,
	0x33, 0x70, 0x1e, 0x33, 0xe2, 0xab, 0xe9, 0x15, 0x83, 0x18, 0xc0, 0x56, 0x5c, 0x48, 0xfb, 0x53,
	0x02, 0xb2, 0xba, 0xf1, 0xe6, 0xd8, 0x20, 0x06, 0xda, 0x83, 0x14, 0xfd, 0xaa, 0xca, 0x5e, 0x72,
	0x3f, 0x5f, 0x5b, 0xaf, 0x32, 0xdd, 0x3a, 0xee, 0x3b, 0xae, 0xa9, 0x33, 0x0a, 0x52, 0x21, 0x7b,
	0x34, 0xc0, 0x36, 0x39, 0x3b, 0x56, 0x13, 0x7b, 0xca, 0x7e, 0x4e, 0xf7, 0x41, 0xa4, 0xc1, 0xfa,
	0x99, 0x4d, 0x5c, 0xc3, 0xc6, 0xe4, 0xac, 0x7d, 0xf3, 0x44, 0x4d, 0xee, 0x25, 0xf7, 0x73, 0x7a,
	0x04, 0x47, 0x79, 0x5a, 0xb7, 0x12, 0x4f, 0x8a, 0xf3, 0xc8, 0xb8, 0x98, 0x9e, 0xba, 0x9a, 0x5e,
	0xd2, 0x53, 0x8f, 0xe9, 0xa9, 0xab, 0x99, 0x25, 0x3d, 0x75, 0x54, 0x86, 0xb5, 0x53, 0xc7, 0x23,
	0xb6, 0x31, 0xc6, 0x6a, 0x96, 0x99, 0x1a, 0xc0, 0xf4, 0x14, 0xdf, 0x62, 0xd7, 0xb3, 0x1c, 0x5b,
	0x5d, 0xe3, 0xa7, 0x10, 0x20, 0xa5, 0xb4, 0x5d, 0xc7, 0x9c, 0xf6, 0x89, 0x9a, 0xe3, 0x14, 0x01,
	0x6a, 0x7f, 0x80, 0x0c, 0xbf, 0x09, 0xaa, 0x99, 0xde, 0x45, 0x77, 0x36, 0xc1, 0xaa, 0xb2, 0xa7,
	0xec, 0xa7, 0xf5, 0x00, 0x46, 0x1f, 0x41, 0xae, 0x6b, 0x8d, 0xb1, 0x47, 0x8c, 0xf1, 0x84, 0xdd,
	0x50, 0x52, 0x0f, 0x11, 0x08, 0x41, 0xaa, 0xe1, 0x98, 0x33, 0x35, 0xb9, 0xa7, 0xec, 0xaf, 0xeb,
	0x6c, 0x4d, 0xcf, 0x72, 0x34, 0x99, 0x60, 0xdb, 0xc4, 0x26, 0xa3, 0xa5, 0x18, 0x2d, 0x82, 0xd3,
	0x5e, 0x43, 0xea, 0x8c, 0xe0, 0x31, 0xaa, 0x42, 0xe6, 0xc4, 0xc2, 0x23, 0xd3, 0x13, 0x1e, 0x2a,
	0x71, 0x0f, 0x51, 0x5a, 0x95, 0x13, 0x5a, 0x36, 0x71, 0x67, 0xba, 0xe0, 0x2a, 0x3f, 0x85, 0xbc,
	0x84, 0x46, 0x45, 0x48, 0x5e, 0xe3, 0x19, 0xb3, 0x39, 0xa7, 0xd3, 0x25, 0xda, 0x86, 0xf4, 0x8d,
	0x31, 0x9a, 0x62, 0xe1, 0x4c, 0x0e, 0x7c, 0x91, 0xf8, 0x8d, 0xa2, 0x3d, 0x86, 0x34, 0x13, 0xfd,
	0xa1, 0x42, 0xda, 0x21, 0xe4, 0xa8, 0x1d, 0x47, 0xae, 0x6b, 0xcc, 0xd0, 0x4f, 0x21, 0x73, 0x25,
	0x1b, 0x9a, 0xe7, 0x86, 0x32, 0x8d, 0xba, 0x20, 0x69, 0x6f, 0x20, 0xdb, 0x74, 0xc6, 0x63, 0xc3,
	0x36, 0xe9, 0xb5, 0xb1, 0x38, 0x6a, 0x12, 0x77, 0x24, 0xee, 0x34, 0x44, 0xa0, 0x9f, 0x41, 0xaa,
	0x6b, 0x78, 0xd7, 0x6c, 0xbf, 0x7c, 0xad, 0xc8, 0x75, 0xb5, 0x47, 0xd3, 0x81, 0x65, 0x53, 0xbc,
	0xce, 0xa8, 0x68, 0x1f, 0x32, 0x4d, 0xc7, 0xbe, 0xb2, 0x06, 0x2c, 0xf4, 0x02, 0x3e, 0x8e, 0xa3,
	0xa6, 0xe9, 0x82, 0xae, 0x5d, 0x01, 0x84, 0xd2, 0xf7, 0xba, 0x13, 0x41, 0xea, 0x82, 0x06, 0x10,
	0x3f, 0x29, 0x5b, 0x53, 0x1c, 0x4b, 0x92, 0x24, 0xc7, 0xb1, 0xb4, 0xd8, 0x86, 0x74, 0xd7, 0xb9,
	0xc6, 0x36, 0xf3, 0x5e, 0x4e, 0xe7, 0x80, 0xf6, 0x37, 0x05, 0x20, 0xdc, 0x3e, 0x50, 0xa6, 0x44,
	0x95, 0xb1, 0x8d, 0xc5, 0x06, 0x6c, 0x53, 0x29, 0x3a, 0x93, 0xd1, 0xe8, 0x2c, 0x41, 0xa6, 0x73,
	0x7a, 0x54, 0xfb, 0xbc, 0x2e, 0xf6, 0x11, 0x10, 0xbd, 0xbe, 0x8e, 0x35, 0xb0, 0x0d, 0x32, 0x75,
	0xb1, 0x9a, 0x66, 0xa4, 0x10, 0x81, 0xf6, 0x20, 0x7f, 0xec, 0xbc, 0xb1, 0x47, 0x8e, 0x61, 0xbe,
	0xd4, 0x5f, 0x88, 0x64, 0x91, 0x51, 0x54, 0xef, 0x31, 0x26, 0x86, 0x35, 0x12, 0x99, 0x22, 0x20,
	0xed, 0x2f, 0x29, 0xc8, 0x9c, 0x7f, 0xc3, 0x4e, 0xf8, 0x3d, 0x41, 0xcf, 0x9c, 0x45, 0x03, 0xdd,
	0x0f, 0xfa, 0x00, 0xb1, 0x32, 0xe8, 0xa5, 0x32, 0x92, 0xba, 0xbf, 0x8c, 0xf0, 0xd3, 0xdc, 0x5f,
	0x46, 0x32, 0x9c, 0xe7, 0xde, 0x32, 0x92, 0x5d, 0xd2, 0xb3, 0x5c, 0x46, 0xd6, 0x96, 0xf4, 0x44,
	0xcb, 0x48, 0xee, 0xee, 0x32, 0x02, 0x77, 0x96, 0x91, 0x7c, 0xa4, 0x8c, 0x50, 0x4a, 0xe7, 0xc6,
	0x65, 0x37, 0xb5, 0xce, 0x6e, 0xca, 0x07, 0x99, 0x4c, 0xe7, 0x9c, 0x45, 0x48, 0x41, 0xc8, 0x70,
	0x50, 0x50, 0xda, 0x06, 0x19, 0xaa, 0x1b, 0x01, 0x85, 0x82, 0x34, 0x39, 0xbb, 0xc6, 0x40, 0xdd,
	0xe4, 0xc9, 0xd9, 0x35, 0x06, 0xd4, 0xde, 0x96, 0x3d, 0x34, 0xec, 0x3e, 0x36, 0xd5, 0x22, 0xb7,
	0xd7, 0x87, 0xd1, 0x2e, 0xc0, 0x99, 0x77, 0xea, 0xd8, 0x78, 0x36, 0x71, 0x88, 0xba, 0xc5, 0xa8,
	0x12, 0x66, 0xa9, 0x14, 0xa1, 0xe5, 0x52, 0xc4, 0x7c, 0xdd, 0xef, 0x3b, 0x53, 0xe6, 0xbb, 0x87,
	0x3c, 0xd4, 0x02, 0x84, 0xf6, 0xaf, 0x14, 0xe4, 0xce, 0xbf, 0xf1, 0xdb, 0xc9, 0xfb, 0xc7, 0xcc,
	0xae, 0x14, 0x33, 0xf9, 0x1a, 0x84, 0x65, 0xee, 0xc7, 0xf8, 0xf9, 0x3f, 0x8e, 0x9f, 0xcf, 0x56,
	0xc4, 0x4f, 0xbe, 0xb6, 0x19, 0x7a, 0x8f, 0x35, 0x87, 0x77, 0x0a, 0xa8, 0xa7, 0x50, 0x78, 0x39,
	0xa1, 0x65, 0x4a, 0xc7, 0xaf, 0xa7, 0xd8, 0x23, 0x61, 0xa5, 0x55, 0xa4, 0x4a, 0x1b, 0xd4, 0xe4,
	0x04, 0xaf, 0x31, 0x74, 0xad, 0x4d, 0x60, 0xc3, 0x17, 0xf5, 0x26, 0x8e, 0xed, 0x61, 0xf4, 0x6b,
	0xc8, 0x74, 0x88, 0x41, 0xa6, 0x1e, 0x13, 0xde, 0xa8, 0x55, 0xb8, 0x65, 0x51, 0xae, 0x2a, 0x67,
	0x69, 0x3a, 0x26, 0xd6, 0x05, 0xbb, 0xf6, 0x73, 0x80, 0x10, 0x8b, 0xf2, 0x90, 0xed, 0xbc, 0x6c,
	0x36, 0x5b, 0x9d, 0x4e, 0xf1, 0x01, 0x02, 0xc8, 0x9c, 0x1c, 0x9d, 0xbd, 0x68, 0x1d, 0x17, 0x15,
	0xed, 0x17, 0xb0, 0xe9, 0x57, 0x55, 0xc9, 0x5c, 0x22, 0x9b, 0xcb, 0x00, 0xed, 0x63, 0x28, 0x86,
	0x8c, 0xc2, 0x38, 0x04, 0x29, 0x93, 0xcf, 0x5e, 0xec, 0x08, 0x74, 0xad, 0x7d, 0xa7, 0xc0, 0x36,
	0x6f, 0x20, 0x3a, 0xbe, 0x72, 0xb1, 0x37, 0xf4, 0xd5, 0x1e, 0x86, 0xf1, 0xcf, 0x14, 0x37, 0x4a,
	0x8b, 0x79, 0x05, 0x19, 0x14, 0xd5, 0xb3, 0xcc, 0x4f, 0x9d, 0xb1, 0x45, 0xf0, 0x78, 0x42, 0x66,
	0x61, 0x5e, 0x3c, 0xf1, 0x7b, 0x5e, 0xd8, 0xcf, 0x1a, 0xdb, 0x8b, 0x79, 0xa5, 0x38, 0x61, 0x58,
	0x49, 0x44, 0xe2, 0x43, 0x6d, 0x3a, 0x40, 0xd8, 0x03, 0xec, 0x4e, 0x5c, 0xcb, 0x26, 0xa2, 0xb1,
	0x3e, 0x92, 0x1b, 0x2b, 0x27, 0xb7, 0x29, 0xb9, 0xb1, 0xb3, 0x98, 0x57, 0xb6, 0xfa, 0x0c, 0xed,
	0x49, 0x0a, 0x65, 0x15, 0xda, 0x9f, 0x15, 0xd8, 0x5a, 0x92, 0x44, 0x1f, 0x43, 0x8a, 0x85, 0x27,
	0x3f, 0x0c, 0x5a, 0xcc, 0x2b, 0x1b, 0x13, 0x83, 0x0c, 0x25, 0x25, 0x8c, 0x4e, 0xf9, 0x4e, 0x0d,
	0x6f, 0x28, 0xec, 0x67, 0x7c, 0x43, 0xc3, 0x8b, 0xf0, 0x51, 0x3a, 0x3a, 0x09, 0x3c, 0x9d, 0x64,
	0x9e, 0x56, 0x23, 0x26, 0xb7, 0x43, 0x67, 0xf2, 0x3b, 0xf0, 0x18, 0x2c, 0x69, 0xf1, 0x1d, 0xff,
	0x5f, 0x05, 0x76, 0x62, 0x0e, 0x10, 0xee, 0xda, 0x8d, 0xdc, 0x27, 0xf7, 0xae, 0x7c, 0x73, 0xb4,
	0x25, 0xe3, 0xbe, 0x8b, 0xc9, 0x73, 0x3c, 0x13, 0xdd, 0x3d, 0x44, 0xdc, 0xd3, 0xe2, 0x55, 0xc8,
	0xea, 0x78, 0x84, 0x0d, 0x0f, 0xb3, 0xca, 0x96, 0xd2, 0x7d, 0x90, 0x0e, 0x7f, 0xe2, 0x4c, 0x69,
	0x76, 0xa6, 0x92, 0x7c, 0xa6, 0xe5, 0xa0, 0x45, 0x07, 0xc1, 0x3c, 0x94, 0x61, 0x6e, 0x43, 0x32,
	0x3f, 0x6f, 0xf0, 0xc1, 0x44, 0xf4, 0xd7, 0x04, 0xac, 0xcb, 0x84, 0x1f, 0xec, 0x90, 0xe3, 0xc0,
	0xa8, 0xc4, 0x7d, 0x46, 0xdd, 0x7f, 0xcd, 0x74, 0xb7, 0x70, 0xa4, 0xe2, 0xbb, 0xd1, 0xf8, 0x97,
	0x77, 0x63, 0x0d, 0xe5, 0x2b, 0x31, 0x2d, 0xa5, 0xd8, 0x5e, 0xdb, 0xf2, 0x5e, 0x14, 0xcf, 0x76,
	0x62, 0xd2, 0x64, 0x36, 0xc1, 0xb2, 0x34, 0x6b, 0x39, 0x7e, 0xf0, 0xa4, 0xbf, 0x27, 0x78, 0x3e,
	0x0d, 0xa6, 0xa1, 0x4c, 0x98, 0x26, 0x26, 0xc3, 0xc8, 0xb6, 0x8b, 0x19, 0xe9, 0x9f, 0x59, 0x28,
	0x9e, 0x62, 0xc3, 0x25, 0xaf, 0xb0, 0x41, 0xa4, 0xfc, 0x6c, 0xbb, 0xce, 0xed, 0x2c, 0x9a, 0x9f,
	0x13, 0x8a, 0x8a, 0xe5, 0xa7, 0x60, 0x43, 0x5f, 0xc3, 0x3a, 0x5b, 0xbe, 0x70, 0xfa, 0xc6, 0xc8,
	0x7f, 0x5d, 0x35, 0x3e, 0x5a, 0xcc, 0x2b, 0x2a, 0x17, 0x1b, 0x51, 0x42, 0x54, 0x38, 0x22, 0x81,
	0x9e, 0xad, 0x7a, 0x80, 0x35, 0x3e, 0x5c, 0xcc, 0x2b, 0x8f, 0x2c, 0x81, 0xef, 0x59, 0x93, 0x9b,
	0x27, 0xb2, 0x82, 0x48, 0x5b, 0x7c, 0xb6, 0xea, 0x75, 0xc6, 0x15, 0xe0, 0xdb, 0x3b, 0x14, 0x44,
	0x7a, 0xe6, 0xb3, 0x55, 0x4f, 0xb7, 0x65, 0x0b, 0xea, 0x77, 0x58, 0x50, 0x8f, 0x59, 0x20, 0xde,
	0x75, 0xcb, 0x16, 0xd4, 0xef, 0xb0, 0xa0, 0x8e, 0x6a, 0xf1, 0x47, 0x1f, 0xbf, 0xf8, 0xa1, 0xc0,
	0x49, 0x72, 0x61, 0x17, 0x7e, 0x1c, 0x7b, 0x0c, 0xf2, 0x32, 0x76, 0xc3, 0x51, 0xb2, 0xab, 0xfc,
	0x14, 0x3d, 0x85, 0xcd, 0xa6, 0x63, 0xdb, 0xb8, 0x4f, 0xb0, 0xc9, 0xca, 0xab, 0xa7, 0xe6, 0x98,
	0xa1, 0xbb, 0x8b, 0x79, 0xa5, 0xdc, 0xf7, 0x49, 0x3d, 0x56, 0x8e, 0xe5, 0x70, 0x8f, 0x8b, 0xa1,
	0x13, 0xd8, 0x60, 0x2e, 0xec, 0x10, 0xc3, 0xe5, 0x93, 0x10, 0x9d, 0x03, 0x92, 0x5c, 0x11, 0x77,
	0xbb, 0x47, 0x49, 0x3d, 0x62, 0x45, 0x8c, 0x8f, 0x49, 0xa1, 0x4b, 0xc8, 0xfb, 0x18, 0x9a, 0x8a,
	0x79, 0x96, 0x1e, 0x5b, 0xe2, 0x9d, 0x14, 0x12, 0x1a, 0xe5, 0xc5, 0xbc, 0x52, 0x0a, 0xf4, 0x46,
	0x73, 0x51, 0xd6, 0x80, 0x1a, 0x50, 0xe0, 0xab, 0x73, 0xec, 0x79, 0xc6, 0x80, 0xcf, 0x1a, 0x22,
	0x1c, 0xb9, 0x64, 0x6f, 0xcc, 0x29, 0x92, 0x86, 0xa8, 0x08, 0x7a, 0x0d, 0x1b, 0x3c, 0x45, 0xb0,
	0x29, 0xec, 0x2a, 0xb0, 0x3a, 0x74, 0xc0, 0xed, 0x8a, 0xe7, 0x4c, 0x35, 0xca, 0xcc, 0x5e, 0xac,
	0x8d, 0x9f, 0x2c, 0xe6, 0x95, 0x0f, 0x4c, 0x41, 0x58, 0xb6, 0x39, 0xb6, 0x41, 0xf9, 0x08, 0x1e,
	0xae, 0xd0, 0xf2, 0x4e, 0xef, 0xde, 0x4f, 0x60, 0x4b, 0xb2, 0x4c, 0x14, 0xfb, 0x52, 0x64, 0x70,
	0xc8, 0x05, 0xed, 0xe1, 0xef, 0x0a, 0x6c, 0x7f, 0x8b, 0x5d, 0xeb, 0x6a, 0x76, 0x66, 0x7b, 0xc4,
	0x18, 0x8d, 0xde, 0xbf, 0x3f, 0x3f, 0x05, 0x10, 0x3a, 0x82, 0x86, 0xd1, 0xf8, 0x60, 0x31, 0xaf,
	0xec, 0x58, 0x1c, 0xdb, 0xbb, 0xc6, 0x33, 0xb9, 0x49, 0x87, 0xcc, 0xe8, 0x2b, 0xc8, 0x0b, 0x88,
	0x15, 0x47, 0x5e, 0x44, 0x99, 0xab, 0x7d, 0xd9, 0x58, 0x39, 0x94, 0xd9, 0xb5, 0x7f, 0x2b, 0xb0,
	0x13, 0x3b, 0x83, 0x38, 0x35, 0x1d, 0x35, 0xa7, 0xfd, 0x3e, 0xf6, 0xf8, 0xb1, 0xd7, 0x74, 0x1f,
	0x8c, 0xce, 0x6c, 0x89, 0xd8, 0xcc, 0x86, 0x5a, 0xb0, 0x76, 0x8e, 0x89, 0x61, 0xf2, 0x8a, 0x4e,
	0x5d, 0xfe, 0x4b, 0xee, 0xf2, 0x95, 0xdb, 0x54, 0x7d, 0x5e, 0xfe, 0xeb, 0x22, 0x10, 0x2d, 0x7f,
	0x09, 0x85, 0x08, 0xe9, 0x5d, 0xdc, 0x78, 0xf0, 0x09, 0x14, 0xe3, 0x3d, 0xe8, 0xce, 0xb9, 0xed,
	0xa0, 0x06, 0x1b, 0xd1, 0x26, 0x82, 0xd6, 0x20, 0x75, 0x62, 0x8d, 0x30, 0xe7, 0xe3, 0xb4, 0xa2,
	0x42, 0xd7, 0x3a, 0x1e, 0x3b, 0x37, 0xb8, 0x98, 0x38, 0x38, 0x04, 0xb4, 0x3c, 0x4d, 0xa0, 0x1c,
	0xa4, 0x5b, 0xb7, 0x96, 0x47, 0x8a, 0x0f, 0xd0, 0x26, 0xe4, 0x2f, 0x1c, 0x1b, 0x53, 0x08, 0xdb,
	0xa4, 0xa8, 0x1c, 0x3c, 0x8f, 0x24, 0x29, 0x2a, 0x40, 0xae, 0x79, 0x79, 0x71, 0xd1, 0x6a, 0x76,
	0x5b, 0xc7, 0xc5, 0x07, 0xa8, 0x0c, 0x25, 0x01, 0x9e, 0x5d, 0x5e, 0xf4, 0x4e, 0xbb, 0xdd, 0x76,
	0xcf, 0xb7, 0x0f, 0x6d, 0x41, 0xe1, 0xe5, 0xc5, 0xf3, 0x8b, 0xcb, 0xdf, 0x5e, 0xf4, 0x5a, 0xba,
	0x7e, 0xa9, 0x17, 0x13, 0xb5, 0x2f, 0x60, 0xad, 0xeb, 0x1a, 0xb6, 0x77, 0x85, 0x5d, 0x54, 0x95,
	0xd6, 0x05, 0xf1, 0xcf, 0x8e, 0xbf, 0xc0, 0xca, 0x05, 0xbf, 0x45, 0xb2, 0xdf, 0x2c, 0xda, 0x83,
	0x7d, 0xe5, 0x50, 0xa9, 0xfd, 0x11, 0xb2, 0xf4, 0x70, 0xad, 0x5b, 0x82, 0x3e, 0x87, 0x0c, 0x9f,
	0x7e, 0xd1, 0xc3, 0xe8, 0x2c, 0xcc, 0xc2, 0xb8, 0xbc, 0xbd, 0x6a, 0x40, 0xde, 0x57, 0xd0, 0x97,
	0xb0, 0xe6, 0xcf, 0xaf, 0x68, 0x87, 0xf3, 0xc4, 0x06, 0xdf, 0x72, 0x29, 0x8e, 0xe6, 0xc2, 0x87,
	0x4a, 0xad, 0x03, 0x39, 0x7e, 0x73, 0xd4, 0x80, 0x13, 0xc8, 0x37, 0x87, 0xb8, 0x7f, 0xcd, 0x31,
	0xa8, 0x2c, 0xb7, 0xf4, 0xe8, 0xcc, 0x5b, 0xfe, 0x70, 0x25, 0x8d, 0xab, 0xad, 0xe9, 0xa2, 0x92,
	0x06, 0xb9, 0x8b, 0xbe, 0x86, 0x42, 0x07, 0xdb, 0x66, 0x88, 0x28, 0xad, 0xae, 0x3b, 0xe5, 0x47,
	0x4b, 0x78, 0xa1, 0xf3, 0x77, 0x50, 0x88, 0x44, 0x2c, 0x3a, 0x8d, 0x23, 0xca, 0x2b, 0xe3, 0x3a,
	0x62, 0xee, 0xca, 0x98, 0x6f, 0xa0, 0x7f, 0xbc, 0xdd, 0x55, 0xbe, 0x7b, 0xbb, 0xab, 0xfc, 0xe7,
	0xed, 0xae, 0xf2, 0x7b, 0xf6, 0xdf, 0xf6, 0x55, 0x86, 0xfd, 0x8f, 0xfd, 0xec, 0x7f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0xc5, 0x15, 0x74, 0x09, 0xd2, 0x15, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TransferClient is the client API for Transfer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TransferClient interface {
	Transfer(ctx context.Context, opts ...grpc.CallOption) (Transfer_TransferClient, error)
}

type transferClient struct {
	cc *grpc.ClientConn
}

func NewTransferClient(cc *grpc.ClientConn) TransferClient {
	return &transferClient{cc}
}

func (c *transferClient) Transfer(ctx context.Context, opts ...grpc.CallOption) (Transfer_TransferClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Transfer_serviceDesc.Streams[0], "/grpc.Transfer/Transfer", opts...)
	if err != nil {
		return nil, err
	}
	x := &transferTransferClient{stream}
	return x, nil
}

type Transfer_TransferClient interface {
	Send(*RawData) error
	Recv() (*Command, error)
	grpc.ClientStream
}

type transferTransferClient struct {
	grpc.ClientStream
}

func (x *transferTransferClient) Send(m *RawData) error {
	return x.ClientStream.SendMsg(m)
}

func (x *transferTransferClient) Recv() (*Command, error) {
	m := new(Command)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TransferServer is the server API for Transfer service.
type TransferServer interface {
	Transfer(Transfer_TransferServer) error
}

// UnimplementedTransferServer can be embedded to have forward compatible implementations.
type UnimplementedTransferServer struct {
}

func (*UnimplementedTransferServer) Transfer(srv Transfer_TransferServer) error {
	return status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}

func RegisterTransferServer(s *grpc.Server, srv TransferServer) {
	s.RegisterService(&_Transfer_serviceDesc, srv)
}

func _Transfer_Transfer_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TransferServer).Transfer(&transferTransferServer{stream})
}

type Transfer_TransferServer interface {
	Send(*Command) error
	Recv() (*RawData, error)
	grpc.ServerStream
}

type transferTransferServer struct {
	grpc.ServerStream
}

func (x *transferTransferServer) Send(m *Command) error {
	return x.ServerStream.SendMsg(m)
}

func (x *transferTransferServer) Recv() (*RawData, error) {
	m := new(RawData)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Transfer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.Transfer",
	HandlerType: (*TransferServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Transfer",
			Handler:       _Transfer_Transfer_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "grpc.proto",
}

// FileExtClient is the client API for FileExt service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileExtClient interface {
	Upload(ctx context.Context, opts ...grpc.CallOption) (FileExt_UploadClient, error)
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (FileExt_DownloadClient, error)
}

type fileExtClient struct {
	cc *grpc.ClientConn
}

func NewFileExtClient(cc *grpc.ClientConn) FileExtClient {
	return &fileExtClient{cc}
}

func (c *fileExtClient) Upload(ctx context.Context, opts ...grpc.CallOption) (FileExt_UploadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileExt_serviceDesc.Streams[0], "/grpc.FileExt/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileExtUploadClient{stream}
	return x, nil
}

type FileExt_UploadClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*UploadResponse, error)
	grpc.ClientStream
}

type fileExtUploadClient struct {
	grpc.ClientStream
}

func (x *fileExtUploadClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileExtUploadClient) CloseAndRecv() (*UploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileExtClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (FileExt_DownloadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileExt_serviceDesc.Streams[1], "/grpc.FileExt/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileExtDownloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileExt_DownloadClient interface {
	Recv() (*DownloadResponse, error)
	grpc.ClientStream
}

type fileExtDownloadClient struct {
	grpc.ClientStream
}

func (x *fileExtDownloadClient) Recv() (*DownloadResponse, error) {
	m := new(DownloadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FileExtServer is the server API for FileExt service.
type FileExtServer interface {
	Upload(FileExt_UploadServer) error
	Download(*DownloadRequest, FileExt_DownloadServer) error
}

// UnimplementedFileExtServer can be embedded to have forward compatible implementations.
type UnimplementedFileExtServer struct {
}

func (*UnimplementedFileExtServer) Upload(srv FileExt_UploadServer) error {
	return status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (*UnimplementedFileExtServer) Download(req *DownloadRequest, srv FileExt_DownloadServer) error {
	return status.Errorf(codes.Unimplemented, "method Download not implemented")
}

func RegisterFileExtServer(s *grpc.Server, srv FileExtServer) {
	s.RegisterService(&_FileExt_serviceDesc, srv)
}

func _FileExt_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileExtServer).Upload(&fileExtUploadServer{stream})
}

type FileExt_UploadServer interface {
	SendAndClose(*UploadResponse) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type fileExtUploadServer struct {
	grpc.ServerStream
}

func (x *fileExtUploadServer) SendAndClose(m *UploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileExtUploadServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileExt_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileExtServer).Download(m, &fileExtDownloadServer{stream})
}

type FileExt_DownloadServer interface {
	Send(*DownloadResponse) error
	grpc.ServerStream
}

type fileExtDownloadServer struct {
	grpc.ServerStream
}

func (x *fileExtDownloadServer) Send(m *DownloadResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _FileExt_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.FileExt",
	HandlerType: (*FileExtServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _FileExt_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Download",
			Handler:       _FileExt_Download_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "grpc.proto",
}

// ConfigExtClient is the client API for ConfigExt service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConfigExtClient interface {
	CheckConfig(ctx context.Context, in *ConfigRefreshRequest, opts ...grpc.CallOption) (*ConfigRefreshResponse, error)
}

type configExtClient struct {
	cc *grpc.ClientConn
}

func NewConfigExtClient(cc *grpc.ClientConn) ConfigExtClient {
	return &configExtClient{cc}
}

func (c *configExtClient) CheckConfig(ctx context.Context, in *ConfigRefreshRequest, opts ...grpc.CallOption) (*ConfigRefreshResponse, error) {
	out := new(ConfigRefreshResponse)
	err := c.cc.Invoke(ctx, "/grpc.ConfigExt/CheckConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigExtServer is the server API for ConfigExt service.
type ConfigExtServer interface {
	CheckConfig(context.Context, *ConfigRefreshRequest) (*ConfigRefreshResponse, error)
}

// UnimplementedConfigExtServer can be embedded to have forward compatible implementations.
type UnimplementedConfigExtServer struct {
}

func (*UnimplementedConfigExtServer) CheckConfig(ctx context.Context, req *ConfigRefreshRequest) (*ConfigRefreshResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckConfig not implemented")
}

func RegisterConfigExtServer(s *grpc.Server, srv ConfigExtServer) {
	s.RegisterService(&_ConfigExt_serviceDesc, srv)
}

func _ConfigExt_CheckConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigRefreshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigExtServer).CheckConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.ConfigExt/CheckConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigExtServer).CheckConfig(ctx, req.(*ConfigRefreshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConfigExt_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.ConfigExt",
	HandlerType: (*ConfigExtServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckConfig",
			Handler:    _ConfigExt_CheckConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// ProxyHeartbeatClient is the client API for ProxyHeartbeat service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProxyHeartbeatClient interface {
	// 发送心跳信息的 RPC 方法
	SendHeartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
}

type proxyHeartbeatClient struct {
	cc *grpc.ClientConn
}

func NewProxyHeartbeatClient(cc *grpc.ClientConn) ProxyHeartbeatClient {
	return &proxyHeartbeatClient{cc}
}

func (c *proxyHeartbeatClient) SendHeartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, "/grpc.ProxyHeartbeat/SendHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProxyHeartbeatServer is the server API for ProxyHeartbeat service.
type ProxyHeartbeatServer interface {
	// 发送心跳信息的 RPC 方法
	SendHeartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
}

// UnimplementedProxyHeartbeatServer can be embedded to have forward compatible implementations.
type UnimplementedProxyHeartbeatServer struct {
}

func (*UnimplementedProxyHeartbeatServer) SendHeartbeat(ctx context.Context, req *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendHeartbeat not implemented")
}

func RegisterProxyHeartbeatServer(s *grpc.Server, srv ProxyHeartbeatServer) {
	s.RegisterService(&_ProxyHeartbeat_serviceDesc, srv)
}

func _ProxyHeartbeat_SendHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyHeartbeatServer).SendHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.ProxyHeartbeat/SendHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyHeartbeatServer).SendHeartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProxyHeartbeat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.ProxyHeartbeat",
	HandlerType: (*ProxyHeartbeatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendHeartbeat",
			Handler:    _ProxyHeartbeat_SendHeartbeat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

// VerifyInstallClient is the client API for VerifyInstall service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VerifyInstallClient interface {
	VerifyInstall(ctx context.Context, in *VerifyInstallRequest, opts ...grpc.CallOption) (*VerifyInstallResponse, error)
}

type verifyInstallClient struct {
	cc *grpc.ClientConn
}

func NewVerifyInstallClient(cc *grpc.ClientConn) VerifyInstallClient {
	return &verifyInstallClient{cc}
}

func (c *verifyInstallClient) VerifyInstall(ctx context.Context, in *VerifyInstallRequest, opts ...grpc.CallOption) (*VerifyInstallResponse, error) {
	out := new(VerifyInstallResponse)
	err := c.cc.Invoke(ctx, "/grpc.VerifyInstall/VerifyInstall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VerifyInstallServer is the server API for VerifyInstall service.
type VerifyInstallServer interface {
	VerifyInstall(context.Context, *VerifyInstallRequest) (*VerifyInstallResponse, error)
}

// UnimplementedVerifyInstallServer can be embedded to have forward compatible implementations.
type UnimplementedVerifyInstallServer struct {
}

func (*UnimplementedVerifyInstallServer) VerifyInstall(ctx context.Context, req *VerifyInstallRequest) (*VerifyInstallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyInstall not implemented")
}

func RegisterVerifyInstallServer(s *grpc.Server, srv VerifyInstallServer) {
	s.RegisterService(&_VerifyInstall_serviceDesc, srv)
}

func _VerifyInstall_VerifyInstall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyInstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifyInstallServer).VerifyInstall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.VerifyInstall/VerifyInstall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifyInstallServer).VerifyInstall(ctx, req.(*VerifyInstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VerifyInstall_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.VerifyInstall",
	HandlerType: (*VerifyInstallServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyInstall",
			Handler:    _VerifyInstall_VerifyInstall_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

func (m *RawData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Product) > 0 {
		i -= len(m.Product)
		copy(dAtA[i:], m.Product)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Product)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExtranetIPv6) > 0 {
		for iNdEx := len(m.ExtranetIPv6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtranetIPv6[iNdEx])
			copy(dAtA[i:], m.ExtranetIPv6[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.ExtranetIPv6[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.IntranetIPv6) > 0 {
		for iNdEx := len(m.IntranetIPv6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IntranetIPv6[iNdEx])
			copy(dAtA[i:], m.IntranetIPv6[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.IntranetIPv6[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ExtranetIPv4) > 0 {
		for iNdEx := len(m.ExtranetIPv4) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtranetIPv4[iNdEx])
			copy(dAtA[i:], m.ExtranetIPv4[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.ExtranetIPv4[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IntranetIPv4) > 0 {
		for iNdEx := len(m.IntranetIPv4) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IntranetIPv4[iNdEx])
			copy(dAtA[i:], m.IntranetIPv4[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.IntranetIPv4[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AgentID) > 0 {
		i -= len(m.AgentID)
		copy(dAtA[i:], m.AgentID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AgentID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppendedBody) > 0 {
		i -= len(m.AppendedBody)
		copy(dAtA[i:], m.AppendedBody)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AppendedBody)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.DataType != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for k := range m.Fields {
			v := m.Fields[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGrpc(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGrpc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGrpc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ItemArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemArray) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemArray) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Command) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		for iNdEx := len(m.Config) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Config[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Task != nil {
		{
			size, err := m.Task.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AgentCtrl != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.AgentCtrl))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.DataType != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConfigItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DownloadURL) > 0 {
		for iNdEx := len(m.DownloadURL) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DownloadURL[iNdEx])
			copy(dAtA[i:], m.DownloadURL[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.DownloadURL[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SHA256) > 0 {
		i -= len(m.SHA256)
		copy(dAtA[i:], m.SHA256)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.SHA256)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MQData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MQData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MQData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccountID) > 0 {
		i -= len(m.AccountID)
		copy(dAtA[i:], m.AccountID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AccountID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.AppendedBody) > 0 {
		i -= len(m.AppendedBody)
		copy(dAtA[i:], m.AppendedBody)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AppendedBody)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.IsHoneypot) > 0 {
		i -= len(m.IsHoneypot)
		copy(dAtA[i:], m.IsHoneypot)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.IsHoneypot)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Enhanced) > 0 {
		i -= len(m.Enhanced)
		copy(dAtA[i:], m.Enhanced)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Enhanced)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.PSMPath) > 0 {
		i -= len(m.PSMPath)
		copy(dAtA[i:], m.PSMPath)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.PSMPath)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.PSMName) > 0 {
		i -= len(m.PSMName)
		copy(dAtA[i:], m.PSMName)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.PSMName)))
		i--
		dAtA[i] = 0x6a
	}
	if m.SvrTime != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.SvrTime))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Product) > 0 {
		i -= len(m.Product)
		copy(dAtA[i:], m.Product)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Product)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ExtranetIPv6) > 0 {
		i -= len(m.ExtranetIPv6)
		copy(dAtA[i:], m.ExtranetIPv6)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.ExtranetIPv6)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IntranetIPv6) > 0 {
		i -= len(m.IntranetIPv6)
		copy(dAtA[i:], m.IntranetIPv6)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.IntranetIPv6)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExtranetIPv4) > 0 {
		i -= len(m.ExtranetIPv4)
		copy(dAtA[i:], m.ExtranetIPv4)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.ExtranetIPv4)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IntranetIPv4) > 0 {
		i -= len(m.IntranetIPv4)
		copy(dAtA[i:], m.IntranetIPv4)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.IntranetIPv4)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AgentID) > 0 {
		i -= len(m.AgentID)
		copy(dAtA[i:], m.AgentID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AgentID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AgentTime != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.AgentTime))
		i--
		dAtA[i] = 0x10
	}
	if m.DataType != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MQRawData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MQRawData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MQRawData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccountID) > 0 {
		i -= len(m.AccountID)
		copy(dAtA[i:], m.AccountID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AccountID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.AppendedBody != nil {
		{
			size, err := m.AppendedBody.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.IsHoneypot) > 0 {
		i -= len(m.IsHoneypot)
		copy(dAtA[i:], m.IsHoneypot)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.IsHoneypot)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Enhanced) > 0 {
		i -= len(m.Enhanced)
		copy(dAtA[i:], m.Enhanced)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Enhanced)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.PSMPath) > 0 {
		i -= len(m.PSMPath)
		copy(dAtA[i:], m.PSMPath)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.PSMPath)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.PSMName) > 0 {
		i -= len(m.PSMName)
		copy(dAtA[i:], m.PSMName)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.PSMName)))
		i--
		dAtA[i] = 0x6a
	}
	if m.SvrTime != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.SvrTime))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Product) > 0 {
		i -= len(m.Product)
		copy(dAtA[i:], m.Product)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Product)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ExtranetIPv6) > 0 {
		i -= len(m.ExtranetIPv6)
		copy(dAtA[i:], m.ExtranetIPv6)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.ExtranetIPv6)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IntranetIPv6) > 0 {
		i -= len(m.IntranetIPv6)
		copy(dAtA[i:], m.IntranetIPv6)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.IntranetIPv6)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExtranetIPv4) > 0 {
		i -= len(m.ExtranetIPv4)
		copy(dAtA[i:], m.ExtranetIPv4)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.ExtranetIPv4)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IntranetIPv4) > 0 {
		i -= len(m.IntranetIPv4)
		copy(dAtA[i:], m.IntranetIPv4)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.IntranetIPv4)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AgentID) > 0 {
		i -= len(m.AgentID)
		copy(dAtA[i:], m.AgentID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AgentID)))
		i--
		dAtA[i] = 0x22
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AgentTime != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.AgentTime))
		i--
		dAtA[i] = 0x10
	}
	if m.DataType != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DownloadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownloadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigRefreshRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigRefreshRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigRefreshRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fingerprint) > 0 {
		for iNdEx := len(m.Fingerprint) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fingerprint[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PluginName) > 0 {
		i -= len(m.PluginName)
		copy(dAtA[i:], m.PluginName)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.PluginName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AgentID) > 0 {
		i -= len(m.AgentID)
		copy(dAtA[i:], m.AgentID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AgentID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigFingerPrint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigFingerPrint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigFingerPrint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigRefreshResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigRefreshResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigRefreshResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		for iNdEx := len(m.Config) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Config[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Status != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.Release != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.Release))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SecretKey) > 0 {
		i -= len(m.SecretKey)
		copy(dAtA[i:], m.SecretKey)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.SecretKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PluginName) > 0 {
		i -= len(m.PluginName)
		copy(dAtA[i:], m.PluginName)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.PluginName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Type != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DetailedStatus) > 0 {
		for k := range m.DetailedStatus {
			v := m.DetailedStatus[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGrpc(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGrpc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGrpc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.StatusMessage) > 0 {
		i -= len(m.StatusMessage)
		copy(dAtA[i:], m.StatusMessage)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.StatusMessage)))
		i--
		dAtA[i] = 0x62
	}
	if m.ProxyStatus != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.ProxyStatus))
		i--
		dAtA[i] = 0x58
	}
	if m.ProxyStartTime != 0 {
		i = encodeVarintGrpc(dAtA, i, uint64(m.ProxyStartTime))
		i--
		dAtA[i] = 0x50
	}
	if len(m.ConnectedAgents) > 0 {
		for iNdEx := len(m.ConnectedAgents) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConnectedAgents[iNdEx])
			copy(dAtA[i:], m.ConnectedAgents[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.ConnectedAgents[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExtranetIPv6) > 0 {
		for iNdEx := len(m.ExtranetIPv6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtranetIPv6[iNdEx])
			copy(dAtA[i:], m.ExtranetIPv6[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.ExtranetIPv6[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.IntranetIPv6) > 0 {
		for iNdEx := len(m.IntranetIPv6) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IntranetIPv6[iNdEx])
			copy(dAtA[i:], m.IntranetIPv6[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.IntranetIPv6[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ExtranetIPv4) > 0 {
		for iNdEx := len(m.ExtranetIPv4) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtranetIPv4[iNdEx])
			copy(dAtA[i:], m.ExtranetIPv4[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.ExtranetIPv4[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IntranetIPv4) > 0 {
		for iNdEx := len(m.IntranetIPv4) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IntranetIPv4[iNdEx])
			copy(dAtA[i:], m.IntranetIPv4[iNdEx])
			i = encodeVarintGrpc(dAtA, i, uint64(len(m.IntranetIPv4[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ProxyLocalID) > 0 {
		i -= len(m.ProxyLocalID)
		copy(dAtA[i:], m.ProxyLocalID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.ProxyLocalID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProxyID) > 0 {
		i -= len(m.ProxyID)
		copy(dAtA[i:], m.ProxyID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.ProxyID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyInstallRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyInstallRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyInstallRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InstallType) > 0 {
		i -= len(m.InstallType)
		copy(dAtA[i:], m.InstallType)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.InstallType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InstallKey) > 0 {
		i -= len(m.InstallKey)
		copy(dAtA[i:], m.InstallKey)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.InstallKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AgentID) > 0 {
		i -= len(m.AgentID)
		copy(dAtA[i:], m.AgentID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AgentID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyInstallResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyInstallResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyInstallResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGrpc(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGrpc(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGrpc(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AccountID) > 0 {
		i -= len(m.AccountID)
		copy(dAtA[i:], m.AccountID)
		i = encodeVarintGrpc(dAtA, i, uint64(len(m.AccountID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGrpc(dAtA []byte, offset int, v uint64) int {
	offset -= sovGrpc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RawData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	l = len(m.AgentID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if len(m.IntranetIPv4) > 0 {
		for _, s := range m.IntranetIPv4 {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if len(m.ExtranetIPv4) > 0 {
		for _, s := range m.ExtranetIPv4 {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if len(m.IntranetIPv6) > 0 {
		for _, s := range m.IntranetIPv6 {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if len(m.ExtranetIPv6) > 0 {
		for _, s := range m.ExtranetIPv6 {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovGrpc(uint64(m.DataType))
	}
	if m.Timestamp != 0 {
		n += 1 + sovGrpc(uint64(m.Timestamp))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.AppendedBody)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGrpc(uint64(len(k))) + 1 + len(v) + sovGrpc(uint64(len(v)))
			n += mapEntrySize + 1 + sovGrpc(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ItemArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Command) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentCtrl != 0 {
		n += 1 + sovGrpc(uint64(m.AgentCtrl))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovGrpc(uint64(l))
	}
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovGrpc(uint64(m.DataType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.SHA256)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if len(m.DownloadURL) > 0 {
		for _, s := range m.DownloadURL {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MQData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovGrpc(uint64(m.DataType))
	}
	if m.AgentTime != 0 {
		n += 1 + sovGrpc(uint64(m.AgentTime))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.AgentID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.IntranetIPv4)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.ExtranetIPv4)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.IntranetIPv6)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.ExtranetIPv6)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.SvrTime != 0 {
		n += 1 + sovGrpc(uint64(m.SvrTime))
	}
	l = len(m.PSMName)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.PSMPath)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Enhanced)
	if l > 0 {
		n += 2 + l + sovGrpc(uint64(l))
	}
	l = len(m.IsHoneypot)
	if l > 0 {
		n += 2 + l + sovGrpc(uint64(l))
	}
	l = len(m.AppendedBody)
	if l > 0 {
		n += 2 + l + sovGrpc(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 2 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MQRawData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovGrpc(uint64(m.DataType))
	}
	if m.AgentTime != 0 {
		n += 1 + sovGrpc(uint64(m.AgentTime))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.AgentID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.IntranetIPv4)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.ExtranetIPv4)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.IntranetIPv6)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.ExtranetIPv6)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.SvrTime != 0 {
		n += 1 + sovGrpc(uint64(m.SvrTime))
	}
	l = len(m.PSMName)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.PSMPath)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Enhanced)
	if l > 0 {
		n += 2 + l + sovGrpc(uint64(l))
	}
	l = len(m.IsHoneypot)
	if l > 0 {
		n += 2 + l + sovGrpc(uint64(l))
	}
	if m.AppendedBody != nil {
		l = m.AppendedBody.Size()
		n += 2 + l + sovGrpc(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 2 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovGrpc(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigRefreshRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AgentID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.PluginName)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if len(m.Fingerprint) > 0 {
		for _, e := range m.Fingerprint {
			l = e.Size()
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigFingerPrint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGrpc(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigRefreshResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PluginName)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.SecretKey)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.Release != 0 {
		n += 1 + sovGrpc(uint64(m.Release))
	}
	if m.Status != 0 {
		n += 1 + sovGrpc(uint64(m.Status))
	}
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGrpc(uint64(m.Status))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGrpc(uint64(m.Type))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProxyID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.ProxyLocalID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if len(m.IntranetIPv4) > 0 {
		for _, s := range m.IntranetIPv4 {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if len(m.ExtranetIPv4) > 0 {
		for _, s := range m.ExtranetIPv4 {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if len(m.IntranetIPv6) > 0 {
		for _, s := range m.IntranetIPv6 {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if len(m.ExtranetIPv6) > 0 {
		for _, s := range m.ExtranetIPv6 {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if len(m.ConnectedAgents) > 0 {
		for _, s := range m.ConnectedAgents {
			l = len(s)
			n += 1 + l + sovGrpc(uint64(l))
		}
	}
	if m.ProxyStartTime != 0 {
		n += 1 + sovGrpc(uint64(m.ProxyStartTime))
	}
	if m.ProxyStatus != 0 {
		n += 1 + sovGrpc(uint64(m.ProxyStatus))
	}
	l = len(m.StatusMessage)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if len(m.DetailedStatus) > 0 {
		for k, v := range m.DetailedStatus {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGrpc(uint64(len(k))) + 1 + len(v) + sovGrpc(uint64(len(v)))
			n += mapEntrySize + 1 + sovGrpc(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyInstallRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AgentID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.InstallKey)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	l = len(m.InstallType)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyInstallResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovGrpc(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGrpc(uint64(len(k))) + 1 + len(v) + sovGrpc(uint64(len(v)))
			n += mapEntrySize + 1 + sovGrpc(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGrpc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGrpc(x uint64) (n int) {
	return sovGrpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RawData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Record{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntranetIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntranetIPv4 = append(m.IntranetIPv4, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtranetIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtranetIPv4 = append(m.ExtranetIPv4, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntranetIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntranetIPv6 = append(m.IntranetIPv6, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtranetIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtranetIPv6 = append(m.ExtranetIPv6, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendedBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppendedBody = append(m.AppendedBody[:0], dAtA[iNdEx:postIndex]...)
			if m.AppendedBody == nil {
				m.AppendedBody = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGrpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGrpc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGrpc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGrpc
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGrpc
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGrpc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGrpc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentCtrl", wireType)
			}
			m.AgentCtrl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentCtrl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &PluginTask{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, &ConfigItem{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHA256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SHA256 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadURL = append(m.DownloadURL, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MQData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MQData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MQData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentTime", wireType)
			}
			m.AgentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntranetIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntranetIPv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtranetIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtranetIPv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntranetIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntranetIPv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtranetIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtranetIPv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvrTime", wireType)
			}
			m.SvrTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SvrTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSMName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PSMName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSMPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PSMPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enhanced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enhanced = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHoneypot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsHoneypot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendedBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppendedBody = append(m.AppendedBody[:0], dAtA[iNdEx:postIndex]...)
			if m.AppendedBody == nil {
				m.AppendedBody = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MQRawData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MQRawData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MQRawData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentTime", wireType)
			}
			m.AgentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &Item{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntranetIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntranetIPv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtranetIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtranetIPv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntranetIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntranetIPv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtranetIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtranetIPv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvrTime", wireType)
			}
			m.SvrTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SvrTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSMName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PSMName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PSMPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PSMPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enhanced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enhanced = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHoneypot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsHoneypot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendedBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppendedBody == nil {
				m.AppendedBody = &ItemArray{}
			}
			if err := m.AppendedBody.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UploadResponse_StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigRefreshRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigRefreshRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigRefreshRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PluginName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fingerprint = append(m.Fingerprint, &ConfigFingerPrint{})
			if err := m.Fingerprint[len(m.Fingerprint)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigFingerPrint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigFingerPrint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigFingerPrint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ConfigFPStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigRefreshResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigRefreshResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigRefreshResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PluginName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			m.Release = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Release |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ConfigStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, &ConfigDetail{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ConfigStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConfigTypeCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyLocalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyLocalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntranetIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntranetIPv4 = append(m.IntranetIPv4, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtranetIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtranetIPv4 = append(m.ExtranetIPv4, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntranetIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntranetIPv6 = append(m.IntranetIPv6, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtranetIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtranetIPv6 = append(m.ExtranetIPv6, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedAgents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedAgents = append(m.ConnectedAgents, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyStartTime", wireType)
			}
			m.ProxyStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProxyStartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyStatus", wireType)
			}
			m.ProxyStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProxyStatus |= ProxyStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetailedStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetailedStatus == nil {
				m.DetailedStatus = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGrpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGrpc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGrpc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGrpc
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGrpc
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGrpc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGrpc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DetailedStatus[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyInstallRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyInstallRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyInstallRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstallKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstallType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyInstallResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyInstallResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyInstallResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGrpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGrpc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGrpc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGrpc
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGrpc
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGrpc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGrpc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGrpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGrpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGrpc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGrpc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGrpc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGrpc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGrpc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGrpc = fmt.Errorf("proto: unexpected end of group")
)
