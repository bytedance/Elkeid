/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const OPENSSL_VERSION_NUMBER: u32 = 269488367;
pub const OPENSSL_VERSION_TEXT: &[u8; 28usize] = b"OpenSSL 1.1.1n  15 Mar 2022\0";
pub const SHLIB_VERSION_HISTORY: &[u8; 1usize] = b"\0";
pub const SHLIB_VERSION_NUMBER: &[u8; 4usize] = b"1.1\0";
pub const OPENSSL_MIN_API: u32 = 0;
pub const OPENSSL_API_COMPAT: u32 = 0;
pub const _INTTYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201605;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 24;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const CRYPTO_F_CMAC_CTX_NEW: u32 = 120;
pub const CRYPTO_F_CRYPTO_DUP_EX_DATA: u32 = 110;
pub const CRYPTO_F_CRYPTO_FREE_EX_DATA: u32 = 111;
pub const CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX: u32 = 100;
pub const CRYPTO_F_CRYPTO_MEMDUP: u32 = 115;
pub const CRYPTO_F_CRYPTO_NEW_EX_DATA: u32 = 112;
pub const CRYPTO_F_CRYPTO_OCB128_COPY_CTX: u32 = 121;
pub const CRYPTO_F_CRYPTO_OCB128_INIT: u32 = 122;
pub const CRYPTO_F_CRYPTO_SET_EX_DATA: u32 = 102;
pub const CRYPTO_F_FIPS_MODE_SET: u32 = 109;
pub const CRYPTO_F_GET_AND_LOCK: u32 = 113;
pub const CRYPTO_F_OPENSSL_ATEXIT: u32 = 114;
pub const CRYPTO_F_OPENSSL_BUF2HEXSTR: u32 = 117;
pub const CRYPTO_F_OPENSSL_FOPEN: u32 = 119;
pub const CRYPTO_F_OPENSSL_HEXSTR2BUF: u32 = 118;
pub const CRYPTO_F_OPENSSL_INIT_CRYPTO: u32 = 116;
pub const CRYPTO_F_OPENSSL_LH_NEW: u32 = 126;
pub const CRYPTO_F_OPENSSL_SK_DEEP_COPY: u32 = 127;
pub const CRYPTO_F_OPENSSL_SK_DUP: u32 = 128;
pub const CRYPTO_F_PKEY_HMAC_INIT: u32 = 123;
pub const CRYPTO_F_PKEY_POLY1305_INIT: u32 = 124;
pub const CRYPTO_F_PKEY_SIPHASH_INIT: u32 = 125;
pub const CRYPTO_F_SK_RESERVE: u32 = 129;
pub const CRYPTO_R_FIPS_MODE_NOT_SUPPORTED: u32 = 101;
pub const CRYPTO_R_ILLEGAL_HEX_DIGIT: u32 = 102;
pub const CRYPTO_R_ODD_NUMBER_OF_DIGITS: u32 = 103;
pub const SSLEAY_VERSION_NUMBER: u32 = 269488367;
pub const CRYPTO_MEM_CHECK_OFF: u32 = 0;
pub const CRYPTO_MEM_CHECK_ON: u32 = 1;
pub const CRYPTO_MEM_CHECK_ENABLE: u32 = 2;
pub const CRYPTO_MEM_CHECK_DISABLE: u32 = 3;
pub const CRYPTO_EX_INDEX_SSL: u32 = 0;
pub const CRYPTO_EX_INDEX_SSL_CTX: u32 = 1;
pub const CRYPTO_EX_INDEX_SSL_SESSION: u32 = 2;
pub const CRYPTO_EX_INDEX_X509: u32 = 3;
pub const CRYPTO_EX_INDEX_X509_STORE: u32 = 4;
pub const CRYPTO_EX_INDEX_X509_STORE_CTX: u32 = 5;
pub const CRYPTO_EX_INDEX_DH: u32 = 6;
pub const CRYPTO_EX_INDEX_DSA: u32 = 7;
pub const CRYPTO_EX_INDEX_EC_KEY: u32 = 8;
pub const CRYPTO_EX_INDEX_RSA: u32 = 9;
pub const CRYPTO_EX_INDEX_ENGINE: u32 = 10;
pub const CRYPTO_EX_INDEX_UI: u32 = 11;
pub const CRYPTO_EX_INDEX_BIO: u32 = 12;
pub const CRYPTO_EX_INDEX_APP: u32 = 13;
pub const CRYPTO_EX_INDEX_UI_METHOD: u32 = 14;
pub const CRYPTO_EX_INDEX_DRBG: u32 = 15;
pub const CRYPTO_EX_INDEX__COUNT: u32 = 16;
pub const OPENSSL_VERSION: u32 = 0;
pub const OPENSSL_CFLAGS: u32 = 1;
pub const OPENSSL_BUILT_ON: u32 = 2;
pub const OPENSSL_PLATFORM: u32 = 3;
pub const OPENSSL_DIR: u32 = 4;
pub const OPENSSL_ENGINES_DIR: u32 = 5;
pub const CRYPTO_LOCK: u32 = 1;
pub const CRYPTO_UNLOCK: u32 = 2;
pub const CRYPTO_READ: u32 = 4;
pub const CRYPTO_WRITE: u32 = 8;
pub const OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS: u32 = 1;
pub const OPENSSL_INIT_LOAD_CRYPTO_STRINGS: u32 = 2;
pub const OPENSSL_INIT_ADD_ALL_CIPHERS: u32 = 4;
pub const OPENSSL_INIT_ADD_ALL_DIGESTS: u32 = 8;
pub const OPENSSL_INIT_NO_ADD_ALL_CIPHERS: u32 = 16;
pub const OPENSSL_INIT_NO_ADD_ALL_DIGESTS: u32 = 32;
pub const OPENSSL_INIT_LOAD_CONFIG: u32 = 64;
pub const OPENSSL_INIT_NO_LOAD_CONFIG: u32 = 128;
pub const OPENSSL_INIT_ASYNC: u32 = 256;
pub const OPENSSL_INIT_ENGINE_RDRAND: u32 = 512;
pub const OPENSSL_INIT_ENGINE_DYNAMIC: u32 = 1024;
pub const OPENSSL_INIT_ENGINE_OPENSSL: u32 = 2048;
pub const OPENSSL_INIT_ENGINE_CRYPTODEV: u32 = 4096;
pub const OPENSSL_INIT_ENGINE_CAPI: u32 = 8192;
pub const OPENSSL_INIT_ENGINE_PADLOCK: u32 = 16384;
pub const OPENSSL_INIT_ENGINE_AFALG: u32 = 32768;
pub const OPENSSL_INIT_ATFORK: u32 = 131072;
pub const OPENSSL_INIT_NO_ATEXIT: u32 = 524288;
pub const OPENSSL_INIT_ENGINE_ALL_BUILTIN: u32 = 30208;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const __defined_schedparam: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const CRYPTO_ONCE_STATIC_INIT: u32 = 0;
pub const COMP_F_BIO_ZLIB_FLUSH: u32 = 99;
pub const COMP_F_BIO_ZLIB_NEW: u32 = 100;
pub const COMP_F_BIO_ZLIB_READ: u32 = 101;
pub const COMP_F_BIO_ZLIB_WRITE: u32 = 102;
pub const COMP_F_COMP_CTX_NEW: u32 = 103;
pub const COMP_R_ZLIB_DEFLATE_ERROR: u32 = 99;
pub const COMP_R_ZLIB_INFLATE_ERROR: u32 = 100;
pub const COMP_R_ZLIB_NOT_SUPPORTED: u32 = 101;
pub const BIO_F_ACPT_STATE: u32 = 100;
pub const BIO_F_ADDRINFO_WRAP: u32 = 148;
pub const BIO_F_ADDR_STRINGS: u32 = 134;
pub const BIO_F_BIO_ACCEPT: u32 = 101;
pub const BIO_F_BIO_ACCEPT_EX: u32 = 137;
pub const BIO_F_BIO_ACCEPT_NEW: u32 = 152;
pub const BIO_F_BIO_ADDR_NEW: u32 = 144;
pub const BIO_F_BIO_BIND: u32 = 147;
pub const BIO_F_BIO_CALLBACK_CTRL: u32 = 131;
pub const BIO_F_BIO_CONNECT: u32 = 138;
pub const BIO_F_BIO_CONNECT_NEW: u32 = 153;
pub const BIO_F_BIO_CTRL: u32 = 103;
pub const BIO_F_BIO_GETS: u32 = 104;
pub const BIO_F_BIO_GET_HOST_IP: u32 = 106;
pub const BIO_F_BIO_GET_NEW_INDEX: u32 = 102;
pub const BIO_F_BIO_GET_PORT: u32 = 107;
pub const BIO_F_BIO_LISTEN: u32 = 139;
pub const BIO_F_BIO_LOOKUP: u32 = 135;
pub const BIO_F_BIO_LOOKUP_EX: u32 = 143;
pub const BIO_F_BIO_MAKE_PAIR: u32 = 121;
pub const BIO_F_BIO_METH_NEW: u32 = 146;
pub const BIO_F_BIO_NEW: u32 = 108;
pub const BIO_F_BIO_NEW_DGRAM_SCTP: u32 = 145;
pub const BIO_F_BIO_NEW_FILE: u32 = 109;
pub const BIO_F_BIO_NEW_MEM_BUF: u32 = 126;
pub const BIO_F_BIO_NREAD: u32 = 123;
pub const BIO_F_BIO_NREAD0: u32 = 124;
pub const BIO_F_BIO_NWRITE: u32 = 125;
pub const BIO_F_BIO_NWRITE0: u32 = 122;
pub const BIO_F_BIO_PARSE_HOSTSERV: u32 = 136;
pub const BIO_F_BIO_PUTS: u32 = 110;
pub const BIO_F_BIO_READ: u32 = 111;
pub const BIO_F_BIO_READ_EX: u32 = 105;
pub const BIO_F_BIO_READ_INTERN: u32 = 120;
pub const BIO_F_BIO_SOCKET: u32 = 140;
pub const BIO_F_BIO_SOCKET_NBIO: u32 = 142;
pub const BIO_F_BIO_SOCK_INFO: u32 = 141;
pub const BIO_F_BIO_SOCK_INIT: u32 = 112;
pub const BIO_F_BIO_WRITE: u32 = 113;
pub const BIO_F_BIO_WRITE_EX: u32 = 119;
pub const BIO_F_BIO_WRITE_INTERN: u32 = 128;
pub const BIO_F_BUFFER_CTRL: u32 = 114;
pub const BIO_F_CONN_CTRL: u32 = 127;
pub const BIO_F_CONN_STATE: u32 = 115;
pub const BIO_F_DGRAM_SCTP_NEW: u32 = 149;
pub const BIO_F_DGRAM_SCTP_READ: u32 = 132;
pub const BIO_F_DGRAM_SCTP_WRITE: u32 = 133;
pub const BIO_F_DOAPR_OUTCH: u32 = 150;
pub const BIO_F_FILE_CTRL: u32 = 116;
pub const BIO_F_FILE_READ: u32 = 130;
pub const BIO_F_LINEBUFFER_CTRL: u32 = 129;
pub const BIO_F_LINEBUFFER_NEW: u32 = 151;
pub const BIO_F_MEM_WRITE: u32 = 117;
pub const BIO_F_NBIOF_NEW: u32 = 154;
pub const BIO_F_SLG_WRITE: u32 = 155;
pub const BIO_F_SSL_NEW: u32 = 118;
pub const BIO_R_ACCEPT_ERROR: u32 = 100;
pub const BIO_R_ADDRINFO_ADDR_IS_NOT_AF_INET: u32 = 141;
pub const BIO_R_AMBIGUOUS_HOST_OR_SERVICE: u32 = 129;
pub const BIO_R_BAD_FOPEN_MODE: u32 = 101;
pub const BIO_R_BROKEN_PIPE: u32 = 124;
pub const BIO_R_CONNECT_ERROR: u32 = 103;
pub const BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET: u32 = 107;
pub const BIO_R_GETSOCKNAME_ERROR: u32 = 132;
pub const BIO_R_GETSOCKNAME_TRUNCATED_ADDRESS: u32 = 133;
pub const BIO_R_GETTING_SOCKTYPE: u32 = 134;
pub const BIO_R_INVALID_ARGUMENT: u32 = 125;
pub const BIO_R_INVALID_SOCKET: u32 = 135;
pub const BIO_R_IN_USE: u32 = 123;
pub const BIO_R_LENGTH_TOO_LONG: u32 = 102;
pub const BIO_R_LISTEN_V6_ONLY: u32 = 136;
pub const BIO_R_LOOKUP_RETURNED_NOTHING: u32 = 142;
pub const BIO_R_MALFORMED_HOST_OR_SERVICE: u32 = 130;
pub const BIO_R_NBIO_CONNECT_ERROR: u32 = 110;
pub const BIO_R_NO_ACCEPT_ADDR_OR_SERVICE_SPECIFIED: u32 = 143;
pub const BIO_R_NO_HOSTNAME_OR_SERVICE_SPECIFIED: u32 = 144;
pub const BIO_R_NO_PORT_DEFINED: u32 = 113;
pub const BIO_R_NO_SUCH_FILE: u32 = 128;
pub const BIO_R_NULL_PARAMETER: u32 = 115;
pub const BIO_R_UNABLE_TO_BIND_SOCKET: u32 = 117;
pub const BIO_R_UNABLE_TO_CREATE_SOCKET: u32 = 118;
pub const BIO_R_UNABLE_TO_KEEPALIVE: u32 = 137;
pub const BIO_R_UNABLE_TO_LISTEN_SOCKET: u32 = 119;
pub const BIO_R_UNABLE_TO_NODELAY: u32 = 138;
pub const BIO_R_UNABLE_TO_REUSEADDR: u32 = 139;
pub const BIO_R_UNAVAILABLE_IP_FAMILY: u32 = 145;
pub const BIO_R_UNINITIALIZED: u32 = 120;
pub const BIO_R_UNKNOWN_INFO_TYPE: u32 = 140;
pub const BIO_R_UNSUPPORTED_IP_FAMILY: u32 = 146;
pub const BIO_R_UNSUPPORTED_METHOD: u32 = 121;
pub const BIO_R_UNSUPPORTED_PROTOCOL_FAMILY: u32 = 131;
pub const BIO_R_WRITE_TO_READ_ONLY_BIO: u32 = 126;
pub const BIO_R_WSASTARTUP: u32 = 122;
pub const BIO_TYPE_DESCRIPTOR: u32 = 256;
pub const BIO_TYPE_FILTER: u32 = 512;
pub const BIO_TYPE_SOURCE_SINK: u32 = 1024;
pub const BIO_TYPE_NONE: u32 = 0;
pub const BIO_TYPE_MEM: u32 = 1025;
pub const BIO_TYPE_FILE: u32 = 1026;
pub const BIO_TYPE_FD: u32 = 1284;
pub const BIO_TYPE_SOCKET: u32 = 1285;
pub const BIO_TYPE_NULL: u32 = 1030;
pub const BIO_TYPE_SSL: u32 = 519;
pub const BIO_TYPE_MD: u32 = 520;
pub const BIO_TYPE_BUFFER: u32 = 521;
pub const BIO_TYPE_CIPHER: u32 = 522;
pub const BIO_TYPE_BASE64: u32 = 523;
pub const BIO_TYPE_CONNECT: u32 = 1292;
pub const BIO_TYPE_ACCEPT: u32 = 1293;
pub const BIO_TYPE_NBIO_TEST: u32 = 528;
pub const BIO_TYPE_NULL_FILTER: u32 = 529;
pub const BIO_TYPE_BIO: u32 = 1043;
pub const BIO_TYPE_LINEBUFFER: u32 = 532;
pub const BIO_TYPE_DGRAM: u32 = 1301;
pub const BIO_TYPE_ASN1: u32 = 534;
pub const BIO_TYPE_COMP: u32 = 535;
pub const BIO_TYPE_START: u32 = 128;
pub const BIO_NOCLOSE: u32 = 0;
pub const BIO_CLOSE: u32 = 1;
pub const BIO_CTRL_RESET: u32 = 1;
pub const BIO_CTRL_EOF: u32 = 2;
pub const BIO_CTRL_INFO: u32 = 3;
pub const BIO_CTRL_SET: u32 = 4;
pub const BIO_CTRL_GET: u32 = 5;
pub const BIO_CTRL_PUSH: u32 = 6;
pub const BIO_CTRL_POP: u32 = 7;
pub const BIO_CTRL_GET_CLOSE: u32 = 8;
pub const BIO_CTRL_SET_CLOSE: u32 = 9;
pub const BIO_CTRL_PENDING: u32 = 10;
pub const BIO_CTRL_FLUSH: u32 = 11;
pub const BIO_CTRL_DUP: u32 = 12;
pub const BIO_CTRL_WPENDING: u32 = 13;
pub const BIO_CTRL_SET_CALLBACK: u32 = 14;
pub const BIO_CTRL_GET_CALLBACK: u32 = 15;
pub const BIO_CTRL_PEEK: u32 = 29;
pub const BIO_CTRL_SET_FILENAME: u32 = 30;
pub const BIO_CTRL_DGRAM_CONNECT: u32 = 31;
pub const BIO_CTRL_DGRAM_SET_CONNECTED: u32 = 32;
pub const BIO_CTRL_DGRAM_SET_RECV_TIMEOUT: u32 = 33;
pub const BIO_CTRL_DGRAM_GET_RECV_TIMEOUT: u32 = 34;
pub const BIO_CTRL_DGRAM_SET_SEND_TIMEOUT: u32 = 35;
pub const BIO_CTRL_DGRAM_GET_SEND_TIMEOUT: u32 = 36;
pub const BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP: u32 = 37;
pub const BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP: u32 = 38;
pub const BIO_CTRL_DGRAM_MTU_DISCOVER: u32 = 39;
pub const BIO_CTRL_DGRAM_QUERY_MTU: u32 = 40;
pub const BIO_CTRL_DGRAM_GET_FALLBACK_MTU: u32 = 47;
pub const BIO_CTRL_DGRAM_GET_MTU: u32 = 41;
pub const BIO_CTRL_DGRAM_SET_MTU: u32 = 42;
pub const BIO_CTRL_DGRAM_MTU_EXCEEDED: u32 = 43;
pub const BIO_CTRL_DGRAM_GET_PEER: u32 = 46;
pub const BIO_CTRL_DGRAM_SET_PEER: u32 = 44;
pub const BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT: u32 = 45;
pub const BIO_CTRL_DGRAM_SET_DONT_FRAG: u32 = 48;
pub const BIO_CTRL_DGRAM_GET_MTU_OVERHEAD: u32 = 49;
pub const BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE: u32 = 50;
pub const BIO_CTRL_DGRAM_SET_PEEK_MODE: u32 = 71;
pub const BIO_FP_READ: u32 = 2;
pub const BIO_FP_WRITE: u32 = 4;
pub const BIO_FP_APPEND: u32 = 8;
pub const BIO_FP_TEXT: u32 = 16;
pub const BIO_FLAGS_READ: u32 = 1;
pub const BIO_FLAGS_WRITE: u32 = 2;
pub const BIO_FLAGS_IO_SPECIAL: u32 = 4;
pub const BIO_FLAGS_RWS: u32 = 7;
pub const BIO_FLAGS_SHOULD_RETRY: u32 = 8;
pub const BIO_FLAGS_UPLINK: u32 = 0;
pub const BIO_FLAGS_BASE64_NO_NL: u32 = 256;
pub const BIO_FLAGS_MEM_RDONLY: u32 = 512;
pub const BIO_FLAGS_NONCLEAR_RST: u32 = 1024;
pub const BIO_FLAGS_IN_EOF: u32 = 2048;
pub const BIO_RR_SSL_X509_LOOKUP: u32 = 1;
pub const BIO_RR_CONNECT: u32 = 2;
pub const BIO_RR_ACCEPT: u32 = 3;
pub const BIO_CB_FREE: u32 = 1;
pub const BIO_CB_READ: u32 = 2;
pub const BIO_CB_WRITE: u32 = 3;
pub const BIO_CB_PUTS: u32 = 4;
pub const BIO_CB_GETS: u32 = 5;
pub const BIO_CB_CTRL: u32 = 6;
pub const BIO_CB_RETURN: u32 = 128;
pub const BIO_C_SET_CONNECT: u32 = 100;
pub const BIO_C_DO_STATE_MACHINE: u32 = 101;
pub const BIO_C_SET_NBIO: u32 = 102;
pub const BIO_C_SET_FD: u32 = 104;
pub const BIO_C_GET_FD: u32 = 105;
pub const BIO_C_SET_FILE_PTR: u32 = 106;
pub const BIO_C_GET_FILE_PTR: u32 = 107;
pub const BIO_C_SET_FILENAME: u32 = 108;
pub const BIO_C_SET_SSL: u32 = 109;
pub const BIO_C_GET_SSL: u32 = 110;
pub const BIO_C_SET_MD: u32 = 111;
pub const BIO_C_GET_MD: u32 = 112;
pub const BIO_C_GET_CIPHER_STATUS: u32 = 113;
pub const BIO_C_SET_BUF_MEM: u32 = 114;
pub const BIO_C_GET_BUF_MEM_PTR: u32 = 115;
pub const BIO_C_GET_BUFF_NUM_LINES: u32 = 116;
pub const BIO_C_SET_BUFF_SIZE: u32 = 117;
pub const BIO_C_SET_ACCEPT: u32 = 118;
pub const BIO_C_SSL_MODE: u32 = 119;
pub const BIO_C_GET_MD_CTX: u32 = 120;
pub const BIO_C_SET_BUFF_READ_DATA: u32 = 122;
pub const BIO_C_GET_CONNECT: u32 = 123;
pub const BIO_C_GET_ACCEPT: u32 = 124;
pub const BIO_C_SET_SSL_RENEGOTIATE_BYTES: u32 = 125;
pub const BIO_C_GET_SSL_NUM_RENEGOTIATES: u32 = 126;
pub const BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT: u32 = 127;
pub const BIO_C_FILE_SEEK: u32 = 128;
pub const BIO_C_GET_CIPHER_CTX: u32 = 129;
pub const BIO_C_SET_BUF_MEM_EOF_RETURN: u32 = 130;
pub const BIO_C_SET_BIND_MODE: u32 = 131;
pub const BIO_C_GET_BIND_MODE: u32 = 132;
pub const BIO_C_FILE_TELL: u32 = 133;
pub const BIO_C_GET_SOCKS: u32 = 134;
pub const BIO_C_SET_SOCKS: u32 = 135;
pub const BIO_C_SET_WRITE_BUF_SIZE: u32 = 136;
pub const BIO_C_GET_WRITE_BUF_SIZE: u32 = 137;
pub const BIO_C_MAKE_BIO_PAIR: u32 = 138;
pub const BIO_C_DESTROY_BIO_PAIR: u32 = 139;
pub const BIO_C_GET_WRITE_GUARANTEE: u32 = 140;
pub const BIO_C_GET_READ_REQUEST: u32 = 141;
pub const BIO_C_SHUTDOWN_WR: u32 = 142;
pub const BIO_C_NREAD0: u32 = 143;
pub const BIO_C_NREAD: u32 = 144;
pub const BIO_C_NWRITE0: u32 = 145;
pub const BIO_C_NWRITE: u32 = 146;
pub const BIO_C_RESET_READ_REQUEST: u32 = 147;
pub const BIO_C_SET_MD_CTX: u32 = 148;
pub const BIO_C_SET_PREFIX: u32 = 149;
pub const BIO_C_GET_PREFIX: u32 = 150;
pub const BIO_C_SET_SUFFIX: u32 = 151;
pub const BIO_C_GET_SUFFIX: u32 = 152;
pub const BIO_C_SET_EX_ARG: u32 = 153;
pub const BIO_C_GET_EX_ARG: u32 = 154;
pub const BIO_C_SET_CONNECT_MODE: u32 = 155;
pub const BIO_FAMILY_IPV4: u32 = 4;
pub const BIO_FAMILY_IPV6: u32 = 6;
pub const BIO_FAMILY_IPANY: u32 = 256;
pub const BIO_BIND_NORMAL: u32 = 0;
pub const BIO_SOCK_REUSEADDR: u32 = 1;
pub const BIO_SOCK_V6_ONLY: u32 = 2;
pub const BIO_SOCK_KEEPALIVE: u32 = 4;
pub const BIO_SOCK_NONBLOCK: u32 = 8;
pub const BIO_SOCK_NODELAY: u32 = 16;
pub const BUF_F_BUF_MEM_GROW: u32 = 100;
pub const BUF_F_BUF_MEM_GROW_CLEAN: u32 = 105;
pub const BUF_F_BUF_MEM_NEW: u32 = 101;
pub const BUF_MEM_FLAG_SECURE: u32 = 1;
pub const EVP_F_AESNI_INIT_KEY: u32 = 165;
pub const EVP_F_AESNI_XTS_INIT_KEY: u32 = 207;
pub const EVP_F_AES_GCM_CTRL: u32 = 196;
pub const EVP_F_AES_INIT_KEY: u32 = 133;
pub const EVP_F_AES_OCB_CIPHER: u32 = 169;
pub const EVP_F_AES_T4_INIT_KEY: u32 = 178;
pub const EVP_F_AES_T4_XTS_INIT_KEY: u32 = 208;
pub const EVP_F_AES_WRAP_CIPHER: u32 = 170;
pub const EVP_F_AES_XTS_INIT_KEY: u32 = 209;
pub const EVP_F_ALG_MODULE_INIT: u32 = 177;
pub const EVP_F_ARIA_CCM_INIT_KEY: u32 = 175;
pub const EVP_F_ARIA_GCM_CTRL: u32 = 197;
pub const EVP_F_ARIA_GCM_INIT_KEY: u32 = 176;
pub const EVP_F_ARIA_INIT_KEY: u32 = 185;
pub const EVP_F_B64_NEW: u32 = 198;
pub const EVP_F_CAMELLIA_INIT_KEY: u32 = 159;
pub const EVP_F_CHACHA20_POLY1305_CTRL: u32 = 182;
pub const EVP_F_CMLL_T4_INIT_KEY: u32 = 179;
pub const EVP_F_DES_EDE3_WRAP_CIPHER: u32 = 171;
pub const EVP_F_DO_SIGVER_INIT: u32 = 161;
pub const EVP_F_ENC_NEW: u32 = 199;
pub const EVP_F_EVP_CIPHERINIT_EX: u32 = 123;
pub const EVP_F_EVP_CIPHER_ASN1_TO_PARAM: u32 = 204;
pub const EVP_F_EVP_CIPHER_CTX_COPY: u32 = 163;
pub const EVP_F_EVP_CIPHER_CTX_CTRL: u32 = 124;
pub const EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH: u32 = 122;
pub const EVP_F_EVP_CIPHER_PARAM_TO_ASN1: u32 = 205;
pub const EVP_F_EVP_DECRYPTFINAL_EX: u32 = 101;
pub const EVP_F_EVP_DECRYPTUPDATE: u32 = 166;
pub const EVP_F_EVP_DIGESTFINALXOF: u32 = 174;
pub const EVP_F_EVP_DIGESTINIT_EX: u32 = 128;
pub const EVP_F_EVP_ENCRYPTDECRYPTUPDATE: u32 = 219;
pub const EVP_F_EVP_ENCRYPTFINAL_EX: u32 = 127;
pub const EVP_F_EVP_ENCRYPTUPDATE: u32 = 167;
pub const EVP_F_EVP_MD_CTX_COPY_EX: u32 = 110;
pub const EVP_F_EVP_MD_SIZE: u32 = 162;
pub const EVP_F_EVP_OPENINIT: u32 = 102;
pub const EVP_F_EVP_PBE_ALG_ADD: u32 = 115;
pub const EVP_F_EVP_PBE_ALG_ADD_TYPE: u32 = 160;
pub const EVP_F_EVP_PBE_CIPHERINIT: u32 = 116;
pub const EVP_F_EVP_PBE_SCRYPT: u32 = 181;
pub const EVP_F_EVP_PKCS82PKEY: u32 = 111;
pub const EVP_F_EVP_PKEY2PKCS8: u32 = 113;
pub const EVP_F_EVP_PKEY_ASN1_ADD0: u32 = 188;
pub const EVP_F_EVP_PKEY_CHECK: u32 = 186;
pub const EVP_F_EVP_PKEY_COPY_PARAMETERS: u32 = 103;
pub const EVP_F_EVP_PKEY_CTX_CTRL: u32 = 137;
pub const EVP_F_EVP_PKEY_CTX_CTRL_STR: u32 = 150;
pub const EVP_F_EVP_PKEY_CTX_DUP: u32 = 156;
pub const EVP_F_EVP_PKEY_CTX_MD: u32 = 168;
pub const EVP_F_EVP_PKEY_DECRYPT: u32 = 104;
pub const EVP_F_EVP_PKEY_DECRYPT_INIT: u32 = 138;
pub const EVP_F_EVP_PKEY_DECRYPT_OLD: u32 = 151;
pub const EVP_F_EVP_PKEY_DERIVE: u32 = 153;
pub const EVP_F_EVP_PKEY_DERIVE_INIT: u32 = 154;
pub const EVP_F_EVP_PKEY_DERIVE_SET_PEER: u32 = 155;
pub const EVP_F_EVP_PKEY_ENCRYPT: u32 = 105;
pub const EVP_F_EVP_PKEY_ENCRYPT_INIT: u32 = 139;
pub const EVP_F_EVP_PKEY_ENCRYPT_OLD: u32 = 152;
pub const EVP_F_EVP_PKEY_GET0_DH: u32 = 119;
pub const EVP_F_EVP_PKEY_GET0_DSA: u32 = 120;
pub const EVP_F_EVP_PKEY_GET0_EC_KEY: u32 = 131;
pub const EVP_F_EVP_PKEY_GET0_HMAC: u32 = 183;
pub const EVP_F_EVP_PKEY_GET0_POLY1305: u32 = 184;
pub const EVP_F_EVP_PKEY_GET0_RSA: u32 = 121;
pub const EVP_F_EVP_PKEY_GET0_SIPHASH: u32 = 172;
pub const EVP_F_EVP_PKEY_GET_RAW_PRIVATE_KEY: u32 = 202;
pub const EVP_F_EVP_PKEY_GET_RAW_PUBLIC_KEY: u32 = 203;
pub const EVP_F_EVP_PKEY_KEYGEN: u32 = 146;
pub const EVP_F_EVP_PKEY_KEYGEN_INIT: u32 = 147;
pub const EVP_F_EVP_PKEY_METH_ADD0: u32 = 194;
pub const EVP_F_EVP_PKEY_METH_NEW: u32 = 195;
pub const EVP_F_EVP_PKEY_NEW: u32 = 106;
pub const EVP_F_EVP_PKEY_NEW_CMAC_KEY: u32 = 193;
pub const EVP_F_EVP_PKEY_NEW_RAW_PRIVATE_KEY: u32 = 191;
pub const EVP_F_EVP_PKEY_NEW_RAW_PUBLIC_KEY: u32 = 192;
pub const EVP_F_EVP_PKEY_PARAMGEN: u32 = 148;
pub const EVP_F_EVP_PKEY_PARAMGEN_INIT: u32 = 149;
pub const EVP_F_EVP_PKEY_PARAM_CHECK: u32 = 189;
pub const EVP_F_EVP_PKEY_PUBLIC_CHECK: u32 = 190;
pub const EVP_F_EVP_PKEY_SET1_ENGINE: u32 = 187;
pub const EVP_F_EVP_PKEY_SET_ALIAS_TYPE: u32 = 206;
pub const EVP_F_EVP_PKEY_SIGN: u32 = 140;
pub const EVP_F_EVP_PKEY_SIGN_INIT: u32 = 141;
pub const EVP_F_EVP_PKEY_VERIFY: u32 = 142;
pub const EVP_F_EVP_PKEY_VERIFY_INIT: u32 = 143;
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER: u32 = 144;
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT: u32 = 145;
pub const EVP_F_EVP_SIGNFINAL: u32 = 107;
pub const EVP_F_EVP_VERIFYFINAL: u32 = 108;
pub const EVP_F_INT_CTX_NEW: u32 = 157;
pub const EVP_F_OK_NEW: u32 = 200;
pub const EVP_F_PKCS5_PBE_KEYIVGEN: u32 = 117;
pub const EVP_F_PKCS5_V2_PBE_KEYIVGEN: u32 = 118;
pub const EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN: u32 = 164;
pub const EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN: u32 = 180;
pub const EVP_F_PKEY_SET_TYPE: u32 = 158;
pub const EVP_F_RC2_MAGIC_TO_METH: u32 = 109;
pub const EVP_F_RC5_CTRL: u32 = 125;
pub const EVP_F_R_32_12_16_INIT_KEY: u32 = 242;
pub const EVP_F_S390X_AES_GCM_CTRL: u32 = 201;
pub const EVP_F_UPDATE: u32 = 173;
pub const EVP_R_AES_KEY_SETUP_FAILED: u32 = 143;
pub const EVP_R_ARIA_KEY_SETUP_FAILED: u32 = 176;
pub const EVP_R_BAD_DECRYPT: u32 = 100;
pub const EVP_R_BAD_KEY_LENGTH: u32 = 195;
pub const EVP_R_BUFFER_TOO_SMALL: u32 = 155;
pub const EVP_R_CAMELLIA_KEY_SETUP_FAILED: u32 = 157;
pub const EVP_R_CIPHER_PARAMETER_ERROR: u32 = 122;
pub const EVP_R_COMMAND_NOT_SUPPORTED: u32 = 147;
pub const EVP_R_COPY_ERROR: u32 = 173;
pub const EVP_R_CTRL_NOT_IMPLEMENTED: u32 = 132;
pub const EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED: u32 = 133;
pub const EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH: u32 = 138;
pub const EVP_R_DECODE_ERROR: u32 = 114;
pub const EVP_R_DIFFERENT_KEY_TYPES: u32 = 101;
pub const EVP_R_DIFFERENT_PARAMETERS: u32 = 153;
pub const EVP_R_ERROR_LOADING_SECTION: u32 = 165;
pub const EVP_R_ERROR_SETTING_FIPS_MODE: u32 = 166;
pub const EVP_R_EXPECTING_AN_HMAC_KEY: u32 = 174;
pub const EVP_R_EXPECTING_AN_RSA_KEY: u32 = 127;
pub const EVP_R_EXPECTING_A_DH_KEY: u32 = 128;
pub const EVP_R_EXPECTING_A_DSA_KEY: u32 = 129;
pub const EVP_R_EXPECTING_A_EC_KEY: u32 = 142;
pub const EVP_R_EXPECTING_A_POLY1305_KEY: u32 = 164;
pub const EVP_R_EXPECTING_A_SIPHASH_KEY: u32 = 175;
pub const EVP_R_FIPS_MODE_NOT_SUPPORTED: u32 = 167;
pub const EVP_R_GET_RAW_KEY_FAILED: u32 = 182;
pub const EVP_R_ILLEGAL_SCRYPT_PARAMETERS: u32 = 171;
pub const EVP_R_INITIALIZATION_ERROR: u32 = 134;
pub const EVP_R_INPUT_NOT_INITIALIZED: u32 = 111;
pub const EVP_R_INVALID_DIGEST: u32 = 152;
pub const EVP_R_INVALID_FIPS_MODE: u32 = 168;
pub const EVP_R_INVALID_IV_LENGTH: u32 = 194;
pub const EVP_R_INVALID_KEY: u32 = 163;
pub const EVP_R_INVALID_KEY_LENGTH: u32 = 130;
pub const EVP_R_INVALID_OPERATION: u32 = 148;
pub const EVP_R_KEYGEN_FAILURE: u32 = 120;
pub const EVP_R_KEY_SETUP_FAILED: u32 = 180;
pub const EVP_R_MEMORY_LIMIT_EXCEEDED: u32 = 172;
pub const EVP_R_MESSAGE_DIGEST_IS_NULL: u32 = 159;
pub const EVP_R_METHOD_NOT_SUPPORTED: u32 = 144;
pub const EVP_R_MISSING_PARAMETERS: u32 = 103;
pub const EVP_R_NOT_XOF_OR_INVALID_LENGTH: u32 = 178;
pub const EVP_R_NO_CIPHER_SET: u32 = 131;
pub const EVP_R_NO_DEFAULT_DIGEST: u32 = 158;
pub const EVP_R_NO_DIGEST_SET: u32 = 139;
pub const EVP_R_NO_KEY_SET: u32 = 154;
pub const EVP_R_NO_OPERATION_SET: u32 = 149;
pub const EVP_R_ONLY_ONESHOT_SUPPORTED: u32 = 177;
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 150;
pub const EVP_R_OPERATON_NOT_INITIALIZED: u32 = 151;
pub const EVP_R_OUTPUT_WOULD_OVERFLOW: u32 = 184;
pub const EVP_R_PARTIALLY_OVERLAPPING: u32 = 162;
pub const EVP_R_PBKDF2_ERROR: u32 = 181;
pub const EVP_R_PKEY_APPLICATION_ASN1_METHOD_ALREADY_REGISTERED: u32 = 179;
pub const EVP_R_PRIVATE_KEY_DECODE_ERROR: u32 = 145;
pub const EVP_R_PRIVATE_KEY_ENCODE_ERROR: u32 = 146;
pub const EVP_R_PUBLIC_KEY_NOT_RSA: u32 = 106;
pub const EVP_R_UNKNOWN_CIPHER: u32 = 160;
pub const EVP_R_UNKNOWN_DIGEST: u32 = 161;
pub const EVP_R_UNKNOWN_OPTION: u32 = 169;
pub const EVP_R_UNKNOWN_PBE_ALGORITHM: u32 = 121;
pub const EVP_R_UNSUPPORTED_ALGORITHM: u32 = 156;
pub const EVP_R_UNSUPPORTED_CIPHER: u32 = 107;
pub const EVP_R_UNSUPPORTED_KEYLENGTH: u32 = 123;
pub const EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION: u32 = 124;
pub const EVP_R_UNSUPPORTED_KEY_SIZE: u32 = 108;
pub const EVP_R_UNSUPPORTED_NUMBER_OF_ROUNDS: u32 = 135;
pub const EVP_R_UNSUPPORTED_PRF: u32 = 125;
pub const EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM: u32 = 118;
pub const EVP_R_UNSUPPORTED_SALT_TYPE: u32 = 126;
pub const EVP_R_WRAP_MODE_NOT_ALLOWED: u32 = 170;
pub const EVP_R_WRONG_FINAL_BLOCK_LENGTH: u32 = 109;
pub const EVP_R_XTS_DUPLICATED_KEYS: u32 = 183;
pub const EVP_MAX_MD_SIZE: u32 = 64;
pub const EVP_MAX_KEY_LENGTH: u32 = 64;
pub const EVP_MAX_IV_LENGTH: u32 = 16;
pub const EVP_MAX_BLOCK_LENGTH: u32 = 32;
pub const PKCS5_SALT_LEN: u32 = 8;
pub const PKCS5_DEFAULT_ITER: u32 = 2048;
pub const SN_undef: &[u8; 6usize] = b"UNDEF\0";
pub const LN_undef: &[u8; 10usize] = b"undefined\0";
pub const NID_undef: u32 = 0;
pub const OBJ_undef: u32 = 0;
pub const SN_itu_t: &[u8; 6usize] = b"ITU-T\0";
pub const LN_itu_t: &[u8; 6usize] = b"itu-t\0";
pub const NID_itu_t: u32 = 645;
pub const OBJ_itu_t: u32 = 0;
pub const NID_ccitt: u32 = 404;
pub const OBJ_ccitt: u32 = 0;
pub const SN_iso: &[u8; 4usize] = b"ISO\0";
pub const LN_iso: &[u8; 4usize] = b"iso\0";
pub const NID_iso: u32 = 181;
pub const OBJ_iso: u32 = 1;
pub const SN_joint_iso_itu_t: &[u8; 16usize] = b"JOINT-ISO-ITU-T\0";
pub const LN_joint_iso_itu_t: &[u8; 16usize] = b"joint-iso-itu-t\0";
pub const NID_joint_iso_itu_t: u32 = 646;
pub const OBJ_joint_iso_itu_t: u32 = 2;
pub const NID_joint_iso_ccitt: u32 = 393;
pub const OBJ_joint_iso_ccitt: u32 = 2;
pub const SN_member_body: &[u8; 12usize] = b"member-body\0";
pub const LN_member_body: &[u8; 16usize] = b"ISO Member Body\0";
pub const NID_member_body: u32 = 182;
pub const SN_identified_organization: &[u8; 24usize] = b"identified-organization\0";
pub const NID_identified_organization: u32 = 676;
pub const SN_hmac_md5: &[u8; 9usize] = b"HMAC-MD5\0";
pub const LN_hmac_md5: &[u8; 9usize] = b"hmac-md5\0";
pub const NID_hmac_md5: u32 = 780;
pub const SN_hmac_sha1: &[u8; 10usize] = b"HMAC-SHA1\0";
pub const LN_hmac_sha1: &[u8; 10usize] = b"hmac-sha1\0";
pub const NID_hmac_sha1: u32 = 781;
pub const SN_x509ExtAdmission: &[u8; 17usize] = b"x509ExtAdmission\0";
pub const LN_x509ExtAdmission: &[u8; 48usize] =
    b"Professional Information or basis for Admission\0";
pub const NID_x509ExtAdmission: u32 = 1093;
pub const SN_certicom_arc: &[u8; 13usize] = b"certicom-arc\0";
pub const NID_certicom_arc: u32 = 677;
pub const SN_ieee: &[u8; 5usize] = b"ieee\0";
pub const NID_ieee: u32 = 1170;
pub const SN_ieee_siswg: &[u8; 11usize] = b"ieee-siswg\0";
pub const LN_ieee_siswg: &[u8; 39usize] = b"IEEE Security in Storage Working Group\0";
pub const NID_ieee_siswg: u32 = 1171;
pub const SN_international_organizations: &[u8; 28usize] = b"international-organizations\0";
pub const LN_international_organizations: &[u8; 28usize] = b"International Organizations\0";
pub const NID_international_organizations: u32 = 647;
pub const SN_wap: &[u8; 4usize] = b"wap\0";
pub const NID_wap: u32 = 678;
pub const SN_wap_wsg: &[u8; 8usize] = b"wap-wsg\0";
pub const NID_wap_wsg: u32 = 679;
pub const SN_selected_attribute_types: &[u8; 25usize] = b"selected-attribute-types\0";
pub const LN_selected_attribute_types: &[u8; 25usize] = b"Selected Attribute Types\0";
pub const NID_selected_attribute_types: u32 = 394;
pub const SN_clearance: &[u8; 10usize] = b"clearance\0";
pub const NID_clearance: u32 = 395;
pub const SN_ISO_US: &[u8; 7usize] = b"ISO-US\0";
pub const LN_ISO_US: &[u8; 19usize] = b"ISO US Member Body\0";
pub const NID_ISO_US: u32 = 183;
pub const SN_X9_57: &[u8; 6usize] = b"X9-57\0";
pub const LN_X9_57: &[u8; 6usize] = b"X9.57\0";
pub const NID_X9_57: u32 = 184;
pub const SN_X9cm: &[u8; 5usize] = b"X9cm\0";
pub const LN_X9cm: &[u8; 11usize] = b"X9.57 CM ?\0";
pub const NID_X9cm: u32 = 185;
pub const SN_ISO_CN: &[u8; 7usize] = b"ISO-CN\0";
pub const LN_ISO_CN: &[u8; 19usize] = b"ISO CN Member Body\0";
pub const NID_ISO_CN: u32 = 1140;
pub const SN_oscca: &[u8; 6usize] = b"oscca\0";
pub const NID_oscca: u32 = 1141;
pub const SN_sm_scheme: &[u8; 10usize] = b"sm-scheme\0";
pub const NID_sm_scheme: u32 = 1142;
pub const SN_dsa: &[u8; 4usize] = b"DSA\0";
pub const LN_dsa: &[u8; 14usize] = b"dsaEncryption\0";
pub const NID_dsa: u32 = 116;
pub const SN_dsaWithSHA1: &[u8; 9usize] = b"DSA-SHA1\0";
pub const LN_dsaWithSHA1: &[u8; 12usize] = b"dsaWithSHA1\0";
pub const NID_dsaWithSHA1: u32 = 113;
pub const SN_ansi_X9_62: &[u8; 11usize] = b"ansi-X9-62\0";
pub const LN_ansi_X9_62: &[u8; 11usize] = b"ANSI X9.62\0";
pub const NID_ansi_X9_62: u32 = 405;
pub const SN_X9_62_prime_field: &[u8; 12usize] = b"prime-field\0";
pub const NID_X9_62_prime_field: u32 = 406;
pub const SN_X9_62_characteristic_two_field: &[u8; 25usize] = b"characteristic-two-field\0";
pub const NID_X9_62_characteristic_two_field: u32 = 407;
pub const SN_X9_62_id_characteristic_two_basis: &[u8; 28usize] = b"id-characteristic-two-basis\0";
pub const NID_X9_62_id_characteristic_two_basis: u32 = 680;
pub const SN_X9_62_onBasis: &[u8; 8usize] = b"onBasis\0";
pub const NID_X9_62_onBasis: u32 = 681;
pub const SN_X9_62_tpBasis: &[u8; 8usize] = b"tpBasis\0";
pub const NID_X9_62_tpBasis: u32 = 682;
pub const SN_X9_62_ppBasis: &[u8; 8usize] = b"ppBasis\0";
pub const NID_X9_62_ppBasis: u32 = 683;
pub const SN_X9_62_id_ecPublicKey: &[u8; 15usize] = b"id-ecPublicKey\0";
pub const NID_X9_62_id_ecPublicKey: u32 = 408;
pub const SN_X9_62_c2pnb163v1: &[u8; 11usize] = b"c2pnb163v1\0";
pub const NID_X9_62_c2pnb163v1: u32 = 684;
pub const SN_X9_62_c2pnb163v2: &[u8; 11usize] = b"c2pnb163v2\0";
pub const NID_X9_62_c2pnb163v2: u32 = 685;
pub const SN_X9_62_c2pnb163v3: &[u8; 11usize] = b"c2pnb163v3\0";
pub const NID_X9_62_c2pnb163v3: u32 = 686;
pub const SN_X9_62_c2pnb176v1: &[u8; 11usize] = b"c2pnb176v1\0";
pub const NID_X9_62_c2pnb176v1: u32 = 687;
pub const SN_X9_62_c2tnb191v1: &[u8; 11usize] = b"c2tnb191v1\0";
pub const NID_X9_62_c2tnb191v1: u32 = 688;
pub const SN_X9_62_c2tnb191v2: &[u8; 11usize] = b"c2tnb191v2\0";
pub const NID_X9_62_c2tnb191v2: u32 = 689;
pub const SN_X9_62_c2tnb191v3: &[u8; 11usize] = b"c2tnb191v3\0";
pub const NID_X9_62_c2tnb191v3: u32 = 690;
pub const SN_X9_62_c2onb191v4: &[u8; 11usize] = b"c2onb191v4\0";
pub const NID_X9_62_c2onb191v4: u32 = 691;
pub const SN_X9_62_c2onb191v5: &[u8; 11usize] = b"c2onb191v5\0";
pub const NID_X9_62_c2onb191v5: u32 = 692;
pub const SN_X9_62_c2pnb208w1: &[u8; 11usize] = b"c2pnb208w1\0";
pub const NID_X9_62_c2pnb208w1: u32 = 693;
pub const SN_X9_62_c2tnb239v1: &[u8; 11usize] = b"c2tnb239v1\0";
pub const NID_X9_62_c2tnb239v1: u32 = 694;
pub const SN_X9_62_c2tnb239v2: &[u8; 11usize] = b"c2tnb239v2\0";
pub const NID_X9_62_c2tnb239v2: u32 = 695;
pub const SN_X9_62_c2tnb239v3: &[u8; 11usize] = b"c2tnb239v3\0";
pub const NID_X9_62_c2tnb239v3: u32 = 696;
pub const SN_X9_62_c2onb239v4: &[u8; 11usize] = b"c2onb239v4\0";
pub const NID_X9_62_c2onb239v4: u32 = 697;
pub const SN_X9_62_c2onb239v5: &[u8; 11usize] = b"c2onb239v5\0";
pub const NID_X9_62_c2onb239v5: u32 = 698;
pub const SN_X9_62_c2pnb272w1: &[u8; 11usize] = b"c2pnb272w1\0";
pub const NID_X9_62_c2pnb272w1: u32 = 699;
pub const SN_X9_62_c2pnb304w1: &[u8; 11usize] = b"c2pnb304w1\0";
pub const NID_X9_62_c2pnb304w1: u32 = 700;
pub const SN_X9_62_c2tnb359v1: &[u8; 11usize] = b"c2tnb359v1\0";
pub const NID_X9_62_c2tnb359v1: u32 = 701;
pub const SN_X9_62_c2pnb368w1: &[u8; 11usize] = b"c2pnb368w1\0";
pub const NID_X9_62_c2pnb368w1: u32 = 702;
pub const SN_X9_62_c2tnb431r1: &[u8; 11usize] = b"c2tnb431r1\0";
pub const NID_X9_62_c2tnb431r1: u32 = 703;
pub const SN_X9_62_prime192v1: &[u8; 11usize] = b"prime192v1\0";
pub const NID_X9_62_prime192v1: u32 = 409;
pub const SN_X9_62_prime192v2: &[u8; 11usize] = b"prime192v2\0";
pub const NID_X9_62_prime192v2: u32 = 410;
pub const SN_X9_62_prime192v3: &[u8; 11usize] = b"prime192v3\0";
pub const NID_X9_62_prime192v3: u32 = 411;
pub const SN_X9_62_prime239v1: &[u8; 11usize] = b"prime239v1\0";
pub const NID_X9_62_prime239v1: u32 = 412;
pub const SN_X9_62_prime239v2: &[u8; 11usize] = b"prime239v2\0";
pub const NID_X9_62_prime239v2: u32 = 413;
pub const SN_X9_62_prime239v3: &[u8; 11usize] = b"prime239v3\0";
pub const NID_X9_62_prime239v3: u32 = 414;
pub const SN_X9_62_prime256v1: &[u8; 11usize] = b"prime256v1\0";
pub const NID_X9_62_prime256v1: u32 = 415;
pub const SN_ecdsa_with_SHA1: &[u8; 16usize] = b"ecdsa-with-SHA1\0";
pub const NID_ecdsa_with_SHA1: u32 = 416;
pub const SN_ecdsa_with_Recommended: &[u8; 23usize] = b"ecdsa-with-Recommended\0";
pub const NID_ecdsa_with_Recommended: u32 = 791;
pub const SN_ecdsa_with_Specified: &[u8; 21usize] = b"ecdsa-with-Specified\0";
pub const NID_ecdsa_with_Specified: u32 = 792;
pub const SN_ecdsa_with_SHA224: &[u8; 18usize] = b"ecdsa-with-SHA224\0";
pub const NID_ecdsa_with_SHA224: u32 = 793;
pub const SN_ecdsa_with_SHA256: &[u8; 18usize] = b"ecdsa-with-SHA256\0";
pub const NID_ecdsa_with_SHA256: u32 = 794;
pub const SN_ecdsa_with_SHA384: &[u8; 18usize] = b"ecdsa-with-SHA384\0";
pub const NID_ecdsa_with_SHA384: u32 = 795;
pub const SN_ecdsa_with_SHA512: &[u8; 18usize] = b"ecdsa-with-SHA512\0";
pub const NID_ecdsa_with_SHA512: u32 = 796;
pub const SN_secp112r1: &[u8; 10usize] = b"secp112r1\0";
pub const NID_secp112r1: u32 = 704;
pub const SN_secp112r2: &[u8; 10usize] = b"secp112r2\0";
pub const NID_secp112r2: u32 = 705;
pub const SN_secp128r1: &[u8; 10usize] = b"secp128r1\0";
pub const NID_secp128r1: u32 = 706;
pub const SN_secp128r2: &[u8; 10usize] = b"secp128r2\0";
pub const NID_secp128r2: u32 = 707;
pub const SN_secp160k1: &[u8; 10usize] = b"secp160k1\0";
pub const NID_secp160k1: u32 = 708;
pub const SN_secp160r1: &[u8; 10usize] = b"secp160r1\0";
pub const NID_secp160r1: u32 = 709;
pub const SN_secp160r2: &[u8; 10usize] = b"secp160r2\0";
pub const NID_secp160r2: u32 = 710;
pub const SN_secp192k1: &[u8; 10usize] = b"secp192k1\0";
pub const NID_secp192k1: u32 = 711;
pub const SN_secp224k1: &[u8; 10usize] = b"secp224k1\0";
pub const NID_secp224k1: u32 = 712;
pub const SN_secp224r1: &[u8; 10usize] = b"secp224r1\0";
pub const NID_secp224r1: u32 = 713;
pub const SN_secp256k1: &[u8; 10usize] = b"secp256k1\0";
pub const NID_secp256k1: u32 = 714;
pub const SN_secp384r1: &[u8; 10usize] = b"secp384r1\0";
pub const NID_secp384r1: u32 = 715;
pub const SN_secp521r1: &[u8; 10usize] = b"secp521r1\0";
pub const NID_secp521r1: u32 = 716;
pub const SN_sect113r1: &[u8; 10usize] = b"sect113r1\0";
pub const NID_sect113r1: u32 = 717;
pub const SN_sect113r2: &[u8; 10usize] = b"sect113r2\0";
pub const NID_sect113r2: u32 = 718;
pub const SN_sect131r1: &[u8; 10usize] = b"sect131r1\0";
pub const NID_sect131r1: u32 = 719;
pub const SN_sect131r2: &[u8; 10usize] = b"sect131r2\0";
pub const NID_sect131r2: u32 = 720;
pub const SN_sect163k1: &[u8; 10usize] = b"sect163k1\0";
pub const NID_sect163k1: u32 = 721;
pub const SN_sect163r1: &[u8; 10usize] = b"sect163r1\0";
pub const NID_sect163r1: u32 = 722;
pub const SN_sect163r2: &[u8; 10usize] = b"sect163r2\0";
pub const NID_sect163r2: u32 = 723;
pub const SN_sect193r1: &[u8; 10usize] = b"sect193r1\0";
pub const NID_sect193r1: u32 = 724;
pub const SN_sect193r2: &[u8; 10usize] = b"sect193r2\0";
pub const NID_sect193r2: u32 = 725;
pub const SN_sect233k1: &[u8; 10usize] = b"sect233k1\0";
pub const NID_sect233k1: u32 = 726;
pub const SN_sect233r1: &[u8; 10usize] = b"sect233r1\0";
pub const NID_sect233r1: u32 = 727;
pub const SN_sect239k1: &[u8; 10usize] = b"sect239k1\0";
pub const NID_sect239k1: u32 = 728;
pub const SN_sect283k1: &[u8; 10usize] = b"sect283k1\0";
pub const NID_sect283k1: u32 = 729;
pub const SN_sect283r1: &[u8; 10usize] = b"sect283r1\0";
pub const NID_sect283r1: u32 = 730;
pub const SN_sect409k1: &[u8; 10usize] = b"sect409k1\0";
pub const NID_sect409k1: u32 = 731;
pub const SN_sect409r1: &[u8; 10usize] = b"sect409r1\0";
pub const NID_sect409r1: u32 = 732;
pub const SN_sect571k1: &[u8; 10usize] = b"sect571k1\0";
pub const NID_sect571k1: u32 = 733;
pub const SN_sect571r1: &[u8; 10usize] = b"sect571r1\0";
pub const NID_sect571r1: u32 = 734;
pub const SN_wap_wsg_idm_ecid_wtls1: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls1\0";
pub const NID_wap_wsg_idm_ecid_wtls1: u32 = 735;
pub const SN_wap_wsg_idm_ecid_wtls3: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls3\0";
pub const NID_wap_wsg_idm_ecid_wtls3: u32 = 736;
pub const SN_wap_wsg_idm_ecid_wtls4: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls4\0";
pub const NID_wap_wsg_idm_ecid_wtls4: u32 = 737;
pub const SN_wap_wsg_idm_ecid_wtls5: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls5\0";
pub const NID_wap_wsg_idm_ecid_wtls5: u32 = 738;
pub const SN_wap_wsg_idm_ecid_wtls6: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls6\0";
pub const NID_wap_wsg_idm_ecid_wtls6: u32 = 739;
pub const SN_wap_wsg_idm_ecid_wtls7: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls7\0";
pub const NID_wap_wsg_idm_ecid_wtls7: u32 = 740;
pub const SN_wap_wsg_idm_ecid_wtls8: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls8\0";
pub const NID_wap_wsg_idm_ecid_wtls8: u32 = 741;
pub const SN_wap_wsg_idm_ecid_wtls9: &[u8; 23usize] = b"wap-wsg-idm-ecid-wtls9\0";
pub const NID_wap_wsg_idm_ecid_wtls9: u32 = 742;
pub const SN_wap_wsg_idm_ecid_wtls10: &[u8; 24usize] = b"wap-wsg-idm-ecid-wtls10\0";
pub const NID_wap_wsg_idm_ecid_wtls10: u32 = 743;
pub const SN_wap_wsg_idm_ecid_wtls11: &[u8; 24usize] = b"wap-wsg-idm-ecid-wtls11\0";
pub const NID_wap_wsg_idm_ecid_wtls11: u32 = 744;
pub const SN_wap_wsg_idm_ecid_wtls12: &[u8; 24usize] = b"wap-wsg-idm-ecid-wtls12\0";
pub const NID_wap_wsg_idm_ecid_wtls12: u32 = 745;
pub const SN_cast5_cbc: &[u8; 10usize] = b"CAST5-CBC\0";
pub const LN_cast5_cbc: &[u8; 10usize] = b"cast5-cbc\0";
pub const NID_cast5_cbc: u32 = 108;
pub const SN_cast5_ecb: &[u8; 10usize] = b"CAST5-ECB\0";
pub const LN_cast5_ecb: &[u8; 10usize] = b"cast5-ecb\0";
pub const NID_cast5_ecb: u32 = 109;
pub const SN_cast5_cfb64: &[u8; 10usize] = b"CAST5-CFB\0";
pub const LN_cast5_cfb64: &[u8; 10usize] = b"cast5-cfb\0";
pub const NID_cast5_cfb64: u32 = 110;
pub const SN_cast5_ofb64: &[u8; 10usize] = b"CAST5-OFB\0";
pub const LN_cast5_ofb64: &[u8; 10usize] = b"cast5-ofb\0";
pub const NID_cast5_ofb64: u32 = 111;
pub const LN_pbeWithMD5AndCast5_CBC: &[u8; 22usize] = b"pbeWithMD5AndCast5CBC\0";
pub const NID_pbeWithMD5AndCast5_CBC: u32 = 112;
pub const SN_id_PasswordBasedMAC: &[u8; 20usize] = b"id-PasswordBasedMAC\0";
pub const LN_id_PasswordBasedMAC: &[u8; 19usize] = b"password based MAC\0";
pub const NID_id_PasswordBasedMAC: u32 = 782;
pub const SN_id_DHBasedMac: &[u8; 14usize] = b"id-DHBasedMac\0";
pub const LN_id_DHBasedMac: &[u8; 25usize] = b"Diffie-Hellman based MAC\0";
pub const NID_id_DHBasedMac: u32 = 783;
pub const SN_rsadsi: &[u8; 7usize] = b"rsadsi\0";
pub const LN_rsadsi: &[u8; 24usize] = b"RSA Data Security, Inc.\0";
pub const NID_rsadsi: u32 = 1;
pub const SN_pkcs: &[u8; 5usize] = b"pkcs\0";
pub const LN_pkcs: &[u8; 29usize] = b"RSA Data Security, Inc. PKCS\0";
pub const NID_pkcs: u32 = 2;
pub const SN_pkcs1: &[u8; 6usize] = b"pkcs1\0";
pub const NID_pkcs1: u32 = 186;
pub const LN_rsaEncryption: &[u8; 14usize] = b"rsaEncryption\0";
pub const NID_rsaEncryption: u32 = 6;
pub const SN_md2WithRSAEncryption: &[u8; 8usize] = b"RSA-MD2\0";
pub const LN_md2WithRSAEncryption: &[u8; 21usize] = b"md2WithRSAEncryption\0";
pub const NID_md2WithRSAEncryption: u32 = 7;
pub const SN_md4WithRSAEncryption: &[u8; 8usize] = b"RSA-MD4\0";
pub const LN_md4WithRSAEncryption: &[u8; 21usize] = b"md4WithRSAEncryption\0";
pub const NID_md4WithRSAEncryption: u32 = 396;
pub const SN_md5WithRSAEncryption: &[u8; 8usize] = b"RSA-MD5\0";
pub const LN_md5WithRSAEncryption: &[u8; 21usize] = b"md5WithRSAEncryption\0";
pub const NID_md5WithRSAEncryption: u32 = 8;
pub const SN_sha1WithRSAEncryption: &[u8; 9usize] = b"RSA-SHA1\0";
pub const LN_sha1WithRSAEncryption: &[u8; 22usize] = b"sha1WithRSAEncryption\0";
pub const NID_sha1WithRSAEncryption: u32 = 65;
pub const SN_rsaesOaep: &[u8; 11usize] = b"RSAES-OAEP\0";
pub const LN_rsaesOaep: &[u8; 10usize] = b"rsaesOaep\0";
pub const NID_rsaesOaep: u32 = 919;
pub const SN_mgf1: &[u8; 5usize] = b"MGF1\0";
pub const LN_mgf1: &[u8; 5usize] = b"mgf1\0";
pub const NID_mgf1: u32 = 911;
pub const SN_pSpecified: &[u8; 11usize] = b"PSPECIFIED\0";
pub const LN_pSpecified: &[u8; 11usize] = b"pSpecified\0";
pub const NID_pSpecified: u32 = 935;
pub const SN_rsassaPss: &[u8; 11usize] = b"RSASSA-PSS\0";
pub const LN_rsassaPss: &[u8; 10usize] = b"rsassaPss\0";
pub const NID_rsassaPss: u32 = 912;
pub const SN_sha256WithRSAEncryption: &[u8; 11usize] = b"RSA-SHA256\0";
pub const LN_sha256WithRSAEncryption: &[u8; 24usize] = b"sha256WithRSAEncryption\0";
pub const NID_sha256WithRSAEncryption: u32 = 668;
pub const SN_sha384WithRSAEncryption: &[u8; 11usize] = b"RSA-SHA384\0";
pub const LN_sha384WithRSAEncryption: &[u8; 24usize] = b"sha384WithRSAEncryption\0";
pub const NID_sha384WithRSAEncryption: u32 = 669;
pub const SN_sha512WithRSAEncryption: &[u8; 11usize] = b"RSA-SHA512\0";
pub const LN_sha512WithRSAEncryption: &[u8; 24usize] = b"sha512WithRSAEncryption\0";
pub const NID_sha512WithRSAEncryption: u32 = 670;
pub const SN_sha224WithRSAEncryption: &[u8; 11usize] = b"RSA-SHA224\0";
pub const LN_sha224WithRSAEncryption: &[u8; 24usize] = b"sha224WithRSAEncryption\0";
pub const NID_sha224WithRSAEncryption: u32 = 671;
pub const SN_sha512_224WithRSAEncryption: &[u8; 15usize] = b"RSA-SHA512/224\0";
pub const LN_sha512_224WithRSAEncryption: &[u8; 28usize] = b"sha512-224WithRSAEncryption\0";
pub const NID_sha512_224WithRSAEncryption: u32 = 1145;
pub const SN_sha512_256WithRSAEncryption: &[u8; 15usize] = b"RSA-SHA512/256\0";
pub const LN_sha512_256WithRSAEncryption: &[u8; 28usize] = b"sha512-256WithRSAEncryption\0";
pub const NID_sha512_256WithRSAEncryption: u32 = 1146;
pub const SN_pkcs3: &[u8; 6usize] = b"pkcs3\0";
pub const NID_pkcs3: u32 = 27;
pub const LN_dhKeyAgreement: &[u8; 15usize] = b"dhKeyAgreement\0";
pub const NID_dhKeyAgreement: u32 = 28;
pub const SN_pkcs5: &[u8; 6usize] = b"pkcs5\0";
pub const NID_pkcs5: u32 = 187;
pub const SN_pbeWithMD2AndDES_CBC: &[u8; 12usize] = b"PBE-MD2-DES\0";
pub const LN_pbeWithMD2AndDES_CBC: &[u8; 21usize] = b"pbeWithMD2AndDES-CBC\0";
pub const NID_pbeWithMD2AndDES_CBC: u32 = 9;
pub const SN_pbeWithMD5AndDES_CBC: &[u8; 12usize] = b"PBE-MD5-DES\0";
pub const LN_pbeWithMD5AndDES_CBC: &[u8; 21usize] = b"pbeWithMD5AndDES-CBC\0";
pub const NID_pbeWithMD5AndDES_CBC: u32 = 10;
pub const SN_pbeWithMD2AndRC2_CBC: &[u8; 15usize] = b"PBE-MD2-RC2-64\0";
pub const LN_pbeWithMD2AndRC2_CBC: &[u8; 21usize] = b"pbeWithMD2AndRC2-CBC\0";
pub const NID_pbeWithMD2AndRC2_CBC: u32 = 168;
pub const SN_pbeWithMD5AndRC2_CBC: &[u8; 15usize] = b"PBE-MD5-RC2-64\0";
pub const LN_pbeWithMD5AndRC2_CBC: &[u8; 21usize] = b"pbeWithMD5AndRC2-CBC\0";
pub const NID_pbeWithMD5AndRC2_CBC: u32 = 169;
pub const SN_pbeWithSHA1AndDES_CBC: &[u8; 13usize] = b"PBE-SHA1-DES\0";
pub const LN_pbeWithSHA1AndDES_CBC: &[u8; 22usize] = b"pbeWithSHA1AndDES-CBC\0";
pub const NID_pbeWithSHA1AndDES_CBC: u32 = 170;
pub const SN_pbeWithSHA1AndRC2_CBC: &[u8; 16usize] = b"PBE-SHA1-RC2-64\0";
pub const LN_pbeWithSHA1AndRC2_CBC: &[u8; 22usize] = b"pbeWithSHA1AndRC2-CBC\0";
pub const NID_pbeWithSHA1AndRC2_CBC: u32 = 68;
pub const LN_id_pbkdf2: &[u8; 7usize] = b"PBKDF2\0";
pub const NID_id_pbkdf2: u32 = 69;
pub const LN_pbes2: &[u8; 6usize] = b"PBES2\0";
pub const NID_pbes2: u32 = 161;
pub const LN_pbmac1: &[u8; 7usize] = b"PBMAC1\0";
pub const NID_pbmac1: u32 = 162;
pub const SN_pkcs7: &[u8; 6usize] = b"pkcs7\0";
pub const NID_pkcs7: u32 = 20;
pub const LN_pkcs7_data: &[u8; 11usize] = b"pkcs7-data\0";
pub const NID_pkcs7_data: u32 = 21;
pub const LN_pkcs7_signed: &[u8; 17usize] = b"pkcs7-signedData\0";
pub const NID_pkcs7_signed: u32 = 22;
pub const LN_pkcs7_enveloped: &[u8; 20usize] = b"pkcs7-envelopedData\0";
pub const NID_pkcs7_enveloped: u32 = 23;
pub const LN_pkcs7_signedAndEnveloped: &[u8; 29usize] = b"pkcs7-signedAndEnvelopedData\0";
pub const NID_pkcs7_signedAndEnveloped: u32 = 24;
pub const LN_pkcs7_digest: &[u8; 17usize] = b"pkcs7-digestData\0";
pub const NID_pkcs7_digest: u32 = 25;
pub const LN_pkcs7_encrypted: &[u8; 20usize] = b"pkcs7-encryptedData\0";
pub const NID_pkcs7_encrypted: u32 = 26;
pub const SN_pkcs9: &[u8; 6usize] = b"pkcs9\0";
pub const NID_pkcs9: u32 = 47;
pub const LN_pkcs9_emailAddress: &[u8; 13usize] = b"emailAddress\0";
pub const NID_pkcs9_emailAddress: u32 = 48;
pub const LN_pkcs9_unstructuredName: &[u8; 17usize] = b"unstructuredName\0";
pub const NID_pkcs9_unstructuredName: u32 = 49;
pub const LN_pkcs9_contentType: &[u8; 12usize] = b"contentType\0";
pub const NID_pkcs9_contentType: u32 = 50;
pub const LN_pkcs9_messageDigest: &[u8; 14usize] = b"messageDigest\0";
pub const NID_pkcs9_messageDigest: u32 = 51;
pub const LN_pkcs9_signingTime: &[u8; 12usize] = b"signingTime\0";
pub const NID_pkcs9_signingTime: u32 = 52;
pub const LN_pkcs9_countersignature: &[u8; 17usize] = b"countersignature\0";
pub const NID_pkcs9_countersignature: u32 = 53;
pub const LN_pkcs9_challengePassword: &[u8; 18usize] = b"challengePassword\0";
pub const NID_pkcs9_challengePassword: u32 = 54;
pub const LN_pkcs9_unstructuredAddress: &[u8; 20usize] = b"unstructuredAddress\0";
pub const NID_pkcs9_unstructuredAddress: u32 = 55;
pub const LN_pkcs9_extCertAttributes: &[u8; 30usize] = b"extendedCertificateAttributes\0";
pub const NID_pkcs9_extCertAttributes: u32 = 56;
pub const SN_ext_req: &[u8; 7usize] = b"extReq\0";
pub const LN_ext_req: &[u8; 18usize] = b"Extension Request\0";
pub const NID_ext_req: u32 = 172;
pub const SN_SMIMECapabilities: &[u8; 11usize] = b"SMIME-CAPS\0";
pub const LN_SMIMECapabilities: &[u8; 20usize] = b"S/MIME Capabilities\0";
pub const NID_SMIMECapabilities: u32 = 167;
pub const SN_SMIME: &[u8; 6usize] = b"SMIME\0";
pub const LN_SMIME: &[u8; 7usize] = b"S/MIME\0";
pub const NID_SMIME: u32 = 188;
pub const SN_id_smime_mod: &[u8; 13usize] = b"id-smime-mod\0";
pub const NID_id_smime_mod: u32 = 189;
pub const SN_id_smime_ct: &[u8; 12usize] = b"id-smime-ct\0";
pub const NID_id_smime_ct: u32 = 190;
pub const SN_id_smime_aa: &[u8; 12usize] = b"id-smime-aa\0";
pub const NID_id_smime_aa: u32 = 191;
pub const SN_id_smime_alg: &[u8; 13usize] = b"id-smime-alg\0";
pub const NID_id_smime_alg: u32 = 192;
pub const SN_id_smime_cd: &[u8; 12usize] = b"id-smime-cd\0";
pub const NID_id_smime_cd: u32 = 193;
pub const SN_id_smime_spq: &[u8; 13usize] = b"id-smime-spq\0";
pub const NID_id_smime_spq: u32 = 194;
pub const SN_id_smime_cti: &[u8; 13usize] = b"id-smime-cti\0";
pub const NID_id_smime_cti: u32 = 195;
pub const SN_id_smime_mod_cms: &[u8; 17usize] = b"id-smime-mod-cms\0";
pub const NID_id_smime_mod_cms: u32 = 196;
pub const SN_id_smime_mod_ess: &[u8; 17usize] = b"id-smime-mod-ess\0";
pub const NID_id_smime_mod_ess: u32 = 197;
pub const SN_id_smime_mod_oid: &[u8; 17usize] = b"id-smime-mod-oid\0";
pub const NID_id_smime_mod_oid: u32 = 198;
pub const SN_id_smime_mod_msg_v3: &[u8; 20usize] = b"id-smime-mod-msg-v3\0";
pub const NID_id_smime_mod_msg_v3: u32 = 199;
pub const SN_id_smime_mod_ets_eSignature_88: &[u8; 31usize] = b"id-smime-mod-ets-eSignature-88\0";
pub const NID_id_smime_mod_ets_eSignature_88: u32 = 200;
pub const SN_id_smime_mod_ets_eSignature_97: &[u8; 31usize] = b"id-smime-mod-ets-eSignature-97\0";
pub const NID_id_smime_mod_ets_eSignature_97: u32 = 201;
pub const SN_id_smime_mod_ets_eSigPolicy_88: &[u8; 31usize] = b"id-smime-mod-ets-eSigPolicy-88\0";
pub const NID_id_smime_mod_ets_eSigPolicy_88: u32 = 202;
pub const SN_id_smime_mod_ets_eSigPolicy_97: &[u8; 31usize] = b"id-smime-mod-ets-eSigPolicy-97\0";
pub const NID_id_smime_mod_ets_eSigPolicy_97: u32 = 203;
pub const SN_id_smime_ct_receipt: &[u8; 20usize] = b"id-smime-ct-receipt\0";
pub const NID_id_smime_ct_receipt: u32 = 204;
pub const SN_id_smime_ct_authData: &[u8; 21usize] = b"id-smime-ct-authData\0";
pub const NID_id_smime_ct_authData: u32 = 205;
pub const SN_id_smime_ct_publishCert: &[u8; 24usize] = b"id-smime-ct-publishCert\0";
pub const NID_id_smime_ct_publishCert: u32 = 206;
pub const SN_id_smime_ct_TSTInfo: &[u8; 20usize] = b"id-smime-ct-TSTInfo\0";
pub const NID_id_smime_ct_TSTInfo: u32 = 207;
pub const SN_id_smime_ct_TDTInfo: &[u8; 20usize] = b"id-smime-ct-TDTInfo\0";
pub const NID_id_smime_ct_TDTInfo: u32 = 208;
pub const SN_id_smime_ct_contentInfo: &[u8; 24usize] = b"id-smime-ct-contentInfo\0";
pub const NID_id_smime_ct_contentInfo: u32 = 209;
pub const SN_id_smime_ct_DVCSRequestData: &[u8; 28usize] = b"id-smime-ct-DVCSRequestData\0";
pub const NID_id_smime_ct_DVCSRequestData: u32 = 210;
pub const SN_id_smime_ct_DVCSResponseData: &[u8; 29usize] = b"id-smime-ct-DVCSResponseData\0";
pub const NID_id_smime_ct_DVCSResponseData: u32 = 211;
pub const SN_id_smime_ct_compressedData: &[u8; 27usize] = b"id-smime-ct-compressedData\0";
pub const NID_id_smime_ct_compressedData: u32 = 786;
pub const SN_id_smime_ct_contentCollection: &[u8; 30usize] = b"id-smime-ct-contentCollection\0";
pub const NID_id_smime_ct_contentCollection: u32 = 1058;
pub const SN_id_smime_ct_authEnvelopedData: &[u8; 30usize] = b"id-smime-ct-authEnvelopedData\0";
pub const NID_id_smime_ct_authEnvelopedData: u32 = 1059;
pub const SN_id_ct_asciiTextWithCRLF: &[u8; 24usize] = b"id-ct-asciiTextWithCRLF\0";
pub const NID_id_ct_asciiTextWithCRLF: u32 = 787;
pub const SN_id_ct_xml: &[u8; 10usize] = b"id-ct-xml\0";
pub const NID_id_ct_xml: u32 = 1060;
pub const SN_id_smime_aa_receiptRequest: &[u8; 27usize] = b"id-smime-aa-receiptRequest\0";
pub const NID_id_smime_aa_receiptRequest: u32 = 212;
pub const SN_id_smime_aa_securityLabel: &[u8; 26usize] = b"id-smime-aa-securityLabel\0";
pub const NID_id_smime_aa_securityLabel: u32 = 213;
pub const SN_id_smime_aa_mlExpandHistory: &[u8; 28usize] = b"id-smime-aa-mlExpandHistory\0";
pub const NID_id_smime_aa_mlExpandHistory: u32 = 214;
pub const SN_id_smime_aa_contentHint: &[u8; 24usize] = b"id-smime-aa-contentHint\0";
pub const NID_id_smime_aa_contentHint: u32 = 215;
pub const SN_id_smime_aa_msgSigDigest: &[u8; 25usize] = b"id-smime-aa-msgSigDigest\0";
pub const NID_id_smime_aa_msgSigDigest: u32 = 216;
pub const SN_id_smime_aa_encapContentType: &[u8; 29usize] = b"id-smime-aa-encapContentType\0";
pub const NID_id_smime_aa_encapContentType: u32 = 217;
pub const SN_id_smime_aa_contentIdentifier: &[u8; 30usize] = b"id-smime-aa-contentIdentifier\0";
pub const NID_id_smime_aa_contentIdentifier: u32 = 218;
pub const SN_id_smime_aa_macValue: &[u8; 21usize] = b"id-smime-aa-macValue\0";
pub const NID_id_smime_aa_macValue: u32 = 219;
pub const SN_id_smime_aa_equivalentLabels: &[u8; 29usize] = b"id-smime-aa-equivalentLabels\0";
pub const NID_id_smime_aa_equivalentLabels: u32 = 220;
pub const SN_id_smime_aa_contentReference: &[u8; 29usize] = b"id-smime-aa-contentReference\0";
pub const NID_id_smime_aa_contentReference: u32 = 221;
pub const SN_id_smime_aa_encrypKeyPref: &[u8; 26usize] = b"id-smime-aa-encrypKeyPref\0";
pub const NID_id_smime_aa_encrypKeyPref: u32 = 222;
pub const SN_id_smime_aa_signingCertificate: &[u8; 31usize] = b"id-smime-aa-signingCertificate\0";
pub const NID_id_smime_aa_signingCertificate: u32 = 223;
pub const SN_id_smime_aa_smimeEncryptCerts: &[u8; 30usize] = b"id-smime-aa-smimeEncryptCerts\0";
pub const NID_id_smime_aa_smimeEncryptCerts: u32 = 224;
pub const SN_id_smime_aa_timeStampToken: &[u8; 27usize] = b"id-smime-aa-timeStampToken\0";
pub const NID_id_smime_aa_timeStampToken: u32 = 225;
pub const SN_id_smime_aa_ets_sigPolicyId: &[u8; 28usize] = b"id-smime-aa-ets-sigPolicyId\0";
pub const NID_id_smime_aa_ets_sigPolicyId: u32 = 226;
pub const SN_id_smime_aa_ets_commitmentType: &[u8; 31usize] = b"id-smime-aa-ets-commitmentType\0";
pub const NID_id_smime_aa_ets_commitmentType: u32 = 227;
pub const SN_id_smime_aa_ets_signerLocation: &[u8; 31usize] = b"id-smime-aa-ets-signerLocation\0";
pub const NID_id_smime_aa_ets_signerLocation: u32 = 228;
pub const SN_id_smime_aa_ets_signerAttr: &[u8; 27usize] = b"id-smime-aa-ets-signerAttr\0";
pub const NID_id_smime_aa_ets_signerAttr: u32 = 229;
pub const SN_id_smime_aa_ets_otherSigCert: &[u8; 29usize] = b"id-smime-aa-ets-otherSigCert\0";
pub const NID_id_smime_aa_ets_otherSigCert: u32 = 230;
pub const SN_id_smime_aa_ets_contentTimestamp: &[u8; 33usize] =
    b"id-smime-aa-ets-contentTimestamp\0";
pub const NID_id_smime_aa_ets_contentTimestamp: u32 = 231;
pub const SN_id_smime_aa_ets_CertificateRefs: &[u8; 32usize] = b"id-smime-aa-ets-CertificateRefs\0";
pub const NID_id_smime_aa_ets_CertificateRefs: u32 = 232;
pub const SN_id_smime_aa_ets_RevocationRefs: &[u8; 31usize] = b"id-smime-aa-ets-RevocationRefs\0";
pub const NID_id_smime_aa_ets_RevocationRefs: u32 = 233;
pub const SN_id_smime_aa_ets_certValues: &[u8; 27usize] = b"id-smime-aa-ets-certValues\0";
pub const NID_id_smime_aa_ets_certValues: u32 = 234;
pub const SN_id_smime_aa_ets_revocationValues: &[u8; 33usize] =
    b"id-smime-aa-ets-revocationValues\0";
pub const NID_id_smime_aa_ets_revocationValues: u32 = 235;
pub const SN_id_smime_aa_ets_escTimeStamp: &[u8; 29usize] = b"id-smime-aa-ets-escTimeStamp\0";
pub const NID_id_smime_aa_ets_escTimeStamp: u32 = 236;
pub const SN_id_smime_aa_ets_certCRLTimestamp: &[u8; 33usize] =
    b"id-smime-aa-ets-certCRLTimestamp\0";
pub const NID_id_smime_aa_ets_certCRLTimestamp: u32 = 237;
pub const SN_id_smime_aa_ets_archiveTimeStamp: &[u8; 33usize] =
    b"id-smime-aa-ets-archiveTimeStamp\0";
pub const NID_id_smime_aa_ets_archiveTimeStamp: u32 = 238;
pub const SN_id_smime_aa_signatureType: &[u8; 26usize] = b"id-smime-aa-signatureType\0";
pub const NID_id_smime_aa_signatureType: u32 = 239;
pub const SN_id_smime_aa_dvcs_dvc: &[u8; 21usize] = b"id-smime-aa-dvcs-dvc\0";
pub const NID_id_smime_aa_dvcs_dvc: u32 = 240;
pub const SN_id_smime_aa_signingCertificateV2: &[u8; 33usize] =
    b"id-smime-aa-signingCertificateV2\0";
pub const NID_id_smime_aa_signingCertificateV2: u32 = 1086;
pub const SN_id_smime_alg_ESDHwith3DES: &[u8; 26usize] = b"id-smime-alg-ESDHwith3DES\0";
pub const NID_id_smime_alg_ESDHwith3DES: u32 = 241;
pub const SN_id_smime_alg_ESDHwithRC2: &[u8; 25usize] = b"id-smime-alg-ESDHwithRC2\0";
pub const NID_id_smime_alg_ESDHwithRC2: u32 = 242;
pub const SN_id_smime_alg_3DESwrap: &[u8; 22usize] = b"id-smime-alg-3DESwrap\0";
pub const NID_id_smime_alg_3DESwrap: u32 = 243;
pub const SN_id_smime_alg_RC2wrap: &[u8; 21usize] = b"id-smime-alg-RC2wrap\0";
pub const NID_id_smime_alg_RC2wrap: u32 = 244;
pub const SN_id_smime_alg_ESDH: &[u8; 18usize] = b"id-smime-alg-ESDH\0";
pub const NID_id_smime_alg_ESDH: u32 = 245;
pub const SN_id_smime_alg_CMS3DESwrap: &[u8; 25usize] = b"id-smime-alg-CMS3DESwrap\0";
pub const NID_id_smime_alg_CMS3DESwrap: u32 = 246;
pub const SN_id_smime_alg_CMSRC2wrap: &[u8; 24usize] = b"id-smime-alg-CMSRC2wrap\0";
pub const NID_id_smime_alg_CMSRC2wrap: u32 = 247;
pub const SN_id_alg_PWRI_KEK: &[u8; 16usize] = b"id-alg-PWRI-KEK\0";
pub const NID_id_alg_PWRI_KEK: u32 = 893;
pub const SN_id_smime_cd_ldap: &[u8; 17usize] = b"id-smime-cd-ldap\0";
pub const NID_id_smime_cd_ldap: u32 = 248;
pub const SN_id_smime_spq_ets_sqt_uri: &[u8; 25usize] = b"id-smime-spq-ets-sqt-uri\0";
pub const NID_id_smime_spq_ets_sqt_uri: u32 = 249;
pub const SN_id_smime_spq_ets_sqt_unotice: &[u8; 29usize] = b"id-smime-spq-ets-sqt-unotice\0";
pub const NID_id_smime_spq_ets_sqt_unotice: u32 = 250;
pub const SN_id_smime_cti_ets_proofOfOrigin: &[u8; 31usize] = b"id-smime-cti-ets-proofOfOrigin\0";
pub const NID_id_smime_cti_ets_proofOfOrigin: u32 = 251;
pub const SN_id_smime_cti_ets_proofOfReceipt: &[u8; 32usize] = b"id-smime-cti-ets-proofOfReceipt\0";
pub const NID_id_smime_cti_ets_proofOfReceipt: u32 = 252;
pub const SN_id_smime_cti_ets_proofOfDelivery: &[u8; 33usize] =
    b"id-smime-cti-ets-proofOfDelivery\0";
pub const NID_id_smime_cti_ets_proofOfDelivery: u32 = 253;
pub const SN_id_smime_cti_ets_proofOfSender: &[u8; 31usize] = b"id-smime-cti-ets-proofOfSender\0";
pub const NID_id_smime_cti_ets_proofOfSender: u32 = 254;
pub const SN_id_smime_cti_ets_proofOfApproval: &[u8; 33usize] =
    b"id-smime-cti-ets-proofOfApproval\0";
pub const NID_id_smime_cti_ets_proofOfApproval: u32 = 255;
pub const SN_id_smime_cti_ets_proofOfCreation: &[u8; 33usize] =
    b"id-smime-cti-ets-proofOfCreation\0";
pub const NID_id_smime_cti_ets_proofOfCreation: u32 = 256;
pub const LN_friendlyName: &[u8; 13usize] = b"friendlyName\0";
pub const NID_friendlyName: u32 = 156;
pub const LN_localKeyID: &[u8; 11usize] = b"localKeyID\0";
pub const NID_localKeyID: u32 = 157;
pub const SN_ms_csp_name: &[u8; 8usize] = b"CSPName\0";
pub const LN_ms_csp_name: &[u8; 19usize] = b"Microsoft CSP Name\0";
pub const NID_ms_csp_name: u32 = 417;
pub const SN_LocalKeySet: &[u8; 12usize] = b"LocalKeySet\0";
pub const LN_LocalKeySet: &[u8; 24usize] = b"Microsoft Local Key set\0";
pub const NID_LocalKeySet: u32 = 856;
pub const LN_x509Certificate: &[u8; 16usize] = b"x509Certificate\0";
pub const NID_x509Certificate: u32 = 158;
pub const LN_sdsiCertificate: &[u8; 16usize] = b"sdsiCertificate\0";
pub const NID_sdsiCertificate: u32 = 159;
pub const LN_x509Crl: &[u8; 8usize] = b"x509Crl\0";
pub const NID_x509Crl: u32 = 160;
pub const SN_pbe_WithSHA1And128BitRC4: &[u8; 17usize] = b"PBE-SHA1-RC4-128\0";
pub const LN_pbe_WithSHA1And128BitRC4: &[u8; 24usize] = b"pbeWithSHA1And128BitRC4\0";
pub const NID_pbe_WithSHA1And128BitRC4: u32 = 144;
pub const SN_pbe_WithSHA1And40BitRC4: &[u8; 16usize] = b"PBE-SHA1-RC4-40\0";
pub const LN_pbe_WithSHA1And40BitRC4: &[u8; 23usize] = b"pbeWithSHA1And40BitRC4\0";
pub const NID_pbe_WithSHA1And40BitRC4: u32 = 145;
pub const SN_pbe_WithSHA1And3_Key_TripleDES_CBC: &[u8; 14usize] = b"PBE-SHA1-3DES\0";
pub const LN_pbe_WithSHA1And3_Key_TripleDES_CBC: &[u8; 33usize] =
    b"pbeWithSHA1And3-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC: u32 = 146;
pub const SN_pbe_WithSHA1And2_Key_TripleDES_CBC: &[u8; 14usize] = b"PBE-SHA1-2DES\0";
pub const LN_pbe_WithSHA1And2_Key_TripleDES_CBC: &[u8; 33usize] =
    b"pbeWithSHA1And2-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC: u32 = 147;
pub const SN_pbe_WithSHA1And128BitRC2_CBC: &[u8; 17usize] = b"PBE-SHA1-RC2-128\0";
pub const LN_pbe_WithSHA1And128BitRC2_CBC: &[u8; 28usize] = b"pbeWithSHA1And128BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And128BitRC2_CBC: u32 = 148;
pub const SN_pbe_WithSHA1And40BitRC2_CBC: &[u8; 16usize] = b"PBE-SHA1-RC2-40\0";
pub const LN_pbe_WithSHA1And40BitRC2_CBC: &[u8; 27usize] = b"pbeWithSHA1And40BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And40BitRC2_CBC: u32 = 149;
pub const LN_keyBag: &[u8; 7usize] = b"keyBag\0";
pub const NID_keyBag: u32 = 150;
pub const LN_pkcs8ShroudedKeyBag: &[u8; 20usize] = b"pkcs8ShroudedKeyBag\0";
pub const NID_pkcs8ShroudedKeyBag: u32 = 151;
pub const LN_certBag: &[u8; 8usize] = b"certBag\0";
pub const NID_certBag: u32 = 152;
pub const LN_crlBag: &[u8; 7usize] = b"crlBag\0";
pub const NID_crlBag: u32 = 153;
pub const LN_secretBag: &[u8; 10usize] = b"secretBag\0";
pub const NID_secretBag: u32 = 154;
pub const LN_safeContentsBag: &[u8; 16usize] = b"safeContentsBag\0";
pub const NID_safeContentsBag: u32 = 155;
pub const SN_md2: &[u8; 4usize] = b"MD2\0";
pub const LN_md2: &[u8; 4usize] = b"md2\0";
pub const NID_md2: u32 = 3;
pub const SN_md4: &[u8; 4usize] = b"MD4\0";
pub const LN_md4: &[u8; 4usize] = b"md4\0";
pub const NID_md4: u32 = 257;
pub const SN_md5: &[u8; 4usize] = b"MD5\0";
pub const LN_md5: &[u8; 4usize] = b"md5\0";
pub const NID_md5: u32 = 4;
pub const SN_md5_sha1: &[u8; 9usize] = b"MD5-SHA1\0";
pub const LN_md5_sha1: &[u8; 9usize] = b"md5-sha1\0";
pub const NID_md5_sha1: u32 = 114;
pub const LN_hmacWithMD5: &[u8; 12usize] = b"hmacWithMD5\0";
pub const NID_hmacWithMD5: u32 = 797;
pub const LN_hmacWithSHA1: &[u8; 13usize] = b"hmacWithSHA1\0";
pub const NID_hmacWithSHA1: u32 = 163;
pub const SN_sm2: &[u8; 4usize] = b"SM2\0";
pub const LN_sm2: &[u8; 4usize] = b"sm2\0";
pub const NID_sm2: u32 = 1172;
pub const SN_sm3: &[u8; 4usize] = b"SM3\0";
pub const LN_sm3: &[u8; 4usize] = b"sm3\0";
pub const NID_sm3: u32 = 1143;
pub const SN_sm3WithRSAEncryption: &[u8; 8usize] = b"RSA-SM3\0";
pub const LN_sm3WithRSAEncryption: &[u8; 21usize] = b"sm3WithRSAEncryption\0";
pub const NID_sm3WithRSAEncryption: u32 = 1144;
pub const LN_hmacWithSHA224: &[u8; 15usize] = b"hmacWithSHA224\0";
pub const NID_hmacWithSHA224: u32 = 798;
pub const LN_hmacWithSHA256: &[u8; 15usize] = b"hmacWithSHA256\0";
pub const NID_hmacWithSHA256: u32 = 799;
pub const LN_hmacWithSHA384: &[u8; 15usize] = b"hmacWithSHA384\0";
pub const NID_hmacWithSHA384: u32 = 800;
pub const LN_hmacWithSHA512: &[u8; 15usize] = b"hmacWithSHA512\0";
pub const NID_hmacWithSHA512: u32 = 801;
pub const LN_hmacWithSHA512_224: &[u8; 19usize] = b"hmacWithSHA512-224\0";
pub const NID_hmacWithSHA512_224: u32 = 1193;
pub const LN_hmacWithSHA512_256: &[u8; 19usize] = b"hmacWithSHA512-256\0";
pub const NID_hmacWithSHA512_256: u32 = 1194;
pub const SN_rc2_cbc: &[u8; 8usize] = b"RC2-CBC\0";
pub const LN_rc2_cbc: &[u8; 8usize] = b"rc2-cbc\0";
pub const NID_rc2_cbc: u32 = 37;
pub const SN_rc2_ecb: &[u8; 8usize] = b"RC2-ECB\0";
pub const LN_rc2_ecb: &[u8; 8usize] = b"rc2-ecb\0";
pub const NID_rc2_ecb: u32 = 38;
pub const SN_rc2_cfb64: &[u8; 8usize] = b"RC2-CFB\0";
pub const LN_rc2_cfb64: &[u8; 8usize] = b"rc2-cfb\0";
pub const NID_rc2_cfb64: u32 = 39;
pub const SN_rc2_ofb64: &[u8; 8usize] = b"RC2-OFB\0";
pub const LN_rc2_ofb64: &[u8; 8usize] = b"rc2-ofb\0";
pub const NID_rc2_ofb64: u32 = 40;
pub const SN_rc2_40_cbc: &[u8; 11usize] = b"RC2-40-CBC\0";
pub const LN_rc2_40_cbc: &[u8; 11usize] = b"rc2-40-cbc\0";
pub const NID_rc2_40_cbc: u32 = 98;
pub const SN_rc2_64_cbc: &[u8; 11usize] = b"RC2-64-CBC\0";
pub const LN_rc2_64_cbc: &[u8; 11usize] = b"rc2-64-cbc\0";
pub const NID_rc2_64_cbc: u32 = 166;
pub const SN_rc4: &[u8; 4usize] = b"RC4\0";
pub const LN_rc4: &[u8; 4usize] = b"rc4\0";
pub const NID_rc4: u32 = 5;
pub const SN_rc4_40: &[u8; 7usize] = b"RC4-40\0";
pub const LN_rc4_40: &[u8; 7usize] = b"rc4-40\0";
pub const NID_rc4_40: u32 = 97;
pub const SN_des_ede3_cbc: &[u8; 13usize] = b"DES-EDE3-CBC\0";
pub const LN_des_ede3_cbc: &[u8; 13usize] = b"des-ede3-cbc\0";
pub const NID_des_ede3_cbc: u32 = 44;
pub const SN_rc5_cbc: &[u8; 8usize] = b"RC5-CBC\0";
pub const LN_rc5_cbc: &[u8; 8usize] = b"rc5-cbc\0";
pub const NID_rc5_cbc: u32 = 120;
pub const SN_rc5_ecb: &[u8; 8usize] = b"RC5-ECB\0";
pub const LN_rc5_ecb: &[u8; 8usize] = b"rc5-ecb\0";
pub const NID_rc5_ecb: u32 = 121;
pub const SN_rc5_cfb64: &[u8; 8usize] = b"RC5-CFB\0";
pub const LN_rc5_cfb64: &[u8; 8usize] = b"rc5-cfb\0";
pub const NID_rc5_cfb64: u32 = 122;
pub const SN_rc5_ofb64: &[u8; 8usize] = b"RC5-OFB\0";
pub const LN_rc5_ofb64: &[u8; 8usize] = b"rc5-ofb\0";
pub const NID_rc5_ofb64: u32 = 123;
pub const SN_ms_ext_req: &[u8; 9usize] = b"msExtReq\0";
pub const LN_ms_ext_req: &[u8; 28usize] = b"Microsoft Extension Request\0";
pub const NID_ms_ext_req: u32 = 171;
pub const SN_ms_code_ind: &[u8; 10usize] = b"msCodeInd\0";
pub const LN_ms_code_ind: &[u8; 34usize] = b"Microsoft Individual Code Signing\0";
pub const NID_ms_code_ind: u32 = 134;
pub const SN_ms_code_com: &[u8; 10usize] = b"msCodeCom\0";
pub const LN_ms_code_com: &[u8; 34usize] = b"Microsoft Commercial Code Signing\0";
pub const NID_ms_code_com: u32 = 135;
pub const SN_ms_ctl_sign: &[u8; 10usize] = b"msCTLSign\0";
pub const LN_ms_ctl_sign: &[u8; 29usize] = b"Microsoft Trust List Signing\0";
pub const NID_ms_ctl_sign: u32 = 136;
pub const SN_ms_sgc: &[u8; 6usize] = b"msSGC\0";
pub const LN_ms_sgc: &[u8; 30usize] = b"Microsoft Server Gated Crypto\0";
pub const NID_ms_sgc: u32 = 137;
pub const SN_ms_efs: &[u8; 6usize] = b"msEFS\0";
pub const LN_ms_efs: &[u8; 32usize] = b"Microsoft Encrypted File System\0";
pub const NID_ms_efs: u32 = 138;
pub const SN_ms_smartcard_login: &[u8; 17usize] = b"msSmartcardLogin\0";
pub const LN_ms_smartcard_login: &[u8; 26usize] = b"Microsoft Smartcard Login\0";
pub const NID_ms_smartcard_login: u32 = 648;
pub const SN_ms_upn: &[u8; 6usize] = b"msUPN\0";
pub const LN_ms_upn: &[u8; 30usize] = b"Microsoft User Principal Name\0";
pub const NID_ms_upn: u32 = 649;
pub const SN_idea_cbc: &[u8; 9usize] = b"IDEA-CBC\0";
pub const LN_idea_cbc: &[u8; 9usize] = b"idea-cbc\0";
pub const NID_idea_cbc: u32 = 34;
pub const SN_idea_ecb: &[u8; 9usize] = b"IDEA-ECB\0";
pub const LN_idea_ecb: &[u8; 9usize] = b"idea-ecb\0";
pub const NID_idea_ecb: u32 = 36;
pub const SN_idea_cfb64: &[u8; 9usize] = b"IDEA-CFB\0";
pub const LN_idea_cfb64: &[u8; 9usize] = b"idea-cfb\0";
pub const NID_idea_cfb64: u32 = 35;
pub const SN_idea_ofb64: &[u8; 9usize] = b"IDEA-OFB\0";
pub const LN_idea_ofb64: &[u8; 9usize] = b"idea-ofb\0";
pub const NID_idea_ofb64: u32 = 46;
pub const SN_bf_cbc: &[u8; 7usize] = b"BF-CBC\0";
pub const LN_bf_cbc: &[u8; 7usize] = b"bf-cbc\0";
pub const NID_bf_cbc: u32 = 91;
pub const SN_bf_ecb: &[u8; 7usize] = b"BF-ECB\0";
pub const LN_bf_ecb: &[u8; 7usize] = b"bf-ecb\0";
pub const NID_bf_ecb: u32 = 92;
pub const SN_bf_cfb64: &[u8; 7usize] = b"BF-CFB\0";
pub const LN_bf_cfb64: &[u8; 7usize] = b"bf-cfb\0";
pub const NID_bf_cfb64: u32 = 93;
pub const SN_bf_ofb64: &[u8; 7usize] = b"BF-OFB\0";
pub const LN_bf_ofb64: &[u8; 7usize] = b"bf-ofb\0";
pub const NID_bf_ofb64: u32 = 94;
pub const SN_id_pkix: &[u8; 5usize] = b"PKIX\0";
pub const NID_id_pkix: u32 = 127;
pub const SN_id_pkix_mod: &[u8; 12usize] = b"id-pkix-mod\0";
pub const NID_id_pkix_mod: u32 = 258;
pub const SN_id_pe: &[u8; 6usize] = b"id-pe\0";
pub const NID_id_pe: u32 = 175;
pub const SN_id_qt: &[u8; 6usize] = b"id-qt\0";
pub const NID_id_qt: u32 = 259;
pub const SN_id_kp: &[u8; 6usize] = b"id-kp\0";
pub const NID_id_kp: u32 = 128;
pub const SN_id_it: &[u8; 6usize] = b"id-it\0";
pub const NID_id_it: u32 = 260;
pub const SN_id_pkip: &[u8; 8usize] = b"id-pkip\0";
pub const NID_id_pkip: u32 = 261;
pub const SN_id_alg: &[u8; 7usize] = b"id-alg\0";
pub const NID_id_alg: u32 = 262;
pub const SN_id_cmc: &[u8; 7usize] = b"id-cmc\0";
pub const NID_id_cmc: u32 = 263;
pub const SN_id_on: &[u8; 6usize] = b"id-on\0";
pub const NID_id_on: u32 = 264;
pub const SN_id_pda: &[u8; 7usize] = b"id-pda\0";
pub const NID_id_pda: u32 = 265;
pub const SN_id_aca: &[u8; 7usize] = b"id-aca\0";
pub const NID_id_aca: u32 = 266;
pub const SN_id_qcs: &[u8; 7usize] = b"id-qcs\0";
pub const NID_id_qcs: u32 = 267;
pub const SN_id_cct: &[u8; 7usize] = b"id-cct\0";
pub const NID_id_cct: u32 = 268;
pub const SN_id_ppl: &[u8; 7usize] = b"id-ppl\0";
pub const NID_id_ppl: u32 = 662;
pub const SN_id_ad: &[u8; 6usize] = b"id-ad\0";
pub const NID_id_ad: u32 = 176;
pub const SN_id_pkix1_explicit_88: &[u8; 21usize] = b"id-pkix1-explicit-88\0";
pub const NID_id_pkix1_explicit_88: u32 = 269;
pub const SN_id_pkix1_implicit_88: &[u8; 21usize] = b"id-pkix1-implicit-88\0";
pub const NID_id_pkix1_implicit_88: u32 = 270;
pub const SN_id_pkix1_explicit_93: &[u8; 21usize] = b"id-pkix1-explicit-93\0";
pub const NID_id_pkix1_explicit_93: u32 = 271;
pub const SN_id_pkix1_implicit_93: &[u8; 21usize] = b"id-pkix1-implicit-93\0";
pub const NID_id_pkix1_implicit_93: u32 = 272;
pub const SN_id_mod_crmf: &[u8; 12usize] = b"id-mod-crmf\0";
pub const NID_id_mod_crmf: u32 = 273;
pub const SN_id_mod_cmc: &[u8; 11usize] = b"id-mod-cmc\0";
pub const NID_id_mod_cmc: u32 = 274;
pub const SN_id_mod_kea_profile_88: &[u8; 22usize] = b"id-mod-kea-profile-88\0";
pub const NID_id_mod_kea_profile_88: u32 = 275;
pub const SN_id_mod_kea_profile_93: &[u8; 22usize] = b"id-mod-kea-profile-93\0";
pub const NID_id_mod_kea_profile_93: u32 = 276;
pub const SN_id_mod_cmp: &[u8; 11usize] = b"id-mod-cmp\0";
pub const NID_id_mod_cmp: u32 = 277;
pub const SN_id_mod_qualified_cert_88: &[u8; 25usize] = b"id-mod-qualified-cert-88\0";
pub const NID_id_mod_qualified_cert_88: u32 = 278;
pub const SN_id_mod_qualified_cert_93: &[u8; 25usize] = b"id-mod-qualified-cert-93\0";
pub const NID_id_mod_qualified_cert_93: u32 = 279;
pub const SN_id_mod_attribute_cert: &[u8; 22usize] = b"id-mod-attribute-cert\0";
pub const NID_id_mod_attribute_cert: u32 = 280;
pub const SN_id_mod_timestamp_protocol: &[u8; 26usize] = b"id-mod-timestamp-protocol\0";
pub const NID_id_mod_timestamp_protocol: u32 = 281;
pub const SN_id_mod_ocsp: &[u8; 12usize] = b"id-mod-ocsp\0";
pub const NID_id_mod_ocsp: u32 = 282;
pub const SN_id_mod_dvcs: &[u8; 12usize] = b"id-mod-dvcs\0";
pub const NID_id_mod_dvcs: u32 = 283;
pub const SN_id_mod_cmp2000: &[u8; 15usize] = b"id-mod-cmp2000\0";
pub const NID_id_mod_cmp2000: u32 = 284;
pub const SN_info_access: &[u8; 20usize] = b"authorityInfoAccess\0";
pub const LN_info_access: &[u8; 29usize] = b"Authority Information Access\0";
pub const NID_info_access: u32 = 177;
pub const SN_biometricInfo: &[u8; 14usize] = b"biometricInfo\0";
pub const LN_biometricInfo: &[u8; 15usize] = b"Biometric Info\0";
pub const NID_biometricInfo: u32 = 285;
pub const SN_qcStatements: &[u8; 13usize] = b"qcStatements\0";
pub const NID_qcStatements: u32 = 286;
pub const SN_ac_auditEntity: &[u8; 15usize] = b"ac-auditEntity\0";
pub const NID_ac_auditEntity: u32 = 287;
pub const SN_ac_targeting: &[u8; 13usize] = b"ac-targeting\0";
pub const NID_ac_targeting: u32 = 288;
pub const SN_aaControls: &[u8; 11usize] = b"aaControls\0";
pub const NID_aaControls: u32 = 289;
pub const SN_sbgp_ipAddrBlock: &[u8; 17usize] = b"sbgp-ipAddrBlock\0";
pub const NID_sbgp_ipAddrBlock: u32 = 290;
pub const SN_sbgp_autonomousSysNum: &[u8; 22usize] = b"sbgp-autonomousSysNum\0";
pub const NID_sbgp_autonomousSysNum: u32 = 291;
pub const SN_sbgp_routerIdentifier: &[u8; 22usize] = b"sbgp-routerIdentifier\0";
pub const NID_sbgp_routerIdentifier: u32 = 292;
pub const SN_ac_proxying: &[u8; 12usize] = b"ac-proxying\0";
pub const NID_ac_proxying: u32 = 397;
pub const SN_sinfo_access: &[u8; 18usize] = b"subjectInfoAccess\0";
pub const LN_sinfo_access: &[u8; 27usize] = b"Subject Information Access\0";
pub const NID_sinfo_access: u32 = 398;
pub const SN_proxyCertInfo: &[u8; 14usize] = b"proxyCertInfo\0";
pub const LN_proxyCertInfo: &[u8; 30usize] = b"Proxy Certificate Information\0";
pub const NID_proxyCertInfo: u32 = 663;
pub const SN_tlsfeature: &[u8; 11usize] = b"tlsfeature\0";
pub const LN_tlsfeature: &[u8; 12usize] = b"TLS Feature\0";
pub const NID_tlsfeature: u32 = 1020;
pub const SN_id_qt_cps: &[u8; 10usize] = b"id-qt-cps\0";
pub const LN_id_qt_cps: &[u8; 21usize] = b"Policy Qualifier CPS\0";
pub const NID_id_qt_cps: u32 = 164;
pub const SN_id_qt_unotice: &[u8; 14usize] = b"id-qt-unotice\0";
pub const LN_id_qt_unotice: &[u8; 29usize] = b"Policy Qualifier User Notice\0";
pub const NID_id_qt_unotice: u32 = 165;
pub const SN_textNotice: &[u8; 11usize] = b"textNotice\0";
pub const NID_textNotice: u32 = 293;
pub const SN_server_auth: &[u8; 11usize] = b"serverAuth\0";
pub const LN_server_auth: &[u8; 30usize] = b"TLS Web Server Authentication\0";
pub const NID_server_auth: u32 = 129;
pub const SN_client_auth: &[u8; 11usize] = b"clientAuth\0";
pub const LN_client_auth: &[u8; 30usize] = b"TLS Web Client Authentication\0";
pub const NID_client_auth: u32 = 130;
pub const SN_code_sign: &[u8; 12usize] = b"codeSigning\0";
pub const LN_code_sign: &[u8; 13usize] = b"Code Signing\0";
pub const NID_code_sign: u32 = 131;
pub const SN_email_protect: &[u8; 16usize] = b"emailProtection\0";
pub const LN_email_protect: &[u8; 18usize] = b"E-mail Protection\0";
pub const NID_email_protect: u32 = 132;
pub const SN_ipsecEndSystem: &[u8; 15usize] = b"ipsecEndSystem\0";
pub const LN_ipsecEndSystem: &[u8; 17usize] = b"IPSec End System\0";
pub const NID_ipsecEndSystem: u32 = 294;
pub const SN_ipsecTunnel: &[u8; 12usize] = b"ipsecTunnel\0";
pub const LN_ipsecTunnel: &[u8; 13usize] = b"IPSec Tunnel\0";
pub const NID_ipsecTunnel: u32 = 295;
pub const SN_ipsecUser: &[u8; 10usize] = b"ipsecUser\0";
pub const LN_ipsecUser: &[u8; 11usize] = b"IPSec User\0";
pub const NID_ipsecUser: u32 = 296;
pub const SN_time_stamp: &[u8; 13usize] = b"timeStamping\0";
pub const LN_time_stamp: &[u8; 14usize] = b"Time Stamping\0";
pub const NID_time_stamp: u32 = 133;
pub const SN_OCSP_sign: &[u8; 12usize] = b"OCSPSigning\0";
pub const LN_OCSP_sign: &[u8; 13usize] = b"OCSP Signing\0";
pub const NID_OCSP_sign: u32 = 180;
pub const SN_dvcs: &[u8; 5usize] = b"DVCS\0";
pub const LN_dvcs: &[u8; 5usize] = b"dvcs\0";
pub const NID_dvcs: u32 = 297;
pub const SN_ipsec_IKE: &[u8; 9usize] = b"ipsecIKE\0";
pub const LN_ipsec_IKE: &[u8; 28usize] = b"ipsec Internet Key Exchange\0";
pub const NID_ipsec_IKE: u32 = 1022;
pub const SN_capwapAC: &[u8; 9usize] = b"capwapAC\0";
pub const LN_capwapAC: &[u8; 26usize] = b"Ctrl/provision WAP Access\0";
pub const NID_capwapAC: u32 = 1023;
pub const SN_capwapWTP: &[u8; 10usize] = b"capwapWTP\0";
pub const LN_capwapWTP: &[u8; 31usize] = b"Ctrl/Provision WAP Termination\0";
pub const NID_capwapWTP: u32 = 1024;
pub const SN_sshClient: &[u8; 18usize] = b"secureShellClient\0";
pub const LN_sshClient: &[u8; 11usize] = b"SSH Client\0";
pub const NID_sshClient: u32 = 1025;
pub const SN_sshServer: &[u8; 18usize] = b"secureShellServer\0";
pub const LN_sshServer: &[u8; 11usize] = b"SSH Server\0";
pub const NID_sshServer: u32 = 1026;
pub const SN_sendRouter: &[u8; 11usize] = b"sendRouter\0";
pub const LN_sendRouter: &[u8; 12usize] = b"Send Router\0";
pub const NID_sendRouter: u32 = 1027;
pub const SN_sendProxiedRouter: &[u8; 18usize] = b"sendProxiedRouter\0";
pub const LN_sendProxiedRouter: &[u8; 20usize] = b"Send Proxied Router\0";
pub const NID_sendProxiedRouter: u32 = 1028;
pub const SN_sendOwner: &[u8; 10usize] = b"sendOwner\0";
pub const LN_sendOwner: &[u8; 11usize] = b"Send Owner\0";
pub const NID_sendOwner: u32 = 1029;
pub const SN_sendProxiedOwner: &[u8; 17usize] = b"sendProxiedOwner\0";
pub const LN_sendProxiedOwner: &[u8; 19usize] = b"Send Proxied Owner\0";
pub const NID_sendProxiedOwner: u32 = 1030;
pub const SN_cmcCA: &[u8; 6usize] = b"cmcCA\0";
pub const LN_cmcCA: &[u8; 26usize] = b"CMC Certificate Authority\0";
pub const NID_cmcCA: u32 = 1131;
pub const SN_cmcRA: &[u8; 6usize] = b"cmcRA\0";
pub const LN_cmcRA: &[u8; 27usize] = b"CMC Registration Authority\0";
pub const NID_cmcRA: u32 = 1132;
pub const SN_id_it_caProtEncCert: &[u8; 20usize] = b"id-it-caProtEncCert\0";
pub const NID_id_it_caProtEncCert: u32 = 298;
pub const SN_id_it_signKeyPairTypes: &[u8; 23usize] = b"id-it-signKeyPairTypes\0";
pub const NID_id_it_signKeyPairTypes: u32 = 299;
pub const SN_id_it_encKeyPairTypes: &[u8; 22usize] = b"id-it-encKeyPairTypes\0";
pub const NID_id_it_encKeyPairTypes: u32 = 300;
pub const SN_id_it_preferredSymmAlg: &[u8; 23usize] = b"id-it-preferredSymmAlg\0";
pub const NID_id_it_preferredSymmAlg: u32 = 301;
pub const SN_id_it_caKeyUpdateInfo: &[u8; 22usize] = b"id-it-caKeyUpdateInfo\0";
pub const NID_id_it_caKeyUpdateInfo: u32 = 302;
pub const SN_id_it_currentCRL: &[u8; 17usize] = b"id-it-currentCRL\0";
pub const NID_id_it_currentCRL: u32 = 303;
pub const SN_id_it_unsupportedOIDs: &[u8; 22usize] = b"id-it-unsupportedOIDs\0";
pub const NID_id_it_unsupportedOIDs: u32 = 304;
pub const SN_id_it_subscriptionRequest: &[u8; 26usize] = b"id-it-subscriptionRequest\0";
pub const NID_id_it_subscriptionRequest: u32 = 305;
pub const SN_id_it_subscriptionResponse: &[u8; 27usize] = b"id-it-subscriptionResponse\0";
pub const NID_id_it_subscriptionResponse: u32 = 306;
pub const SN_id_it_keyPairParamReq: &[u8; 22usize] = b"id-it-keyPairParamReq\0";
pub const NID_id_it_keyPairParamReq: u32 = 307;
pub const SN_id_it_keyPairParamRep: &[u8; 22usize] = b"id-it-keyPairParamRep\0";
pub const NID_id_it_keyPairParamRep: u32 = 308;
pub const SN_id_it_revPassphrase: &[u8; 20usize] = b"id-it-revPassphrase\0";
pub const NID_id_it_revPassphrase: u32 = 309;
pub const SN_id_it_implicitConfirm: &[u8; 22usize] = b"id-it-implicitConfirm\0";
pub const NID_id_it_implicitConfirm: u32 = 310;
pub const SN_id_it_confirmWaitTime: &[u8; 22usize] = b"id-it-confirmWaitTime\0";
pub const NID_id_it_confirmWaitTime: u32 = 311;
pub const SN_id_it_origPKIMessage: &[u8; 21usize] = b"id-it-origPKIMessage\0";
pub const NID_id_it_origPKIMessage: u32 = 312;
pub const SN_id_it_suppLangTags: &[u8; 19usize] = b"id-it-suppLangTags\0";
pub const NID_id_it_suppLangTags: u32 = 784;
pub const SN_id_regCtrl: &[u8; 11usize] = b"id-regCtrl\0";
pub const NID_id_regCtrl: u32 = 313;
pub const SN_id_regInfo: &[u8; 11usize] = b"id-regInfo\0";
pub const NID_id_regInfo: u32 = 314;
pub const SN_id_regCtrl_regToken: &[u8; 20usize] = b"id-regCtrl-regToken\0";
pub const NID_id_regCtrl_regToken: u32 = 315;
pub const SN_id_regCtrl_authenticator: &[u8; 25usize] = b"id-regCtrl-authenticator\0";
pub const NID_id_regCtrl_authenticator: u32 = 316;
pub const SN_id_regCtrl_pkiPublicationInfo: &[u8; 30usize] = b"id-regCtrl-pkiPublicationInfo\0";
pub const NID_id_regCtrl_pkiPublicationInfo: u32 = 317;
pub const SN_id_regCtrl_pkiArchiveOptions: &[u8; 29usize] = b"id-regCtrl-pkiArchiveOptions\0";
pub const NID_id_regCtrl_pkiArchiveOptions: u32 = 318;
pub const SN_id_regCtrl_oldCertID: &[u8; 21usize] = b"id-regCtrl-oldCertID\0";
pub const NID_id_regCtrl_oldCertID: u32 = 319;
pub const SN_id_regCtrl_protocolEncrKey: &[u8; 27usize] = b"id-regCtrl-protocolEncrKey\0";
pub const NID_id_regCtrl_protocolEncrKey: u32 = 320;
pub const SN_id_regInfo_utf8Pairs: &[u8; 21usize] = b"id-regInfo-utf8Pairs\0";
pub const NID_id_regInfo_utf8Pairs: u32 = 321;
pub const SN_id_regInfo_certReq: &[u8; 19usize] = b"id-regInfo-certReq\0";
pub const NID_id_regInfo_certReq: u32 = 322;
pub const SN_id_alg_des40: &[u8; 13usize] = b"id-alg-des40\0";
pub const NID_id_alg_des40: u32 = 323;
pub const SN_id_alg_noSignature: &[u8; 19usize] = b"id-alg-noSignature\0";
pub const NID_id_alg_noSignature: u32 = 324;
pub const SN_id_alg_dh_sig_hmac_sha1: &[u8; 24usize] = b"id-alg-dh-sig-hmac-sha1\0";
pub const NID_id_alg_dh_sig_hmac_sha1: u32 = 325;
pub const SN_id_alg_dh_pop: &[u8; 14usize] = b"id-alg-dh-pop\0";
pub const NID_id_alg_dh_pop: u32 = 326;
pub const SN_id_cmc_statusInfo: &[u8; 18usize] = b"id-cmc-statusInfo\0";
pub const NID_id_cmc_statusInfo: u32 = 327;
pub const SN_id_cmc_identification: &[u8; 22usize] = b"id-cmc-identification\0";
pub const NID_id_cmc_identification: u32 = 328;
pub const SN_id_cmc_identityProof: &[u8; 21usize] = b"id-cmc-identityProof\0";
pub const NID_id_cmc_identityProof: u32 = 329;
pub const SN_id_cmc_dataReturn: &[u8; 18usize] = b"id-cmc-dataReturn\0";
pub const NID_id_cmc_dataReturn: u32 = 330;
pub const SN_id_cmc_transactionId: &[u8; 21usize] = b"id-cmc-transactionId\0";
pub const NID_id_cmc_transactionId: u32 = 331;
pub const SN_id_cmc_senderNonce: &[u8; 19usize] = b"id-cmc-senderNonce\0";
pub const NID_id_cmc_senderNonce: u32 = 332;
pub const SN_id_cmc_recipientNonce: &[u8; 22usize] = b"id-cmc-recipientNonce\0";
pub const NID_id_cmc_recipientNonce: u32 = 333;
pub const SN_id_cmc_addExtensions: &[u8; 21usize] = b"id-cmc-addExtensions\0";
pub const NID_id_cmc_addExtensions: u32 = 334;
pub const SN_id_cmc_encryptedPOP: &[u8; 20usize] = b"id-cmc-encryptedPOP\0";
pub const NID_id_cmc_encryptedPOP: u32 = 335;
pub const SN_id_cmc_decryptedPOP: &[u8; 20usize] = b"id-cmc-decryptedPOP\0";
pub const NID_id_cmc_decryptedPOP: u32 = 336;
pub const SN_id_cmc_lraPOPWitness: &[u8; 21usize] = b"id-cmc-lraPOPWitness\0";
pub const NID_id_cmc_lraPOPWitness: u32 = 337;
pub const SN_id_cmc_getCert: &[u8; 15usize] = b"id-cmc-getCert\0";
pub const NID_id_cmc_getCert: u32 = 338;
pub const SN_id_cmc_getCRL: &[u8; 14usize] = b"id-cmc-getCRL\0";
pub const NID_id_cmc_getCRL: u32 = 339;
pub const SN_id_cmc_revokeRequest: &[u8; 21usize] = b"id-cmc-revokeRequest\0";
pub const NID_id_cmc_revokeRequest: u32 = 340;
pub const SN_id_cmc_regInfo: &[u8; 15usize] = b"id-cmc-regInfo\0";
pub const NID_id_cmc_regInfo: u32 = 341;
pub const SN_id_cmc_responseInfo: &[u8; 20usize] = b"id-cmc-responseInfo\0";
pub const NID_id_cmc_responseInfo: u32 = 342;
pub const SN_id_cmc_queryPending: &[u8; 20usize] = b"id-cmc-queryPending\0";
pub const NID_id_cmc_queryPending: u32 = 343;
pub const SN_id_cmc_popLinkRandom: &[u8; 21usize] = b"id-cmc-popLinkRandom\0";
pub const NID_id_cmc_popLinkRandom: u32 = 344;
pub const SN_id_cmc_popLinkWitness: &[u8; 22usize] = b"id-cmc-popLinkWitness\0";
pub const NID_id_cmc_popLinkWitness: u32 = 345;
pub const SN_id_cmc_confirmCertAcceptance: &[u8; 29usize] = b"id-cmc-confirmCertAcceptance\0";
pub const NID_id_cmc_confirmCertAcceptance: u32 = 346;
pub const SN_id_on_personalData: &[u8; 19usize] = b"id-on-personalData\0";
pub const NID_id_on_personalData: u32 = 347;
pub const SN_id_on_permanentIdentifier: &[u8; 26usize] = b"id-on-permanentIdentifier\0";
pub const LN_id_on_permanentIdentifier: &[u8; 21usize] = b"Permanent Identifier\0";
pub const NID_id_on_permanentIdentifier: u32 = 858;
pub const SN_id_pda_dateOfBirth: &[u8; 19usize] = b"id-pda-dateOfBirth\0";
pub const NID_id_pda_dateOfBirth: u32 = 348;
pub const SN_id_pda_placeOfBirth: &[u8; 20usize] = b"id-pda-placeOfBirth\0";
pub const NID_id_pda_placeOfBirth: u32 = 349;
pub const SN_id_pda_gender: &[u8; 14usize] = b"id-pda-gender\0";
pub const NID_id_pda_gender: u32 = 351;
pub const SN_id_pda_countryOfCitizenship: &[u8; 28usize] = b"id-pda-countryOfCitizenship\0";
pub const NID_id_pda_countryOfCitizenship: u32 = 352;
pub const SN_id_pda_countryOfResidence: &[u8; 26usize] = b"id-pda-countryOfResidence\0";
pub const NID_id_pda_countryOfResidence: u32 = 353;
pub const SN_id_aca_authenticationInfo: &[u8; 26usize] = b"id-aca-authenticationInfo\0";
pub const NID_id_aca_authenticationInfo: u32 = 354;
pub const SN_id_aca_accessIdentity: &[u8; 22usize] = b"id-aca-accessIdentity\0";
pub const NID_id_aca_accessIdentity: u32 = 355;
pub const SN_id_aca_chargingIdentity: &[u8; 24usize] = b"id-aca-chargingIdentity\0";
pub const NID_id_aca_chargingIdentity: u32 = 356;
pub const SN_id_aca_group: &[u8; 13usize] = b"id-aca-group\0";
pub const NID_id_aca_group: u32 = 357;
pub const SN_id_aca_role: &[u8; 12usize] = b"id-aca-role\0";
pub const NID_id_aca_role: u32 = 358;
pub const SN_id_aca_encAttrs: &[u8; 16usize] = b"id-aca-encAttrs\0";
pub const NID_id_aca_encAttrs: u32 = 399;
pub const SN_id_qcs_pkixQCSyntax_v1: &[u8; 23usize] = b"id-qcs-pkixQCSyntax-v1\0";
pub const NID_id_qcs_pkixQCSyntax_v1: u32 = 359;
pub const SN_id_cct_crs: &[u8; 11usize] = b"id-cct-crs\0";
pub const NID_id_cct_crs: u32 = 360;
pub const SN_id_cct_PKIData: &[u8; 15usize] = b"id-cct-PKIData\0";
pub const NID_id_cct_PKIData: u32 = 361;
pub const SN_id_cct_PKIResponse: &[u8; 19usize] = b"id-cct-PKIResponse\0";
pub const NID_id_cct_PKIResponse: u32 = 362;
pub const SN_id_ppl_anyLanguage: &[u8; 19usize] = b"id-ppl-anyLanguage\0";
pub const LN_id_ppl_anyLanguage: &[u8; 13usize] = b"Any language\0";
pub const NID_id_ppl_anyLanguage: u32 = 664;
pub const SN_id_ppl_inheritAll: &[u8; 18usize] = b"id-ppl-inheritAll\0";
pub const LN_id_ppl_inheritAll: &[u8; 12usize] = b"Inherit all\0";
pub const NID_id_ppl_inheritAll: u32 = 665;
pub const SN_Independent: &[u8; 19usize] = b"id-ppl-independent\0";
pub const LN_Independent: &[u8; 12usize] = b"Independent\0";
pub const NID_Independent: u32 = 667;
pub const SN_ad_OCSP: &[u8; 5usize] = b"OCSP\0";
pub const LN_ad_OCSP: &[u8; 5usize] = b"OCSP\0";
pub const NID_ad_OCSP: u32 = 178;
pub const SN_ad_ca_issuers: &[u8; 10usize] = b"caIssuers\0";
pub const LN_ad_ca_issuers: &[u8; 11usize] = b"CA Issuers\0";
pub const NID_ad_ca_issuers: u32 = 179;
pub const SN_ad_timeStamping: &[u8; 16usize] = b"ad_timestamping\0";
pub const LN_ad_timeStamping: &[u8; 17usize] = b"AD Time Stamping\0";
pub const NID_ad_timeStamping: u32 = 363;
pub const SN_ad_dvcs: &[u8; 8usize] = b"AD_DVCS\0";
pub const LN_ad_dvcs: &[u8; 8usize] = b"ad dvcs\0";
pub const NID_ad_dvcs: u32 = 364;
pub const SN_caRepository: &[u8; 13usize] = b"caRepository\0";
pub const LN_caRepository: &[u8; 14usize] = b"CA Repository\0";
pub const NID_caRepository: u32 = 785;
pub const SN_id_pkix_OCSP_basic: &[u8; 18usize] = b"basicOCSPResponse\0";
pub const LN_id_pkix_OCSP_basic: &[u8; 20usize] = b"Basic OCSP Response\0";
pub const NID_id_pkix_OCSP_basic: u32 = 365;
pub const SN_id_pkix_OCSP_Nonce: &[u8; 6usize] = b"Nonce\0";
pub const LN_id_pkix_OCSP_Nonce: &[u8; 11usize] = b"OCSP Nonce\0";
pub const NID_id_pkix_OCSP_Nonce: u32 = 366;
pub const SN_id_pkix_OCSP_CrlID: &[u8; 6usize] = b"CrlID\0";
pub const LN_id_pkix_OCSP_CrlID: &[u8; 12usize] = b"OCSP CRL ID\0";
pub const NID_id_pkix_OCSP_CrlID: u32 = 367;
pub const SN_id_pkix_OCSP_acceptableResponses: &[u8; 20usize] = b"acceptableResponses\0";
pub const LN_id_pkix_OCSP_acceptableResponses: &[u8; 26usize] = b"Acceptable OCSP Responses\0";
pub const NID_id_pkix_OCSP_acceptableResponses: u32 = 368;
pub const SN_id_pkix_OCSP_noCheck: &[u8; 8usize] = b"noCheck\0";
pub const LN_id_pkix_OCSP_noCheck: &[u8; 14usize] = b"OCSP No Check\0";
pub const NID_id_pkix_OCSP_noCheck: u32 = 369;
pub const SN_id_pkix_OCSP_archiveCutoff: &[u8; 14usize] = b"archiveCutoff\0";
pub const LN_id_pkix_OCSP_archiveCutoff: &[u8; 20usize] = b"OCSP Archive Cutoff\0";
pub const NID_id_pkix_OCSP_archiveCutoff: u32 = 370;
pub const SN_id_pkix_OCSP_serviceLocator: &[u8; 15usize] = b"serviceLocator\0";
pub const LN_id_pkix_OCSP_serviceLocator: &[u8; 21usize] = b"OCSP Service Locator\0";
pub const NID_id_pkix_OCSP_serviceLocator: u32 = 371;
pub const SN_id_pkix_OCSP_extendedStatus: &[u8; 15usize] = b"extendedStatus\0";
pub const LN_id_pkix_OCSP_extendedStatus: &[u8; 21usize] = b"Extended OCSP Status\0";
pub const NID_id_pkix_OCSP_extendedStatus: u32 = 372;
pub const SN_id_pkix_OCSP_valid: &[u8; 6usize] = b"valid\0";
pub const NID_id_pkix_OCSP_valid: u32 = 373;
pub const SN_id_pkix_OCSP_path: &[u8; 5usize] = b"path\0";
pub const NID_id_pkix_OCSP_path: u32 = 374;
pub const SN_id_pkix_OCSP_trustRoot: &[u8; 10usize] = b"trustRoot\0";
pub const LN_id_pkix_OCSP_trustRoot: &[u8; 11usize] = b"Trust Root\0";
pub const NID_id_pkix_OCSP_trustRoot: u32 = 375;
pub const SN_algorithm: &[u8; 10usize] = b"algorithm\0";
pub const LN_algorithm: &[u8; 10usize] = b"algorithm\0";
pub const NID_algorithm: u32 = 376;
pub const SN_md5WithRSA: &[u8; 11usize] = b"RSA-NP-MD5\0";
pub const LN_md5WithRSA: &[u8; 11usize] = b"md5WithRSA\0";
pub const NID_md5WithRSA: u32 = 104;
pub const SN_des_ecb: &[u8; 8usize] = b"DES-ECB\0";
pub const LN_des_ecb: &[u8; 8usize] = b"des-ecb\0";
pub const NID_des_ecb: u32 = 29;
pub const SN_des_cbc: &[u8; 8usize] = b"DES-CBC\0";
pub const LN_des_cbc: &[u8; 8usize] = b"des-cbc\0";
pub const NID_des_cbc: u32 = 31;
pub const SN_des_ofb64: &[u8; 8usize] = b"DES-OFB\0";
pub const LN_des_ofb64: &[u8; 8usize] = b"des-ofb\0";
pub const NID_des_ofb64: u32 = 45;
pub const SN_des_cfb64: &[u8; 8usize] = b"DES-CFB\0";
pub const LN_des_cfb64: &[u8; 8usize] = b"des-cfb\0";
pub const NID_des_cfb64: u32 = 30;
pub const SN_rsaSignature: &[u8; 13usize] = b"rsaSignature\0";
pub const NID_rsaSignature: u32 = 377;
pub const SN_dsa_2: &[u8; 8usize] = b"DSA-old\0";
pub const LN_dsa_2: &[u8; 18usize] = b"dsaEncryption-old\0";
pub const NID_dsa_2: u32 = 67;
pub const SN_dsaWithSHA: &[u8; 8usize] = b"DSA-SHA\0";
pub const LN_dsaWithSHA: &[u8; 11usize] = b"dsaWithSHA\0";
pub const NID_dsaWithSHA: u32 = 66;
pub const SN_shaWithRSAEncryption: &[u8; 8usize] = b"RSA-SHA\0";
pub const LN_shaWithRSAEncryption: &[u8; 21usize] = b"shaWithRSAEncryption\0";
pub const NID_shaWithRSAEncryption: u32 = 42;
pub const SN_des_ede_ecb: &[u8; 8usize] = b"DES-EDE\0";
pub const LN_des_ede_ecb: &[u8; 8usize] = b"des-ede\0";
pub const NID_des_ede_ecb: u32 = 32;
pub const SN_des_ede3_ecb: &[u8; 9usize] = b"DES-EDE3\0";
pub const LN_des_ede3_ecb: &[u8; 9usize] = b"des-ede3\0";
pub const NID_des_ede3_ecb: u32 = 33;
pub const SN_des_ede_cbc: &[u8; 12usize] = b"DES-EDE-CBC\0";
pub const LN_des_ede_cbc: &[u8; 12usize] = b"des-ede-cbc\0";
pub const NID_des_ede_cbc: u32 = 43;
pub const SN_des_ede_cfb64: &[u8; 12usize] = b"DES-EDE-CFB\0";
pub const LN_des_ede_cfb64: &[u8; 12usize] = b"des-ede-cfb\0";
pub const NID_des_ede_cfb64: u32 = 60;
pub const SN_des_ede3_cfb64: &[u8; 13usize] = b"DES-EDE3-CFB\0";
pub const LN_des_ede3_cfb64: &[u8; 13usize] = b"des-ede3-cfb\0";
pub const NID_des_ede3_cfb64: u32 = 61;
pub const SN_des_ede_ofb64: &[u8; 12usize] = b"DES-EDE-OFB\0";
pub const LN_des_ede_ofb64: &[u8; 12usize] = b"des-ede-ofb\0";
pub const NID_des_ede_ofb64: u32 = 62;
pub const SN_des_ede3_ofb64: &[u8; 13usize] = b"DES-EDE3-OFB\0";
pub const LN_des_ede3_ofb64: &[u8; 13usize] = b"des-ede3-ofb\0";
pub const NID_des_ede3_ofb64: u32 = 63;
pub const SN_desx_cbc: &[u8; 9usize] = b"DESX-CBC\0";
pub const LN_desx_cbc: &[u8; 9usize] = b"desx-cbc\0";
pub const NID_desx_cbc: u32 = 80;
pub const SN_sha: &[u8; 4usize] = b"SHA\0";
pub const LN_sha: &[u8; 4usize] = b"sha\0";
pub const NID_sha: u32 = 41;
pub const SN_sha1: &[u8; 5usize] = b"SHA1\0";
pub const LN_sha1: &[u8; 5usize] = b"sha1\0";
pub const NID_sha1: u32 = 64;
pub const SN_dsaWithSHA1_2: &[u8; 13usize] = b"DSA-SHA1-old\0";
pub const LN_dsaWithSHA1_2: &[u8; 16usize] = b"dsaWithSHA1-old\0";
pub const NID_dsaWithSHA1_2: u32 = 70;
pub const SN_sha1WithRSA: &[u8; 11usize] = b"RSA-SHA1-2\0";
pub const LN_sha1WithRSA: &[u8; 12usize] = b"sha1WithRSA\0";
pub const NID_sha1WithRSA: u32 = 115;
pub const SN_ripemd160: &[u8; 10usize] = b"RIPEMD160\0";
pub const LN_ripemd160: &[u8; 10usize] = b"ripemd160\0";
pub const NID_ripemd160: u32 = 117;
pub const SN_ripemd160WithRSA: &[u8; 14usize] = b"RSA-RIPEMD160\0";
pub const LN_ripemd160WithRSA: &[u8; 17usize] = b"ripemd160WithRSA\0";
pub const NID_ripemd160WithRSA: u32 = 119;
pub const SN_blake2b512: &[u8; 11usize] = b"BLAKE2b512\0";
pub const LN_blake2b512: &[u8; 11usize] = b"blake2b512\0";
pub const NID_blake2b512: u32 = 1056;
pub const SN_blake2s256: &[u8; 11usize] = b"BLAKE2s256\0";
pub const LN_blake2s256: &[u8; 11usize] = b"blake2s256\0";
pub const NID_blake2s256: u32 = 1057;
pub const SN_sxnet: &[u8; 8usize] = b"SXNetID\0";
pub const LN_sxnet: &[u8; 19usize] = b"Strong Extranet ID\0";
pub const NID_sxnet: u32 = 143;
pub const SN_X500: &[u8; 5usize] = b"X500\0";
pub const LN_X500: &[u8; 27usize] = b"directory services (X.500)\0";
pub const NID_X500: u32 = 11;
pub const SN_X509: &[u8; 5usize] = b"X509\0";
pub const NID_X509: u32 = 12;
pub const SN_commonName: &[u8; 3usize] = b"CN\0";
pub const LN_commonName: &[u8; 11usize] = b"commonName\0";
pub const NID_commonName: u32 = 13;
pub const SN_surname: &[u8; 3usize] = b"SN\0";
pub const LN_surname: &[u8; 8usize] = b"surname\0";
pub const NID_surname: u32 = 100;
pub const LN_serialNumber: &[u8; 13usize] = b"serialNumber\0";
pub const NID_serialNumber: u32 = 105;
pub const SN_countryName: &[u8; 2usize] = b"C\0";
pub const LN_countryName: &[u8; 12usize] = b"countryName\0";
pub const NID_countryName: u32 = 14;
pub const SN_localityName: &[u8; 2usize] = b"L\0";
pub const LN_localityName: &[u8; 13usize] = b"localityName\0";
pub const NID_localityName: u32 = 15;
pub const SN_stateOrProvinceName: &[u8; 3usize] = b"ST\0";
pub const LN_stateOrProvinceName: &[u8; 20usize] = b"stateOrProvinceName\0";
pub const NID_stateOrProvinceName: u32 = 16;
pub const SN_streetAddress: &[u8; 7usize] = b"street\0";
pub const LN_streetAddress: &[u8; 14usize] = b"streetAddress\0";
pub const NID_streetAddress: u32 = 660;
pub const SN_organizationName: &[u8; 2usize] = b"O\0";
pub const LN_organizationName: &[u8; 17usize] = b"organizationName\0";
pub const NID_organizationName: u32 = 17;
pub const SN_organizationalUnitName: &[u8; 3usize] = b"OU\0";
pub const LN_organizationalUnitName: &[u8; 23usize] = b"organizationalUnitName\0";
pub const NID_organizationalUnitName: u32 = 18;
pub const SN_title: &[u8; 6usize] = b"title\0";
pub const LN_title: &[u8; 6usize] = b"title\0";
pub const NID_title: u32 = 106;
pub const LN_description: &[u8; 12usize] = b"description\0";
pub const NID_description: u32 = 107;
pub const LN_searchGuide: &[u8; 12usize] = b"searchGuide\0";
pub const NID_searchGuide: u32 = 859;
pub const LN_businessCategory: &[u8; 17usize] = b"businessCategory\0";
pub const NID_businessCategory: u32 = 860;
pub const LN_postalAddress: &[u8; 14usize] = b"postalAddress\0";
pub const NID_postalAddress: u32 = 861;
pub const LN_postalCode: &[u8; 11usize] = b"postalCode\0";
pub const NID_postalCode: u32 = 661;
pub const LN_postOfficeBox: &[u8; 14usize] = b"postOfficeBox\0";
pub const NID_postOfficeBox: u32 = 862;
pub const LN_physicalDeliveryOfficeName: &[u8; 27usize] = b"physicalDeliveryOfficeName\0";
pub const NID_physicalDeliveryOfficeName: u32 = 863;
pub const LN_telephoneNumber: &[u8; 16usize] = b"telephoneNumber\0";
pub const NID_telephoneNumber: u32 = 864;
pub const LN_telexNumber: &[u8; 12usize] = b"telexNumber\0";
pub const NID_telexNumber: u32 = 865;
pub const LN_teletexTerminalIdentifier: &[u8; 26usize] = b"teletexTerminalIdentifier\0";
pub const NID_teletexTerminalIdentifier: u32 = 866;
pub const LN_facsimileTelephoneNumber: &[u8; 25usize] = b"facsimileTelephoneNumber\0";
pub const NID_facsimileTelephoneNumber: u32 = 867;
pub const LN_x121Address: &[u8; 12usize] = b"x121Address\0";
pub const NID_x121Address: u32 = 868;
pub const LN_internationaliSDNNumber: &[u8; 24usize] = b"internationaliSDNNumber\0";
pub const NID_internationaliSDNNumber: u32 = 869;
pub const LN_registeredAddress: &[u8; 18usize] = b"registeredAddress\0";
pub const NID_registeredAddress: u32 = 870;
pub const LN_destinationIndicator: &[u8; 21usize] = b"destinationIndicator\0";
pub const NID_destinationIndicator: u32 = 871;
pub const LN_preferredDeliveryMethod: &[u8; 24usize] = b"preferredDeliveryMethod\0";
pub const NID_preferredDeliveryMethod: u32 = 872;
pub const LN_presentationAddress: &[u8; 20usize] = b"presentationAddress\0";
pub const NID_presentationAddress: u32 = 873;
pub const LN_supportedApplicationContext: &[u8; 28usize] = b"supportedApplicationContext\0";
pub const NID_supportedApplicationContext: u32 = 874;
pub const SN_member: &[u8; 7usize] = b"member\0";
pub const NID_member: u32 = 875;
pub const SN_owner: &[u8; 6usize] = b"owner\0";
pub const NID_owner: u32 = 876;
pub const LN_roleOccupant: &[u8; 13usize] = b"roleOccupant\0";
pub const NID_roleOccupant: u32 = 877;
pub const SN_seeAlso: &[u8; 8usize] = b"seeAlso\0";
pub const NID_seeAlso: u32 = 878;
pub const LN_userPassword: &[u8; 13usize] = b"userPassword\0";
pub const NID_userPassword: u32 = 879;
pub const LN_userCertificate: &[u8; 16usize] = b"userCertificate\0";
pub const NID_userCertificate: u32 = 880;
pub const LN_cACertificate: &[u8; 14usize] = b"cACertificate\0";
pub const NID_cACertificate: u32 = 881;
pub const LN_authorityRevocationList: &[u8; 24usize] = b"authorityRevocationList\0";
pub const NID_authorityRevocationList: u32 = 882;
pub const LN_certificateRevocationList: &[u8; 26usize] = b"certificateRevocationList\0";
pub const NID_certificateRevocationList: u32 = 883;
pub const LN_crossCertificatePair: &[u8; 21usize] = b"crossCertificatePair\0";
pub const NID_crossCertificatePair: u32 = 884;
pub const SN_name: &[u8; 5usize] = b"name\0";
pub const LN_name: &[u8; 5usize] = b"name\0";
pub const NID_name: u32 = 173;
pub const SN_givenName: &[u8; 3usize] = b"GN\0";
pub const LN_givenName: &[u8; 10usize] = b"givenName\0";
pub const NID_givenName: u32 = 99;
pub const SN_initials: &[u8; 9usize] = b"initials\0";
pub const LN_initials: &[u8; 9usize] = b"initials\0";
pub const NID_initials: u32 = 101;
pub const LN_generationQualifier: &[u8; 20usize] = b"generationQualifier\0";
pub const NID_generationQualifier: u32 = 509;
pub const LN_x500UniqueIdentifier: &[u8; 21usize] = b"x500UniqueIdentifier\0";
pub const NID_x500UniqueIdentifier: u32 = 503;
pub const SN_dnQualifier: &[u8; 12usize] = b"dnQualifier\0";
pub const LN_dnQualifier: &[u8; 12usize] = b"dnQualifier\0";
pub const NID_dnQualifier: u32 = 174;
pub const LN_enhancedSearchGuide: &[u8; 20usize] = b"enhancedSearchGuide\0";
pub const NID_enhancedSearchGuide: u32 = 885;
pub const LN_protocolInformation: &[u8; 20usize] = b"protocolInformation\0";
pub const NID_protocolInformation: u32 = 886;
pub const LN_distinguishedName: &[u8; 18usize] = b"distinguishedName\0";
pub const NID_distinguishedName: u32 = 887;
pub const LN_uniqueMember: &[u8; 13usize] = b"uniqueMember\0";
pub const NID_uniqueMember: u32 = 888;
pub const LN_houseIdentifier: &[u8; 16usize] = b"houseIdentifier\0";
pub const NID_houseIdentifier: u32 = 889;
pub const LN_supportedAlgorithms: &[u8; 20usize] = b"supportedAlgorithms\0";
pub const NID_supportedAlgorithms: u32 = 890;
pub const LN_deltaRevocationList: &[u8; 20usize] = b"deltaRevocationList\0";
pub const NID_deltaRevocationList: u32 = 891;
pub const SN_dmdName: &[u8; 8usize] = b"dmdName\0";
pub const NID_dmdName: u32 = 892;
pub const LN_pseudonym: &[u8; 10usize] = b"pseudonym\0";
pub const NID_pseudonym: u32 = 510;
pub const SN_role: &[u8; 5usize] = b"role\0";
pub const LN_role: &[u8; 5usize] = b"role\0";
pub const NID_role: u32 = 400;
pub const LN_organizationIdentifier: &[u8; 23usize] = b"organizationIdentifier\0";
pub const NID_organizationIdentifier: u32 = 1089;
pub const SN_countryCode3c: &[u8; 3usize] = b"c3\0";
pub const LN_countryCode3c: &[u8; 14usize] = b"countryCode3c\0";
pub const NID_countryCode3c: u32 = 1090;
pub const SN_countryCode3n: &[u8; 3usize] = b"n3\0";
pub const LN_countryCode3n: &[u8; 14usize] = b"countryCode3n\0";
pub const NID_countryCode3n: u32 = 1091;
pub const LN_dnsName: &[u8; 8usize] = b"dnsName\0";
pub const NID_dnsName: u32 = 1092;
pub const SN_X500algorithms: &[u8; 15usize] = b"X500algorithms\0";
pub const LN_X500algorithms: &[u8; 32usize] = b"directory services - algorithms\0";
pub const NID_X500algorithms: u32 = 378;
pub const SN_rsa: &[u8; 4usize] = b"RSA\0";
pub const LN_rsa: &[u8; 4usize] = b"rsa\0";
pub const NID_rsa: u32 = 19;
pub const SN_mdc2WithRSA: &[u8; 9usize] = b"RSA-MDC2\0";
pub const LN_mdc2WithRSA: &[u8; 12usize] = b"mdc2WithRSA\0";
pub const NID_mdc2WithRSA: u32 = 96;
pub const SN_mdc2: &[u8; 5usize] = b"MDC2\0";
pub const LN_mdc2: &[u8; 5usize] = b"mdc2\0";
pub const NID_mdc2: u32 = 95;
pub const SN_id_ce: &[u8; 6usize] = b"id-ce\0";
pub const NID_id_ce: u32 = 81;
pub const SN_subject_directory_attributes: &[u8; 27usize] = b"subjectDirectoryAttributes\0";
pub const LN_subject_directory_attributes: &[u8; 36usize] =
    b"X509v3 Subject Directory Attributes\0";
pub const NID_subject_directory_attributes: u32 = 769;
pub const SN_subject_key_identifier: &[u8; 21usize] = b"subjectKeyIdentifier\0";
pub const LN_subject_key_identifier: &[u8; 30usize] = b"X509v3 Subject Key Identifier\0";
pub const NID_subject_key_identifier: u32 = 82;
pub const SN_key_usage: &[u8; 9usize] = b"keyUsage\0";
pub const LN_key_usage: &[u8; 17usize] = b"X509v3 Key Usage\0";
pub const NID_key_usage: u32 = 83;
pub const SN_private_key_usage_period: &[u8; 22usize] = b"privateKeyUsagePeriod\0";
pub const LN_private_key_usage_period: &[u8; 32usize] = b"X509v3 Private Key Usage Period\0";
pub const NID_private_key_usage_period: u32 = 84;
pub const SN_subject_alt_name: &[u8; 15usize] = b"subjectAltName\0";
pub const LN_subject_alt_name: &[u8; 32usize] = b"X509v3 Subject Alternative Name\0";
pub const NID_subject_alt_name: u32 = 85;
pub const SN_issuer_alt_name: &[u8; 14usize] = b"issuerAltName\0";
pub const LN_issuer_alt_name: &[u8; 31usize] = b"X509v3 Issuer Alternative Name\0";
pub const NID_issuer_alt_name: u32 = 86;
pub const SN_basic_constraints: &[u8; 17usize] = b"basicConstraints\0";
pub const LN_basic_constraints: &[u8; 25usize] = b"X509v3 Basic Constraints\0";
pub const NID_basic_constraints: u32 = 87;
pub const SN_crl_number: &[u8; 10usize] = b"crlNumber\0";
pub const LN_crl_number: &[u8; 18usize] = b"X509v3 CRL Number\0";
pub const NID_crl_number: u32 = 88;
pub const SN_crl_reason: &[u8; 10usize] = b"CRLReason\0";
pub const LN_crl_reason: &[u8; 23usize] = b"X509v3 CRL Reason Code\0";
pub const NID_crl_reason: u32 = 141;
pub const SN_invalidity_date: &[u8; 15usize] = b"invalidityDate\0";
pub const LN_invalidity_date: &[u8; 16usize] = b"Invalidity Date\0";
pub const NID_invalidity_date: u32 = 142;
pub const SN_delta_crl: &[u8; 9usize] = b"deltaCRL\0";
pub const LN_delta_crl: &[u8; 27usize] = b"X509v3 Delta CRL Indicator\0";
pub const NID_delta_crl: u32 = 140;
pub const SN_issuing_distribution_point: &[u8; 25usize] = b"issuingDistributionPoint\0";
pub const LN_issuing_distribution_point: &[u8; 34usize] = b"X509v3 Issuing Distribution Point\0";
pub const NID_issuing_distribution_point: u32 = 770;
pub const SN_certificate_issuer: &[u8; 18usize] = b"certificateIssuer\0";
pub const LN_certificate_issuer: &[u8; 26usize] = b"X509v3 Certificate Issuer\0";
pub const NID_certificate_issuer: u32 = 771;
pub const SN_name_constraints: &[u8; 16usize] = b"nameConstraints\0";
pub const LN_name_constraints: &[u8; 24usize] = b"X509v3 Name Constraints\0";
pub const NID_name_constraints: u32 = 666;
pub const SN_crl_distribution_points: &[u8; 22usize] = b"crlDistributionPoints\0";
pub const LN_crl_distribution_points: &[u8; 31usize] = b"X509v3 CRL Distribution Points\0";
pub const NID_crl_distribution_points: u32 = 103;
pub const SN_certificate_policies: &[u8; 20usize] = b"certificatePolicies\0";
pub const LN_certificate_policies: &[u8; 28usize] = b"X509v3 Certificate Policies\0";
pub const NID_certificate_policies: u32 = 89;
pub const SN_any_policy: &[u8; 10usize] = b"anyPolicy\0";
pub const LN_any_policy: &[u8; 18usize] = b"X509v3 Any Policy\0";
pub const NID_any_policy: u32 = 746;
pub const SN_policy_mappings: &[u8; 15usize] = b"policyMappings\0";
pub const LN_policy_mappings: &[u8; 23usize] = b"X509v3 Policy Mappings\0";
pub const NID_policy_mappings: u32 = 747;
pub const SN_authority_key_identifier: &[u8; 23usize] = b"authorityKeyIdentifier\0";
pub const LN_authority_key_identifier: &[u8; 32usize] = b"X509v3 Authority Key Identifier\0";
pub const NID_authority_key_identifier: u32 = 90;
pub const SN_policy_constraints: &[u8; 18usize] = b"policyConstraints\0";
pub const LN_policy_constraints: &[u8; 26usize] = b"X509v3 Policy Constraints\0";
pub const NID_policy_constraints: u32 = 401;
pub const SN_ext_key_usage: &[u8; 17usize] = b"extendedKeyUsage\0";
pub const LN_ext_key_usage: &[u8; 26usize] = b"X509v3 Extended Key Usage\0";
pub const NID_ext_key_usage: u32 = 126;
pub const SN_freshest_crl: &[u8; 12usize] = b"freshestCRL\0";
pub const LN_freshest_crl: &[u8; 20usize] = b"X509v3 Freshest CRL\0";
pub const NID_freshest_crl: u32 = 857;
pub const SN_inhibit_any_policy: &[u8; 17usize] = b"inhibitAnyPolicy\0";
pub const LN_inhibit_any_policy: &[u8; 26usize] = b"X509v3 Inhibit Any Policy\0";
pub const NID_inhibit_any_policy: u32 = 748;
pub const SN_target_information: &[u8; 18usize] = b"targetInformation\0";
pub const LN_target_information: &[u8; 20usize] = b"X509v3 AC Targeting\0";
pub const NID_target_information: u32 = 402;
pub const SN_no_rev_avail: &[u8; 11usize] = b"noRevAvail\0";
pub const LN_no_rev_avail: &[u8; 31usize] = b"X509v3 No Revocation Available\0";
pub const NID_no_rev_avail: u32 = 403;
pub const SN_anyExtendedKeyUsage: &[u8; 20usize] = b"anyExtendedKeyUsage\0";
pub const LN_anyExtendedKeyUsage: &[u8; 23usize] = b"Any Extended Key Usage\0";
pub const NID_anyExtendedKeyUsage: u32 = 910;
pub const SN_netscape: &[u8; 9usize] = b"Netscape\0";
pub const LN_netscape: &[u8; 30usize] = b"Netscape Communications Corp.\0";
pub const NID_netscape: u32 = 57;
pub const SN_netscape_cert_extension: &[u8; 10usize] = b"nsCertExt\0";
pub const LN_netscape_cert_extension: &[u8; 31usize] = b"Netscape Certificate Extension\0";
pub const NID_netscape_cert_extension: u32 = 58;
pub const SN_netscape_data_type: &[u8; 11usize] = b"nsDataType\0";
pub const LN_netscape_data_type: &[u8; 19usize] = b"Netscape Data Type\0";
pub const NID_netscape_data_type: u32 = 59;
pub const SN_netscape_cert_type: &[u8; 11usize] = b"nsCertType\0";
pub const LN_netscape_cert_type: &[u8; 19usize] = b"Netscape Cert Type\0";
pub const NID_netscape_cert_type: u32 = 71;
pub const SN_netscape_base_url: &[u8; 10usize] = b"nsBaseUrl\0";
pub const LN_netscape_base_url: &[u8; 18usize] = b"Netscape Base Url\0";
pub const NID_netscape_base_url: u32 = 72;
pub const SN_netscape_revocation_url: &[u8; 16usize] = b"nsRevocationUrl\0";
pub const LN_netscape_revocation_url: &[u8; 24usize] = b"Netscape Revocation Url\0";
pub const NID_netscape_revocation_url: u32 = 73;
pub const SN_netscape_ca_revocation_url: &[u8; 18usize] = b"nsCaRevocationUrl\0";
pub const LN_netscape_ca_revocation_url: &[u8; 27usize] = b"Netscape CA Revocation Url\0";
pub const NID_netscape_ca_revocation_url: u32 = 74;
pub const SN_netscape_renewal_url: &[u8; 13usize] = b"nsRenewalUrl\0";
pub const LN_netscape_renewal_url: &[u8; 21usize] = b"Netscape Renewal Url\0";
pub const NID_netscape_renewal_url: u32 = 75;
pub const SN_netscape_ca_policy_url: &[u8; 14usize] = b"nsCaPolicyUrl\0";
pub const LN_netscape_ca_policy_url: &[u8; 23usize] = b"Netscape CA Policy Url\0";
pub const NID_netscape_ca_policy_url: u32 = 76;
pub const SN_netscape_ssl_server_name: &[u8; 16usize] = b"nsSslServerName\0";
pub const LN_netscape_ssl_server_name: &[u8; 25usize] = b"Netscape SSL Server Name\0";
pub const NID_netscape_ssl_server_name: u32 = 77;
pub const SN_netscape_comment: &[u8; 10usize] = b"nsComment\0";
pub const LN_netscape_comment: &[u8; 17usize] = b"Netscape Comment\0";
pub const NID_netscape_comment: u32 = 78;
pub const SN_netscape_cert_sequence: &[u8; 15usize] = b"nsCertSequence\0";
pub const LN_netscape_cert_sequence: &[u8; 30usize] = b"Netscape Certificate Sequence\0";
pub const NID_netscape_cert_sequence: u32 = 79;
pub const SN_ns_sgc: &[u8; 6usize] = b"nsSGC\0";
pub const LN_ns_sgc: &[u8; 29usize] = b"Netscape Server Gated Crypto\0";
pub const NID_ns_sgc: u32 = 139;
pub const SN_org: &[u8; 4usize] = b"ORG\0";
pub const LN_org: &[u8; 4usize] = b"org\0";
pub const NID_org: u32 = 379;
pub const SN_dod: &[u8; 4usize] = b"DOD\0";
pub const LN_dod: &[u8; 4usize] = b"dod\0";
pub const NID_dod: u32 = 380;
pub const SN_iana: &[u8; 5usize] = b"IANA\0";
pub const LN_iana: &[u8; 5usize] = b"iana\0";
pub const NID_iana: u32 = 381;
pub const SN_Directory: &[u8; 10usize] = b"directory\0";
pub const LN_Directory: &[u8; 10usize] = b"Directory\0";
pub const NID_Directory: u32 = 382;
pub const SN_Management: &[u8; 5usize] = b"mgmt\0";
pub const LN_Management: &[u8; 11usize] = b"Management\0";
pub const NID_Management: u32 = 383;
pub const SN_Experimental: &[u8; 13usize] = b"experimental\0";
pub const LN_Experimental: &[u8; 13usize] = b"Experimental\0";
pub const NID_Experimental: u32 = 384;
pub const SN_Private: &[u8; 8usize] = b"private\0";
pub const LN_Private: &[u8; 8usize] = b"Private\0";
pub const NID_Private: u32 = 385;
pub const SN_Security: &[u8; 9usize] = b"security\0";
pub const LN_Security: &[u8; 9usize] = b"Security\0";
pub const NID_Security: u32 = 386;
pub const SN_SNMPv2: &[u8; 7usize] = b"snmpv2\0";
pub const LN_SNMPv2: &[u8; 7usize] = b"SNMPv2\0";
pub const NID_SNMPv2: u32 = 387;
pub const LN_Mail: &[u8; 5usize] = b"Mail\0";
pub const NID_Mail: u32 = 388;
pub const SN_Enterprises: &[u8; 12usize] = b"enterprises\0";
pub const LN_Enterprises: &[u8; 12usize] = b"Enterprises\0";
pub const NID_Enterprises: u32 = 389;
pub const SN_dcObject: &[u8; 9usize] = b"dcobject\0";
pub const LN_dcObject: &[u8; 9usize] = b"dcObject\0";
pub const NID_dcObject: u32 = 390;
pub const SN_mime_mhs: &[u8; 9usize] = b"mime-mhs\0";
pub const LN_mime_mhs: &[u8; 9usize] = b"MIME MHS\0";
pub const NID_mime_mhs: u32 = 504;
pub const SN_mime_mhs_headings: &[u8; 18usize] = b"mime-mhs-headings\0";
pub const LN_mime_mhs_headings: &[u8; 18usize] = b"mime-mhs-headings\0";
pub const NID_mime_mhs_headings: u32 = 505;
pub const SN_mime_mhs_bodies: &[u8; 16usize] = b"mime-mhs-bodies\0";
pub const LN_mime_mhs_bodies: &[u8; 16usize] = b"mime-mhs-bodies\0";
pub const NID_mime_mhs_bodies: u32 = 506;
pub const SN_id_hex_partial_message: &[u8; 23usize] = b"id-hex-partial-message\0";
pub const LN_id_hex_partial_message: &[u8; 23usize] = b"id-hex-partial-message\0";
pub const NID_id_hex_partial_message: u32 = 507;
pub const SN_id_hex_multipart_message: &[u8; 25usize] = b"id-hex-multipart-message\0";
pub const LN_id_hex_multipart_message: &[u8; 25usize] = b"id-hex-multipart-message\0";
pub const NID_id_hex_multipart_message: u32 = 508;
pub const SN_zlib_compression: &[u8; 5usize] = b"ZLIB\0";
pub const LN_zlib_compression: &[u8; 17usize] = b"zlib compression\0";
pub const NID_zlib_compression: u32 = 125;
pub const SN_aes_128_ecb: &[u8; 12usize] = b"AES-128-ECB\0";
pub const LN_aes_128_ecb: &[u8; 12usize] = b"aes-128-ecb\0";
pub const NID_aes_128_ecb: u32 = 418;
pub const SN_aes_128_cbc: &[u8; 12usize] = b"AES-128-CBC\0";
pub const LN_aes_128_cbc: &[u8; 12usize] = b"aes-128-cbc\0";
pub const NID_aes_128_cbc: u32 = 419;
pub const SN_aes_128_ofb128: &[u8; 12usize] = b"AES-128-OFB\0";
pub const LN_aes_128_ofb128: &[u8; 12usize] = b"aes-128-ofb\0";
pub const NID_aes_128_ofb128: u32 = 420;
pub const SN_aes_128_cfb128: &[u8; 12usize] = b"AES-128-CFB\0";
pub const LN_aes_128_cfb128: &[u8; 12usize] = b"aes-128-cfb\0";
pub const NID_aes_128_cfb128: u32 = 421;
pub const SN_id_aes128_wrap: &[u8; 15usize] = b"id-aes128-wrap\0";
pub const NID_id_aes128_wrap: u32 = 788;
pub const SN_aes_128_gcm: &[u8; 14usize] = b"id-aes128-GCM\0";
pub const LN_aes_128_gcm: &[u8; 12usize] = b"aes-128-gcm\0";
pub const NID_aes_128_gcm: u32 = 895;
pub const SN_aes_128_ccm: &[u8; 14usize] = b"id-aes128-CCM\0";
pub const LN_aes_128_ccm: &[u8; 12usize] = b"aes-128-ccm\0";
pub const NID_aes_128_ccm: u32 = 896;
pub const SN_id_aes128_wrap_pad: &[u8; 19usize] = b"id-aes128-wrap-pad\0";
pub const NID_id_aes128_wrap_pad: u32 = 897;
pub const SN_aes_192_ecb: &[u8; 12usize] = b"AES-192-ECB\0";
pub const LN_aes_192_ecb: &[u8; 12usize] = b"aes-192-ecb\0";
pub const NID_aes_192_ecb: u32 = 422;
pub const SN_aes_192_cbc: &[u8; 12usize] = b"AES-192-CBC\0";
pub const LN_aes_192_cbc: &[u8; 12usize] = b"aes-192-cbc\0";
pub const NID_aes_192_cbc: u32 = 423;
pub const SN_aes_192_ofb128: &[u8; 12usize] = b"AES-192-OFB\0";
pub const LN_aes_192_ofb128: &[u8; 12usize] = b"aes-192-ofb\0";
pub const NID_aes_192_ofb128: u32 = 424;
pub const SN_aes_192_cfb128: &[u8; 12usize] = b"AES-192-CFB\0";
pub const LN_aes_192_cfb128: &[u8; 12usize] = b"aes-192-cfb\0";
pub const NID_aes_192_cfb128: u32 = 425;
pub const SN_id_aes192_wrap: &[u8; 15usize] = b"id-aes192-wrap\0";
pub const NID_id_aes192_wrap: u32 = 789;
pub const SN_aes_192_gcm: &[u8; 14usize] = b"id-aes192-GCM\0";
pub const LN_aes_192_gcm: &[u8; 12usize] = b"aes-192-gcm\0";
pub const NID_aes_192_gcm: u32 = 898;
pub const SN_aes_192_ccm: &[u8; 14usize] = b"id-aes192-CCM\0";
pub const LN_aes_192_ccm: &[u8; 12usize] = b"aes-192-ccm\0";
pub const NID_aes_192_ccm: u32 = 899;
pub const SN_id_aes192_wrap_pad: &[u8; 19usize] = b"id-aes192-wrap-pad\0";
pub const NID_id_aes192_wrap_pad: u32 = 900;
pub const SN_aes_256_ecb: &[u8; 12usize] = b"AES-256-ECB\0";
pub const LN_aes_256_ecb: &[u8; 12usize] = b"aes-256-ecb\0";
pub const NID_aes_256_ecb: u32 = 426;
pub const SN_aes_256_cbc: &[u8; 12usize] = b"AES-256-CBC\0";
pub const LN_aes_256_cbc: &[u8; 12usize] = b"aes-256-cbc\0";
pub const NID_aes_256_cbc: u32 = 427;
pub const SN_aes_256_ofb128: &[u8; 12usize] = b"AES-256-OFB\0";
pub const LN_aes_256_ofb128: &[u8; 12usize] = b"aes-256-ofb\0";
pub const NID_aes_256_ofb128: u32 = 428;
pub const SN_aes_256_cfb128: &[u8; 12usize] = b"AES-256-CFB\0";
pub const LN_aes_256_cfb128: &[u8; 12usize] = b"aes-256-cfb\0";
pub const NID_aes_256_cfb128: u32 = 429;
pub const SN_id_aes256_wrap: &[u8; 15usize] = b"id-aes256-wrap\0";
pub const NID_id_aes256_wrap: u32 = 790;
pub const SN_aes_256_gcm: &[u8; 14usize] = b"id-aes256-GCM\0";
pub const LN_aes_256_gcm: &[u8; 12usize] = b"aes-256-gcm\0";
pub const NID_aes_256_gcm: u32 = 901;
pub const SN_aes_256_ccm: &[u8; 14usize] = b"id-aes256-CCM\0";
pub const LN_aes_256_ccm: &[u8; 12usize] = b"aes-256-ccm\0";
pub const NID_aes_256_ccm: u32 = 902;
pub const SN_id_aes256_wrap_pad: &[u8; 19usize] = b"id-aes256-wrap-pad\0";
pub const NID_id_aes256_wrap_pad: u32 = 903;
pub const SN_aes_128_xts: &[u8; 12usize] = b"AES-128-XTS\0";
pub const LN_aes_128_xts: &[u8; 12usize] = b"aes-128-xts\0";
pub const NID_aes_128_xts: u32 = 913;
pub const SN_aes_256_xts: &[u8; 12usize] = b"AES-256-XTS\0";
pub const LN_aes_256_xts: &[u8; 12usize] = b"aes-256-xts\0";
pub const NID_aes_256_xts: u32 = 914;
pub const SN_aes_128_cfb1: &[u8; 13usize] = b"AES-128-CFB1\0";
pub const LN_aes_128_cfb1: &[u8; 13usize] = b"aes-128-cfb1\0";
pub const NID_aes_128_cfb1: u32 = 650;
pub const SN_aes_192_cfb1: &[u8; 13usize] = b"AES-192-CFB1\0";
pub const LN_aes_192_cfb1: &[u8; 13usize] = b"aes-192-cfb1\0";
pub const NID_aes_192_cfb1: u32 = 651;
pub const SN_aes_256_cfb1: &[u8; 13usize] = b"AES-256-CFB1\0";
pub const LN_aes_256_cfb1: &[u8; 13usize] = b"aes-256-cfb1\0";
pub const NID_aes_256_cfb1: u32 = 652;
pub const SN_aes_128_cfb8: &[u8; 13usize] = b"AES-128-CFB8\0";
pub const LN_aes_128_cfb8: &[u8; 13usize] = b"aes-128-cfb8\0";
pub const NID_aes_128_cfb8: u32 = 653;
pub const SN_aes_192_cfb8: &[u8; 13usize] = b"AES-192-CFB8\0";
pub const LN_aes_192_cfb8: &[u8; 13usize] = b"aes-192-cfb8\0";
pub const NID_aes_192_cfb8: u32 = 654;
pub const SN_aes_256_cfb8: &[u8; 13usize] = b"AES-256-CFB8\0";
pub const LN_aes_256_cfb8: &[u8; 13usize] = b"aes-256-cfb8\0";
pub const NID_aes_256_cfb8: u32 = 655;
pub const SN_aes_128_ctr: &[u8; 12usize] = b"AES-128-CTR\0";
pub const LN_aes_128_ctr: &[u8; 12usize] = b"aes-128-ctr\0";
pub const NID_aes_128_ctr: u32 = 904;
pub const SN_aes_192_ctr: &[u8; 12usize] = b"AES-192-CTR\0";
pub const LN_aes_192_ctr: &[u8; 12usize] = b"aes-192-ctr\0";
pub const NID_aes_192_ctr: u32 = 905;
pub const SN_aes_256_ctr: &[u8; 12usize] = b"AES-256-CTR\0";
pub const LN_aes_256_ctr: &[u8; 12usize] = b"aes-256-ctr\0";
pub const NID_aes_256_ctr: u32 = 906;
pub const SN_aes_128_ocb: &[u8; 12usize] = b"AES-128-OCB\0";
pub const LN_aes_128_ocb: &[u8; 12usize] = b"aes-128-ocb\0";
pub const NID_aes_128_ocb: u32 = 958;
pub const SN_aes_192_ocb: &[u8; 12usize] = b"AES-192-OCB\0";
pub const LN_aes_192_ocb: &[u8; 12usize] = b"aes-192-ocb\0";
pub const NID_aes_192_ocb: u32 = 959;
pub const SN_aes_256_ocb: &[u8; 12usize] = b"AES-256-OCB\0";
pub const LN_aes_256_ocb: &[u8; 12usize] = b"aes-256-ocb\0";
pub const NID_aes_256_ocb: u32 = 960;
pub const SN_des_cfb1: &[u8; 9usize] = b"DES-CFB1\0";
pub const LN_des_cfb1: &[u8; 9usize] = b"des-cfb1\0";
pub const NID_des_cfb1: u32 = 656;
pub const SN_des_cfb8: &[u8; 9usize] = b"DES-CFB8\0";
pub const LN_des_cfb8: &[u8; 9usize] = b"des-cfb8\0";
pub const NID_des_cfb8: u32 = 657;
pub const SN_des_ede3_cfb1: &[u8; 14usize] = b"DES-EDE3-CFB1\0";
pub const LN_des_ede3_cfb1: &[u8; 14usize] = b"des-ede3-cfb1\0";
pub const NID_des_ede3_cfb1: u32 = 658;
pub const SN_des_ede3_cfb8: &[u8; 14usize] = b"DES-EDE3-CFB8\0";
pub const LN_des_ede3_cfb8: &[u8; 14usize] = b"des-ede3-cfb8\0";
pub const NID_des_ede3_cfb8: u32 = 659;
pub const SN_sha256: &[u8; 7usize] = b"SHA256\0";
pub const LN_sha256: &[u8; 7usize] = b"sha256\0";
pub const NID_sha256: u32 = 672;
pub const SN_sha384: &[u8; 7usize] = b"SHA384\0";
pub const LN_sha384: &[u8; 7usize] = b"sha384\0";
pub const NID_sha384: u32 = 673;
pub const SN_sha512: &[u8; 7usize] = b"SHA512\0";
pub const LN_sha512: &[u8; 7usize] = b"sha512\0";
pub const NID_sha512: u32 = 674;
pub const SN_sha224: &[u8; 7usize] = b"SHA224\0";
pub const LN_sha224: &[u8; 7usize] = b"sha224\0";
pub const NID_sha224: u32 = 675;
pub const SN_sha512_224: &[u8; 11usize] = b"SHA512-224\0";
pub const LN_sha512_224: &[u8; 11usize] = b"sha512-224\0";
pub const NID_sha512_224: u32 = 1094;
pub const SN_sha512_256: &[u8; 11usize] = b"SHA512-256\0";
pub const LN_sha512_256: &[u8; 11usize] = b"sha512-256\0";
pub const NID_sha512_256: u32 = 1095;
pub const SN_sha3_224: &[u8; 9usize] = b"SHA3-224\0";
pub const LN_sha3_224: &[u8; 9usize] = b"sha3-224\0";
pub const NID_sha3_224: u32 = 1096;
pub const SN_sha3_256: &[u8; 9usize] = b"SHA3-256\0";
pub const LN_sha3_256: &[u8; 9usize] = b"sha3-256\0";
pub const NID_sha3_256: u32 = 1097;
pub const SN_sha3_384: &[u8; 9usize] = b"SHA3-384\0";
pub const LN_sha3_384: &[u8; 9usize] = b"sha3-384\0";
pub const NID_sha3_384: u32 = 1098;
pub const SN_sha3_512: &[u8; 9usize] = b"SHA3-512\0";
pub const LN_sha3_512: &[u8; 9usize] = b"sha3-512\0";
pub const NID_sha3_512: u32 = 1099;
pub const SN_shake128: &[u8; 9usize] = b"SHAKE128\0";
pub const LN_shake128: &[u8; 9usize] = b"shake128\0";
pub const NID_shake128: u32 = 1100;
pub const SN_shake256: &[u8; 9usize] = b"SHAKE256\0";
pub const LN_shake256: &[u8; 9usize] = b"shake256\0";
pub const NID_shake256: u32 = 1101;
pub const SN_hmac_sha3_224: &[u8; 20usize] = b"id-hmacWithSHA3-224\0";
pub const LN_hmac_sha3_224: &[u8; 14usize] = b"hmac-sha3-224\0";
pub const NID_hmac_sha3_224: u32 = 1102;
pub const SN_hmac_sha3_256: &[u8; 20usize] = b"id-hmacWithSHA3-256\0";
pub const LN_hmac_sha3_256: &[u8; 14usize] = b"hmac-sha3-256\0";
pub const NID_hmac_sha3_256: u32 = 1103;
pub const SN_hmac_sha3_384: &[u8; 20usize] = b"id-hmacWithSHA3-384\0";
pub const LN_hmac_sha3_384: &[u8; 14usize] = b"hmac-sha3-384\0";
pub const NID_hmac_sha3_384: u32 = 1104;
pub const SN_hmac_sha3_512: &[u8; 20usize] = b"id-hmacWithSHA3-512\0";
pub const LN_hmac_sha3_512: &[u8; 14usize] = b"hmac-sha3-512\0";
pub const NID_hmac_sha3_512: u32 = 1105;
pub const SN_dsa_with_SHA224: &[u8; 16usize] = b"dsa_with_SHA224\0";
pub const NID_dsa_with_SHA224: u32 = 802;
pub const SN_dsa_with_SHA256: &[u8; 16usize] = b"dsa_with_SHA256\0";
pub const NID_dsa_with_SHA256: u32 = 803;
pub const SN_dsa_with_SHA384: &[u8; 19usize] = b"id-dsa-with-sha384\0";
pub const LN_dsa_with_SHA384: &[u8; 16usize] = b"dsa_with_SHA384\0";
pub const NID_dsa_with_SHA384: u32 = 1106;
pub const SN_dsa_with_SHA512: &[u8; 19usize] = b"id-dsa-with-sha512\0";
pub const LN_dsa_with_SHA512: &[u8; 16usize] = b"dsa_with_SHA512\0";
pub const NID_dsa_with_SHA512: u32 = 1107;
pub const SN_dsa_with_SHA3_224: &[u8; 21usize] = b"id-dsa-with-sha3-224\0";
pub const LN_dsa_with_SHA3_224: &[u8; 18usize] = b"dsa_with_SHA3-224\0";
pub const NID_dsa_with_SHA3_224: u32 = 1108;
pub const SN_dsa_with_SHA3_256: &[u8; 21usize] = b"id-dsa-with-sha3-256\0";
pub const LN_dsa_with_SHA3_256: &[u8; 18usize] = b"dsa_with_SHA3-256\0";
pub const NID_dsa_with_SHA3_256: u32 = 1109;
pub const SN_dsa_with_SHA3_384: &[u8; 21usize] = b"id-dsa-with-sha3-384\0";
pub const LN_dsa_with_SHA3_384: &[u8; 18usize] = b"dsa_with_SHA3-384\0";
pub const NID_dsa_with_SHA3_384: u32 = 1110;
pub const SN_dsa_with_SHA3_512: &[u8; 21usize] = b"id-dsa-with-sha3-512\0";
pub const LN_dsa_with_SHA3_512: &[u8; 18usize] = b"dsa_with_SHA3-512\0";
pub const NID_dsa_with_SHA3_512: u32 = 1111;
pub const SN_ecdsa_with_SHA3_224: &[u8; 23usize] = b"id-ecdsa-with-sha3-224\0";
pub const LN_ecdsa_with_SHA3_224: &[u8; 20usize] = b"ecdsa_with_SHA3-224\0";
pub const NID_ecdsa_with_SHA3_224: u32 = 1112;
pub const SN_ecdsa_with_SHA3_256: &[u8; 23usize] = b"id-ecdsa-with-sha3-256\0";
pub const LN_ecdsa_with_SHA3_256: &[u8; 20usize] = b"ecdsa_with_SHA3-256\0";
pub const NID_ecdsa_with_SHA3_256: u32 = 1113;
pub const SN_ecdsa_with_SHA3_384: &[u8; 23usize] = b"id-ecdsa-with-sha3-384\0";
pub const LN_ecdsa_with_SHA3_384: &[u8; 20usize] = b"ecdsa_with_SHA3-384\0";
pub const NID_ecdsa_with_SHA3_384: u32 = 1114;
pub const SN_ecdsa_with_SHA3_512: &[u8; 23usize] = b"id-ecdsa-with-sha3-512\0";
pub const LN_ecdsa_with_SHA3_512: &[u8; 20usize] = b"ecdsa_with_SHA3-512\0";
pub const NID_ecdsa_with_SHA3_512: u32 = 1115;
pub const SN_RSA_SHA3_224: &[u8; 35usize] = b"id-rsassa-pkcs1-v1_5-with-sha3-224\0";
pub const LN_RSA_SHA3_224: &[u8; 13usize] = b"RSA-SHA3-224\0";
pub const NID_RSA_SHA3_224: u32 = 1116;
pub const SN_RSA_SHA3_256: &[u8; 35usize] = b"id-rsassa-pkcs1-v1_5-with-sha3-256\0";
pub const LN_RSA_SHA3_256: &[u8; 13usize] = b"RSA-SHA3-256\0";
pub const NID_RSA_SHA3_256: u32 = 1117;
pub const SN_RSA_SHA3_384: &[u8; 35usize] = b"id-rsassa-pkcs1-v1_5-with-sha3-384\0";
pub const LN_RSA_SHA3_384: &[u8; 13usize] = b"RSA-SHA3-384\0";
pub const NID_RSA_SHA3_384: u32 = 1118;
pub const SN_RSA_SHA3_512: &[u8; 35usize] = b"id-rsassa-pkcs1-v1_5-with-sha3-512\0";
pub const LN_RSA_SHA3_512: &[u8; 13usize] = b"RSA-SHA3-512\0";
pub const NID_RSA_SHA3_512: u32 = 1119;
pub const SN_hold_instruction_code: &[u8; 20usize] = b"holdInstructionCode\0";
pub const LN_hold_instruction_code: &[u8; 22usize] = b"Hold Instruction Code\0";
pub const NID_hold_instruction_code: u32 = 430;
pub const SN_hold_instruction_none: &[u8; 20usize] = b"holdInstructionNone\0";
pub const LN_hold_instruction_none: &[u8; 22usize] = b"Hold Instruction None\0";
pub const NID_hold_instruction_none: u32 = 431;
pub const SN_hold_instruction_call_issuer: &[u8; 26usize] = b"holdInstructionCallIssuer\0";
pub const LN_hold_instruction_call_issuer: &[u8; 29usize] = b"Hold Instruction Call Issuer\0";
pub const NID_hold_instruction_call_issuer: u32 = 432;
pub const SN_hold_instruction_reject: &[u8; 22usize] = b"holdInstructionReject\0";
pub const LN_hold_instruction_reject: &[u8; 24usize] = b"Hold Instruction Reject\0";
pub const NID_hold_instruction_reject: u32 = 433;
pub const SN_data: &[u8; 5usize] = b"data\0";
pub const NID_data: u32 = 434;
pub const SN_pss: &[u8; 4usize] = b"pss\0";
pub const NID_pss: u32 = 435;
pub const SN_ucl: &[u8; 4usize] = b"ucl\0";
pub const NID_ucl: u32 = 436;
pub const SN_pilot: &[u8; 6usize] = b"pilot\0";
pub const NID_pilot: u32 = 437;
pub const LN_pilotAttributeType: &[u8; 19usize] = b"pilotAttributeType\0";
pub const NID_pilotAttributeType: u32 = 438;
pub const LN_pilotAttributeSyntax: &[u8; 21usize] = b"pilotAttributeSyntax\0";
pub const NID_pilotAttributeSyntax: u32 = 439;
pub const LN_pilotObjectClass: &[u8; 17usize] = b"pilotObjectClass\0";
pub const NID_pilotObjectClass: u32 = 440;
pub const LN_pilotGroups: &[u8; 12usize] = b"pilotGroups\0";
pub const NID_pilotGroups: u32 = 441;
pub const LN_iA5StringSyntax: &[u8; 16usize] = b"iA5StringSyntax\0";
pub const NID_iA5StringSyntax: u32 = 442;
pub const LN_caseIgnoreIA5StringSyntax: &[u8; 26usize] = b"caseIgnoreIA5StringSyntax\0";
pub const NID_caseIgnoreIA5StringSyntax: u32 = 443;
pub const LN_pilotObject: &[u8; 12usize] = b"pilotObject\0";
pub const NID_pilotObject: u32 = 444;
pub const LN_pilotPerson: &[u8; 12usize] = b"pilotPerson\0";
pub const NID_pilotPerson: u32 = 445;
pub const SN_account: &[u8; 8usize] = b"account\0";
pub const NID_account: u32 = 446;
pub const SN_document: &[u8; 9usize] = b"document\0";
pub const NID_document: u32 = 447;
pub const SN_room: &[u8; 5usize] = b"room\0";
pub const NID_room: u32 = 448;
pub const LN_documentSeries: &[u8; 15usize] = b"documentSeries\0";
pub const NID_documentSeries: u32 = 449;
pub const SN_Domain: &[u8; 7usize] = b"domain\0";
pub const LN_Domain: &[u8; 7usize] = b"Domain\0";
pub const NID_Domain: u32 = 392;
pub const LN_rFC822localPart: &[u8; 16usize] = b"rFC822localPart\0";
pub const NID_rFC822localPart: u32 = 450;
pub const LN_dNSDomain: &[u8; 10usize] = b"dNSDomain\0";
pub const NID_dNSDomain: u32 = 451;
pub const LN_domainRelatedObject: &[u8; 20usize] = b"domainRelatedObject\0";
pub const NID_domainRelatedObject: u32 = 452;
pub const LN_friendlyCountry: &[u8; 16usize] = b"friendlyCountry\0";
pub const NID_friendlyCountry: u32 = 453;
pub const LN_simpleSecurityObject: &[u8; 21usize] = b"simpleSecurityObject\0";
pub const NID_simpleSecurityObject: u32 = 454;
pub const LN_pilotOrganization: &[u8; 18usize] = b"pilotOrganization\0";
pub const NID_pilotOrganization: u32 = 455;
pub const LN_pilotDSA: &[u8; 9usize] = b"pilotDSA\0";
pub const NID_pilotDSA: u32 = 456;
pub const LN_qualityLabelledData: &[u8; 20usize] = b"qualityLabelledData\0";
pub const NID_qualityLabelledData: u32 = 457;
pub const SN_userId: &[u8; 4usize] = b"UID\0";
pub const LN_userId: &[u8; 7usize] = b"userId\0";
pub const NID_userId: u32 = 458;
pub const LN_textEncodedORAddress: &[u8; 21usize] = b"textEncodedORAddress\0";
pub const NID_textEncodedORAddress: u32 = 459;
pub const SN_rfc822Mailbox: &[u8; 5usize] = b"mail\0";
pub const LN_rfc822Mailbox: &[u8; 14usize] = b"rfc822Mailbox\0";
pub const NID_rfc822Mailbox: u32 = 460;
pub const SN_info: &[u8; 5usize] = b"info\0";
pub const NID_info: u32 = 461;
pub const LN_favouriteDrink: &[u8; 15usize] = b"favouriteDrink\0";
pub const NID_favouriteDrink: u32 = 462;
pub const LN_roomNumber: &[u8; 11usize] = b"roomNumber\0";
pub const NID_roomNumber: u32 = 463;
pub const SN_photo: &[u8; 6usize] = b"photo\0";
pub const NID_photo: u32 = 464;
pub const LN_userClass: &[u8; 10usize] = b"userClass\0";
pub const NID_userClass: u32 = 465;
pub const SN_host: &[u8; 5usize] = b"host\0";
pub const NID_host: u32 = 466;
pub const SN_manager: &[u8; 8usize] = b"manager\0";
pub const NID_manager: u32 = 467;
pub const LN_documentIdentifier: &[u8; 19usize] = b"documentIdentifier\0";
pub const NID_documentIdentifier: u32 = 468;
pub const LN_documentTitle: &[u8; 14usize] = b"documentTitle\0";
pub const NID_documentTitle: u32 = 469;
pub const LN_documentVersion: &[u8; 16usize] = b"documentVersion\0";
pub const NID_documentVersion: u32 = 470;
pub const LN_documentAuthor: &[u8; 15usize] = b"documentAuthor\0";
pub const NID_documentAuthor: u32 = 471;
pub const LN_documentLocation: &[u8; 17usize] = b"documentLocation\0";
pub const NID_documentLocation: u32 = 472;
pub const LN_homeTelephoneNumber: &[u8; 20usize] = b"homeTelephoneNumber\0";
pub const NID_homeTelephoneNumber: u32 = 473;
pub const SN_secretary: &[u8; 10usize] = b"secretary\0";
pub const NID_secretary: u32 = 474;
pub const LN_otherMailbox: &[u8; 13usize] = b"otherMailbox\0";
pub const NID_otherMailbox: u32 = 475;
pub const LN_lastModifiedTime: &[u8; 17usize] = b"lastModifiedTime\0";
pub const NID_lastModifiedTime: u32 = 476;
pub const LN_lastModifiedBy: &[u8; 15usize] = b"lastModifiedBy\0";
pub const NID_lastModifiedBy: u32 = 477;
pub const SN_domainComponent: &[u8; 3usize] = b"DC\0";
pub const LN_domainComponent: &[u8; 16usize] = b"domainComponent\0";
pub const NID_domainComponent: u32 = 391;
pub const LN_aRecord: &[u8; 8usize] = b"aRecord\0";
pub const NID_aRecord: u32 = 478;
pub const LN_pilotAttributeType27: &[u8; 21usize] = b"pilotAttributeType27\0";
pub const NID_pilotAttributeType27: u32 = 479;
pub const LN_mXRecord: &[u8; 9usize] = b"mXRecord\0";
pub const NID_mXRecord: u32 = 480;
pub const LN_nSRecord: &[u8; 9usize] = b"nSRecord\0";
pub const NID_nSRecord: u32 = 481;
pub const LN_sOARecord: &[u8; 10usize] = b"sOARecord\0";
pub const NID_sOARecord: u32 = 482;
pub const LN_cNAMERecord: &[u8; 12usize] = b"cNAMERecord\0";
pub const NID_cNAMERecord: u32 = 483;
pub const LN_associatedDomain: &[u8; 17usize] = b"associatedDomain\0";
pub const NID_associatedDomain: u32 = 484;
pub const LN_associatedName: &[u8; 15usize] = b"associatedName\0";
pub const NID_associatedName: u32 = 485;
pub const LN_homePostalAddress: &[u8; 18usize] = b"homePostalAddress\0";
pub const NID_homePostalAddress: u32 = 486;
pub const LN_personalTitle: &[u8; 14usize] = b"personalTitle\0";
pub const NID_personalTitle: u32 = 487;
pub const LN_mobileTelephoneNumber: &[u8; 22usize] = b"mobileTelephoneNumber\0";
pub const NID_mobileTelephoneNumber: u32 = 488;
pub const LN_pagerTelephoneNumber: &[u8; 21usize] = b"pagerTelephoneNumber\0";
pub const NID_pagerTelephoneNumber: u32 = 489;
pub const LN_friendlyCountryName: &[u8; 20usize] = b"friendlyCountryName\0";
pub const NID_friendlyCountryName: u32 = 490;
pub const SN_uniqueIdentifier: &[u8; 4usize] = b"uid\0";
pub const LN_uniqueIdentifier: &[u8; 17usize] = b"uniqueIdentifier\0";
pub const NID_uniqueIdentifier: u32 = 102;
pub const LN_organizationalStatus: &[u8; 21usize] = b"organizationalStatus\0";
pub const NID_organizationalStatus: u32 = 491;
pub const LN_janetMailbox: &[u8; 13usize] = b"janetMailbox\0";
pub const NID_janetMailbox: u32 = 492;
pub const LN_mailPreferenceOption: &[u8; 21usize] = b"mailPreferenceOption\0";
pub const NID_mailPreferenceOption: u32 = 493;
pub const LN_buildingName: &[u8; 13usize] = b"buildingName\0";
pub const NID_buildingName: u32 = 494;
pub const LN_dSAQuality: &[u8; 11usize] = b"dSAQuality\0";
pub const NID_dSAQuality: u32 = 495;
pub const LN_singleLevelQuality: &[u8; 19usize] = b"singleLevelQuality\0";
pub const NID_singleLevelQuality: u32 = 496;
pub const LN_subtreeMinimumQuality: &[u8; 22usize] = b"subtreeMinimumQuality\0";
pub const NID_subtreeMinimumQuality: u32 = 497;
pub const LN_subtreeMaximumQuality: &[u8; 22usize] = b"subtreeMaximumQuality\0";
pub const NID_subtreeMaximumQuality: u32 = 498;
pub const LN_personalSignature: &[u8; 18usize] = b"personalSignature\0";
pub const NID_personalSignature: u32 = 499;
pub const LN_dITRedirect: &[u8; 12usize] = b"dITRedirect\0";
pub const NID_dITRedirect: u32 = 500;
pub const SN_audio: &[u8; 6usize] = b"audio\0";
pub const NID_audio: u32 = 501;
pub const LN_documentPublisher: &[u8; 18usize] = b"documentPublisher\0";
pub const NID_documentPublisher: u32 = 502;
pub const SN_id_set: &[u8; 7usize] = b"id-set\0";
pub const LN_id_set: &[u8; 31usize] = b"Secure Electronic Transactions\0";
pub const NID_id_set: u32 = 512;
pub const SN_set_ctype: &[u8; 10usize] = b"set-ctype\0";
pub const LN_set_ctype: &[u8; 14usize] = b"content types\0";
pub const NID_set_ctype: u32 = 513;
pub const SN_set_msgExt: &[u8; 11usize] = b"set-msgExt\0";
pub const LN_set_msgExt: &[u8; 19usize] = b"message extensions\0";
pub const NID_set_msgExt: u32 = 514;
pub const SN_set_attr: &[u8; 9usize] = b"set-attr\0";
pub const NID_set_attr: u32 = 515;
pub const SN_set_policy: &[u8; 11usize] = b"set-policy\0";
pub const NID_set_policy: u32 = 516;
pub const SN_set_certExt: &[u8; 12usize] = b"set-certExt\0";
pub const LN_set_certExt: &[u8; 23usize] = b"certificate extensions\0";
pub const NID_set_certExt: u32 = 517;
pub const SN_set_brand: &[u8; 10usize] = b"set-brand\0";
pub const NID_set_brand: u32 = 518;
pub const SN_setct_PANData: &[u8; 14usize] = b"setct-PANData\0";
pub const NID_setct_PANData: u32 = 519;
pub const SN_setct_PANToken: &[u8; 15usize] = b"setct-PANToken\0";
pub const NID_setct_PANToken: u32 = 520;
pub const SN_setct_PANOnly: &[u8; 14usize] = b"setct-PANOnly\0";
pub const NID_setct_PANOnly: u32 = 521;
pub const SN_setct_OIData: &[u8; 13usize] = b"setct-OIData\0";
pub const NID_setct_OIData: u32 = 522;
pub const SN_setct_PI: &[u8; 9usize] = b"setct-PI\0";
pub const NID_setct_PI: u32 = 523;
pub const SN_setct_PIData: &[u8; 13usize] = b"setct-PIData\0";
pub const NID_setct_PIData: u32 = 524;
pub const SN_setct_PIDataUnsigned: &[u8; 21usize] = b"setct-PIDataUnsigned\0";
pub const NID_setct_PIDataUnsigned: u32 = 525;
pub const SN_setct_HODInput: &[u8; 15usize] = b"setct-HODInput\0";
pub const NID_setct_HODInput: u32 = 526;
pub const SN_setct_AuthResBaggage: &[u8; 21usize] = b"setct-AuthResBaggage\0";
pub const NID_setct_AuthResBaggage: u32 = 527;
pub const SN_setct_AuthRevReqBaggage: &[u8; 24usize] = b"setct-AuthRevReqBaggage\0";
pub const NID_setct_AuthRevReqBaggage: u32 = 528;
pub const SN_setct_AuthRevResBaggage: &[u8; 24usize] = b"setct-AuthRevResBaggage\0";
pub const NID_setct_AuthRevResBaggage: u32 = 529;
pub const SN_setct_CapTokenSeq: &[u8; 18usize] = b"setct-CapTokenSeq\0";
pub const NID_setct_CapTokenSeq: u32 = 530;
pub const SN_setct_PInitResData: &[u8; 19usize] = b"setct-PInitResData\0";
pub const NID_setct_PInitResData: u32 = 531;
pub const SN_setct_PI_TBS: &[u8; 13usize] = b"setct-PI-TBS\0";
pub const NID_setct_PI_TBS: u32 = 532;
pub const SN_setct_PResData: &[u8; 15usize] = b"setct-PResData\0";
pub const NID_setct_PResData: u32 = 533;
pub const SN_setct_AuthReqTBS: &[u8; 17usize] = b"setct-AuthReqTBS\0";
pub const NID_setct_AuthReqTBS: u32 = 534;
pub const SN_setct_AuthResTBS: &[u8; 17usize] = b"setct-AuthResTBS\0";
pub const NID_setct_AuthResTBS: u32 = 535;
pub const SN_setct_AuthResTBSX: &[u8; 18usize] = b"setct-AuthResTBSX\0";
pub const NID_setct_AuthResTBSX: u32 = 536;
pub const SN_setct_AuthTokenTBS: &[u8; 19usize] = b"setct-AuthTokenTBS\0";
pub const NID_setct_AuthTokenTBS: u32 = 537;
pub const SN_setct_CapTokenData: &[u8; 19usize] = b"setct-CapTokenData\0";
pub const NID_setct_CapTokenData: u32 = 538;
pub const SN_setct_CapTokenTBS: &[u8; 18usize] = b"setct-CapTokenTBS\0";
pub const NID_setct_CapTokenTBS: u32 = 539;
pub const SN_setct_AcqCardCodeMsg: &[u8; 21usize] = b"setct-AcqCardCodeMsg\0";
pub const NID_setct_AcqCardCodeMsg: u32 = 540;
pub const SN_setct_AuthRevReqTBS: &[u8; 20usize] = b"setct-AuthRevReqTBS\0";
pub const NID_setct_AuthRevReqTBS: u32 = 541;
pub const SN_setct_AuthRevResData: &[u8; 21usize] = b"setct-AuthRevResData\0";
pub const NID_setct_AuthRevResData: u32 = 542;
pub const SN_setct_AuthRevResTBS: &[u8; 20usize] = b"setct-AuthRevResTBS\0";
pub const NID_setct_AuthRevResTBS: u32 = 543;
pub const SN_setct_CapReqTBS: &[u8; 16usize] = b"setct-CapReqTBS\0";
pub const NID_setct_CapReqTBS: u32 = 544;
pub const SN_setct_CapReqTBSX: &[u8; 17usize] = b"setct-CapReqTBSX\0";
pub const NID_setct_CapReqTBSX: u32 = 545;
pub const SN_setct_CapResData: &[u8; 17usize] = b"setct-CapResData\0";
pub const NID_setct_CapResData: u32 = 546;
pub const SN_setct_CapRevReqTBS: &[u8; 19usize] = b"setct-CapRevReqTBS\0";
pub const NID_setct_CapRevReqTBS: u32 = 547;
pub const SN_setct_CapRevReqTBSX: &[u8; 20usize] = b"setct-CapRevReqTBSX\0";
pub const NID_setct_CapRevReqTBSX: u32 = 548;
pub const SN_setct_CapRevResData: &[u8; 20usize] = b"setct-CapRevResData\0";
pub const NID_setct_CapRevResData: u32 = 549;
pub const SN_setct_CredReqTBS: &[u8; 17usize] = b"setct-CredReqTBS\0";
pub const NID_setct_CredReqTBS: u32 = 550;
pub const SN_setct_CredReqTBSX: &[u8; 18usize] = b"setct-CredReqTBSX\0";
pub const NID_setct_CredReqTBSX: u32 = 551;
pub const SN_setct_CredResData: &[u8; 18usize] = b"setct-CredResData\0";
pub const NID_setct_CredResData: u32 = 552;
pub const SN_setct_CredRevReqTBS: &[u8; 20usize] = b"setct-CredRevReqTBS\0";
pub const NID_setct_CredRevReqTBS: u32 = 553;
pub const SN_setct_CredRevReqTBSX: &[u8; 21usize] = b"setct-CredRevReqTBSX\0";
pub const NID_setct_CredRevReqTBSX: u32 = 554;
pub const SN_setct_CredRevResData: &[u8; 21usize] = b"setct-CredRevResData\0";
pub const NID_setct_CredRevResData: u32 = 555;
pub const SN_setct_PCertReqData: &[u8; 19usize] = b"setct-PCertReqData\0";
pub const NID_setct_PCertReqData: u32 = 556;
pub const SN_setct_PCertResTBS: &[u8; 18usize] = b"setct-PCertResTBS\0";
pub const NID_setct_PCertResTBS: u32 = 557;
pub const SN_setct_BatchAdminReqData: &[u8; 24usize] = b"setct-BatchAdminReqData\0";
pub const NID_setct_BatchAdminReqData: u32 = 558;
pub const SN_setct_BatchAdminResData: &[u8; 24usize] = b"setct-BatchAdminResData\0";
pub const NID_setct_BatchAdminResData: u32 = 559;
pub const SN_setct_CardCInitResTBS: &[u8; 22usize] = b"setct-CardCInitResTBS\0";
pub const NID_setct_CardCInitResTBS: u32 = 560;
pub const SN_setct_MeAqCInitResTBS: &[u8; 22usize] = b"setct-MeAqCInitResTBS\0";
pub const NID_setct_MeAqCInitResTBS: u32 = 561;
pub const SN_setct_RegFormResTBS: &[u8; 20usize] = b"setct-RegFormResTBS\0";
pub const NID_setct_RegFormResTBS: u32 = 562;
pub const SN_setct_CertReqData: &[u8; 18usize] = b"setct-CertReqData\0";
pub const NID_setct_CertReqData: u32 = 563;
pub const SN_setct_CertReqTBS: &[u8; 17usize] = b"setct-CertReqTBS\0";
pub const NID_setct_CertReqTBS: u32 = 564;
pub const SN_setct_CertResData: &[u8; 18usize] = b"setct-CertResData\0";
pub const NID_setct_CertResData: u32 = 565;
pub const SN_setct_CertInqReqTBS: &[u8; 20usize] = b"setct-CertInqReqTBS\0";
pub const NID_setct_CertInqReqTBS: u32 = 566;
pub const SN_setct_ErrorTBS: &[u8; 15usize] = b"setct-ErrorTBS\0";
pub const NID_setct_ErrorTBS: u32 = 567;
pub const SN_setct_PIDualSignedTBE: &[u8; 22usize] = b"setct-PIDualSignedTBE\0";
pub const NID_setct_PIDualSignedTBE: u32 = 568;
pub const SN_setct_PIUnsignedTBE: &[u8; 20usize] = b"setct-PIUnsignedTBE\0";
pub const NID_setct_PIUnsignedTBE: u32 = 569;
pub const SN_setct_AuthReqTBE: &[u8; 17usize] = b"setct-AuthReqTBE\0";
pub const NID_setct_AuthReqTBE: u32 = 570;
pub const SN_setct_AuthResTBE: &[u8; 17usize] = b"setct-AuthResTBE\0";
pub const NID_setct_AuthResTBE: u32 = 571;
pub const SN_setct_AuthResTBEX: &[u8; 18usize] = b"setct-AuthResTBEX\0";
pub const NID_setct_AuthResTBEX: u32 = 572;
pub const SN_setct_AuthTokenTBE: &[u8; 19usize] = b"setct-AuthTokenTBE\0";
pub const NID_setct_AuthTokenTBE: u32 = 573;
pub const SN_setct_CapTokenTBE: &[u8; 18usize] = b"setct-CapTokenTBE\0";
pub const NID_setct_CapTokenTBE: u32 = 574;
pub const SN_setct_CapTokenTBEX: &[u8; 19usize] = b"setct-CapTokenTBEX\0";
pub const NID_setct_CapTokenTBEX: u32 = 575;
pub const SN_setct_AcqCardCodeMsgTBE: &[u8; 24usize] = b"setct-AcqCardCodeMsgTBE\0";
pub const NID_setct_AcqCardCodeMsgTBE: u32 = 576;
pub const SN_setct_AuthRevReqTBE: &[u8; 20usize] = b"setct-AuthRevReqTBE\0";
pub const NID_setct_AuthRevReqTBE: u32 = 577;
pub const SN_setct_AuthRevResTBE: &[u8; 20usize] = b"setct-AuthRevResTBE\0";
pub const NID_setct_AuthRevResTBE: u32 = 578;
pub const SN_setct_AuthRevResTBEB: &[u8; 21usize] = b"setct-AuthRevResTBEB\0";
pub const NID_setct_AuthRevResTBEB: u32 = 579;
pub const SN_setct_CapReqTBE: &[u8; 16usize] = b"setct-CapReqTBE\0";
pub const NID_setct_CapReqTBE: u32 = 580;
pub const SN_setct_CapReqTBEX: &[u8; 17usize] = b"setct-CapReqTBEX\0";
pub const NID_setct_CapReqTBEX: u32 = 581;
pub const SN_setct_CapResTBE: &[u8; 16usize] = b"setct-CapResTBE\0";
pub const NID_setct_CapResTBE: u32 = 582;
pub const SN_setct_CapRevReqTBE: &[u8; 19usize] = b"setct-CapRevReqTBE\0";
pub const NID_setct_CapRevReqTBE: u32 = 583;
pub const SN_setct_CapRevReqTBEX: &[u8; 20usize] = b"setct-CapRevReqTBEX\0";
pub const NID_setct_CapRevReqTBEX: u32 = 584;
pub const SN_setct_CapRevResTBE: &[u8; 19usize] = b"setct-CapRevResTBE\0";
pub const NID_setct_CapRevResTBE: u32 = 585;
pub const SN_setct_CredReqTBE: &[u8; 17usize] = b"setct-CredReqTBE\0";
pub const NID_setct_CredReqTBE: u32 = 586;
pub const SN_setct_CredReqTBEX: &[u8; 18usize] = b"setct-CredReqTBEX\0";
pub const NID_setct_CredReqTBEX: u32 = 587;
pub const SN_setct_CredResTBE: &[u8; 17usize] = b"setct-CredResTBE\0";
pub const NID_setct_CredResTBE: u32 = 588;
pub const SN_setct_CredRevReqTBE: &[u8; 20usize] = b"setct-CredRevReqTBE\0";
pub const NID_setct_CredRevReqTBE: u32 = 589;
pub const SN_setct_CredRevReqTBEX: &[u8; 21usize] = b"setct-CredRevReqTBEX\0";
pub const NID_setct_CredRevReqTBEX: u32 = 590;
pub const SN_setct_CredRevResTBE: &[u8; 20usize] = b"setct-CredRevResTBE\0";
pub const NID_setct_CredRevResTBE: u32 = 591;
pub const SN_setct_BatchAdminReqTBE: &[u8; 23usize] = b"setct-BatchAdminReqTBE\0";
pub const NID_setct_BatchAdminReqTBE: u32 = 592;
pub const SN_setct_BatchAdminResTBE: &[u8; 23usize] = b"setct-BatchAdminResTBE\0";
pub const NID_setct_BatchAdminResTBE: u32 = 593;
pub const SN_setct_RegFormReqTBE: &[u8; 20usize] = b"setct-RegFormReqTBE\0";
pub const NID_setct_RegFormReqTBE: u32 = 594;
pub const SN_setct_CertReqTBE: &[u8; 17usize] = b"setct-CertReqTBE\0";
pub const NID_setct_CertReqTBE: u32 = 595;
pub const SN_setct_CertReqTBEX: &[u8; 18usize] = b"setct-CertReqTBEX\0";
pub const NID_setct_CertReqTBEX: u32 = 596;
pub const SN_setct_CertResTBE: &[u8; 17usize] = b"setct-CertResTBE\0";
pub const NID_setct_CertResTBE: u32 = 597;
pub const SN_setct_CRLNotificationTBS: &[u8; 25usize] = b"setct-CRLNotificationTBS\0";
pub const NID_setct_CRLNotificationTBS: u32 = 598;
pub const SN_setct_CRLNotificationResTBS: &[u8; 28usize] = b"setct-CRLNotificationResTBS\0";
pub const NID_setct_CRLNotificationResTBS: u32 = 599;
pub const SN_setct_BCIDistributionTBS: &[u8; 25usize] = b"setct-BCIDistributionTBS\0";
pub const NID_setct_BCIDistributionTBS: u32 = 600;
pub const SN_setext_genCrypt: &[u8; 16usize] = b"setext-genCrypt\0";
pub const LN_setext_genCrypt: &[u8; 19usize] = b"generic cryptogram\0";
pub const NID_setext_genCrypt: u32 = 601;
pub const SN_setext_miAuth: &[u8; 14usize] = b"setext-miAuth\0";
pub const LN_setext_miAuth: &[u8; 24usize] = b"merchant initiated auth\0";
pub const NID_setext_miAuth: u32 = 602;
pub const SN_setext_pinSecure: &[u8; 17usize] = b"setext-pinSecure\0";
pub const NID_setext_pinSecure: u32 = 603;
pub const SN_setext_pinAny: &[u8; 14usize] = b"setext-pinAny\0";
pub const NID_setext_pinAny: u32 = 604;
pub const SN_setext_track2: &[u8; 14usize] = b"setext-track2\0";
pub const NID_setext_track2: u32 = 605;
pub const SN_setext_cv: &[u8; 10usize] = b"setext-cv\0";
pub const LN_setext_cv: &[u8; 24usize] = b"additional verification\0";
pub const NID_setext_cv: u32 = 606;
pub const SN_set_policy_root: &[u8; 16usize] = b"set-policy-root\0";
pub const NID_set_policy_root: u32 = 607;
pub const SN_setCext_hashedRoot: &[u8; 19usize] = b"setCext-hashedRoot\0";
pub const NID_setCext_hashedRoot: u32 = 608;
pub const SN_setCext_certType: &[u8; 17usize] = b"setCext-certType\0";
pub const NID_setCext_certType: u32 = 609;
pub const SN_setCext_merchData: &[u8; 18usize] = b"setCext-merchData\0";
pub const NID_setCext_merchData: u32 = 610;
pub const SN_setCext_cCertRequired: &[u8; 22usize] = b"setCext-cCertRequired\0";
pub const NID_setCext_cCertRequired: u32 = 611;
pub const SN_setCext_tunneling: &[u8; 18usize] = b"setCext-tunneling\0";
pub const NID_setCext_tunneling: u32 = 612;
pub const SN_setCext_setExt: &[u8; 15usize] = b"setCext-setExt\0";
pub const NID_setCext_setExt: u32 = 613;
pub const SN_setCext_setQualf: &[u8; 17usize] = b"setCext-setQualf\0";
pub const NID_setCext_setQualf: u32 = 614;
pub const SN_setCext_PGWYcapabilities: &[u8; 25usize] = b"setCext-PGWYcapabilities\0";
pub const NID_setCext_PGWYcapabilities: u32 = 615;
pub const SN_setCext_TokenIdentifier: &[u8; 24usize] = b"setCext-TokenIdentifier\0";
pub const NID_setCext_TokenIdentifier: u32 = 616;
pub const SN_setCext_Track2Data: &[u8; 19usize] = b"setCext-Track2Data\0";
pub const NID_setCext_Track2Data: u32 = 617;
pub const SN_setCext_TokenType: &[u8; 18usize] = b"setCext-TokenType\0";
pub const NID_setCext_TokenType: u32 = 618;
pub const SN_setCext_IssuerCapabilities: &[u8; 27usize] = b"setCext-IssuerCapabilities\0";
pub const NID_setCext_IssuerCapabilities: u32 = 619;
pub const SN_setAttr_Cert: &[u8; 13usize] = b"setAttr-Cert\0";
pub const NID_setAttr_Cert: u32 = 620;
pub const SN_setAttr_PGWYcap: &[u8; 16usize] = b"setAttr-PGWYcap\0";
pub const LN_setAttr_PGWYcap: &[u8; 29usize] = b"payment gateway capabilities\0";
pub const NID_setAttr_PGWYcap: u32 = 621;
pub const SN_setAttr_TokenType: &[u8; 18usize] = b"setAttr-TokenType\0";
pub const NID_setAttr_TokenType: u32 = 622;
pub const SN_setAttr_IssCap: &[u8; 15usize] = b"setAttr-IssCap\0";
pub const LN_setAttr_IssCap: &[u8; 20usize] = b"issuer capabilities\0";
pub const NID_setAttr_IssCap: u32 = 623;
pub const SN_set_rootKeyThumb: &[u8; 17usize] = b"set-rootKeyThumb\0";
pub const NID_set_rootKeyThumb: u32 = 624;
pub const SN_set_addPolicy: &[u8; 14usize] = b"set-addPolicy\0";
pub const NID_set_addPolicy: u32 = 625;
pub const SN_setAttr_Token_EMV: &[u8; 18usize] = b"setAttr-Token-EMV\0";
pub const NID_setAttr_Token_EMV: u32 = 626;
pub const SN_setAttr_Token_B0Prime: &[u8; 22usize] = b"setAttr-Token-B0Prime\0";
pub const NID_setAttr_Token_B0Prime: u32 = 627;
pub const SN_setAttr_IssCap_CVM: &[u8; 19usize] = b"setAttr-IssCap-CVM\0";
pub const NID_setAttr_IssCap_CVM: u32 = 628;
pub const SN_setAttr_IssCap_T2: &[u8; 18usize] = b"setAttr-IssCap-T2\0";
pub const NID_setAttr_IssCap_T2: u32 = 629;
pub const SN_setAttr_IssCap_Sig: &[u8; 19usize] = b"setAttr-IssCap-Sig\0";
pub const NID_setAttr_IssCap_Sig: u32 = 630;
pub const SN_setAttr_GenCryptgrm: &[u8; 20usize] = b"setAttr-GenCryptgrm\0";
pub const LN_setAttr_GenCryptgrm: &[u8; 20usize] = b"generate cryptogram\0";
pub const NID_setAttr_GenCryptgrm: u32 = 631;
pub const SN_setAttr_T2Enc: &[u8; 14usize] = b"setAttr-T2Enc\0";
pub const LN_setAttr_T2Enc: &[u8; 18usize] = b"encrypted track 2\0";
pub const NID_setAttr_T2Enc: u32 = 632;
pub const SN_setAttr_T2cleartxt: &[u8; 19usize] = b"setAttr-T2cleartxt\0";
pub const LN_setAttr_T2cleartxt: &[u8; 18usize] = b"cleartext track 2\0";
pub const NID_setAttr_T2cleartxt: u32 = 633;
pub const SN_setAttr_TokICCsig: &[u8; 18usize] = b"setAttr-TokICCsig\0";
pub const LN_setAttr_TokICCsig: &[u8; 23usize] = b"ICC or token signature\0";
pub const NID_setAttr_TokICCsig: u32 = 634;
pub const SN_setAttr_SecDevSig: &[u8; 18usize] = b"setAttr-SecDevSig\0";
pub const LN_setAttr_SecDevSig: &[u8; 24usize] = b"secure device signature\0";
pub const NID_setAttr_SecDevSig: u32 = 635;
pub const SN_set_brand_IATA_ATA: &[u8; 19usize] = b"set-brand-IATA-ATA\0";
pub const NID_set_brand_IATA_ATA: u32 = 636;
pub const SN_set_brand_Diners: &[u8; 17usize] = b"set-brand-Diners\0";
pub const NID_set_brand_Diners: u32 = 637;
pub const SN_set_brand_AmericanExpress: &[u8; 26usize] = b"set-brand-AmericanExpress\0";
pub const NID_set_brand_AmericanExpress: u32 = 638;
pub const SN_set_brand_JCB: &[u8; 14usize] = b"set-brand-JCB\0";
pub const NID_set_brand_JCB: u32 = 639;
pub const SN_set_brand_Visa: &[u8; 15usize] = b"set-brand-Visa\0";
pub const NID_set_brand_Visa: u32 = 640;
pub const SN_set_brand_MasterCard: &[u8; 21usize] = b"set-brand-MasterCard\0";
pub const NID_set_brand_MasterCard: u32 = 641;
pub const SN_set_brand_Novus: &[u8; 16usize] = b"set-brand-Novus\0";
pub const NID_set_brand_Novus: u32 = 642;
pub const SN_des_cdmf: &[u8; 9usize] = b"DES-CDMF\0";
pub const LN_des_cdmf: &[u8; 9usize] = b"des-cdmf\0";
pub const NID_des_cdmf: u32 = 643;
pub const SN_rsaOAEPEncryptionSET: &[u8; 21usize] = b"rsaOAEPEncryptionSET\0";
pub const NID_rsaOAEPEncryptionSET: u32 = 644;
pub const SN_ipsec3: &[u8; 14usize] = b"Oakley-EC2N-3\0";
pub const LN_ipsec3: &[u8; 7usize] = b"ipsec3\0";
pub const NID_ipsec3: u32 = 749;
pub const SN_ipsec4: &[u8; 14usize] = b"Oakley-EC2N-4\0";
pub const LN_ipsec4: &[u8; 7usize] = b"ipsec4\0";
pub const NID_ipsec4: u32 = 750;
pub const SN_whirlpool: &[u8; 10usize] = b"whirlpool\0";
pub const NID_whirlpool: u32 = 804;
pub const SN_cryptopro: &[u8; 10usize] = b"cryptopro\0";
pub const NID_cryptopro: u32 = 805;
pub const SN_cryptocom: &[u8; 10usize] = b"cryptocom\0";
pub const NID_cryptocom: u32 = 806;
pub const SN_id_tc26: &[u8; 8usize] = b"id-tc26\0";
pub const NID_id_tc26: u32 = 974;
pub const SN_id_GostR3411_94_with_GostR3410_2001: &[u8; 36usize] =
    b"id-GostR3411-94-with-GostR3410-2001\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001: &[u8; 39usize] =
    b"GOST R 34.11-94 with GOST R 34.10-2001\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001: u32 = 807;
pub const SN_id_GostR3411_94_with_GostR3410_94: &[u8; 34usize] =
    b"id-GostR3411-94-with-GostR3410-94\0";
pub const LN_id_GostR3411_94_with_GostR3410_94: &[u8; 37usize] =
    b"GOST R 34.11-94 with GOST R 34.10-94\0";
pub const NID_id_GostR3411_94_with_GostR3410_94: u32 = 808;
pub const SN_id_GostR3411_94: &[u8; 10usize] = b"md_gost94\0";
pub const LN_id_GostR3411_94: &[u8; 16usize] = b"GOST R 34.11-94\0";
pub const NID_id_GostR3411_94: u32 = 809;
pub const SN_id_HMACGostR3411_94: &[u8; 20usize] = b"id-HMACGostR3411-94\0";
pub const LN_id_HMACGostR3411_94: &[u8; 19usize] = b"HMAC GOST 34.11-94\0";
pub const NID_id_HMACGostR3411_94: u32 = 810;
pub const SN_id_GostR3410_2001: &[u8; 9usize] = b"gost2001\0";
pub const LN_id_GostR3410_2001: &[u8; 18usize] = b"GOST R 34.10-2001\0";
pub const NID_id_GostR3410_2001: u32 = 811;
pub const SN_id_GostR3410_94: &[u8; 7usize] = b"gost94\0";
pub const LN_id_GostR3410_94: &[u8; 16usize] = b"GOST R 34.10-94\0";
pub const NID_id_GostR3410_94: u32 = 812;
pub const SN_id_Gost28147_89: &[u8; 7usize] = b"gost89\0";
pub const LN_id_Gost28147_89: &[u8; 14usize] = b"GOST 28147-89\0";
pub const NID_id_Gost28147_89: u32 = 813;
pub const SN_gost89_cnt: &[u8; 11usize] = b"gost89-cnt\0";
pub const NID_gost89_cnt: u32 = 814;
pub const SN_gost89_cnt_12: &[u8; 14usize] = b"gost89-cnt-12\0";
pub const NID_gost89_cnt_12: u32 = 975;
pub const SN_gost89_cbc: &[u8; 11usize] = b"gost89-cbc\0";
pub const NID_gost89_cbc: u32 = 1009;
pub const SN_gost89_ecb: &[u8; 11usize] = b"gost89-ecb\0";
pub const NID_gost89_ecb: u32 = 1010;
pub const SN_gost89_ctr: &[u8; 11usize] = b"gost89-ctr\0";
pub const NID_gost89_ctr: u32 = 1011;
pub const SN_id_Gost28147_89_MAC: &[u8; 9usize] = b"gost-mac\0";
pub const LN_id_Gost28147_89_MAC: &[u8; 18usize] = b"GOST 28147-89 MAC\0";
pub const NID_id_Gost28147_89_MAC: u32 = 815;
pub const SN_gost_mac_12: &[u8; 12usize] = b"gost-mac-12\0";
pub const NID_gost_mac_12: u32 = 976;
pub const SN_id_GostR3411_94_prf: &[u8; 17usize] = b"prf-gostr3411-94\0";
pub const LN_id_GostR3411_94_prf: &[u8; 20usize] = b"GOST R 34.11-94 PRF\0";
pub const NID_id_GostR3411_94_prf: u32 = 816;
pub const SN_id_GostR3410_2001DH: &[u8; 20usize] = b"id-GostR3410-2001DH\0";
pub const LN_id_GostR3410_2001DH: &[u8; 21usize] = b"GOST R 34.10-2001 DH\0";
pub const NID_id_GostR3410_2001DH: u32 = 817;
pub const SN_id_GostR3410_94DH: &[u8; 18usize] = b"id-GostR3410-94DH\0";
pub const LN_id_GostR3410_94DH: &[u8; 19usize] = b"GOST R 34.10-94 DH\0";
pub const NID_id_GostR3410_94DH: u32 = 818;
pub const SN_id_Gost28147_89_CryptoPro_KeyMeshing: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-KeyMeshing\0";
pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing: u32 = 819;
pub const SN_id_Gost28147_89_None_KeyMeshing: &[u8; 32usize] = b"id-Gost28147-89-None-KeyMeshing\0";
pub const NID_id_Gost28147_89_None_KeyMeshing: u32 = 820;
pub const SN_id_GostR3411_94_TestParamSet: &[u8; 29usize] = b"id-GostR3411-94-TestParamSet\0";
pub const NID_id_GostR3411_94_TestParamSet: u32 = 821;
pub const SN_id_GostR3411_94_CryptoProParamSet: &[u8; 34usize] =
    b"id-GostR3411-94-CryptoProParamSet\0";
pub const NID_id_GostR3411_94_CryptoProParamSet: u32 = 822;
pub const SN_id_Gost28147_89_TestParamSet: &[u8; 29usize] = b"id-Gost28147-89-TestParamSet\0";
pub const NID_id_Gost28147_89_TestParamSet: u32 = 823;
pub const SN_id_Gost28147_89_CryptoPro_A_ParamSet: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-A-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet: u32 = 824;
pub const SN_id_Gost28147_89_CryptoPro_B_ParamSet: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-B-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet: u32 = 825;
pub const SN_id_Gost28147_89_CryptoPro_C_ParamSet: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-C-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet: u32 = 826;
pub const SN_id_Gost28147_89_CryptoPro_D_ParamSet: &[u8; 37usize] =
    b"id-Gost28147-89-CryptoPro-D-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet: u32 = 827;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: &[u8; 45usize] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: u32 = 828;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: &[u8; 45usize] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-0-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: u32 = 829;
pub const SN_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: &[u8; 41usize] =
    b"id-Gost28147-89-CryptoPro-RIC-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: u32 = 830;
pub const SN_id_GostR3410_94_TestParamSet: &[u8; 29usize] = b"id-GostR3410-94-TestParamSet\0";
pub const NID_id_GostR3410_94_TestParamSet: u32 = 831;
pub const SN_id_GostR3410_94_CryptoPro_A_ParamSet: &[u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet: u32 = 832;
pub const SN_id_GostR3410_94_CryptoPro_B_ParamSet: &[u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet: u32 = 833;
pub const SN_id_GostR3410_94_CryptoPro_C_ParamSet: &[u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet: u32 = 834;
pub const SN_id_GostR3410_94_CryptoPro_D_ParamSet: &[u8; 37usize] =
    b"id-GostR3410-94-CryptoPro-D-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet: u32 = 835;
pub const SN_id_GostR3410_94_CryptoPro_XchA_ParamSet: &[u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet: u32 = 836;
pub const SN_id_GostR3410_94_CryptoPro_XchB_ParamSet: &[u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet: u32 = 837;
pub const SN_id_GostR3410_94_CryptoPro_XchC_ParamSet: &[u8; 40usize] =
    b"id-GostR3410-94-CryptoPro-XchC-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet: u32 = 838;
pub const SN_id_GostR3410_2001_TestParamSet: &[u8; 31usize] = b"id-GostR3410-2001-TestParamSet\0";
pub const NID_id_GostR3410_2001_TestParamSet: u32 = 839;
pub const SN_id_GostR3410_2001_CryptoPro_A_ParamSet: &[u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet: u32 = 840;
pub const SN_id_GostR3410_2001_CryptoPro_B_ParamSet: &[u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet: u32 = 841;
pub const SN_id_GostR3410_2001_CryptoPro_C_ParamSet: &[u8; 39usize] =
    b"id-GostR3410-2001-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet: u32 = 842;
pub const SN_id_GostR3410_2001_CryptoPro_XchA_ParamSet: &[u8; 42usize] =
    b"id-GostR3410-2001-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet: u32 = 843;
pub const SN_id_GostR3410_2001_CryptoPro_XchB_ParamSet: &[u8; 42usize] =
    b"id-GostR3410-2001-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet: u32 = 844;
pub const SN_id_GostR3410_94_a: &[u8; 18usize] = b"id-GostR3410-94-a\0";
pub const NID_id_GostR3410_94_a: u32 = 845;
pub const SN_id_GostR3410_94_aBis: &[u8; 21usize] = b"id-GostR3410-94-aBis\0";
pub const NID_id_GostR3410_94_aBis: u32 = 846;
pub const SN_id_GostR3410_94_b: &[u8; 18usize] = b"id-GostR3410-94-b\0";
pub const NID_id_GostR3410_94_b: u32 = 847;
pub const SN_id_GostR3410_94_bBis: &[u8; 21usize] = b"id-GostR3410-94-bBis\0";
pub const NID_id_GostR3410_94_bBis: u32 = 848;
pub const SN_id_Gost28147_89_cc: &[u8; 19usize] = b"id-Gost28147-89-cc\0";
pub const LN_id_Gost28147_89_cc: &[u8; 33usize] = b"GOST 28147-89 Cryptocom ParamSet\0";
pub const NID_id_Gost28147_89_cc: u32 = 849;
pub const SN_id_GostR3410_94_cc: &[u8; 9usize] = b"gost94cc\0";
pub const LN_id_GostR3410_94_cc: &[u8; 24usize] = b"GOST 34.10-94 Cryptocom\0";
pub const NID_id_GostR3410_94_cc: u32 = 850;
pub const SN_id_GostR3410_2001_cc: &[u8; 11usize] = b"gost2001cc\0";
pub const LN_id_GostR3410_2001_cc: &[u8; 26usize] = b"GOST 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3410_2001_cc: u32 = 851;
pub const SN_id_GostR3411_94_with_GostR3410_94_cc: &[u8; 37usize] =
    b"id-GostR3411-94-with-GostR3410-94-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_94_cc: &[u8; 47usize] =
    b"GOST R 34.11-94 with GOST R 34.10-94 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_94_cc: u32 = 852;
pub const SN_id_GostR3411_94_with_GostR3410_2001_cc: &[u8; 39usize] =
    b"id-GostR3411-94-with-GostR3410-2001-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001_cc: &[u8; 49usize] =
    b"GOST R 34.11-94 with GOST R 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001_cc: u32 = 853;
pub const SN_id_GostR3410_2001_ParamSet_cc: &[u8; 30usize] = b"id-GostR3410-2001-ParamSet-cc\0";
pub const LN_id_GostR3410_2001_ParamSet_cc: &[u8; 41usize] =
    b"GOST R 3410-2001 Parameter Set Cryptocom\0";
pub const NID_id_GostR3410_2001_ParamSet_cc: u32 = 854;
pub const SN_id_tc26_algorithms: &[u8; 19usize] = b"id-tc26-algorithms\0";
pub const NID_id_tc26_algorithms: u32 = 977;
pub const SN_id_tc26_sign: &[u8; 13usize] = b"id-tc26-sign\0";
pub const NID_id_tc26_sign: u32 = 978;
pub const SN_id_GostR3410_2012_256: &[u8; 13usize] = b"gost2012_256\0";
pub const LN_id_GostR3410_2012_256: &[u8; 39usize] = b"GOST R 34.10-2012 with 256 bit modulus\0";
pub const NID_id_GostR3410_2012_256: u32 = 979;
pub const SN_id_GostR3410_2012_512: &[u8; 13usize] = b"gost2012_512\0";
pub const LN_id_GostR3410_2012_512: &[u8; 39usize] = b"GOST R 34.10-2012 with 512 bit modulus\0";
pub const NID_id_GostR3410_2012_512: u32 = 980;
pub const SN_id_tc26_digest: &[u8; 15usize] = b"id-tc26-digest\0";
pub const NID_id_tc26_digest: u32 = 981;
pub const SN_id_GostR3411_2012_256: &[u8; 14usize] = b"md_gost12_256\0";
pub const LN_id_GostR3411_2012_256: &[u8; 36usize] = b"GOST R 34.11-2012 with 256 bit hash\0";
pub const NID_id_GostR3411_2012_256: u32 = 982;
pub const SN_id_GostR3411_2012_512: &[u8; 14usize] = b"md_gost12_512\0";
pub const LN_id_GostR3411_2012_512: &[u8; 36usize] = b"GOST R 34.11-2012 with 512 bit hash\0";
pub const NID_id_GostR3411_2012_512: u32 = 983;
pub const SN_id_tc26_signwithdigest: &[u8; 23usize] = b"id-tc26-signwithdigest\0";
pub const NID_id_tc26_signwithdigest: u32 = 984;
pub const SN_id_tc26_signwithdigest_gost3410_2012_256: &[u8; 41usize] =
    b"id-tc26-signwithdigest-gost3410-2012-256\0";
pub const LN_id_tc26_signwithdigest_gost3410_2012_256: &[u8; 51usize] =
    b"GOST R 34.10-2012 with GOST R 34.11-2012 (256 bit)\0";
pub const NID_id_tc26_signwithdigest_gost3410_2012_256: u32 = 985;
pub const SN_id_tc26_signwithdigest_gost3410_2012_512: &[u8; 41usize] =
    b"id-tc26-signwithdigest-gost3410-2012-512\0";
pub const LN_id_tc26_signwithdigest_gost3410_2012_512: &[u8; 51usize] =
    b"GOST R 34.10-2012 with GOST R 34.11-2012 (512 bit)\0";
pub const NID_id_tc26_signwithdigest_gost3410_2012_512: u32 = 986;
pub const SN_id_tc26_mac: &[u8; 12usize] = b"id-tc26-mac\0";
pub const NID_id_tc26_mac: u32 = 987;
pub const SN_id_tc26_hmac_gost_3411_2012_256: &[u8; 32usize] = b"id-tc26-hmac-gost-3411-2012-256\0";
pub const LN_id_tc26_hmac_gost_3411_2012_256: &[u8; 29usize] = b"HMAC GOST 34.11-2012 256 bit\0";
pub const NID_id_tc26_hmac_gost_3411_2012_256: u32 = 988;
pub const SN_id_tc26_hmac_gost_3411_2012_512: &[u8; 32usize] = b"id-tc26-hmac-gost-3411-2012-512\0";
pub const LN_id_tc26_hmac_gost_3411_2012_512: &[u8; 29usize] = b"HMAC GOST 34.11-2012 512 bit\0";
pub const NID_id_tc26_hmac_gost_3411_2012_512: u32 = 989;
pub const SN_id_tc26_cipher: &[u8; 15usize] = b"id-tc26-cipher\0";
pub const NID_id_tc26_cipher: u32 = 990;
pub const SN_id_tc26_cipher_gostr3412_2015_magma: &[u8; 36usize] =
    b"id-tc26-cipher-gostr3412-2015-magma\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma: u32 = 1173;
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm: &[u8; 45usize] =
    b"id-tc26-cipher-gostr3412-2015-magma-ctracpkm\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm: u32 = 1174;
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac: &[u8; 50usize] =
    b"id-tc26-cipher-gostr3412-2015-magma-ctracpkm-omac\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac: u32 = 1175;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik: &[u8; 41usize] =
    b"id-tc26-cipher-gostr3412-2015-kuznyechik\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik: u32 = 1176;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm: &[u8; 50usize] =
    b"id-tc26-cipher-gostr3412-2015-kuznyechik-ctracpkm\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm: u32 = 1177;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac: &[u8; 55usize] =
    b"id-tc26-cipher-gostr3412-2015-kuznyechik-ctracpkm-omac\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac: u32 = 1178;
pub const SN_id_tc26_agreement: &[u8; 18usize] = b"id-tc26-agreement\0";
pub const NID_id_tc26_agreement: u32 = 991;
pub const SN_id_tc26_agreement_gost_3410_2012_256: &[u8; 37usize] =
    b"id-tc26-agreement-gost-3410-2012-256\0";
pub const NID_id_tc26_agreement_gost_3410_2012_256: u32 = 992;
pub const SN_id_tc26_agreement_gost_3410_2012_512: &[u8; 37usize] =
    b"id-tc26-agreement-gost-3410-2012-512\0";
pub const NID_id_tc26_agreement_gost_3410_2012_512: u32 = 993;
pub const SN_id_tc26_wrap: &[u8; 13usize] = b"id-tc26-wrap\0";
pub const NID_id_tc26_wrap: u32 = 1179;
pub const SN_id_tc26_wrap_gostr3412_2015_magma: &[u8; 34usize] =
    b"id-tc26-wrap-gostr3412-2015-magma\0";
pub const NID_id_tc26_wrap_gostr3412_2015_magma: u32 = 1180;
pub const SN_id_tc26_wrap_gostr3412_2015_magma_kexp15: &[u8; 41usize] =
    b"id-tc26-wrap-gostr3412-2015-magma-kexp15\0";
pub const NID_id_tc26_wrap_gostr3412_2015_magma_kexp15: u32 = 1181;
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik: &[u8; 39usize] =
    b"id-tc26-wrap-gostr3412-2015-kuznyechik\0";
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik: u32 = 1182;
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15: &[u8; 46usize] =
    b"id-tc26-wrap-gostr3412-2015-kuznyechik-kexp15\0";
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15: u32 = 1183;
pub const SN_id_tc26_constants: &[u8; 18usize] = b"id-tc26-constants\0";
pub const NID_id_tc26_constants: u32 = 994;
pub const SN_id_tc26_sign_constants: &[u8; 23usize] = b"id-tc26-sign-constants\0";
pub const NID_id_tc26_sign_constants: u32 = 995;
pub const SN_id_tc26_gost_3410_2012_256_constants: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-constants\0";
pub const NID_id_tc26_gost_3410_2012_256_constants: u32 = 1147;
pub const SN_id_tc26_gost_3410_2012_256_paramSetA: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-paramSetA\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetA: &[u8; 39usize] =
    b"GOST R 34.10-2012 (256 bit) ParamSet A\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetA: u32 = 1148;
pub const SN_id_tc26_gost_3410_2012_256_paramSetB: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-paramSetB\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetB: &[u8; 39usize] =
    b"GOST R 34.10-2012 (256 bit) ParamSet B\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetB: u32 = 1184;
pub const SN_id_tc26_gost_3410_2012_256_paramSetC: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-paramSetC\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetC: &[u8; 39usize] =
    b"GOST R 34.10-2012 (256 bit) ParamSet C\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetC: u32 = 1185;
pub const SN_id_tc26_gost_3410_2012_256_paramSetD: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-256-paramSetD\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetD: &[u8; 39usize] =
    b"GOST R 34.10-2012 (256 bit) ParamSet D\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetD: u32 = 1186;
pub const SN_id_tc26_gost_3410_2012_512_constants: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-512-constants\0";
pub const NID_id_tc26_gost_3410_2012_512_constants: u32 = 996;
pub const SN_id_tc26_gost_3410_2012_512_paramSetTest: &[u8; 40usize] =
    b"id-tc26-gost-3410-2012-512-paramSetTest\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetTest: &[u8; 50usize] =
    b"GOST R 34.10-2012 (512 bit) testing parameter set\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetTest: u32 = 997;
pub const SN_id_tc26_gost_3410_2012_512_paramSetA: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-512-paramSetA\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetA: &[u8; 39usize] =
    b"GOST R 34.10-2012 (512 bit) ParamSet A\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetA: u32 = 998;
pub const SN_id_tc26_gost_3410_2012_512_paramSetB: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-512-paramSetB\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetB: &[u8; 39usize] =
    b"GOST R 34.10-2012 (512 bit) ParamSet B\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetB: u32 = 999;
pub const SN_id_tc26_gost_3410_2012_512_paramSetC: &[u8; 37usize] =
    b"id-tc26-gost-3410-2012-512-paramSetC\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetC: &[u8; 39usize] =
    b"GOST R 34.10-2012 (512 bit) ParamSet C\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetC: u32 = 1149;
pub const SN_id_tc26_digest_constants: &[u8; 25usize] = b"id-tc26-digest-constants\0";
pub const NID_id_tc26_digest_constants: u32 = 1000;
pub const SN_id_tc26_cipher_constants: &[u8; 25usize] = b"id-tc26-cipher-constants\0";
pub const NID_id_tc26_cipher_constants: u32 = 1001;
pub const SN_id_tc26_gost_28147_constants: &[u8; 29usize] = b"id-tc26-gost-28147-constants\0";
pub const NID_id_tc26_gost_28147_constants: u32 = 1002;
pub const SN_id_tc26_gost_28147_param_Z: &[u8; 27usize] = b"id-tc26-gost-28147-param-Z\0";
pub const LN_id_tc26_gost_28147_param_Z: &[u8; 33usize] = b"GOST 28147-89 TC26 parameter set\0";
pub const NID_id_tc26_gost_28147_param_Z: u32 = 1003;
pub const SN_INN: &[u8; 4usize] = b"INN\0";
pub const LN_INN: &[u8; 4usize] = b"INN\0";
pub const NID_INN: u32 = 1004;
pub const SN_OGRN: &[u8; 5usize] = b"OGRN\0";
pub const LN_OGRN: &[u8; 5usize] = b"OGRN\0";
pub const NID_OGRN: u32 = 1005;
pub const SN_SNILS: &[u8; 6usize] = b"SNILS\0";
pub const LN_SNILS: &[u8; 6usize] = b"SNILS\0";
pub const NID_SNILS: u32 = 1006;
pub const SN_subjectSignTool: &[u8; 16usize] = b"subjectSignTool\0";
pub const LN_subjectSignTool: &[u8; 24usize] = b"Signing Tool of Subject\0";
pub const NID_subjectSignTool: u32 = 1007;
pub const SN_issuerSignTool: &[u8; 15usize] = b"issuerSignTool\0";
pub const LN_issuerSignTool: &[u8; 23usize] = b"Signing Tool of Issuer\0";
pub const NID_issuerSignTool: u32 = 1008;
pub const SN_grasshopper_ecb: &[u8; 16usize] = b"grasshopper-ecb\0";
pub const NID_grasshopper_ecb: u32 = 1012;
pub const SN_grasshopper_ctr: &[u8; 16usize] = b"grasshopper-ctr\0";
pub const NID_grasshopper_ctr: u32 = 1013;
pub const SN_grasshopper_ofb: &[u8; 16usize] = b"grasshopper-ofb\0";
pub const NID_grasshopper_ofb: u32 = 1014;
pub const SN_grasshopper_cbc: &[u8; 16usize] = b"grasshopper-cbc\0";
pub const NID_grasshopper_cbc: u32 = 1015;
pub const SN_grasshopper_cfb: &[u8; 16usize] = b"grasshopper-cfb\0";
pub const NID_grasshopper_cfb: u32 = 1016;
pub const SN_grasshopper_mac: &[u8; 16usize] = b"grasshopper-mac\0";
pub const NID_grasshopper_mac: u32 = 1017;
pub const SN_magma_ecb: &[u8; 10usize] = b"magma-ecb\0";
pub const NID_magma_ecb: u32 = 1187;
pub const SN_magma_ctr: &[u8; 10usize] = b"magma-ctr\0";
pub const NID_magma_ctr: u32 = 1188;
pub const SN_magma_ofb: &[u8; 10usize] = b"magma-ofb\0";
pub const NID_magma_ofb: u32 = 1189;
pub const SN_magma_cbc: &[u8; 10usize] = b"magma-cbc\0";
pub const NID_magma_cbc: u32 = 1190;
pub const SN_magma_cfb: &[u8; 10usize] = b"magma-cfb\0";
pub const NID_magma_cfb: u32 = 1191;
pub const SN_magma_mac: &[u8; 10usize] = b"magma-mac\0";
pub const NID_magma_mac: u32 = 1192;
pub const SN_camellia_128_cbc: &[u8; 17usize] = b"CAMELLIA-128-CBC\0";
pub const LN_camellia_128_cbc: &[u8; 17usize] = b"camellia-128-cbc\0";
pub const NID_camellia_128_cbc: u32 = 751;
pub const SN_camellia_192_cbc: &[u8; 17usize] = b"CAMELLIA-192-CBC\0";
pub const LN_camellia_192_cbc: &[u8; 17usize] = b"camellia-192-cbc\0";
pub const NID_camellia_192_cbc: u32 = 752;
pub const SN_camellia_256_cbc: &[u8; 17usize] = b"CAMELLIA-256-CBC\0";
pub const LN_camellia_256_cbc: &[u8; 17usize] = b"camellia-256-cbc\0";
pub const NID_camellia_256_cbc: u32 = 753;
pub const SN_id_camellia128_wrap: &[u8; 20usize] = b"id-camellia128-wrap\0";
pub const NID_id_camellia128_wrap: u32 = 907;
pub const SN_id_camellia192_wrap: &[u8; 20usize] = b"id-camellia192-wrap\0";
pub const NID_id_camellia192_wrap: u32 = 908;
pub const SN_id_camellia256_wrap: &[u8; 20usize] = b"id-camellia256-wrap\0";
pub const NID_id_camellia256_wrap: u32 = 909;
pub const SN_camellia_128_ecb: &[u8; 17usize] = b"CAMELLIA-128-ECB\0";
pub const LN_camellia_128_ecb: &[u8; 17usize] = b"camellia-128-ecb\0";
pub const NID_camellia_128_ecb: u32 = 754;
pub const SN_camellia_128_ofb128: &[u8; 17usize] = b"CAMELLIA-128-OFB\0";
pub const LN_camellia_128_ofb128: &[u8; 17usize] = b"camellia-128-ofb\0";
pub const NID_camellia_128_ofb128: u32 = 766;
pub const SN_camellia_128_cfb128: &[u8; 17usize] = b"CAMELLIA-128-CFB\0";
pub const LN_camellia_128_cfb128: &[u8; 17usize] = b"camellia-128-cfb\0";
pub const NID_camellia_128_cfb128: u32 = 757;
pub const SN_camellia_128_gcm: &[u8; 17usize] = b"CAMELLIA-128-GCM\0";
pub const LN_camellia_128_gcm: &[u8; 17usize] = b"camellia-128-gcm\0";
pub const NID_camellia_128_gcm: u32 = 961;
pub const SN_camellia_128_ccm: &[u8; 17usize] = b"CAMELLIA-128-CCM\0";
pub const LN_camellia_128_ccm: &[u8; 17usize] = b"camellia-128-ccm\0";
pub const NID_camellia_128_ccm: u32 = 962;
pub const SN_camellia_128_ctr: &[u8; 17usize] = b"CAMELLIA-128-CTR\0";
pub const LN_camellia_128_ctr: &[u8; 17usize] = b"camellia-128-ctr\0";
pub const NID_camellia_128_ctr: u32 = 963;
pub const SN_camellia_128_cmac: &[u8; 18usize] = b"CAMELLIA-128-CMAC\0";
pub const LN_camellia_128_cmac: &[u8; 18usize] = b"camellia-128-cmac\0";
pub const NID_camellia_128_cmac: u32 = 964;
pub const SN_camellia_192_ecb: &[u8; 17usize] = b"CAMELLIA-192-ECB\0";
pub const LN_camellia_192_ecb: &[u8; 17usize] = b"camellia-192-ecb\0";
pub const NID_camellia_192_ecb: u32 = 755;
pub const SN_camellia_192_ofb128: &[u8; 17usize] = b"CAMELLIA-192-OFB\0";
pub const LN_camellia_192_ofb128: &[u8; 17usize] = b"camellia-192-ofb\0";
pub const NID_camellia_192_ofb128: u32 = 767;
pub const SN_camellia_192_cfb128: &[u8; 17usize] = b"CAMELLIA-192-CFB\0";
pub const LN_camellia_192_cfb128: &[u8; 17usize] = b"camellia-192-cfb\0";
pub const NID_camellia_192_cfb128: u32 = 758;
pub const SN_camellia_192_gcm: &[u8; 17usize] = b"CAMELLIA-192-GCM\0";
pub const LN_camellia_192_gcm: &[u8; 17usize] = b"camellia-192-gcm\0";
pub const NID_camellia_192_gcm: u32 = 965;
pub const SN_camellia_192_ccm: &[u8; 17usize] = b"CAMELLIA-192-CCM\0";
pub const LN_camellia_192_ccm: &[u8; 17usize] = b"camellia-192-ccm\0";
pub const NID_camellia_192_ccm: u32 = 966;
pub const SN_camellia_192_ctr: &[u8; 17usize] = b"CAMELLIA-192-CTR\0";
pub const LN_camellia_192_ctr: &[u8; 17usize] = b"camellia-192-ctr\0";
pub const NID_camellia_192_ctr: u32 = 967;
pub const SN_camellia_192_cmac: &[u8; 18usize] = b"CAMELLIA-192-CMAC\0";
pub const LN_camellia_192_cmac: &[u8; 18usize] = b"camellia-192-cmac\0";
pub const NID_camellia_192_cmac: u32 = 968;
pub const SN_camellia_256_ecb: &[u8; 17usize] = b"CAMELLIA-256-ECB\0";
pub const LN_camellia_256_ecb: &[u8; 17usize] = b"camellia-256-ecb\0";
pub const NID_camellia_256_ecb: u32 = 756;
pub const SN_camellia_256_ofb128: &[u8; 17usize] = b"CAMELLIA-256-OFB\0";
pub const LN_camellia_256_ofb128: &[u8; 17usize] = b"camellia-256-ofb\0";
pub const NID_camellia_256_ofb128: u32 = 768;
pub const SN_camellia_256_cfb128: &[u8; 17usize] = b"CAMELLIA-256-CFB\0";
pub const LN_camellia_256_cfb128: &[u8; 17usize] = b"camellia-256-cfb\0";
pub const NID_camellia_256_cfb128: u32 = 759;
pub const SN_camellia_256_gcm: &[u8; 17usize] = b"CAMELLIA-256-GCM\0";
pub const LN_camellia_256_gcm: &[u8; 17usize] = b"camellia-256-gcm\0";
pub const NID_camellia_256_gcm: u32 = 969;
pub const SN_camellia_256_ccm: &[u8; 17usize] = b"CAMELLIA-256-CCM\0";
pub const LN_camellia_256_ccm: &[u8; 17usize] = b"camellia-256-ccm\0";
pub const NID_camellia_256_ccm: u32 = 970;
pub const SN_camellia_256_ctr: &[u8; 17usize] = b"CAMELLIA-256-CTR\0";
pub const LN_camellia_256_ctr: &[u8; 17usize] = b"camellia-256-ctr\0";
pub const NID_camellia_256_ctr: u32 = 971;
pub const SN_camellia_256_cmac: &[u8; 18usize] = b"CAMELLIA-256-CMAC\0";
pub const LN_camellia_256_cmac: &[u8; 18usize] = b"camellia-256-cmac\0";
pub const NID_camellia_256_cmac: u32 = 972;
pub const SN_camellia_128_cfb1: &[u8; 18usize] = b"CAMELLIA-128-CFB1\0";
pub const LN_camellia_128_cfb1: &[u8; 18usize] = b"camellia-128-cfb1\0";
pub const NID_camellia_128_cfb1: u32 = 760;
pub const SN_camellia_192_cfb1: &[u8; 18usize] = b"CAMELLIA-192-CFB1\0";
pub const LN_camellia_192_cfb1: &[u8; 18usize] = b"camellia-192-cfb1\0";
pub const NID_camellia_192_cfb1: u32 = 761;
pub const SN_camellia_256_cfb1: &[u8; 18usize] = b"CAMELLIA-256-CFB1\0";
pub const LN_camellia_256_cfb1: &[u8; 18usize] = b"camellia-256-cfb1\0";
pub const NID_camellia_256_cfb1: u32 = 762;
pub const SN_camellia_128_cfb8: &[u8; 18usize] = b"CAMELLIA-128-CFB8\0";
pub const LN_camellia_128_cfb8: &[u8; 18usize] = b"camellia-128-cfb8\0";
pub const NID_camellia_128_cfb8: u32 = 763;
pub const SN_camellia_192_cfb8: &[u8; 18usize] = b"CAMELLIA-192-CFB8\0";
pub const LN_camellia_192_cfb8: &[u8; 18usize] = b"camellia-192-cfb8\0";
pub const NID_camellia_192_cfb8: u32 = 764;
pub const SN_camellia_256_cfb8: &[u8; 18usize] = b"CAMELLIA-256-CFB8\0";
pub const LN_camellia_256_cfb8: &[u8; 18usize] = b"camellia-256-cfb8\0";
pub const NID_camellia_256_cfb8: u32 = 765;
pub const SN_aria_128_ecb: &[u8; 13usize] = b"ARIA-128-ECB\0";
pub const LN_aria_128_ecb: &[u8; 13usize] = b"aria-128-ecb\0";
pub const NID_aria_128_ecb: u32 = 1065;
pub const SN_aria_128_cbc: &[u8; 13usize] = b"ARIA-128-CBC\0";
pub const LN_aria_128_cbc: &[u8; 13usize] = b"aria-128-cbc\0";
pub const NID_aria_128_cbc: u32 = 1066;
pub const SN_aria_128_cfb128: &[u8; 13usize] = b"ARIA-128-CFB\0";
pub const LN_aria_128_cfb128: &[u8; 13usize] = b"aria-128-cfb\0";
pub const NID_aria_128_cfb128: u32 = 1067;
pub const SN_aria_128_ofb128: &[u8; 13usize] = b"ARIA-128-OFB\0";
pub const LN_aria_128_ofb128: &[u8; 13usize] = b"aria-128-ofb\0";
pub const NID_aria_128_ofb128: u32 = 1068;
pub const SN_aria_128_ctr: &[u8; 13usize] = b"ARIA-128-CTR\0";
pub const LN_aria_128_ctr: &[u8; 13usize] = b"aria-128-ctr\0";
pub const NID_aria_128_ctr: u32 = 1069;
pub const SN_aria_192_ecb: &[u8; 13usize] = b"ARIA-192-ECB\0";
pub const LN_aria_192_ecb: &[u8; 13usize] = b"aria-192-ecb\0";
pub const NID_aria_192_ecb: u32 = 1070;
pub const SN_aria_192_cbc: &[u8; 13usize] = b"ARIA-192-CBC\0";
pub const LN_aria_192_cbc: &[u8; 13usize] = b"aria-192-cbc\0";
pub const NID_aria_192_cbc: u32 = 1071;
pub const SN_aria_192_cfb128: &[u8; 13usize] = b"ARIA-192-CFB\0";
pub const LN_aria_192_cfb128: &[u8; 13usize] = b"aria-192-cfb\0";
pub const NID_aria_192_cfb128: u32 = 1072;
pub const SN_aria_192_ofb128: &[u8; 13usize] = b"ARIA-192-OFB\0";
pub const LN_aria_192_ofb128: &[u8; 13usize] = b"aria-192-ofb\0";
pub const NID_aria_192_ofb128: u32 = 1073;
pub const SN_aria_192_ctr: &[u8; 13usize] = b"ARIA-192-CTR\0";
pub const LN_aria_192_ctr: &[u8; 13usize] = b"aria-192-ctr\0";
pub const NID_aria_192_ctr: u32 = 1074;
pub const SN_aria_256_ecb: &[u8; 13usize] = b"ARIA-256-ECB\0";
pub const LN_aria_256_ecb: &[u8; 13usize] = b"aria-256-ecb\0";
pub const NID_aria_256_ecb: u32 = 1075;
pub const SN_aria_256_cbc: &[u8; 13usize] = b"ARIA-256-CBC\0";
pub const LN_aria_256_cbc: &[u8; 13usize] = b"aria-256-cbc\0";
pub const NID_aria_256_cbc: u32 = 1076;
pub const SN_aria_256_cfb128: &[u8; 13usize] = b"ARIA-256-CFB\0";
pub const LN_aria_256_cfb128: &[u8; 13usize] = b"aria-256-cfb\0";
pub const NID_aria_256_cfb128: u32 = 1077;
pub const SN_aria_256_ofb128: &[u8; 13usize] = b"ARIA-256-OFB\0";
pub const LN_aria_256_ofb128: &[u8; 13usize] = b"aria-256-ofb\0";
pub const NID_aria_256_ofb128: u32 = 1078;
pub const SN_aria_256_ctr: &[u8; 13usize] = b"ARIA-256-CTR\0";
pub const LN_aria_256_ctr: &[u8; 13usize] = b"aria-256-ctr\0";
pub const NID_aria_256_ctr: u32 = 1079;
pub const SN_aria_128_cfb1: &[u8; 14usize] = b"ARIA-128-CFB1\0";
pub const LN_aria_128_cfb1: &[u8; 14usize] = b"aria-128-cfb1\0";
pub const NID_aria_128_cfb1: u32 = 1080;
pub const SN_aria_192_cfb1: &[u8; 14usize] = b"ARIA-192-CFB1\0";
pub const LN_aria_192_cfb1: &[u8; 14usize] = b"aria-192-cfb1\0";
pub const NID_aria_192_cfb1: u32 = 1081;
pub const SN_aria_256_cfb1: &[u8; 14usize] = b"ARIA-256-CFB1\0";
pub const LN_aria_256_cfb1: &[u8; 14usize] = b"aria-256-cfb1\0";
pub const NID_aria_256_cfb1: u32 = 1082;
pub const SN_aria_128_cfb8: &[u8; 14usize] = b"ARIA-128-CFB8\0";
pub const LN_aria_128_cfb8: &[u8; 14usize] = b"aria-128-cfb8\0";
pub const NID_aria_128_cfb8: u32 = 1083;
pub const SN_aria_192_cfb8: &[u8; 14usize] = b"ARIA-192-CFB8\0";
pub const LN_aria_192_cfb8: &[u8; 14usize] = b"aria-192-cfb8\0";
pub const NID_aria_192_cfb8: u32 = 1084;
pub const SN_aria_256_cfb8: &[u8; 14usize] = b"ARIA-256-CFB8\0";
pub const LN_aria_256_cfb8: &[u8; 14usize] = b"aria-256-cfb8\0";
pub const NID_aria_256_cfb8: u32 = 1085;
pub const SN_aria_128_ccm: &[u8; 13usize] = b"ARIA-128-CCM\0";
pub const LN_aria_128_ccm: &[u8; 13usize] = b"aria-128-ccm\0";
pub const NID_aria_128_ccm: u32 = 1120;
pub const SN_aria_192_ccm: &[u8; 13usize] = b"ARIA-192-CCM\0";
pub const LN_aria_192_ccm: &[u8; 13usize] = b"aria-192-ccm\0";
pub const NID_aria_192_ccm: u32 = 1121;
pub const SN_aria_256_ccm: &[u8; 13usize] = b"ARIA-256-CCM\0";
pub const LN_aria_256_ccm: &[u8; 13usize] = b"aria-256-ccm\0";
pub const NID_aria_256_ccm: u32 = 1122;
pub const SN_aria_128_gcm: &[u8; 13usize] = b"ARIA-128-GCM\0";
pub const LN_aria_128_gcm: &[u8; 13usize] = b"aria-128-gcm\0";
pub const NID_aria_128_gcm: u32 = 1123;
pub const SN_aria_192_gcm: &[u8; 13usize] = b"ARIA-192-GCM\0";
pub const LN_aria_192_gcm: &[u8; 13usize] = b"aria-192-gcm\0";
pub const NID_aria_192_gcm: u32 = 1124;
pub const SN_aria_256_gcm: &[u8; 13usize] = b"ARIA-256-GCM\0";
pub const LN_aria_256_gcm: &[u8; 13usize] = b"aria-256-gcm\0";
pub const NID_aria_256_gcm: u32 = 1125;
pub const SN_kisa: &[u8; 5usize] = b"KISA\0";
pub const LN_kisa: &[u8; 5usize] = b"kisa\0";
pub const NID_kisa: u32 = 773;
pub const SN_seed_ecb: &[u8; 9usize] = b"SEED-ECB\0";
pub const LN_seed_ecb: &[u8; 9usize] = b"seed-ecb\0";
pub const NID_seed_ecb: u32 = 776;
pub const SN_seed_cbc: &[u8; 9usize] = b"SEED-CBC\0";
pub const LN_seed_cbc: &[u8; 9usize] = b"seed-cbc\0";
pub const NID_seed_cbc: u32 = 777;
pub const SN_seed_cfb128: &[u8; 9usize] = b"SEED-CFB\0";
pub const LN_seed_cfb128: &[u8; 9usize] = b"seed-cfb\0";
pub const NID_seed_cfb128: u32 = 779;
pub const SN_seed_ofb128: &[u8; 9usize] = b"SEED-OFB\0";
pub const LN_seed_ofb128: &[u8; 9usize] = b"seed-ofb\0";
pub const NID_seed_ofb128: u32 = 778;
pub const SN_sm4_ecb: &[u8; 8usize] = b"SM4-ECB\0";
pub const LN_sm4_ecb: &[u8; 8usize] = b"sm4-ecb\0";
pub const NID_sm4_ecb: u32 = 1133;
pub const SN_sm4_cbc: &[u8; 8usize] = b"SM4-CBC\0";
pub const LN_sm4_cbc: &[u8; 8usize] = b"sm4-cbc\0";
pub const NID_sm4_cbc: u32 = 1134;
pub const SN_sm4_ofb128: &[u8; 8usize] = b"SM4-OFB\0";
pub const LN_sm4_ofb128: &[u8; 8usize] = b"sm4-ofb\0";
pub const NID_sm4_ofb128: u32 = 1135;
pub const SN_sm4_cfb128: &[u8; 8usize] = b"SM4-CFB\0";
pub const LN_sm4_cfb128: &[u8; 8usize] = b"sm4-cfb\0";
pub const NID_sm4_cfb128: u32 = 1137;
pub const SN_sm4_cfb1: &[u8; 9usize] = b"SM4-CFB1\0";
pub const LN_sm4_cfb1: &[u8; 9usize] = b"sm4-cfb1\0";
pub const NID_sm4_cfb1: u32 = 1136;
pub const SN_sm4_cfb8: &[u8; 9usize] = b"SM4-CFB8\0";
pub const LN_sm4_cfb8: &[u8; 9usize] = b"sm4-cfb8\0";
pub const NID_sm4_cfb8: u32 = 1138;
pub const SN_sm4_ctr: &[u8; 8usize] = b"SM4-CTR\0";
pub const LN_sm4_ctr: &[u8; 8usize] = b"sm4-ctr\0";
pub const NID_sm4_ctr: u32 = 1139;
pub const SN_hmac: &[u8; 5usize] = b"HMAC\0";
pub const LN_hmac: &[u8; 5usize] = b"hmac\0";
pub const NID_hmac: u32 = 855;
pub const SN_cmac: &[u8; 5usize] = b"CMAC\0";
pub const LN_cmac: &[u8; 5usize] = b"cmac\0";
pub const NID_cmac: u32 = 894;
pub const SN_rc4_hmac_md5: &[u8; 13usize] = b"RC4-HMAC-MD5\0";
pub const LN_rc4_hmac_md5: &[u8; 13usize] = b"rc4-hmac-md5\0";
pub const NID_rc4_hmac_md5: u32 = 915;
pub const SN_aes_128_cbc_hmac_sha1: &[u8; 22usize] = b"AES-128-CBC-HMAC-SHA1\0";
pub const LN_aes_128_cbc_hmac_sha1: &[u8; 22usize] = b"aes-128-cbc-hmac-sha1\0";
pub const NID_aes_128_cbc_hmac_sha1: u32 = 916;
pub const SN_aes_192_cbc_hmac_sha1: &[u8; 22usize] = b"AES-192-CBC-HMAC-SHA1\0";
pub const LN_aes_192_cbc_hmac_sha1: &[u8; 22usize] = b"aes-192-cbc-hmac-sha1\0";
pub const NID_aes_192_cbc_hmac_sha1: u32 = 917;
pub const SN_aes_256_cbc_hmac_sha1: &[u8; 22usize] = b"AES-256-CBC-HMAC-SHA1\0";
pub const LN_aes_256_cbc_hmac_sha1: &[u8; 22usize] = b"aes-256-cbc-hmac-sha1\0";
pub const NID_aes_256_cbc_hmac_sha1: u32 = 918;
pub const SN_aes_128_cbc_hmac_sha256: &[u8; 24usize] = b"AES-128-CBC-HMAC-SHA256\0";
pub const LN_aes_128_cbc_hmac_sha256: &[u8; 24usize] = b"aes-128-cbc-hmac-sha256\0";
pub const NID_aes_128_cbc_hmac_sha256: u32 = 948;
pub const SN_aes_192_cbc_hmac_sha256: &[u8; 24usize] = b"AES-192-CBC-HMAC-SHA256\0";
pub const LN_aes_192_cbc_hmac_sha256: &[u8; 24usize] = b"aes-192-cbc-hmac-sha256\0";
pub const NID_aes_192_cbc_hmac_sha256: u32 = 949;
pub const SN_aes_256_cbc_hmac_sha256: &[u8; 24usize] = b"AES-256-CBC-HMAC-SHA256\0";
pub const LN_aes_256_cbc_hmac_sha256: &[u8; 24usize] = b"aes-256-cbc-hmac-sha256\0";
pub const NID_aes_256_cbc_hmac_sha256: u32 = 950;
pub const SN_chacha20_poly1305: &[u8; 18usize] = b"ChaCha20-Poly1305\0";
pub const LN_chacha20_poly1305: &[u8; 18usize] = b"chacha20-poly1305\0";
pub const NID_chacha20_poly1305: u32 = 1018;
pub const SN_chacha20: &[u8; 9usize] = b"ChaCha20\0";
pub const LN_chacha20: &[u8; 9usize] = b"chacha20\0";
pub const NID_chacha20: u32 = 1019;
pub const SN_dhpublicnumber: &[u8; 15usize] = b"dhpublicnumber\0";
pub const LN_dhpublicnumber: &[u8; 9usize] = b"X9.42 DH\0";
pub const NID_dhpublicnumber: u32 = 920;
pub const SN_brainpoolP160r1: &[u8; 16usize] = b"brainpoolP160r1\0";
pub const NID_brainpoolP160r1: u32 = 921;
pub const SN_brainpoolP160t1: &[u8; 16usize] = b"brainpoolP160t1\0";
pub const NID_brainpoolP160t1: u32 = 922;
pub const SN_brainpoolP192r1: &[u8; 16usize] = b"brainpoolP192r1\0";
pub const NID_brainpoolP192r1: u32 = 923;
pub const SN_brainpoolP192t1: &[u8; 16usize] = b"brainpoolP192t1\0";
pub const NID_brainpoolP192t1: u32 = 924;
pub const SN_brainpoolP224r1: &[u8; 16usize] = b"brainpoolP224r1\0";
pub const NID_brainpoolP224r1: u32 = 925;
pub const SN_brainpoolP224t1: &[u8; 16usize] = b"brainpoolP224t1\0";
pub const NID_brainpoolP224t1: u32 = 926;
pub const SN_brainpoolP256r1: &[u8; 16usize] = b"brainpoolP256r1\0";
pub const NID_brainpoolP256r1: u32 = 927;
pub const SN_brainpoolP256t1: &[u8; 16usize] = b"brainpoolP256t1\0";
pub const NID_brainpoolP256t1: u32 = 928;
pub const SN_brainpoolP320r1: &[u8; 16usize] = b"brainpoolP320r1\0";
pub const NID_brainpoolP320r1: u32 = 929;
pub const SN_brainpoolP320t1: &[u8; 16usize] = b"brainpoolP320t1\0";
pub const NID_brainpoolP320t1: u32 = 930;
pub const SN_brainpoolP384r1: &[u8; 16usize] = b"brainpoolP384r1\0";
pub const NID_brainpoolP384r1: u32 = 931;
pub const SN_brainpoolP384t1: &[u8; 16usize] = b"brainpoolP384t1\0";
pub const NID_brainpoolP384t1: u32 = 932;
pub const SN_brainpoolP512r1: &[u8; 16usize] = b"brainpoolP512r1\0";
pub const NID_brainpoolP512r1: u32 = 933;
pub const SN_brainpoolP512t1: &[u8; 16usize] = b"brainpoolP512t1\0";
pub const NID_brainpoolP512t1: u32 = 934;
pub const SN_dhSinglePass_stdDH_sha1kdf_scheme: &[u8; 34usize] =
    b"dhSinglePass-stdDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha1kdf_scheme: u32 = 936;
pub const SN_dhSinglePass_stdDH_sha224kdf_scheme: &[u8; 36usize] =
    b"dhSinglePass-stdDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha224kdf_scheme: u32 = 937;
pub const SN_dhSinglePass_stdDH_sha256kdf_scheme: &[u8; 36usize] =
    b"dhSinglePass-stdDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha256kdf_scheme: u32 = 938;
pub const SN_dhSinglePass_stdDH_sha384kdf_scheme: &[u8; 36usize] =
    b"dhSinglePass-stdDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha384kdf_scheme: u32 = 939;
pub const SN_dhSinglePass_stdDH_sha512kdf_scheme: &[u8; 36usize] =
    b"dhSinglePass-stdDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha512kdf_scheme: u32 = 940;
pub const SN_dhSinglePass_cofactorDH_sha1kdf_scheme: &[u8; 39usize] =
    b"dhSinglePass-cofactorDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha1kdf_scheme: u32 = 941;
pub const SN_dhSinglePass_cofactorDH_sha224kdf_scheme: &[u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha224kdf_scheme: u32 = 942;
pub const SN_dhSinglePass_cofactorDH_sha256kdf_scheme: &[u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha256kdf_scheme: u32 = 943;
pub const SN_dhSinglePass_cofactorDH_sha384kdf_scheme: &[u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha384kdf_scheme: u32 = 944;
pub const SN_dhSinglePass_cofactorDH_sha512kdf_scheme: &[u8; 41usize] =
    b"dhSinglePass-cofactorDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha512kdf_scheme: u32 = 945;
pub const SN_dh_std_kdf: &[u8; 11usize] = b"dh-std-kdf\0";
pub const NID_dh_std_kdf: u32 = 946;
pub const SN_dh_cofactor_kdf: &[u8; 16usize] = b"dh-cofactor-kdf\0";
pub const NID_dh_cofactor_kdf: u32 = 947;
pub const SN_ct_precert_scts: &[u8; 16usize] = b"ct_precert_scts\0";
pub const LN_ct_precert_scts: &[u8; 23usize] = b"CT Precertificate SCTs\0";
pub const NID_ct_precert_scts: u32 = 951;
pub const SN_ct_precert_poison: &[u8; 18usize] = b"ct_precert_poison\0";
pub const LN_ct_precert_poison: &[u8; 25usize] = b"CT Precertificate Poison\0";
pub const NID_ct_precert_poison: u32 = 952;
pub const SN_ct_precert_signer: &[u8; 18usize] = b"ct_precert_signer\0";
pub const LN_ct_precert_signer: &[u8; 25usize] = b"CT Precertificate Signer\0";
pub const NID_ct_precert_signer: u32 = 953;
pub const SN_ct_cert_scts: &[u8; 13usize] = b"ct_cert_scts\0";
pub const LN_ct_cert_scts: &[u8; 20usize] = b"CT Certificate SCTs\0";
pub const NID_ct_cert_scts: u32 = 954;
pub const SN_jurisdictionLocalityName: &[u8; 14usize] = b"jurisdictionL\0";
pub const LN_jurisdictionLocalityName: &[u8; 25usize] = b"jurisdictionLocalityName\0";
pub const NID_jurisdictionLocalityName: u32 = 955;
pub const SN_jurisdictionStateOrProvinceName: &[u8; 15usize] = b"jurisdictionST\0";
pub const LN_jurisdictionStateOrProvinceName: &[u8; 32usize] = b"jurisdictionStateOrProvinceName\0";
pub const NID_jurisdictionStateOrProvinceName: u32 = 956;
pub const SN_jurisdictionCountryName: &[u8; 14usize] = b"jurisdictionC\0";
pub const LN_jurisdictionCountryName: &[u8; 24usize] = b"jurisdictionCountryName\0";
pub const NID_jurisdictionCountryName: u32 = 957;
pub const SN_id_scrypt: &[u8; 10usize] = b"id-scrypt\0";
pub const LN_id_scrypt: &[u8; 7usize] = b"scrypt\0";
pub const NID_id_scrypt: u32 = 973;
pub const SN_tls1_prf: &[u8; 9usize] = b"TLS1-PRF\0";
pub const LN_tls1_prf: &[u8; 9usize] = b"tls1-prf\0";
pub const NID_tls1_prf: u32 = 1021;
pub const SN_hkdf: &[u8; 5usize] = b"HKDF\0";
pub const LN_hkdf: &[u8; 5usize] = b"hkdf\0";
pub const NID_hkdf: u32 = 1036;
pub const SN_id_pkinit: &[u8; 10usize] = b"id-pkinit\0";
pub const NID_id_pkinit: u32 = 1031;
pub const SN_pkInitClientAuth: &[u8; 17usize] = b"pkInitClientAuth\0";
pub const LN_pkInitClientAuth: &[u8; 19usize] = b"PKINIT Client Auth\0";
pub const NID_pkInitClientAuth: u32 = 1032;
pub const SN_pkInitKDC: &[u8; 10usize] = b"pkInitKDC\0";
pub const LN_pkInitKDC: &[u8; 21usize] = b"Signing KDC Response\0";
pub const NID_pkInitKDC: u32 = 1033;
pub const SN_X25519: &[u8; 7usize] = b"X25519\0";
pub const NID_X25519: u32 = 1034;
pub const SN_X448: &[u8; 5usize] = b"X448\0";
pub const NID_X448: u32 = 1035;
pub const SN_ED25519: &[u8; 8usize] = b"ED25519\0";
pub const NID_ED25519: u32 = 1087;
pub const SN_ED448: &[u8; 6usize] = b"ED448\0";
pub const NID_ED448: u32 = 1088;
pub const SN_kx_rsa: &[u8; 6usize] = b"KxRSA\0";
pub const LN_kx_rsa: &[u8; 7usize] = b"kx-rsa\0";
pub const NID_kx_rsa: u32 = 1037;
pub const SN_kx_ecdhe: &[u8; 8usize] = b"KxECDHE\0";
pub const LN_kx_ecdhe: &[u8; 9usize] = b"kx-ecdhe\0";
pub const NID_kx_ecdhe: u32 = 1038;
pub const SN_kx_dhe: &[u8; 6usize] = b"KxDHE\0";
pub const LN_kx_dhe: &[u8; 7usize] = b"kx-dhe\0";
pub const NID_kx_dhe: u32 = 1039;
pub const SN_kx_ecdhe_psk: &[u8; 12usize] = b"KxECDHE-PSK\0";
pub const LN_kx_ecdhe_psk: &[u8; 13usize] = b"kx-ecdhe-psk\0";
pub const NID_kx_ecdhe_psk: u32 = 1040;
pub const SN_kx_dhe_psk: &[u8; 10usize] = b"KxDHE-PSK\0";
pub const LN_kx_dhe_psk: &[u8; 11usize] = b"kx-dhe-psk\0";
pub const NID_kx_dhe_psk: u32 = 1041;
pub const SN_kx_rsa_psk: &[u8; 10usize] = b"KxRSA_PSK\0";
pub const LN_kx_rsa_psk: &[u8; 11usize] = b"kx-rsa-psk\0";
pub const NID_kx_rsa_psk: u32 = 1042;
pub const SN_kx_psk: &[u8; 6usize] = b"KxPSK\0";
pub const LN_kx_psk: &[u8; 7usize] = b"kx-psk\0";
pub const NID_kx_psk: u32 = 1043;
pub const SN_kx_srp: &[u8; 6usize] = b"KxSRP\0";
pub const LN_kx_srp: &[u8; 7usize] = b"kx-srp\0";
pub const NID_kx_srp: u32 = 1044;
pub const SN_kx_gost: &[u8; 7usize] = b"KxGOST\0";
pub const LN_kx_gost: &[u8; 8usize] = b"kx-gost\0";
pub const NID_kx_gost: u32 = 1045;
pub const SN_kx_any: &[u8; 6usize] = b"KxANY\0";
pub const LN_kx_any: &[u8; 7usize] = b"kx-any\0";
pub const NID_kx_any: u32 = 1063;
pub const SN_auth_rsa: &[u8; 8usize] = b"AuthRSA\0";
pub const LN_auth_rsa: &[u8; 9usize] = b"auth-rsa\0";
pub const NID_auth_rsa: u32 = 1046;
pub const SN_auth_ecdsa: &[u8; 10usize] = b"AuthECDSA\0";
pub const LN_auth_ecdsa: &[u8; 11usize] = b"auth-ecdsa\0";
pub const NID_auth_ecdsa: u32 = 1047;
pub const SN_auth_psk: &[u8; 8usize] = b"AuthPSK\0";
pub const LN_auth_psk: &[u8; 9usize] = b"auth-psk\0";
pub const NID_auth_psk: u32 = 1048;
pub const SN_auth_dss: &[u8; 8usize] = b"AuthDSS\0";
pub const LN_auth_dss: &[u8; 9usize] = b"auth-dss\0";
pub const NID_auth_dss: u32 = 1049;
pub const SN_auth_gost01: &[u8; 11usize] = b"AuthGOST01\0";
pub const LN_auth_gost01: &[u8; 12usize] = b"auth-gost01\0";
pub const NID_auth_gost01: u32 = 1050;
pub const SN_auth_gost12: &[u8; 11usize] = b"AuthGOST12\0";
pub const LN_auth_gost12: &[u8; 12usize] = b"auth-gost12\0";
pub const NID_auth_gost12: u32 = 1051;
pub const SN_auth_srp: &[u8; 8usize] = b"AuthSRP\0";
pub const LN_auth_srp: &[u8; 9usize] = b"auth-srp\0";
pub const NID_auth_srp: u32 = 1052;
pub const SN_auth_null: &[u8; 9usize] = b"AuthNULL\0";
pub const LN_auth_null: &[u8; 10usize] = b"auth-null\0";
pub const NID_auth_null: u32 = 1053;
pub const SN_auth_any: &[u8; 8usize] = b"AuthANY\0";
pub const LN_auth_any: &[u8; 9usize] = b"auth-any\0";
pub const NID_auth_any: u32 = 1064;
pub const SN_poly1305: &[u8; 9usize] = b"Poly1305\0";
pub const LN_poly1305: &[u8; 9usize] = b"poly1305\0";
pub const NID_poly1305: u32 = 1061;
pub const SN_siphash: &[u8; 8usize] = b"SipHash\0";
pub const LN_siphash: &[u8; 8usize] = b"siphash\0";
pub const NID_siphash: u32 = 1062;
pub const SN_ffdhe2048: &[u8; 10usize] = b"ffdhe2048\0";
pub const NID_ffdhe2048: u32 = 1126;
pub const SN_ffdhe3072: &[u8; 10usize] = b"ffdhe3072\0";
pub const NID_ffdhe3072: u32 = 1127;
pub const SN_ffdhe4096: &[u8; 10usize] = b"ffdhe4096\0";
pub const NID_ffdhe4096: u32 = 1128;
pub const SN_ffdhe6144: &[u8; 10usize] = b"ffdhe6144\0";
pub const NID_ffdhe6144: u32 = 1129;
pub const SN_ffdhe8192: &[u8; 10usize] = b"ffdhe8192\0";
pub const NID_ffdhe8192: u32 = 1130;
pub const SN_ISO_UA: &[u8; 7usize] = b"ISO-UA\0";
pub const NID_ISO_UA: u32 = 1150;
pub const SN_ua_pki: &[u8; 7usize] = b"ua-pki\0";
pub const NID_ua_pki: u32 = 1151;
pub const SN_dstu28147: &[u8; 10usize] = b"dstu28147\0";
pub const LN_dstu28147: &[u8; 21usize] = b"DSTU Gost 28147-2009\0";
pub const NID_dstu28147: u32 = 1152;
pub const SN_dstu28147_ofb: &[u8; 14usize] = b"dstu28147-ofb\0";
pub const LN_dstu28147_ofb: &[u8; 30usize] = b"DSTU Gost 28147-2009 OFB mode\0";
pub const NID_dstu28147_ofb: u32 = 1153;
pub const SN_dstu28147_cfb: &[u8; 14usize] = b"dstu28147-cfb\0";
pub const LN_dstu28147_cfb: &[u8; 30usize] = b"DSTU Gost 28147-2009 CFB mode\0";
pub const NID_dstu28147_cfb: u32 = 1154;
pub const SN_dstu28147_wrap: &[u8; 15usize] = b"dstu28147-wrap\0";
pub const LN_dstu28147_wrap: &[u8; 30usize] = b"DSTU Gost 28147-2009 key wrap\0";
pub const NID_dstu28147_wrap: u32 = 1155;
pub const SN_hmacWithDstu34311: &[u8; 18usize] = b"hmacWithDstu34311\0";
pub const LN_hmacWithDstu34311: &[u8; 24usize] = b"HMAC DSTU Gost 34311-95\0";
pub const NID_hmacWithDstu34311: u32 = 1156;
pub const SN_dstu34311: &[u8; 10usize] = b"dstu34311\0";
pub const LN_dstu34311: &[u8; 19usize] = b"DSTU Gost 34311-95\0";
pub const NID_dstu34311: u32 = 1157;
pub const SN_dstu4145le: &[u8; 11usize] = b"dstu4145le\0";
pub const LN_dstu4145le: &[u8; 29usize] = b"DSTU 4145-2002 little endian\0";
pub const NID_dstu4145le: u32 = 1158;
pub const SN_dstu4145be: &[u8; 11usize] = b"dstu4145be\0";
pub const LN_dstu4145be: &[u8; 26usize] = b"DSTU 4145-2002 big endian\0";
pub const NID_dstu4145be: u32 = 1159;
pub const SN_uacurve0: &[u8; 9usize] = b"uacurve0\0";
pub const LN_uacurve0: &[u8; 13usize] = b"DSTU curve 0\0";
pub const NID_uacurve0: u32 = 1160;
pub const SN_uacurve1: &[u8; 9usize] = b"uacurve1\0";
pub const LN_uacurve1: &[u8; 13usize] = b"DSTU curve 1\0";
pub const NID_uacurve1: u32 = 1161;
pub const SN_uacurve2: &[u8; 9usize] = b"uacurve2\0";
pub const LN_uacurve2: &[u8; 13usize] = b"DSTU curve 2\0";
pub const NID_uacurve2: u32 = 1162;
pub const SN_uacurve3: &[u8; 9usize] = b"uacurve3\0";
pub const LN_uacurve3: &[u8; 13usize] = b"DSTU curve 3\0";
pub const NID_uacurve3: u32 = 1163;
pub const SN_uacurve4: &[u8; 9usize] = b"uacurve4\0";
pub const LN_uacurve4: &[u8; 13usize] = b"DSTU curve 4\0";
pub const NID_uacurve4: u32 = 1164;
pub const SN_uacurve5: &[u8; 9usize] = b"uacurve5\0";
pub const LN_uacurve5: &[u8; 13usize] = b"DSTU curve 5\0";
pub const NID_uacurve5: u32 = 1165;
pub const SN_uacurve6: &[u8; 9usize] = b"uacurve6\0";
pub const LN_uacurve6: &[u8; 13usize] = b"DSTU curve 6\0";
pub const NID_uacurve6: u32 = 1166;
pub const SN_uacurve7: &[u8; 9usize] = b"uacurve7\0";
pub const LN_uacurve7: &[u8; 13usize] = b"DSTU curve 7\0";
pub const NID_uacurve7: u32 = 1167;
pub const SN_uacurve8: &[u8; 9usize] = b"uacurve8\0";
pub const LN_uacurve8: &[u8; 13usize] = b"DSTU curve 8\0";
pub const NID_uacurve8: u32 = 1168;
pub const SN_uacurve9: &[u8; 9usize] = b"uacurve9\0";
pub const LN_uacurve9: &[u8; 13usize] = b"DSTU curve 9\0";
pub const NID_uacurve9: u32 = 1169;
pub const ASN1_F_A2D_ASN1_OBJECT: u32 = 100;
pub const ASN1_F_A2I_ASN1_INTEGER: u32 = 102;
pub const ASN1_F_A2I_ASN1_STRING: u32 = 103;
pub const ASN1_F_APPEND_EXP: u32 = 176;
pub const ASN1_F_ASN1_BIO_INIT: u32 = 113;
pub const ASN1_F_ASN1_BIT_STRING_SET_BIT: u32 = 183;
pub const ASN1_F_ASN1_CB: u32 = 177;
pub const ASN1_F_ASN1_CHECK_TLEN: u32 = 104;
pub const ASN1_F_ASN1_COLLECT: u32 = 106;
pub const ASN1_F_ASN1_D2I_EX_PRIMITIVE: u32 = 108;
pub const ASN1_F_ASN1_D2I_FP: u32 = 109;
pub const ASN1_F_ASN1_D2I_READ_BIO: u32 = 107;
pub const ASN1_F_ASN1_DIGEST: u32 = 184;
pub const ASN1_F_ASN1_DO_ADB: u32 = 110;
pub const ASN1_F_ASN1_DO_LOCK: u32 = 233;
pub const ASN1_F_ASN1_DUP: u32 = 111;
pub const ASN1_F_ASN1_ENC_SAVE: u32 = 115;
pub const ASN1_F_ASN1_EX_C2I: u32 = 204;
pub const ASN1_F_ASN1_FIND_END: u32 = 190;
pub const ASN1_F_ASN1_GENERALIZEDTIME_ADJ: u32 = 216;
pub const ASN1_F_ASN1_GENERATE_V3: u32 = 178;
pub const ASN1_F_ASN1_GET_INT64: u32 = 224;
pub const ASN1_F_ASN1_GET_OBJECT: u32 = 114;
pub const ASN1_F_ASN1_GET_UINT64: u32 = 225;
pub const ASN1_F_ASN1_I2D_BIO: u32 = 116;
pub const ASN1_F_ASN1_I2D_FP: u32 = 117;
pub const ASN1_F_ASN1_ITEM_D2I_FP: u32 = 206;
pub const ASN1_F_ASN1_ITEM_DUP: u32 = 191;
pub const ASN1_F_ASN1_ITEM_EMBED_D2I: u32 = 120;
pub const ASN1_F_ASN1_ITEM_EMBED_NEW: u32 = 121;
pub const ASN1_F_ASN1_ITEM_EX_I2D: u32 = 144;
pub const ASN1_F_ASN1_ITEM_FLAGS_I2D: u32 = 118;
pub const ASN1_F_ASN1_ITEM_I2D_BIO: u32 = 192;
pub const ASN1_F_ASN1_ITEM_I2D_FP: u32 = 193;
pub const ASN1_F_ASN1_ITEM_PACK: u32 = 198;
pub const ASN1_F_ASN1_ITEM_SIGN: u32 = 195;
pub const ASN1_F_ASN1_ITEM_SIGN_CTX: u32 = 220;
pub const ASN1_F_ASN1_ITEM_UNPACK: u32 = 199;
pub const ASN1_F_ASN1_ITEM_VERIFY: u32 = 197;
pub const ASN1_F_ASN1_MBSTRING_NCOPY: u32 = 122;
pub const ASN1_F_ASN1_OBJECT_NEW: u32 = 123;
pub const ASN1_F_ASN1_OUTPUT_DATA: u32 = 214;
pub const ASN1_F_ASN1_PCTX_NEW: u32 = 205;
pub const ASN1_F_ASN1_PRIMITIVE_NEW: u32 = 119;
pub const ASN1_F_ASN1_SCTX_NEW: u32 = 221;
pub const ASN1_F_ASN1_SIGN: u32 = 128;
pub const ASN1_F_ASN1_STR2TYPE: u32 = 179;
pub const ASN1_F_ASN1_STRING_GET_INT64: u32 = 227;
pub const ASN1_F_ASN1_STRING_GET_UINT64: u32 = 230;
pub const ASN1_F_ASN1_STRING_SET: u32 = 186;
pub const ASN1_F_ASN1_STRING_TABLE_ADD: u32 = 129;
pub const ASN1_F_ASN1_STRING_TO_BN: u32 = 228;
pub const ASN1_F_ASN1_STRING_TYPE_NEW: u32 = 130;
pub const ASN1_F_ASN1_TEMPLATE_EX_D2I: u32 = 132;
pub const ASN1_F_ASN1_TEMPLATE_NEW: u32 = 133;
pub const ASN1_F_ASN1_TEMPLATE_NOEXP_D2I: u32 = 131;
pub const ASN1_F_ASN1_TIME_ADJ: u32 = 217;
pub const ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING: u32 = 134;
pub const ASN1_F_ASN1_TYPE_GET_OCTETSTRING: u32 = 135;
pub const ASN1_F_ASN1_UTCTIME_ADJ: u32 = 218;
pub const ASN1_F_ASN1_VERIFY: u32 = 137;
pub const ASN1_F_B64_READ_ASN1: u32 = 209;
pub const ASN1_F_B64_WRITE_ASN1: u32 = 210;
pub const ASN1_F_BIO_NEW_NDEF: u32 = 208;
pub const ASN1_F_BITSTR_CB: u32 = 180;
pub const ASN1_F_BN_TO_ASN1_STRING: u32 = 229;
pub const ASN1_F_C2I_ASN1_BIT_STRING: u32 = 189;
pub const ASN1_F_C2I_ASN1_INTEGER: u32 = 194;
pub const ASN1_F_C2I_ASN1_OBJECT: u32 = 196;
pub const ASN1_F_C2I_IBUF: u32 = 226;
pub const ASN1_F_C2I_UINT64_INT: u32 = 101;
pub const ASN1_F_COLLECT_DATA: u32 = 140;
pub const ASN1_F_D2I_ASN1_OBJECT: u32 = 147;
pub const ASN1_F_D2I_ASN1_UINTEGER: u32 = 150;
pub const ASN1_F_D2I_AUTOPRIVATEKEY: u32 = 207;
pub const ASN1_F_D2I_PRIVATEKEY: u32 = 154;
pub const ASN1_F_D2I_PUBLICKEY: u32 = 155;
pub const ASN1_F_DO_BUF: u32 = 142;
pub const ASN1_F_DO_CREATE: u32 = 124;
pub const ASN1_F_DO_DUMP: u32 = 125;
pub const ASN1_F_DO_TCREATE: u32 = 222;
pub const ASN1_F_I2A_ASN1_OBJECT: u32 = 126;
pub const ASN1_F_I2D_ASN1_BIO_STREAM: u32 = 211;
pub const ASN1_F_I2D_ASN1_OBJECT: u32 = 143;
pub const ASN1_F_I2D_DSA_PUBKEY: u32 = 161;
pub const ASN1_F_I2D_EC_PUBKEY: u32 = 181;
pub const ASN1_F_I2D_PRIVATEKEY: u32 = 163;
pub const ASN1_F_I2D_PUBLICKEY: u32 = 164;
pub const ASN1_F_I2D_RSA_PUBKEY: u32 = 165;
pub const ASN1_F_LONG_C2I: u32 = 166;
pub const ASN1_F_NDEF_PREFIX: u32 = 127;
pub const ASN1_F_NDEF_SUFFIX: u32 = 136;
pub const ASN1_F_OID_MODULE_INIT: u32 = 174;
pub const ASN1_F_PARSE_TAGGING: u32 = 182;
pub const ASN1_F_PKCS5_PBE2_SET_IV: u32 = 167;
pub const ASN1_F_PKCS5_PBE2_SET_SCRYPT: u32 = 231;
pub const ASN1_F_PKCS5_PBE_SET: u32 = 202;
pub const ASN1_F_PKCS5_PBE_SET0_ALGOR: u32 = 215;
pub const ASN1_F_PKCS5_PBKDF2_SET: u32 = 219;
pub const ASN1_F_PKCS5_SCRYPT_SET: u32 = 232;
pub const ASN1_F_SMIME_READ_ASN1: u32 = 212;
pub const ASN1_F_SMIME_TEXT: u32 = 213;
pub const ASN1_F_STABLE_GET: u32 = 138;
pub const ASN1_F_STBL_MODULE_INIT: u32 = 223;
pub const ASN1_F_UINT32_C2I: u32 = 105;
pub const ASN1_F_UINT32_NEW: u32 = 139;
pub const ASN1_F_UINT64_C2I: u32 = 112;
pub const ASN1_F_UINT64_NEW: u32 = 141;
pub const ASN1_F_X509_CRL_ADD0_REVOKED: u32 = 169;
pub const ASN1_F_X509_INFO_NEW: u32 = 170;
pub const ASN1_F_X509_NAME_ENCODE: u32 = 203;
pub const ASN1_F_X509_NAME_EX_D2I: u32 = 158;
pub const ASN1_F_X509_NAME_EX_NEW: u32 = 171;
pub const ASN1_F_X509_PKEY_NEW: u32 = 173;
pub const ASN1_R_ADDING_OBJECT: u32 = 171;
pub const ASN1_R_ASN1_PARSE_ERROR: u32 = 203;
pub const ASN1_R_ASN1_SIG_PARSE_ERROR: u32 = 204;
pub const ASN1_R_AUX_ERROR: u32 = 100;
pub const ASN1_R_BAD_OBJECT_HEADER: u32 = 102;
pub const ASN1_R_BAD_TEMPLATE: u32 = 230;
pub const ASN1_R_BMPSTRING_IS_WRONG_LENGTH: u32 = 214;
pub const ASN1_R_BN_LIB: u32 = 105;
pub const ASN1_R_BOOLEAN_IS_WRONG_LENGTH: u32 = 106;
pub const ASN1_R_BUFFER_TOO_SMALL: u32 = 107;
pub const ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER: u32 = 108;
pub const ASN1_R_CONTEXT_NOT_INITIALISED: u32 = 217;
pub const ASN1_R_DATA_IS_WRONG: u32 = 109;
pub const ASN1_R_DECODE_ERROR: u32 = 110;
pub const ASN1_R_DEPTH_EXCEEDED: u32 = 174;
pub const ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED: u32 = 198;
pub const ASN1_R_ENCODE_ERROR: u32 = 112;
pub const ASN1_R_ERROR_GETTING_TIME: u32 = 173;
pub const ASN1_R_ERROR_LOADING_SECTION: u32 = 172;
pub const ASN1_R_ERROR_SETTING_CIPHER_PARAMS: u32 = 114;
pub const ASN1_R_EXPECTING_AN_INTEGER: u32 = 115;
pub const ASN1_R_EXPECTING_AN_OBJECT: u32 = 116;
pub const ASN1_R_EXPLICIT_LENGTH_MISMATCH: u32 = 119;
pub const ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED: u32 = 120;
pub const ASN1_R_FIELD_MISSING: u32 = 121;
pub const ASN1_R_FIRST_NUM_TOO_LARGE: u32 = 122;
pub const ASN1_R_HEADER_TOO_LONG: u32 = 123;
pub const ASN1_R_ILLEGAL_BITSTRING_FORMAT: u32 = 175;
pub const ASN1_R_ILLEGAL_BOOLEAN: u32 = 176;
pub const ASN1_R_ILLEGAL_CHARACTERS: u32 = 124;
pub const ASN1_R_ILLEGAL_FORMAT: u32 = 177;
pub const ASN1_R_ILLEGAL_HEX: u32 = 178;
pub const ASN1_R_ILLEGAL_IMPLICIT_TAG: u32 = 179;
pub const ASN1_R_ILLEGAL_INTEGER: u32 = 180;
pub const ASN1_R_ILLEGAL_NEGATIVE_VALUE: u32 = 226;
pub const ASN1_R_ILLEGAL_NESTED_TAGGING: u32 = 181;
pub const ASN1_R_ILLEGAL_NULL: u32 = 125;
pub const ASN1_R_ILLEGAL_NULL_VALUE: u32 = 182;
pub const ASN1_R_ILLEGAL_OBJECT: u32 = 183;
pub const ASN1_R_ILLEGAL_OPTIONAL_ANY: u32 = 126;
pub const ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE: u32 = 170;
pub const ASN1_R_ILLEGAL_PADDING: u32 = 221;
pub const ASN1_R_ILLEGAL_TAGGED_ANY: u32 = 127;
pub const ASN1_R_ILLEGAL_TIME_VALUE: u32 = 184;
pub const ASN1_R_ILLEGAL_ZERO_CONTENT: u32 = 222;
pub const ASN1_R_INTEGER_NOT_ASCII_FORMAT: u32 = 185;
pub const ASN1_R_INTEGER_TOO_LARGE_FOR_LONG: u32 = 128;
pub const ASN1_R_INVALID_BIT_STRING_BITS_LEFT: u32 = 220;
pub const ASN1_R_INVALID_BMPSTRING_LENGTH: u32 = 129;
pub const ASN1_R_INVALID_DIGIT: u32 = 130;
pub const ASN1_R_INVALID_MIME_TYPE: u32 = 205;
pub const ASN1_R_INVALID_MODIFIER: u32 = 186;
pub const ASN1_R_INVALID_NUMBER: u32 = 187;
pub const ASN1_R_INVALID_OBJECT_ENCODING: u32 = 216;
pub const ASN1_R_INVALID_SCRYPT_PARAMETERS: u32 = 227;
pub const ASN1_R_INVALID_SEPARATOR: u32 = 131;
pub const ASN1_R_INVALID_STRING_TABLE_VALUE: u32 = 218;
pub const ASN1_R_INVALID_UNIVERSALSTRING_LENGTH: u32 = 133;
pub const ASN1_R_INVALID_UTF8STRING: u32 = 134;
pub const ASN1_R_INVALID_VALUE: u32 = 219;
pub const ASN1_R_LIST_ERROR: u32 = 188;
pub const ASN1_R_MIME_NO_CONTENT_TYPE: u32 = 206;
pub const ASN1_R_MIME_PARSE_ERROR: u32 = 207;
pub const ASN1_R_MIME_SIG_PARSE_ERROR: u32 = 208;
pub const ASN1_R_MISSING_EOC: u32 = 137;
pub const ASN1_R_MISSING_SECOND_NUMBER: u32 = 138;
pub const ASN1_R_MISSING_VALUE: u32 = 189;
pub const ASN1_R_MSTRING_NOT_UNIVERSAL: u32 = 139;
pub const ASN1_R_MSTRING_WRONG_TAG: u32 = 140;
pub const ASN1_R_NESTED_ASN1_STRING: u32 = 197;
pub const ASN1_R_NESTED_TOO_DEEP: u32 = 201;
pub const ASN1_R_NON_HEX_CHARACTERS: u32 = 141;
pub const ASN1_R_NOT_ASCII_FORMAT: u32 = 190;
pub const ASN1_R_NOT_ENOUGH_DATA: u32 = 142;
pub const ASN1_R_NO_CONTENT_TYPE: u32 = 209;
pub const ASN1_R_NO_MATCHING_CHOICE_TYPE: u32 = 143;
pub const ASN1_R_NO_MULTIPART_BODY_FAILURE: u32 = 210;
pub const ASN1_R_NO_MULTIPART_BOUNDARY: u32 = 211;
pub const ASN1_R_NO_SIG_CONTENT_TYPE: u32 = 212;
pub const ASN1_R_NULL_IS_WRONG_LENGTH: u32 = 144;
pub const ASN1_R_OBJECT_NOT_ASCII_FORMAT: u32 = 191;
pub const ASN1_R_ODD_NUMBER_OF_CHARS: u32 = 145;
pub const ASN1_R_SECOND_NUMBER_TOO_LARGE: u32 = 147;
pub const ASN1_R_SEQUENCE_LENGTH_MISMATCH: u32 = 148;
pub const ASN1_R_SEQUENCE_NOT_CONSTRUCTED: u32 = 149;
pub const ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG: u32 = 192;
pub const ASN1_R_SHORT_LINE: u32 = 150;
pub const ASN1_R_SIG_INVALID_MIME_TYPE: u32 = 213;
pub const ASN1_R_STREAMING_NOT_SUPPORTED: u32 = 202;
pub const ASN1_R_STRING_TOO_LONG: u32 = 151;
pub const ASN1_R_STRING_TOO_SHORT: u32 = 152;
pub const ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD: u32 = 154;
pub const ASN1_R_TIME_NOT_ASCII_FORMAT: u32 = 193;
pub const ASN1_R_TOO_LARGE: u32 = 223;
pub const ASN1_R_TOO_LONG: u32 = 155;
pub const ASN1_R_TOO_SMALL: u32 = 224;
pub const ASN1_R_TYPE_NOT_CONSTRUCTED: u32 = 156;
pub const ASN1_R_TYPE_NOT_PRIMITIVE: u32 = 195;
pub const ASN1_R_UNEXPECTED_EOC: u32 = 159;
pub const ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH: u32 = 215;
pub const ASN1_R_UNKNOWN_FORMAT: u32 = 160;
pub const ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM: u32 = 161;
pub const ASN1_R_UNKNOWN_OBJECT_TYPE: u32 = 162;
pub const ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE: u32 = 163;
pub const ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM: u32 = 199;
pub const ASN1_R_UNKNOWN_TAG: u32 = 194;
pub const ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE: u32 = 164;
pub const ASN1_R_UNSUPPORTED_CIPHER: u32 = 228;
pub const ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 167;
pub const ASN1_R_UNSUPPORTED_TYPE: u32 = 196;
pub const ASN1_R_WRONG_INTEGER_TYPE: u32 = 225;
pub const ASN1_R_WRONG_PUBLIC_KEY_TYPE: u32 = 200;
pub const ASN1_R_WRONG_TAG: u32 = 168;
pub const BN_F_BNRAND: u32 = 127;
pub const BN_F_BNRAND_RANGE: u32 = 138;
pub const BN_F_BN_BLINDING_CONVERT_EX: u32 = 100;
pub const BN_F_BN_BLINDING_CREATE_PARAM: u32 = 128;
pub const BN_F_BN_BLINDING_INVERT_EX: u32 = 101;
pub const BN_F_BN_BLINDING_NEW: u32 = 102;
pub const BN_F_BN_BLINDING_UPDATE: u32 = 103;
pub const BN_F_BN_BN2DEC: u32 = 104;
pub const BN_F_BN_BN2HEX: u32 = 105;
pub const BN_F_BN_COMPUTE_WNAF: u32 = 142;
pub const BN_F_BN_CTX_GET: u32 = 116;
pub const BN_F_BN_CTX_NEW: u32 = 106;
pub const BN_F_BN_CTX_START: u32 = 129;
pub const BN_F_BN_DIV: u32 = 107;
pub const BN_F_BN_DIV_RECP: u32 = 130;
pub const BN_F_BN_EXP: u32 = 123;
pub const BN_F_BN_EXPAND_INTERNAL: u32 = 120;
pub const BN_F_BN_GENCB_NEW: u32 = 143;
pub const BN_F_BN_GENERATE_DSA_NONCE: u32 = 140;
pub const BN_F_BN_GENERATE_PRIME_EX: u32 = 141;
pub const BN_F_BN_GF2M_MOD: u32 = 131;
pub const BN_F_BN_GF2M_MOD_EXP: u32 = 132;
pub const BN_F_BN_GF2M_MOD_MUL: u32 = 133;
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD: u32 = 134;
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR: u32 = 135;
pub const BN_F_BN_GF2M_MOD_SQR: u32 = 136;
pub const BN_F_BN_GF2M_MOD_SQRT: u32 = 137;
pub const BN_F_BN_LSHIFT: u32 = 145;
pub const BN_F_BN_MOD_EXP2_MONT: u32 = 118;
pub const BN_F_BN_MOD_EXP_MONT: u32 = 109;
pub const BN_F_BN_MOD_EXP_MONT_CONSTTIME: u32 = 124;
pub const BN_F_BN_MOD_EXP_MONT_WORD: u32 = 117;
pub const BN_F_BN_MOD_EXP_RECP: u32 = 125;
pub const BN_F_BN_MOD_EXP_SIMPLE: u32 = 126;
pub const BN_F_BN_MOD_INVERSE: u32 = 110;
pub const BN_F_BN_MOD_INVERSE_NO_BRANCH: u32 = 139;
pub const BN_F_BN_MOD_LSHIFT_QUICK: u32 = 119;
pub const BN_F_BN_MOD_SQRT: u32 = 121;
pub const BN_F_BN_MONT_CTX_NEW: u32 = 149;
pub const BN_F_BN_MPI2BN: u32 = 112;
pub const BN_F_BN_NEW: u32 = 113;
pub const BN_F_BN_POOL_GET: u32 = 147;
pub const BN_F_BN_RAND: u32 = 114;
pub const BN_F_BN_RAND_RANGE: u32 = 122;
pub const BN_F_BN_RECP_CTX_NEW: u32 = 150;
pub const BN_F_BN_RSHIFT: u32 = 146;
pub const BN_F_BN_SET_WORDS: u32 = 144;
pub const BN_F_BN_STACK_PUSH: u32 = 148;
pub const BN_F_BN_USUB: u32 = 115;
pub const BN_R_ARG2_LT_ARG3: u32 = 100;
pub const BN_R_BAD_RECIPROCAL: u32 = 101;
pub const BN_R_BIGNUM_TOO_LONG: u32 = 114;
pub const BN_R_BITS_TOO_SMALL: u32 = 118;
pub const BN_R_CALLED_WITH_EVEN_MODULUS: u32 = 102;
pub const BN_R_DIV_BY_ZERO: u32 = 103;
pub const BN_R_ENCODING_ERROR: u32 = 104;
pub const BN_R_EXPAND_ON_STATIC_BIGNUM_DATA: u32 = 105;
pub const BN_R_INPUT_NOT_REDUCED: u32 = 110;
pub const BN_R_INVALID_LENGTH: u32 = 106;
pub const BN_R_INVALID_RANGE: u32 = 115;
pub const BN_R_INVALID_SHIFT: u32 = 119;
pub const BN_R_NOT_A_SQUARE: u32 = 111;
pub const BN_R_NOT_INITIALIZED: u32 = 107;
pub const BN_R_NO_INVERSE: u32 = 108;
pub const BN_R_NO_SOLUTION: u32 = 116;
pub const BN_R_PRIVATE_KEY_TOO_LARGE: u32 = 117;
pub const BN_R_P_IS_NOT_PRIME: u32 = 112;
pub const BN_R_TOO_MANY_ITERATIONS: u32 = 113;
pub const BN_R_TOO_MANY_TEMPORARY_VARIABLES: u32 = 109;
pub const BN_BYTES: u32 = 8;
pub const BN_BITS2: u32 = 64;
pub const BN_BITS: u32 = 128;
pub const BN_FLG_MALLOCED: u32 = 1;
pub const BN_FLG_STATIC_DATA: u32 = 2;
pub const BN_FLG_CONSTTIME: u32 = 4;
pub const BN_FLG_SECURE: u32 = 8;
pub const BN_FLG_EXP_CONSTTIME: u32 = 4;
pub const BN_FLG_FREE: u32 = 32768;
pub const BN_RAND_TOP_ANY: i32 = -1;
pub const BN_RAND_TOP_ONE: u32 = 0;
pub const BN_RAND_TOP_TWO: u32 = 1;
pub const BN_RAND_BOTTOM_ANY: u32 = 0;
pub const BN_RAND_BOTTOM_ODD: u32 = 1;
pub const BN_prime_checks: u32 = 0;
pub const BN_BLINDING_NO_UPDATE: u32 = 1;
pub const BN_BLINDING_NO_RECREATE: u32 = 2;
pub const V_ASN1_UNIVERSAL: u32 = 0;
pub const V_ASN1_APPLICATION: u32 = 64;
pub const V_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const V_ASN1_PRIVATE: u32 = 192;
pub const V_ASN1_CONSTRUCTED: u32 = 32;
pub const V_ASN1_PRIMITIVE_TAG: u32 = 31;
pub const V_ASN1_PRIMATIVE_TAG: u32 = 31;
pub const V_ASN1_APP_CHOOSE: i32 = -2;
pub const V_ASN1_OTHER: i32 = -3;
pub const V_ASN1_ANY: i32 = -4;
pub const V_ASN1_UNDEF: i32 = -1;
pub const V_ASN1_EOC: u32 = 0;
pub const V_ASN1_BOOLEAN: u32 = 1;
pub const V_ASN1_INTEGER: u32 = 2;
pub const V_ASN1_BIT_STRING: u32 = 3;
pub const V_ASN1_OCTET_STRING: u32 = 4;
pub const V_ASN1_NULL: u32 = 5;
pub const V_ASN1_OBJECT: u32 = 6;
pub const V_ASN1_OBJECT_DESCRIPTOR: u32 = 7;
pub const V_ASN1_EXTERNAL: u32 = 8;
pub const V_ASN1_REAL: u32 = 9;
pub const V_ASN1_ENUMERATED: u32 = 10;
pub const V_ASN1_UTF8STRING: u32 = 12;
pub const V_ASN1_SEQUENCE: u32 = 16;
pub const V_ASN1_SET: u32 = 17;
pub const V_ASN1_NUMERICSTRING: u32 = 18;
pub const V_ASN1_PRINTABLESTRING: u32 = 19;
pub const V_ASN1_T61STRING: u32 = 20;
pub const V_ASN1_TELETEXSTRING: u32 = 20;
pub const V_ASN1_VIDEOTEXSTRING: u32 = 21;
pub const V_ASN1_IA5STRING: u32 = 22;
pub const V_ASN1_UTCTIME: u32 = 23;
pub const V_ASN1_GENERALIZEDTIME: u32 = 24;
pub const V_ASN1_GRAPHICSTRING: u32 = 25;
pub const V_ASN1_ISO64STRING: u32 = 26;
pub const V_ASN1_VISIBLESTRING: u32 = 26;
pub const V_ASN1_GENERALSTRING: u32 = 27;
pub const V_ASN1_UNIVERSALSTRING: u32 = 28;
pub const V_ASN1_BMPSTRING: u32 = 30;
pub const V_ASN1_NEG: u32 = 256;
pub const V_ASN1_NEG_INTEGER: u32 = 258;
pub const V_ASN1_NEG_ENUMERATED: u32 = 266;
pub const B_ASN1_NUMERICSTRING: u32 = 1;
pub const B_ASN1_PRINTABLESTRING: u32 = 2;
pub const B_ASN1_T61STRING: u32 = 4;
pub const B_ASN1_TELETEXSTRING: u32 = 4;
pub const B_ASN1_VIDEOTEXSTRING: u32 = 8;
pub const B_ASN1_IA5STRING: u32 = 16;
pub const B_ASN1_GRAPHICSTRING: u32 = 32;
pub const B_ASN1_ISO64STRING: u32 = 64;
pub const B_ASN1_VISIBLESTRING: u32 = 64;
pub const B_ASN1_GENERALSTRING: u32 = 128;
pub const B_ASN1_UNIVERSALSTRING: u32 = 256;
pub const B_ASN1_OCTET_STRING: u32 = 512;
pub const B_ASN1_BIT_STRING: u32 = 1024;
pub const B_ASN1_BMPSTRING: u32 = 2048;
pub const B_ASN1_UNKNOWN: u32 = 4096;
pub const B_ASN1_UTF8STRING: u32 = 8192;
pub const B_ASN1_UTCTIME: u32 = 16384;
pub const B_ASN1_GENERALIZEDTIME: u32 = 32768;
pub const B_ASN1_SEQUENCE: u32 = 65536;
pub const MBSTRING_FLAG: u32 = 4096;
pub const MBSTRING_UTF8: u32 = 4096;
pub const MBSTRING_ASC: u32 = 4097;
pub const MBSTRING_BMP: u32 = 4098;
pub const MBSTRING_UNIV: u32 = 4100;
pub const SMIME_OLDMIME: u32 = 1024;
pub const SMIME_CRLFEOL: u32 = 2048;
pub const SMIME_STREAM: u32 = 4096;
pub const ASN1_STRING_FLAG_BITS_LEFT: u32 = 8;
pub const ASN1_STRING_FLAG_NDEF: u32 = 16;
pub const ASN1_STRING_FLAG_CONT: u32 = 32;
pub const ASN1_STRING_FLAG_MSTRING: u32 = 64;
pub const ASN1_STRING_FLAG_EMBED: u32 = 128;
pub const ASN1_STRING_FLAG_X509_TIME: u32 = 256;
pub const ASN1_LONG_UNDEF: u32 = 2147483647;
pub const STABLE_FLAGS_MALLOC: u32 = 1;
pub const STABLE_FLAGS_CLEAR: u32 = 1;
pub const STABLE_NO_MASK: u32 = 2;
pub const DIRSTRING_TYPE: u32 = 10246;
pub const PKCS9STRING_TYPE: u32 = 10262;
pub const ub_name: u32 = 32768;
pub const ub_common_name: u32 = 64;
pub const ub_locality_name: u32 = 128;
pub const ub_state_name: u32 = 128;
pub const ub_organization_name: u32 = 64;
pub const ub_organization_unit_name: u32 = 64;
pub const ub_title: u32 = 64;
pub const ub_email_address: u32 = 128;
pub const ASN1_STRFLGS_ESC_2253: u32 = 1;
pub const ASN1_STRFLGS_ESC_CTRL: u32 = 2;
pub const ASN1_STRFLGS_ESC_MSB: u32 = 4;
pub const ASN1_STRFLGS_ESC_QUOTE: u32 = 8;
pub const CHARTYPE_PRINTABLESTRING: u32 = 16;
pub const CHARTYPE_FIRST_ESC_2253: u32 = 32;
pub const CHARTYPE_LAST_ESC_2253: u32 = 64;
pub const ASN1_STRFLGS_UTF8_CONVERT: u32 = 16;
pub const ASN1_STRFLGS_IGNORE_TYPE: u32 = 32;
pub const ASN1_STRFLGS_SHOW_TYPE: u32 = 64;
pub const ASN1_STRFLGS_DUMP_ALL: u32 = 128;
pub const ASN1_STRFLGS_DUMP_UNKNOWN: u32 = 256;
pub const ASN1_STRFLGS_DUMP_DER: u32 = 512;
pub const ASN1_STRFLGS_ESC_2254: u32 = 1024;
pub const ASN1_STRFLGS_RFC2253: u32 = 791;
pub const B_ASN1_TIME: u32 = 49152;
pub const B_ASN1_PRINTABLE: u32 = 81175;
pub const B_ASN1_DIRECTORYSTRING: u32 = 10502;
pub const B_ASN1_DISPLAYTEXT: u32 = 10320;
pub const ASN1_PCTX_FLAGS_SHOW_ABSENT: u32 = 1;
pub const ASN1_PCTX_FLAGS_SHOW_SEQUENCE: u32 = 2;
pub const ASN1_PCTX_FLAGS_SHOW_SSOF: u32 = 4;
pub const ASN1_PCTX_FLAGS_SHOW_TYPE: u32 = 8;
pub const ASN1_PCTX_FLAGS_NO_ANY_TYPE: u32 = 16;
pub const ASN1_PCTX_FLAGS_NO_MSTRING_TYPE: u32 = 32;
pub const ASN1_PCTX_FLAGS_NO_FIELD_NAME: u32 = 64;
pub const ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME: u32 = 128;
pub const ASN1_PCTX_FLAGS_NO_STRUCT_NAME: u32 = 256;
pub const OBJ_F_OBJ_ADD_OBJECT: u32 = 105;
pub const OBJ_F_OBJ_ADD_SIGID: u32 = 107;
pub const OBJ_F_OBJ_CREATE: u32 = 100;
pub const OBJ_F_OBJ_DUP: u32 = 101;
pub const OBJ_F_OBJ_NAME_NEW_INDEX: u32 = 106;
pub const OBJ_F_OBJ_NID2LN: u32 = 102;
pub const OBJ_F_OBJ_NID2OBJ: u32 = 103;
pub const OBJ_F_OBJ_NID2SN: u32 = 104;
pub const OBJ_F_OBJ_TXT2OBJ: u32 = 108;
pub const OBJ_R_OID_EXISTS: u32 = 102;
pub const OBJ_R_UNKNOWN_NID: u32 = 101;
pub const OBJ_NAME_TYPE_UNDEF: u32 = 0;
pub const OBJ_NAME_TYPE_MD_METH: u32 = 1;
pub const OBJ_NAME_TYPE_CIPHER_METH: u32 = 2;
pub const OBJ_NAME_TYPE_PKEY_METH: u32 = 3;
pub const OBJ_NAME_TYPE_COMP_METH: u32 = 4;
pub const OBJ_NAME_TYPE_NUM: u32 = 5;
pub const OBJ_NAME_ALIAS: u32 = 32768;
pub const OBJ_BSEARCH_VALUE_ON_NOMATCH: u32 = 1;
pub const OBJ_BSEARCH_FIRST_VALUE_ON_MATCH: u32 = 2;
pub const EVP_PK_RSA: u32 = 1;
pub const EVP_PK_DSA: u32 = 2;
pub const EVP_PK_DH: u32 = 4;
pub const EVP_PK_EC: u32 = 8;
pub const EVP_PKT_SIGN: u32 = 16;
pub const EVP_PKT_ENC: u32 = 32;
pub const EVP_PKT_EXCH: u32 = 64;
pub const EVP_PKS_RSA: u32 = 256;
pub const EVP_PKS_DSA: u32 = 512;
pub const EVP_PKS_EC: u32 = 1024;
pub const EVP_PKEY_NONE: u32 = 0;
pub const EVP_PKEY_RSA: u32 = 6;
pub const EVP_PKEY_RSA2: u32 = 19;
pub const EVP_PKEY_RSA_PSS: u32 = 912;
pub const EVP_PKEY_DSA: u32 = 116;
pub const EVP_PKEY_DSA1: u32 = 67;
pub const EVP_PKEY_DSA2: u32 = 66;
pub const EVP_PKEY_DSA3: u32 = 113;
pub const EVP_PKEY_DSA4: u32 = 70;
pub const EVP_PKEY_DH: u32 = 28;
pub const EVP_PKEY_DHX: u32 = 920;
pub const EVP_PKEY_EC: u32 = 408;
pub const EVP_PKEY_SM2: u32 = 1172;
pub const EVP_PKEY_HMAC: u32 = 855;
pub const EVP_PKEY_CMAC: u32 = 894;
pub const EVP_PKEY_SCRYPT: u32 = 973;
pub const EVP_PKEY_TLS1_PRF: u32 = 1021;
pub const EVP_PKEY_HKDF: u32 = 1036;
pub const EVP_PKEY_POLY1305: u32 = 1061;
pub const EVP_PKEY_SIPHASH: u32 = 1062;
pub const EVP_PKEY_X25519: u32 = 1034;
pub const EVP_PKEY_ED25519: u32 = 1087;
pub const EVP_PKEY_X448: u32 = 1035;
pub const EVP_PKEY_ED448: u32 = 1088;
pub const EVP_PKEY_MO_SIGN: u32 = 1;
pub const EVP_PKEY_MO_VERIFY: u32 = 2;
pub const EVP_PKEY_MO_ENCRYPT: u32 = 4;
pub const EVP_PKEY_MO_DECRYPT: u32 = 8;
pub const EVP_MD_FLAG_ONESHOT: u32 = 1;
pub const EVP_MD_FLAG_XOF: u32 = 2;
pub const EVP_MD_FLAG_DIGALGID_MASK: u32 = 24;
pub const EVP_MD_FLAG_DIGALGID_NULL: u32 = 0;
pub const EVP_MD_FLAG_DIGALGID_ABSENT: u32 = 8;
pub const EVP_MD_FLAG_DIGALGID_CUSTOM: u32 = 24;
pub const EVP_MD_FLAG_FIPS: u32 = 1024;
pub const EVP_MD_CTRL_DIGALGID: u32 = 1;
pub const EVP_MD_CTRL_MICALG: u32 = 2;
pub const EVP_MD_CTRL_XOF_LEN: u32 = 3;
pub const EVP_MD_CTRL_ALG_CTRL: u32 = 4096;
pub const EVP_MD_CTX_FLAG_ONESHOT: u32 = 1;
pub const EVP_MD_CTX_FLAG_CLEANED: u32 = 2;
pub const EVP_MD_CTX_FLAG_REUSE: u32 = 4;
pub const EVP_MD_CTX_FLAG_NON_FIPS_ALLOW: u32 = 8;
pub const EVP_MD_CTX_FLAG_PAD_MASK: u32 = 240;
pub const EVP_MD_CTX_FLAG_PAD_PKCS1: u32 = 0;
pub const EVP_MD_CTX_FLAG_PAD_X931: u32 = 16;
pub const EVP_MD_CTX_FLAG_PAD_PSS: u32 = 32;
pub const EVP_MD_CTX_FLAG_NO_INIT: u32 = 256;
pub const EVP_MD_CTX_FLAG_FINALISE: u32 = 512;
pub const EVP_CIPH_STREAM_CIPHER: u32 = 0;
pub const EVP_CIPH_ECB_MODE: u32 = 1;
pub const EVP_CIPH_CBC_MODE: u32 = 2;
pub const EVP_CIPH_CFB_MODE: u32 = 3;
pub const EVP_CIPH_OFB_MODE: u32 = 4;
pub const EVP_CIPH_CTR_MODE: u32 = 5;
pub const EVP_CIPH_GCM_MODE: u32 = 6;
pub const EVP_CIPH_CCM_MODE: u32 = 7;
pub const EVP_CIPH_XTS_MODE: u32 = 65537;
pub const EVP_CIPH_WRAP_MODE: u32 = 65538;
pub const EVP_CIPH_OCB_MODE: u32 = 65539;
pub const EVP_CIPH_MODE: u32 = 983047;
pub const EVP_CIPH_VARIABLE_LENGTH: u32 = 8;
pub const EVP_CIPH_CUSTOM_IV: u32 = 16;
pub const EVP_CIPH_ALWAYS_CALL_INIT: u32 = 32;
pub const EVP_CIPH_CTRL_INIT: u32 = 64;
pub const EVP_CIPH_CUSTOM_KEY_LENGTH: u32 = 128;
pub const EVP_CIPH_NO_PADDING: u32 = 256;
pub const EVP_CIPH_RAND_KEY: u32 = 512;
pub const EVP_CIPH_CUSTOM_COPY: u32 = 1024;
pub const EVP_CIPH_CUSTOM_IV_LENGTH: u32 = 2048;
pub const EVP_CIPH_FLAG_DEFAULT_ASN1: u32 = 4096;
pub const EVP_CIPH_FLAG_LENGTH_BITS: u32 = 8192;
pub const EVP_CIPH_FLAG_FIPS: u32 = 16384;
pub const EVP_CIPH_FLAG_NON_FIPS_ALLOW: u32 = 32768;
pub const EVP_CIPH_FLAG_CUSTOM_CIPHER: u32 = 1048576;
pub const EVP_CIPH_FLAG_AEAD_CIPHER: u32 = 2097152;
pub const EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK: u32 = 4194304;
pub const EVP_CIPH_FLAG_PIPELINE: u32 = 8388608;
pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW: u32 = 1;
pub const EVP_CTRL_INIT: u32 = 0;
pub const EVP_CTRL_SET_KEY_LENGTH: u32 = 1;
pub const EVP_CTRL_GET_RC2_KEY_BITS: u32 = 2;
pub const EVP_CTRL_SET_RC2_KEY_BITS: u32 = 3;
pub const EVP_CTRL_GET_RC5_ROUNDS: u32 = 4;
pub const EVP_CTRL_SET_RC5_ROUNDS: u32 = 5;
pub const EVP_CTRL_RAND_KEY: u32 = 6;
pub const EVP_CTRL_PBE_PRF_NID: u32 = 7;
pub const EVP_CTRL_COPY: u32 = 8;
pub const EVP_CTRL_AEAD_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_AEAD_GET_TAG: u32 = 16;
pub const EVP_CTRL_AEAD_SET_TAG: u32 = 17;
pub const EVP_CTRL_AEAD_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_GCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_GCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_GCM_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_IV_GEN: u32 = 19;
pub const EVP_CTRL_CCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_CCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_CCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_CCM_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_CCM_SET_L: u32 = 20;
pub const EVP_CTRL_CCM_SET_MSGLEN: u32 = 21;
pub const EVP_CTRL_AEAD_TLS1_AAD: u32 = 22;
pub const EVP_CTRL_AEAD_SET_MAC_KEY: u32 = 23;
pub const EVP_CTRL_GCM_SET_IV_INV: u32 = 24;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_AAD: u32 = 25;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT: u32 = 26;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT: u32 = 27;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE: u32 = 28;
pub const EVP_CTRL_SSL3_MASTER_SECRET: u32 = 29;
pub const EVP_CTRL_SET_SBOX: u32 = 30;
pub const EVP_CTRL_SBOX_USED: u32 = 31;
pub const EVP_CTRL_KEY_MESH: u32 = 32;
pub const EVP_CTRL_BLOCK_PADDING_MODE: u32 = 33;
pub const EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS: u32 = 34;
pub const EVP_CTRL_SET_PIPELINE_INPUT_BUFS: u32 = 35;
pub const EVP_CTRL_SET_PIPELINE_INPUT_LENS: u32 = 36;
pub const EVP_CTRL_GET_IVLEN: u32 = 37;
pub const EVP_PADDING_PKCS7: u32 = 1;
pub const EVP_PADDING_ISO7816_4: u32 = 2;
pub const EVP_PADDING_ANSI923: u32 = 3;
pub const EVP_PADDING_ISO10126: u32 = 4;
pub const EVP_PADDING_ZERO: u32 = 5;
pub const EVP_AEAD_TLS1_AAD_LEN: u32 = 13;
pub const EVP_GCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_GCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_GCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_CCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_CCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_CCM_TLS_IV_LEN: u32 = 12;
pub const EVP_CCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_CCM8_TLS_TAG_LEN: u32 = 8;
pub const EVP_CHACHAPOLY_TLS_TAG_LEN: u32 = 16;
pub const EVP_PBE_TYPE_OUTER: u32 = 0;
pub const EVP_PBE_TYPE_PRF: u32 = 1;
pub const EVP_PBE_TYPE_KDF: u32 = 2;
pub const ASN1_PKEY_ALIAS: u32 = 1;
pub const ASN1_PKEY_DYNAMIC: u32 = 2;
pub const ASN1_PKEY_SIGPARAM_NULL: u32 = 4;
pub const ASN1_PKEY_CTRL_PKCS7_SIGN: u32 = 1;
pub const ASN1_PKEY_CTRL_PKCS7_ENCRYPT: u32 = 2;
pub const ASN1_PKEY_CTRL_DEFAULT_MD_NID: u32 = 3;
pub const ASN1_PKEY_CTRL_CMS_SIGN: u32 = 5;
pub const ASN1_PKEY_CTRL_CMS_ENVELOPE: u32 = 7;
pub const ASN1_PKEY_CTRL_CMS_RI_TYPE: u32 = 8;
pub const ASN1_PKEY_CTRL_SET1_TLS_ENCPT: u32 = 9;
pub const ASN1_PKEY_CTRL_GET1_TLS_ENCPT: u32 = 10;
pub const EVP_PKEY_OP_UNDEFINED: u32 = 0;
pub const EVP_PKEY_OP_PARAMGEN: u32 = 2;
pub const EVP_PKEY_OP_KEYGEN: u32 = 4;
pub const EVP_PKEY_OP_SIGN: u32 = 8;
pub const EVP_PKEY_OP_VERIFY: u32 = 16;
pub const EVP_PKEY_OP_VERIFYRECOVER: u32 = 32;
pub const EVP_PKEY_OP_SIGNCTX: u32 = 64;
pub const EVP_PKEY_OP_VERIFYCTX: u32 = 128;
pub const EVP_PKEY_OP_ENCRYPT: u32 = 256;
pub const EVP_PKEY_OP_DECRYPT: u32 = 512;
pub const EVP_PKEY_OP_DERIVE: u32 = 1024;
pub const EVP_PKEY_OP_TYPE_SIG: u32 = 248;
pub const EVP_PKEY_OP_TYPE_CRYPT: u32 = 768;
pub const EVP_PKEY_OP_TYPE_NOGEN: u32 = 2040;
pub const EVP_PKEY_OP_TYPE_GEN: u32 = 6;
pub const EVP_PKEY_CTRL_MD: u32 = 1;
pub const EVP_PKEY_CTRL_PEER_KEY: u32 = 2;
pub const EVP_PKEY_CTRL_PKCS7_ENCRYPT: u32 = 3;
pub const EVP_PKEY_CTRL_PKCS7_DECRYPT: u32 = 4;
pub const EVP_PKEY_CTRL_PKCS7_SIGN: u32 = 5;
pub const EVP_PKEY_CTRL_SET_MAC_KEY: u32 = 6;
pub const EVP_PKEY_CTRL_DIGESTINIT: u32 = 7;
pub const EVP_PKEY_CTRL_SET_IV: u32 = 8;
pub const EVP_PKEY_CTRL_CMS_ENCRYPT: u32 = 9;
pub const EVP_PKEY_CTRL_CMS_DECRYPT: u32 = 10;
pub const EVP_PKEY_CTRL_CMS_SIGN: u32 = 11;
pub const EVP_PKEY_CTRL_CIPHER: u32 = 12;
pub const EVP_PKEY_CTRL_GET_MD: u32 = 13;
pub const EVP_PKEY_CTRL_SET_DIGEST_SIZE: u32 = 14;
pub const EVP_PKEY_ALG_CTRL: u32 = 4096;
pub const EVP_PKEY_FLAG_AUTOARGLEN: u32 = 2;
pub const EVP_PKEY_FLAG_SIGCTX_CUSTOM: u32 = 4;
pub const EC_F_BN_TO_FELEM: u32 = 224;
pub const EC_F_D2I_ECPARAMETERS: u32 = 144;
pub const EC_F_D2I_ECPKPARAMETERS: u32 = 145;
pub const EC_F_D2I_ECPRIVATEKEY: u32 = 146;
pub const EC_F_DO_EC_KEY_PRINT: u32 = 221;
pub const EC_F_ECDH_CMS_DECRYPT: u32 = 238;
pub const EC_F_ECDH_CMS_SET_SHARED_INFO: u32 = 239;
pub const EC_F_ECDH_COMPUTE_KEY: u32 = 246;
pub const EC_F_ECDH_SIMPLE_COMPUTE_KEY: u32 = 257;
pub const EC_F_ECDSA_DO_SIGN_EX: u32 = 251;
pub const EC_F_ECDSA_DO_VERIFY: u32 = 252;
pub const EC_F_ECDSA_SIGN_EX: u32 = 254;
pub const EC_F_ECDSA_SIGN_SETUP: u32 = 248;
pub const EC_F_ECDSA_SIG_NEW: u32 = 265;
pub const EC_F_ECDSA_VERIFY: u32 = 253;
pub const EC_F_ECD_ITEM_VERIFY: u32 = 270;
pub const EC_F_ECKEY_PARAM2TYPE: u32 = 223;
pub const EC_F_ECKEY_PARAM_DECODE: u32 = 212;
pub const EC_F_ECKEY_PRIV_DECODE: u32 = 213;
pub const EC_F_ECKEY_PRIV_ENCODE: u32 = 214;
pub const EC_F_ECKEY_PUB_DECODE: u32 = 215;
pub const EC_F_ECKEY_PUB_ENCODE: u32 = 216;
pub const EC_F_ECKEY_TYPE2PARAM: u32 = 220;
pub const EC_F_ECPARAMETERS_PRINT: u32 = 147;
pub const EC_F_ECPARAMETERS_PRINT_FP: u32 = 148;
pub const EC_F_ECPKPARAMETERS_PRINT: u32 = 149;
pub const EC_F_ECPKPARAMETERS_PRINT_FP: u32 = 150;
pub const EC_F_ECP_NISTZ256_GET_AFFINE: u32 = 240;
pub const EC_F_ECP_NISTZ256_INV_MOD_ORD: u32 = 275;
pub const EC_F_ECP_NISTZ256_MULT_PRECOMPUTE: u32 = 243;
pub const EC_F_ECP_NISTZ256_POINTS_MUL: u32 = 241;
pub const EC_F_ECP_NISTZ256_PRE_COMP_NEW: u32 = 244;
pub const EC_F_ECP_NISTZ256_WINDOWED_MUL: u32 = 242;
pub const EC_F_ECX_KEY_OP: u32 = 266;
pub const EC_F_ECX_PRIV_ENCODE: u32 = 267;
pub const EC_F_ECX_PUB_ENCODE: u32 = 268;
pub const EC_F_EC_ASN1_GROUP2CURVE: u32 = 153;
pub const EC_F_EC_ASN1_GROUP2FIELDID: u32 = 154;
pub const EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY: u32 = 208;
pub const EC_F_EC_GF2M_SIMPLE_FIELD_INV: u32 = 296;
pub const EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT: u32 = 159;
pub const EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE: u32 = 195;
pub const EC_F_EC_GF2M_SIMPLE_LADDER_POST: u32 = 285;
pub const EC_F_EC_GF2M_SIMPLE_LADDER_PRE: u32 = 288;
pub const EC_F_EC_GF2M_SIMPLE_OCT2POINT: u32 = 160;
pub const EC_F_EC_GF2M_SIMPLE_POINT2OCT: u32 = 161;
pub const EC_F_EC_GF2M_SIMPLE_POINTS_MUL: u32 = 289;
pub const EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES: u32 = 162;
pub const EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES: u32 = 163;
pub const EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES: u32 = 164;
pub const EC_F_EC_GFP_MONT_FIELD_DECODE: u32 = 133;
pub const EC_F_EC_GFP_MONT_FIELD_ENCODE: u32 = 134;
pub const EC_F_EC_GFP_MONT_FIELD_INV: u32 = 297;
pub const EC_F_EC_GFP_MONT_FIELD_MUL: u32 = 131;
pub const EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE: u32 = 209;
pub const EC_F_EC_GFP_MONT_FIELD_SQR: u32 = 132;
pub const EC_F_EC_GFP_MONT_GROUP_SET_CURVE: u32 = 189;
pub const EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE: u32 = 225;
pub const EC_F_EC_GFP_NISTP224_POINTS_MUL: u32 = 228;
pub const EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES: u32 = 226;
pub const EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE: u32 = 230;
pub const EC_F_EC_GFP_NISTP256_POINTS_MUL: u32 = 231;
pub const EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES: u32 = 232;
pub const EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE: u32 = 233;
pub const EC_F_EC_GFP_NISTP521_POINTS_MUL: u32 = 234;
pub const EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES: u32 = 235;
pub const EC_F_EC_GFP_NIST_FIELD_MUL: u32 = 200;
pub const EC_F_EC_GFP_NIST_FIELD_SQR: u32 = 201;
pub const EC_F_EC_GFP_NIST_GROUP_SET_CURVE: u32 = 202;
pub const EC_F_EC_GFP_SIMPLE_BLIND_COORDINATES: u32 = 287;
pub const EC_F_EC_GFP_SIMPLE_FIELD_INV: u32 = 298;
pub const EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT: u32 = 165;
pub const EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE: u32 = 166;
pub const EC_F_EC_GFP_SIMPLE_MAKE_AFFINE: u32 = 102;
pub const EC_F_EC_GFP_SIMPLE_OCT2POINT: u32 = 103;
pub const EC_F_EC_GFP_SIMPLE_POINT2OCT: u32 = 104;
pub const EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE: u32 = 137;
pub const EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES: u32 = 167;
pub const EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES: u32 = 168;
pub const EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES: u32 = 169;
pub const EC_F_EC_GROUP_CHECK: u32 = 170;
pub const EC_F_EC_GROUP_CHECK_DISCRIMINANT: u32 = 171;
pub const EC_F_EC_GROUP_COPY: u32 = 106;
pub const EC_F_EC_GROUP_GET_CURVE: u32 = 291;
pub const EC_F_EC_GROUP_GET_CURVE_GF2M: u32 = 172;
pub const EC_F_EC_GROUP_GET_CURVE_GFP: u32 = 130;
pub const EC_F_EC_GROUP_GET_DEGREE: u32 = 173;
pub const EC_F_EC_GROUP_GET_ECPARAMETERS: u32 = 261;
pub const EC_F_EC_GROUP_GET_ECPKPARAMETERS: u32 = 262;
pub const EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS: u32 = 193;
pub const EC_F_EC_GROUP_GET_TRINOMIAL_BASIS: u32 = 194;
pub const EC_F_EC_GROUP_NEW: u32 = 108;
pub const EC_F_EC_GROUP_NEW_BY_CURVE_NAME: u32 = 174;
pub const EC_F_EC_GROUP_NEW_FROM_DATA: u32 = 175;
pub const EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS: u32 = 263;
pub const EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS: u32 = 264;
pub const EC_F_EC_GROUP_SET_CURVE: u32 = 292;
pub const EC_F_EC_GROUP_SET_CURVE_GF2M: u32 = 176;
pub const EC_F_EC_GROUP_SET_CURVE_GFP: u32 = 109;
pub const EC_F_EC_GROUP_SET_GENERATOR: u32 = 111;
pub const EC_F_EC_GROUP_SET_SEED: u32 = 286;
pub const EC_F_EC_KEY_CHECK_KEY: u32 = 177;
pub const EC_F_EC_KEY_COPY: u32 = 178;
pub const EC_F_EC_KEY_GENERATE_KEY: u32 = 179;
pub const EC_F_EC_KEY_NEW: u32 = 182;
pub const EC_F_EC_KEY_NEW_METHOD: u32 = 245;
pub const EC_F_EC_KEY_OCT2PRIV: u32 = 255;
pub const EC_F_EC_KEY_PRINT: u32 = 180;
pub const EC_F_EC_KEY_PRINT_FP: u32 = 181;
pub const EC_F_EC_KEY_PRIV2BUF: u32 = 279;
pub const EC_F_EC_KEY_PRIV2OCT: u32 = 256;
pub const EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES: u32 = 229;
pub const EC_F_EC_KEY_SIMPLE_CHECK_KEY: u32 = 258;
pub const EC_F_EC_KEY_SIMPLE_OCT2PRIV: u32 = 259;
pub const EC_F_EC_KEY_SIMPLE_PRIV2OCT: u32 = 260;
pub const EC_F_EC_PKEY_CHECK: u32 = 273;
pub const EC_F_EC_PKEY_PARAM_CHECK: u32 = 274;
pub const EC_F_EC_POINTS_MAKE_AFFINE: u32 = 136;
pub const EC_F_EC_POINTS_MUL: u32 = 290;
pub const EC_F_EC_POINT_ADD: u32 = 112;
pub const EC_F_EC_POINT_BN2POINT: u32 = 280;
pub const EC_F_EC_POINT_CMP: u32 = 113;
pub const EC_F_EC_POINT_COPY: u32 = 114;
pub const EC_F_EC_POINT_DBL: u32 = 115;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES: u32 = 293;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M: u32 = 183;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP: u32 = 116;
pub const EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP: u32 = 117;
pub const EC_F_EC_POINT_INVERT: u32 = 210;
pub const EC_F_EC_POINT_IS_AT_INFINITY: u32 = 118;
pub const EC_F_EC_POINT_IS_ON_CURVE: u32 = 119;
pub const EC_F_EC_POINT_MAKE_AFFINE: u32 = 120;
pub const EC_F_EC_POINT_NEW: u32 = 121;
pub const EC_F_EC_POINT_OCT2POINT: u32 = 122;
pub const EC_F_EC_POINT_POINT2BUF: u32 = 281;
pub const EC_F_EC_POINT_POINT2OCT: u32 = 123;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES: u32 = 294;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M: u32 = 185;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP: u32 = 124;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES: u32 = 295;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M: u32 = 186;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP: u32 = 125;
pub const EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP: u32 = 126;
pub const EC_F_EC_POINT_SET_TO_INFINITY: u32 = 127;
pub const EC_F_EC_PRE_COMP_NEW: u32 = 196;
pub const EC_F_EC_SCALAR_MUL_LADDER: u32 = 284;
pub const EC_F_EC_WNAF_MUL: u32 = 187;
pub const EC_F_EC_WNAF_PRECOMPUTE_MULT: u32 = 188;
pub const EC_F_I2D_ECPARAMETERS: u32 = 190;
pub const EC_F_I2D_ECPKPARAMETERS: u32 = 191;
pub const EC_F_I2D_ECPRIVATEKEY: u32 = 192;
pub const EC_F_I2O_ECPUBLICKEY: u32 = 151;
pub const EC_F_NISTP224_PRE_COMP_NEW: u32 = 227;
pub const EC_F_NISTP256_PRE_COMP_NEW: u32 = 236;
pub const EC_F_NISTP521_PRE_COMP_NEW: u32 = 237;
pub const EC_F_O2I_ECPUBLICKEY: u32 = 152;
pub const EC_F_OLD_EC_PRIV_DECODE: u32 = 222;
pub const EC_F_OSSL_ECDH_COMPUTE_KEY: u32 = 247;
pub const EC_F_OSSL_ECDSA_SIGN_SIG: u32 = 249;
pub const EC_F_OSSL_ECDSA_VERIFY_SIG: u32 = 250;
pub const EC_F_PKEY_ECD_CTRL: u32 = 271;
pub const EC_F_PKEY_ECD_DIGESTSIGN: u32 = 272;
pub const EC_F_PKEY_ECD_DIGESTSIGN25519: u32 = 276;
pub const EC_F_PKEY_ECD_DIGESTSIGN448: u32 = 277;
pub const EC_F_PKEY_ECX_DERIVE: u32 = 269;
pub const EC_F_PKEY_EC_CTRL: u32 = 197;
pub const EC_F_PKEY_EC_CTRL_STR: u32 = 198;
pub const EC_F_PKEY_EC_DERIVE: u32 = 217;
pub const EC_F_PKEY_EC_INIT: u32 = 282;
pub const EC_F_PKEY_EC_KDF_DERIVE: u32 = 283;
pub const EC_F_PKEY_EC_KEYGEN: u32 = 199;
pub const EC_F_PKEY_EC_PARAMGEN: u32 = 219;
pub const EC_F_PKEY_EC_SIGN: u32 = 218;
pub const EC_F_VALIDATE_ECX_DERIVE: u32 = 278;
pub const EC_R_ASN1_ERROR: u32 = 115;
pub const EC_R_BAD_SIGNATURE: u32 = 156;
pub const EC_R_BIGNUM_OUT_OF_RANGE: u32 = 144;
pub const EC_R_BUFFER_TOO_SMALL: u32 = 100;
pub const EC_R_CANNOT_INVERT: u32 = 165;
pub const EC_R_COORDINATES_OUT_OF_RANGE: u32 = 146;
pub const EC_R_CURVE_DOES_NOT_SUPPORT_ECDH: u32 = 160;
pub const EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING: u32 = 159;
pub const EC_R_D2I_ECPKPARAMETERS_FAILURE: u32 = 117;
pub const EC_R_DECODE_ERROR: u32 = 142;
pub const EC_R_DISCRIMINANT_IS_ZERO: u32 = 118;
pub const EC_R_EC_GROUP_NEW_BY_NAME_FAILURE: u32 = 119;
pub const EC_R_FIELD_TOO_LARGE: u32 = 143;
pub const EC_R_GF2M_NOT_SUPPORTED: u32 = 147;
pub const EC_R_GROUP2PKPARAMETERS_FAILURE: u32 = 120;
pub const EC_R_I2D_ECPKPARAMETERS_FAILURE: u32 = 121;
pub const EC_R_INCOMPATIBLE_OBJECTS: u32 = 101;
pub const EC_R_INVALID_ARGUMENT: u32 = 112;
pub const EC_R_INVALID_COMPRESSED_POINT: u32 = 110;
pub const EC_R_INVALID_COMPRESSION_BIT: u32 = 109;
pub const EC_R_INVALID_CURVE: u32 = 141;
pub const EC_R_INVALID_DIGEST: u32 = 151;
pub const EC_R_INVALID_DIGEST_TYPE: u32 = 138;
pub const EC_R_INVALID_ENCODING: u32 = 102;
pub const EC_R_INVALID_FIELD: u32 = 103;
pub const EC_R_INVALID_FORM: u32 = 104;
pub const EC_R_INVALID_GROUP_ORDER: u32 = 122;
pub const EC_R_INVALID_KEY: u32 = 116;
pub const EC_R_INVALID_OUTPUT_LENGTH: u32 = 161;
pub const EC_R_INVALID_PEER_KEY: u32 = 133;
pub const EC_R_INVALID_PENTANOMIAL_BASIS: u32 = 132;
pub const EC_R_INVALID_PRIVATE_KEY: u32 = 123;
pub const EC_R_INVALID_TRINOMIAL_BASIS: u32 = 137;
pub const EC_R_KDF_PARAMETER_ERROR: u32 = 148;
pub const EC_R_KEYS_NOT_SET: u32 = 140;
pub const EC_R_LADDER_POST_FAILURE: u32 = 136;
pub const EC_R_LADDER_PRE_FAILURE: u32 = 153;
pub const EC_R_LADDER_STEP_FAILURE: u32 = 162;
pub const EC_R_MISSING_OID: u32 = 167;
pub const EC_R_MISSING_PARAMETERS: u32 = 124;
pub const EC_R_MISSING_PRIVATE_KEY: u32 = 125;
pub const EC_R_NEED_NEW_SETUP_VALUES: u32 = 157;
pub const EC_R_NOT_A_NIST_PRIME: u32 = 135;
pub const EC_R_NOT_IMPLEMENTED: u32 = 126;
pub const EC_R_NOT_INITIALIZED: u32 = 111;
pub const EC_R_NO_PARAMETERS_SET: u32 = 139;
pub const EC_R_NO_PRIVATE_VALUE: u32 = 154;
pub const EC_R_OPERATION_NOT_SUPPORTED: u32 = 152;
pub const EC_R_PASSED_NULL_PARAMETER: u32 = 134;
pub const EC_R_PEER_KEY_ERROR: u32 = 149;
pub const EC_R_PKPARAMETERS2GROUP_FAILURE: u32 = 127;
pub const EC_R_POINT_ARITHMETIC_FAILURE: u32 = 155;
pub const EC_R_POINT_AT_INFINITY: u32 = 106;
pub const EC_R_POINT_COORDINATES_BLIND_FAILURE: u32 = 163;
pub const EC_R_POINT_IS_NOT_ON_CURVE: u32 = 107;
pub const EC_R_RANDOM_NUMBER_GENERATION_FAILED: u32 = 158;
pub const EC_R_SHARED_INFO_ERROR: u32 = 150;
pub const EC_R_SLOT_FULL: u32 = 108;
pub const EC_R_UNDEFINED_GENERATOR: u32 = 113;
pub const EC_R_UNDEFINED_ORDER: u32 = 128;
pub const EC_R_UNKNOWN_COFACTOR: u32 = 164;
pub const EC_R_UNKNOWN_GROUP: u32 = 129;
pub const EC_R_UNKNOWN_ORDER: u32 = 114;
pub const EC_R_UNSUPPORTED_FIELD: u32 = 131;
pub const EC_R_WRONG_CURVE_PARAMETERS: u32 = 145;
pub const EC_R_WRONG_ORDER: u32 = 130;
pub const OPENSSL_ECC_MAX_FIELD_BITS: u32 = 661;
pub const OPENSSL_EC_EXPLICIT_CURVE: u32 = 0;
pub const OPENSSL_EC_NAMED_CURVE: u32 = 1;
pub const EC_PKEY_NO_PARAMETERS: u32 = 1;
pub const EC_PKEY_NO_PUBKEY: u32 = 2;
pub const EC_FLAG_NON_FIPS_ALLOW: u32 = 1;
pub const EC_FLAG_FIPS_CHECKED: u32 = 2;
pub const EC_FLAG_COFACTOR_ECDH: u32 = 4096;
pub const EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID: u32 = 4097;
pub const EVP_PKEY_CTRL_EC_PARAM_ENC: u32 = 4098;
pub const EVP_PKEY_CTRL_EC_ECDH_COFACTOR: u32 = 4099;
pub const EVP_PKEY_CTRL_EC_KDF_TYPE: u32 = 4100;
pub const EVP_PKEY_CTRL_EC_KDF_MD: u32 = 4101;
pub const EVP_PKEY_CTRL_GET_EC_KDF_MD: u32 = 4102;
pub const EVP_PKEY_CTRL_EC_KDF_OUTLEN: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN: u32 = 4104;
pub const EVP_PKEY_CTRL_EC_KDF_UKM: u32 = 4105;
pub const EVP_PKEY_CTRL_GET_EC_KDF_UKM: u32 = 4106;
pub const EVP_PKEY_CTRL_SET1_ID: u32 = 4107;
pub const EVP_PKEY_CTRL_GET1_ID: u32 = 4108;
pub const EVP_PKEY_CTRL_GET1_ID_LEN: u32 = 4109;
pub const EVP_PKEY_ECDH_KDF_NONE: u32 = 1;
pub const EVP_PKEY_ECDH_KDF_X9_63: u32 = 2;
pub const EVP_PKEY_ECDH_KDF_X9_62: u32 = 2;
pub const RSA_F_CHECK_PADDING_MD: u32 = 140;
pub const RSA_F_ENCODE_PKCS1: u32 = 146;
pub const RSA_F_INT_RSA_VERIFY: u32 = 145;
pub const RSA_F_OLD_RSA_PRIV_DECODE: u32 = 147;
pub const RSA_F_PKEY_PSS_INIT: u32 = 165;
pub const RSA_F_PKEY_RSA_CTRL: u32 = 143;
pub const RSA_F_PKEY_RSA_CTRL_STR: u32 = 144;
pub const RSA_F_PKEY_RSA_SIGN: u32 = 142;
pub const RSA_F_PKEY_RSA_VERIFY: u32 = 149;
pub const RSA_F_PKEY_RSA_VERIFYRECOVER: u32 = 141;
pub const RSA_F_RSA_ALGOR_TO_MD: u32 = 156;
pub const RSA_F_RSA_BUILTIN_KEYGEN: u32 = 129;
pub const RSA_F_RSA_CHECK_KEY: u32 = 123;
pub const RSA_F_RSA_CHECK_KEY_EX: u32 = 160;
pub const RSA_F_RSA_CMS_DECRYPT: u32 = 159;
pub const RSA_F_RSA_CMS_VERIFY: u32 = 158;
pub const RSA_F_RSA_ITEM_VERIFY: u32 = 148;
pub const RSA_F_RSA_METH_DUP: u32 = 161;
pub const RSA_F_RSA_METH_NEW: u32 = 162;
pub const RSA_F_RSA_METH_SET1_NAME: u32 = 163;
pub const RSA_F_RSA_MGF1_TO_MD: u32 = 157;
pub const RSA_F_RSA_MULTIP_INFO_NEW: u32 = 166;
pub const RSA_F_RSA_NEW_METHOD: u32 = 106;
pub const RSA_F_RSA_NULL: u32 = 124;
pub const RSA_F_RSA_NULL_PRIVATE_DECRYPT: u32 = 132;
pub const RSA_F_RSA_NULL_PRIVATE_ENCRYPT: u32 = 133;
pub const RSA_F_RSA_NULL_PUBLIC_DECRYPT: u32 = 134;
pub const RSA_F_RSA_NULL_PUBLIC_ENCRYPT: u32 = 135;
pub const RSA_F_RSA_OSSL_PRIVATE_DECRYPT: u32 = 101;
pub const RSA_F_RSA_OSSL_PRIVATE_ENCRYPT: u32 = 102;
pub const RSA_F_RSA_OSSL_PUBLIC_DECRYPT: u32 = 103;
pub const RSA_F_RSA_OSSL_PUBLIC_ENCRYPT: u32 = 104;
pub const RSA_F_RSA_PADDING_ADD_NONE: u32 = 107;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP: u32 = 121;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1: u32 = 154;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS: u32 = 125;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1: u32 = 152;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1: u32 = 108;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2: u32 = 109;
pub const RSA_F_RSA_PADDING_ADD_SSLV23: u32 = 110;
pub const RSA_F_RSA_PADDING_ADD_X931: u32 = 127;
pub const RSA_F_RSA_PADDING_CHECK_NONE: u32 = 111;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP: u32 = 122;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1: u32 = 153;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1: u32 = 112;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2: u32 = 113;
pub const RSA_F_RSA_PADDING_CHECK_SSLV23: u32 = 114;
pub const RSA_F_RSA_PADDING_CHECK_X931: u32 = 128;
pub const RSA_F_RSA_PARAM_DECODE: u32 = 164;
pub const RSA_F_RSA_PRINT: u32 = 115;
pub const RSA_F_RSA_PRINT_FP: u32 = 116;
pub const RSA_F_RSA_PRIV_DECODE: u32 = 150;
pub const RSA_F_RSA_PRIV_ENCODE: u32 = 138;
pub const RSA_F_RSA_PSS_GET_PARAM: u32 = 151;
pub const RSA_F_RSA_PSS_TO_CTX: u32 = 155;
pub const RSA_F_RSA_PUB_DECODE: u32 = 139;
pub const RSA_F_RSA_SETUP_BLINDING: u32 = 136;
pub const RSA_F_RSA_SIGN: u32 = 117;
pub const RSA_F_RSA_SIGN_ASN1_OCTET_STRING: u32 = 118;
pub const RSA_F_RSA_VERIFY: u32 = 119;
pub const RSA_F_RSA_VERIFY_ASN1_OCTET_STRING: u32 = 120;
pub const RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1: u32 = 126;
pub const RSA_F_SETUP_TBUF: u32 = 167;
pub const RSA_R_ALGORITHM_MISMATCH: u32 = 100;
pub const RSA_R_BAD_E_VALUE: u32 = 101;
pub const RSA_R_BAD_FIXED_HEADER_DECRYPT: u32 = 102;
pub const RSA_R_BAD_PAD_BYTE_COUNT: u32 = 103;
pub const RSA_R_BAD_SIGNATURE: u32 = 104;
pub const RSA_R_BLOCK_TYPE_IS_NOT_01: u32 = 106;
pub const RSA_R_BLOCK_TYPE_IS_NOT_02: u32 = 107;
pub const RSA_R_DATA_GREATER_THAN_MOD_LEN: u32 = 108;
pub const RSA_R_DATA_TOO_LARGE: u32 = 109;
pub const RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE: u32 = 110;
pub const RSA_R_DATA_TOO_LARGE_FOR_MODULUS: u32 = 132;
pub const RSA_R_DATA_TOO_SMALL: u32 = 111;
pub const RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE: u32 = 122;
pub const RSA_R_DIGEST_DOES_NOT_MATCH: u32 = 158;
pub const RSA_R_DIGEST_NOT_ALLOWED: u32 = 145;
pub const RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY: u32 = 112;
pub const RSA_R_DMP1_NOT_CONGRUENT_TO_D: u32 = 124;
pub const RSA_R_DMQ1_NOT_CONGRUENT_TO_D: u32 = 125;
pub const RSA_R_D_E_NOT_CONGRUENT_TO_1: u32 = 123;
pub const RSA_R_FIRST_OCTET_INVALID: u32 = 133;
pub const RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE: u32 = 144;
pub const RSA_R_INVALID_DIGEST: u32 = 157;
pub const RSA_R_INVALID_DIGEST_LENGTH: u32 = 143;
pub const RSA_R_INVALID_HEADER: u32 = 137;
pub const RSA_R_INVALID_LABEL: u32 = 160;
pub const RSA_R_INVALID_MESSAGE_LENGTH: u32 = 131;
pub const RSA_R_INVALID_MGF1_MD: u32 = 156;
pub const RSA_R_INVALID_MULTI_PRIME_KEY: u32 = 167;
pub const RSA_R_INVALID_OAEP_PARAMETERS: u32 = 161;
pub const RSA_R_INVALID_PADDING: u32 = 138;
pub const RSA_R_INVALID_PADDING_MODE: u32 = 141;
pub const RSA_R_INVALID_PSS_PARAMETERS: u32 = 149;
pub const RSA_R_INVALID_PSS_SALTLEN: u32 = 146;
pub const RSA_R_INVALID_SALT_LENGTH: u32 = 150;
pub const RSA_R_INVALID_TRAILER: u32 = 139;
pub const RSA_R_INVALID_X931_DIGEST: u32 = 142;
pub const RSA_R_IQMP_NOT_INVERSE_OF_Q: u32 = 126;
pub const RSA_R_KEY_PRIME_NUM_INVALID: u32 = 165;
pub const RSA_R_KEY_SIZE_TOO_SMALL: u32 = 120;
pub const RSA_R_LAST_OCTET_INVALID: u32 = 134;
pub const RSA_R_MISSING_PRIVATE_KEY: u32 = 179;
pub const RSA_R_MGF1_DIGEST_NOT_ALLOWED: u32 = 152;
pub const RSA_R_MODULUS_TOO_LARGE: u32 = 105;
pub const RSA_R_MP_COEFFICIENT_NOT_INVERSE_OF_R: u32 = 168;
pub const RSA_R_MP_EXPONENT_NOT_CONGRUENT_TO_D: u32 = 169;
pub const RSA_R_MP_R_NOT_PRIME: u32 = 170;
pub const RSA_R_NO_PUBLIC_EXPONENT: u32 = 140;
pub const RSA_R_NULL_BEFORE_BLOCK_MISSING: u32 = 113;
pub const RSA_R_N_DOES_NOT_EQUAL_PRODUCT_OF_PRIMES: u32 = 172;
pub const RSA_R_N_DOES_NOT_EQUAL_P_Q: u32 = 127;
pub const RSA_R_OAEP_DECODING_ERROR: u32 = 121;
pub const RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 148;
pub const RSA_R_PADDING_CHECK_FAILED: u32 = 114;
pub const RSA_R_PKCS_DECODING_ERROR: u32 = 159;
pub const RSA_R_PSS_SALTLEN_TOO_SMALL: u32 = 164;
pub const RSA_R_P_NOT_PRIME: u32 = 128;
pub const RSA_R_Q_NOT_PRIME: u32 = 129;
pub const RSA_R_RSA_OPERATIONS_NOT_SUPPORTED: u32 = 130;
pub const RSA_R_SLEN_CHECK_FAILED: u32 = 136;
pub const RSA_R_SLEN_RECOVERY_FAILED: u32 = 135;
pub const RSA_R_SSLV3_ROLLBACK_ATTACK: u32 = 115;
pub const RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD: u32 = 116;
pub const RSA_R_UNKNOWN_ALGORITHM_TYPE: u32 = 117;
pub const RSA_R_UNKNOWN_DIGEST: u32 = 166;
pub const RSA_R_UNKNOWN_MASK_DIGEST: u32 = 151;
pub const RSA_R_UNKNOWN_PADDING_TYPE: u32 = 118;
pub const RSA_R_UNSUPPORTED_ENCRYPTION_TYPE: u32 = 162;
pub const RSA_R_UNSUPPORTED_LABEL_SOURCE: u32 = 163;
pub const RSA_R_UNSUPPORTED_MASK_ALGORITHM: u32 = 153;
pub const RSA_R_UNSUPPORTED_MASK_PARAMETER: u32 = 154;
pub const RSA_R_UNSUPPORTED_SIGNATURE_TYPE: u32 = 155;
pub const RSA_R_VALUE_MISSING: u32 = 147;
pub const RSA_R_WRONG_SIGNATURE_LENGTH: u32 = 119;
pub const OPENSSL_RSA_MAX_MODULUS_BITS: u32 = 16384;
pub const OPENSSL_RSA_FIPS_MIN_MODULUS_BITS: u32 = 1024;
pub const OPENSSL_RSA_SMALL_MODULUS_BITS: u32 = 3072;
pub const OPENSSL_RSA_MAX_PUBEXP_BITS: u32 = 64;
pub const RSA_3: u32 = 3;
pub const RSA_F4: u32 = 65537;
pub const RSA_ASN1_VERSION_DEFAULT: u32 = 0;
pub const RSA_ASN1_VERSION_MULTI: u32 = 1;
pub const RSA_DEFAULT_PRIME_NUM: u32 = 2;
pub const RSA_METHOD_FLAG_NO_CHECK: u32 = 1;
pub const RSA_FLAG_CACHE_PUBLIC: u32 = 2;
pub const RSA_FLAG_CACHE_PRIVATE: u32 = 4;
pub const RSA_FLAG_BLINDING: u32 = 8;
pub const RSA_FLAG_THREAD_SAFE: u32 = 16;
pub const RSA_FLAG_EXT_PKEY: u32 = 32;
pub const RSA_FLAG_NO_BLINDING: u32 = 128;
pub const RSA_FLAG_NO_CONSTTIME: u32 = 0;
pub const RSA_FLAG_NO_EXP_CONSTTIME: u32 = 0;
pub const RSA_PSS_SALTLEN_DIGEST: i32 = -1;
pub const RSA_PSS_SALTLEN_AUTO: i32 = -2;
pub const RSA_PSS_SALTLEN_MAX: i32 = -3;
pub const RSA_PSS_SALTLEN_MAX_SIGN: i32 = -2;
pub const EVP_PKEY_CTRL_RSA_PADDING: u32 = 4097;
pub const EVP_PKEY_CTRL_RSA_PSS_SALTLEN: u32 = 4098;
pub const EVP_PKEY_CTRL_RSA_KEYGEN_BITS: u32 = 4099;
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP: u32 = 4100;
pub const EVP_PKEY_CTRL_RSA_MGF1_MD: u32 = 4101;
pub const EVP_PKEY_CTRL_GET_RSA_PADDING: u32 = 4102;
pub const EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_RSA_MGF1_MD: u32 = 4104;
pub const EVP_PKEY_CTRL_RSA_OAEP_MD: u32 = 4105;
pub const EVP_PKEY_CTRL_RSA_OAEP_LABEL: u32 = 4106;
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_MD: u32 = 4107;
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL: u32 = 4108;
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES: u32 = 4109;
pub const RSA_PKCS1_PADDING: u32 = 1;
pub const RSA_SSLV23_PADDING: u32 = 2;
pub const RSA_NO_PADDING: u32 = 3;
pub const RSA_PKCS1_OAEP_PADDING: u32 = 4;
pub const RSA_X931_PADDING: u32 = 5;
pub const RSA_PKCS1_PSS_PADDING: u32 = 6;
pub const RSA_PKCS1_PADDING_SIZE: u32 = 11;
pub const RSA_FLAG_FIPS_METHOD: u32 = 1024;
pub const RSA_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const RSA_FLAG_CHECKED: u32 = 2048;
pub const DH_F_COMPUTE_KEY: u32 = 102;
pub const DH_F_DHPARAMS_PRINT_FP: u32 = 101;
pub const DH_F_DH_BUILTIN_GENPARAMS: u32 = 106;
pub const DH_F_DH_CHECK_EX: u32 = 121;
pub const DH_F_DH_CHECK_PARAMS_EX: u32 = 122;
pub const DH_F_DH_CHECK_PUB_KEY_EX: u32 = 123;
pub const DH_F_DH_CMS_DECRYPT: u32 = 114;
pub const DH_F_DH_CMS_SET_PEERKEY: u32 = 115;
pub const DH_F_DH_CMS_SET_SHARED_INFO: u32 = 116;
pub const DH_F_DH_METH_DUP: u32 = 117;
pub const DH_F_DH_METH_NEW: u32 = 118;
pub const DH_F_DH_METH_SET1_NAME: u32 = 119;
pub const DH_F_DH_NEW_BY_NID: u32 = 104;
pub const DH_F_DH_NEW_METHOD: u32 = 105;
pub const DH_F_DH_PARAM_DECODE: u32 = 107;
pub const DH_F_DH_PKEY_PUBLIC_CHECK: u32 = 124;
pub const DH_F_DH_PRIV_DECODE: u32 = 110;
pub const DH_F_DH_PRIV_ENCODE: u32 = 111;
pub const DH_F_DH_PUB_DECODE: u32 = 108;
pub const DH_F_DH_PUB_ENCODE: u32 = 109;
pub const DH_F_DO_DH_PRINT: u32 = 100;
pub const DH_F_GENERATE_KEY: u32 = 103;
pub const DH_F_PKEY_DH_CTRL_STR: u32 = 120;
pub const DH_F_PKEY_DH_DERIVE: u32 = 112;
pub const DH_F_PKEY_DH_INIT: u32 = 125;
pub const DH_F_PKEY_DH_KEYGEN: u32 = 113;
pub const DH_R_BAD_GENERATOR: u32 = 101;
pub const DH_R_BN_DECODE_ERROR: u32 = 109;
pub const DH_R_BN_ERROR: u32 = 106;
pub const DH_R_CHECK_INVALID_J_VALUE: u32 = 115;
pub const DH_R_CHECK_INVALID_Q_VALUE: u32 = 116;
pub const DH_R_CHECK_PUBKEY_INVALID: u32 = 122;
pub const DH_R_CHECK_PUBKEY_TOO_LARGE: u32 = 123;
pub const DH_R_CHECK_PUBKEY_TOO_SMALL: u32 = 124;
pub const DH_R_CHECK_P_NOT_PRIME: u32 = 117;
pub const DH_R_CHECK_P_NOT_SAFE_PRIME: u32 = 118;
pub const DH_R_CHECK_Q_NOT_PRIME: u32 = 119;
pub const DH_R_DECODE_ERROR: u32 = 104;
pub const DH_R_INVALID_PARAMETER_NAME: u32 = 110;
pub const DH_R_INVALID_PARAMETER_NID: u32 = 114;
pub const DH_R_INVALID_PUBKEY: u32 = 102;
pub const DH_R_KDF_PARAMETER_ERROR: u32 = 112;
pub const DH_R_KEYS_NOT_SET: u32 = 108;
pub const DH_R_MISSING_PUBKEY: u32 = 125;
pub const DH_R_MODULUS_TOO_LARGE: u32 = 103;
pub const DH_R_NOT_SUITABLE_GENERATOR: u32 = 120;
pub const DH_R_NO_PARAMETERS_SET: u32 = 107;
pub const DH_R_NO_PRIVATE_VALUE: u32 = 100;
pub const DH_R_PARAMETER_ENCODING_ERROR: u32 = 105;
pub const DH_R_PEER_KEY_ERROR: u32 = 111;
pub const DH_R_SHARED_INFO_ERROR: u32 = 113;
pub const DH_R_UNABLE_TO_CHECK_GENERATOR: u32 = 121;
pub const OPENSSL_DH_MAX_MODULUS_BITS: u32 = 10000;
pub const OPENSSL_DH_FIPS_MIN_MODULUS_BITS: u32 = 1024;
pub const DH_FLAG_CACHE_MONT_P: u32 = 1;
pub const DH_FLAG_NO_EXP_CONSTTIME: u32 = 0;
pub const DH_FLAG_FIPS_METHOD: u32 = 1024;
pub const DH_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const DH_GENERATOR_2: u32 = 2;
pub const DH_GENERATOR_5: u32 = 5;
pub const DH_CHECK_P_NOT_PRIME: u32 = 1;
pub const DH_CHECK_P_NOT_SAFE_PRIME: u32 = 2;
pub const DH_UNABLE_TO_CHECK_GENERATOR: u32 = 4;
pub const DH_NOT_SUITABLE_GENERATOR: u32 = 8;
pub const DH_CHECK_Q_NOT_PRIME: u32 = 16;
pub const DH_CHECK_INVALID_Q_VALUE: u32 = 32;
pub const DH_CHECK_INVALID_J_VALUE: u32 = 64;
pub const DH_CHECK_PUBKEY_TOO_SMALL: u32 = 1;
pub const DH_CHECK_PUBKEY_TOO_LARGE: u32 = 2;
pub const DH_CHECK_PUBKEY_INVALID: u32 = 4;
pub const DH_CHECK_P_NOT_STRONG_PRIME: u32 = 2;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN: u32 = 4097;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR: u32 = 4098;
pub const EVP_PKEY_CTRL_DH_RFC5114: u32 = 4099;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN: u32 = 4100;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_TYPE: u32 = 4101;
pub const EVP_PKEY_CTRL_DH_KDF_TYPE: u32 = 4102;
pub const EVP_PKEY_CTRL_DH_KDF_MD: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_DH_KDF_MD: u32 = 4104;
pub const EVP_PKEY_CTRL_DH_KDF_OUTLEN: u32 = 4105;
pub const EVP_PKEY_CTRL_GET_DH_KDF_OUTLEN: u32 = 4106;
pub const EVP_PKEY_CTRL_DH_KDF_UKM: u32 = 4107;
pub const EVP_PKEY_CTRL_GET_DH_KDF_UKM: u32 = 4108;
pub const EVP_PKEY_CTRL_DH_KDF_OID: u32 = 4109;
pub const EVP_PKEY_CTRL_GET_DH_KDF_OID: u32 = 4110;
pub const EVP_PKEY_CTRL_DH_NID: u32 = 4111;
pub const EVP_PKEY_CTRL_DH_PAD: u32 = 4112;
pub const EVP_PKEY_DH_KDF_NONE: u32 = 1;
pub const EVP_PKEY_DH_KDF_X9_42: u32 = 2;
pub const DSA_F_DSAPARAMS_PRINT: u32 = 100;
pub const DSA_F_DSAPARAMS_PRINT_FP: u32 = 101;
pub const DSA_F_DSA_BUILTIN_PARAMGEN: u32 = 125;
pub const DSA_F_DSA_BUILTIN_PARAMGEN2: u32 = 126;
pub const DSA_F_DSA_DO_SIGN: u32 = 112;
pub const DSA_F_DSA_DO_VERIFY: u32 = 113;
pub const DSA_F_DSA_METH_DUP: u32 = 127;
pub const DSA_F_DSA_METH_NEW: u32 = 128;
pub const DSA_F_DSA_METH_SET1_NAME: u32 = 129;
pub const DSA_F_DSA_NEW_METHOD: u32 = 103;
pub const DSA_F_DSA_PARAM_DECODE: u32 = 119;
pub const DSA_F_DSA_PRINT_FP: u32 = 105;
pub const DSA_F_DSA_PRIV_DECODE: u32 = 115;
pub const DSA_F_DSA_PRIV_ENCODE: u32 = 116;
pub const DSA_F_DSA_PUB_DECODE: u32 = 117;
pub const DSA_F_DSA_PUB_ENCODE: u32 = 118;
pub const DSA_F_DSA_SIGN: u32 = 106;
pub const DSA_F_DSA_SIGN_SETUP: u32 = 107;
pub const DSA_F_DSA_SIG_NEW: u32 = 102;
pub const DSA_F_OLD_DSA_PRIV_DECODE: u32 = 122;
pub const DSA_F_PKEY_DSA_CTRL: u32 = 120;
pub const DSA_F_PKEY_DSA_CTRL_STR: u32 = 104;
pub const DSA_F_PKEY_DSA_KEYGEN: u32 = 121;
pub const DSA_R_BAD_Q_VALUE: u32 = 102;
pub const DSA_R_BN_DECODE_ERROR: u32 = 108;
pub const DSA_R_BN_ERROR: u32 = 109;
pub const DSA_R_DECODE_ERROR: u32 = 104;
pub const DSA_R_INVALID_DIGEST_TYPE: u32 = 106;
pub const DSA_R_INVALID_PARAMETERS: u32 = 112;
pub const DSA_R_MISSING_PARAMETERS: u32 = 101;
pub const DSA_R_MISSING_PRIVATE_KEY: u32 = 111;
pub const DSA_R_MODULUS_TOO_LARGE: u32 = 103;
pub const DSA_R_NO_PARAMETERS_SET: u32 = 107;
pub const DSA_R_PARAMETER_ENCODING_ERROR: u32 = 105;
pub const DSA_R_Q_NOT_PRIME: u32 = 113;
pub const DSA_R_SEED_LEN_SMALL: u32 = 110;
pub const OPENSSL_DSA_MAX_MODULUS_BITS: u32 = 10000;
pub const OPENSSL_DSA_FIPS_MIN_MODULUS_BITS: u32 = 1024;
pub const DSA_FLAG_CACHE_MONT_P: u32 = 1;
pub const DSA_FLAG_NO_EXP_CONSTTIME: u32 = 0;
pub const DSA_FLAG_FIPS_METHOD: u32 = 1024;
pub const DSA_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const DSA_FLAG_FIPS_CHECKED: u32 = 2048;
pub const DSS_prime_checks: u32 = 64;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_BITS: u32 = 4097;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS: u32 = 4098;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_MD: u32 = 4099;
pub const SHA_LBLOCK: u32 = 16;
pub const SHA_CBLOCK: u32 = 64;
pub const SHA_LAST_BLOCK: u32 = 56;
pub const SHA_DIGEST_LENGTH: u32 = 20;
pub const SHA256_CBLOCK: u32 = 64;
pub const SHA224_DIGEST_LENGTH: u32 = 28;
pub const SHA256_DIGEST_LENGTH: u32 = 32;
pub const SHA384_DIGEST_LENGTH: u32 = 48;
pub const SHA512_DIGEST_LENGTH: u32 = 64;
pub const SHA512_CBLOCK: u32 = 128;
pub const X509_F_ADD_CERT_DIR: u32 = 100;
pub const X509_F_BUILD_CHAIN: u32 = 106;
pub const X509_F_BY_FILE_CTRL: u32 = 101;
pub const X509_F_CHECK_NAME_CONSTRAINTS: u32 = 149;
pub const X509_F_CHECK_POLICY: u32 = 145;
pub const X509_F_DANE_I2D: u32 = 107;
pub const X509_F_DIR_CTRL: u32 = 102;
pub const X509_F_GET_CERT_BY_SUBJECT: u32 = 103;
pub const X509_F_I2D_X509_AUX: u32 = 151;
pub const X509_F_LOOKUP_CERTS_SK: u32 = 152;
pub const X509_F_NETSCAPE_SPKI_B64_DECODE: u32 = 129;
pub const X509_F_NETSCAPE_SPKI_B64_ENCODE: u32 = 130;
pub const X509_F_NEW_DIR: u32 = 153;
pub const X509_F_X509AT_ADD1_ATTR: u32 = 135;
pub const X509_F_X509V3_ADD_EXT: u32 = 104;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_NID: u32 = 136;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_OBJ: u32 = 137;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_TXT: u32 = 140;
pub const X509_F_X509_ATTRIBUTE_GET0_DATA: u32 = 139;
pub const X509_F_X509_ATTRIBUTE_SET1_DATA: u32 = 138;
pub const X509_F_X509_CHECK_PRIVATE_KEY: u32 = 128;
pub const X509_F_X509_CRL_DIFF: u32 = 105;
pub const X509_F_X509_CRL_METHOD_NEW: u32 = 154;
pub const X509_F_X509_CRL_PRINT_FP: u32 = 147;
pub const X509_F_X509_EXTENSION_CREATE_BY_NID: u32 = 108;
pub const X509_F_X509_EXTENSION_CREATE_BY_OBJ: u32 = 109;
pub const X509_F_X509_GET_PUBKEY_PARAMETERS: u32 = 110;
pub const X509_F_X509_LOAD_CERT_CRL_FILE: u32 = 132;
pub const X509_F_X509_LOAD_CERT_FILE: u32 = 111;
pub const X509_F_X509_LOAD_CRL_FILE: u32 = 112;
pub const X509_F_X509_LOOKUP_METH_NEW: u32 = 160;
pub const X509_F_X509_LOOKUP_NEW: u32 = 155;
pub const X509_F_X509_NAME_ADD_ENTRY: u32 = 113;
pub const X509_F_X509_NAME_CANON: u32 = 156;
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_NID: u32 = 114;
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_TXT: u32 = 131;
pub const X509_F_X509_NAME_ENTRY_SET_OBJECT: u32 = 115;
pub const X509_F_X509_NAME_ONELINE: u32 = 116;
pub const X509_F_X509_NAME_PRINT: u32 = 117;
pub const X509_F_X509_OBJECT_NEW: u32 = 150;
pub const X509_F_X509_PRINT_EX_FP: u32 = 118;
pub const X509_F_X509_PUBKEY_DECODE: u32 = 148;
pub const X509_F_X509_PUBKEY_GET: u32 = 161;
pub const X509_F_X509_PUBKEY_GET0: u32 = 119;
pub const X509_F_X509_PUBKEY_SET: u32 = 120;
pub const X509_F_X509_REQ_CHECK_PRIVATE_KEY: u32 = 144;
pub const X509_F_X509_REQ_PRINT_EX: u32 = 121;
pub const X509_F_X509_REQ_PRINT_FP: u32 = 122;
pub const X509_F_X509_REQ_TO_X509: u32 = 123;
pub const X509_F_X509_STORE_ADD_CERT: u32 = 124;
pub const X509_F_X509_STORE_ADD_CRL: u32 = 125;
pub const X509_F_X509_STORE_ADD_LOOKUP: u32 = 157;
pub const X509_F_X509_STORE_CTX_GET1_ISSUER: u32 = 146;
pub const X509_F_X509_STORE_CTX_INIT: u32 = 143;
pub const X509_F_X509_STORE_CTX_NEW: u32 = 142;
pub const X509_F_X509_STORE_CTX_PURPOSE_INHERIT: u32 = 134;
pub const X509_F_X509_STORE_NEW: u32 = 158;
pub const X509_F_X509_TO_X509_REQ: u32 = 126;
pub const X509_F_X509_TRUST_ADD: u32 = 133;
pub const X509_F_X509_TRUST_SET: u32 = 141;
pub const X509_F_X509_VERIFY_CERT: u32 = 127;
pub const X509_F_X509_VERIFY_PARAM_NEW: u32 = 159;
pub const X509_R_AKID_MISMATCH: u32 = 110;
pub const X509_R_BAD_SELECTOR: u32 = 133;
pub const X509_R_BAD_X509_FILETYPE: u32 = 100;
pub const X509_R_BASE64_DECODE_ERROR: u32 = 118;
pub const X509_R_CANT_CHECK_DH_KEY: u32 = 114;
pub const X509_R_CERT_ALREADY_IN_HASH_TABLE: u32 = 101;
pub const X509_R_CRL_ALREADY_DELTA: u32 = 127;
pub const X509_R_CRL_VERIFY_FAILURE: u32 = 131;
pub const X509_R_IDP_MISMATCH: u32 = 128;
pub const X509_R_INVALID_ATTRIBUTES: u32 = 138;
pub const X509_R_INVALID_DIRECTORY: u32 = 113;
pub const X509_R_INVALID_FIELD_NAME: u32 = 119;
pub const X509_R_INVALID_TRUST: u32 = 123;
pub const X509_R_ISSUER_MISMATCH: u32 = 129;
pub const X509_R_KEY_TYPE_MISMATCH: u32 = 115;
pub const X509_R_KEY_VALUES_MISMATCH: u32 = 116;
pub const X509_R_LOADING_CERT_DIR: u32 = 103;
pub const X509_R_LOADING_DEFAULTS: u32 = 104;
pub const X509_R_METHOD_NOT_SUPPORTED: u32 = 124;
pub const X509_R_NAME_TOO_LONG: u32 = 134;
pub const X509_R_NEWER_CRL_NOT_NEWER: u32 = 132;
pub const X509_R_NO_CERTIFICATE_FOUND: u32 = 135;
pub const X509_R_NO_CERTIFICATE_OR_CRL_FOUND: u32 = 136;
pub const X509_R_NO_CERT_SET_FOR_US_TO_VERIFY: u32 = 105;
pub const X509_R_NO_CRL_FOUND: u32 = 137;
pub const X509_R_NO_CRL_NUMBER: u32 = 130;
pub const X509_R_PUBLIC_KEY_DECODE_ERROR: u32 = 125;
pub const X509_R_PUBLIC_KEY_ENCODE_ERROR: u32 = 126;
pub const X509_R_SHOULD_RETRY: u32 = 106;
pub const X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN: u32 = 107;
pub const X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY: u32 = 108;
pub const X509_R_UNKNOWN_KEY_TYPE: u32 = 117;
pub const X509_R_UNKNOWN_NID: u32 = 109;
pub const X509_R_UNKNOWN_PURPOSE_ID: u32 = 121;
pub const X509_R_UNKNOWN_TRUST_ID: u32 = 120;
pub const X509_R_UNSUPPORTED_ALGORITHM: u32 = 111;
pub const X509_R_WRONG_LOOKUP_TYPE: u32 = 112;
pub const X509_R_WRONG_TYPE: u32 = 122;
pub const X509_SIG_INFO_VALID: u32 = 1;
pub const X509_SIG_INFO_TLS: u32 = 2;
pub const X509_FILETYPE_PEM: u32 = 1;
pub const X509_FILETYPE_ASN1: u32 = 2;
pub const X509_FILETYPE_DEFAULT: u32 = 3;
pub const X509v3_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const X509v3_KU_NON_REPUDIATION: u32 = 64;
pub const X509v3_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const X509v3_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const X509v3_KU_KEY_AGREEMENT: u32 = 8;
pub const X509v3_KU_KEY_CERT_SIGN: u32 = 4;
pub const X509v3_KU_CRL_SIGN: u32 = 2;
pub const X509v3_KU_ENCIPHER_ONLY: u32 = 1;
pub const X509v3_KU_DECIPHER_ONLY: u32 = 32768;
pub const X509v3_KU_UNDEF: u32 = 65535;
pub const X509_EX_V_NETSCAPE_HACK: u32 = 32768;
pub const X509_EX_V_INIT: u32 = 1;
pub const X509_TRUST_DEFAULT: u32 = 0;
pub const X509_TRUST_COMPAT: u32 = 1;
pub const X509_TRUST_SSL_CLIENT: u32 = 2;
pub const X509_TRUST_SSL_SERVER: u32 = 3;
pub const X509_TRUST_EMAIL: u32 = 4;
pub const X509_TRUST_OBJECT_SIGN: u32 = 5;
pub const X509_TRUST_OCSP_SIGN: u32 = 6;
pub const X509_TRUST_OCSP_REQUEST: u32 = 7;
pub const X509_TRUST_TSA: u32 = 8;
pub const X509_TRUST_MIN: u32 = 1;
pub const X509_TRUST_MAX: u32 = 8;
pub const X509_TRUST_DYNAMIC: u32 = 1;
pub const X509_TRUST_DYNAMIC_NAME: u32 = 2;
pub const X509_TRUST_NO_SS_COMPAT: u32 = 4;
pub const X509_TRUST_DO_SS_COMPAT: u32 = 8;
pub const X509_TRUST_OK_ANY_EKU: u32 = 16;
pub const X509_TRUST_TRUSTED: u32 = 1;
pub const X509_TRUST_REJECTED: u32 = 2;
pub const X509_TRUST_UNTRUSTED: u32 = 3;
pub const X509_FLAG_COMPAT: u32 = 0;
pub const X509_FLAG_NO_HEADER: u32 = 1;
pub const X509_FLAG_NO_VERSION: u32 = 2;
pub const X509_FLAG_NO_SERIAL: u32 = 4;
pub const X509_FLAG_NO_SIGNAME: u32 = 8;
pub const X509_FLAG_NO_ISSUER: u32 = 16;
pub const X509_FLAG_NO_VALIDITY: u32 = 32;
pub const X509_FLAG_NO_SUBJECT: u32 = 64;
pub const X509_FLAG_NO_PUBKEY: u32 = 128;
pub const X509_FLAG_NO_EXTENSIONS: u32 = 256;
pub const X509_FLAG_NO_SIGDUMP: u32 = 512;
pub const X509_FLAG_NO_AUX: u32 = 1024;
pub const X509_FLAG_NO_ATTRIBUTES: u32 = 2048;
pub const X509_FLAG_NO_IDS: u32 = 4096;
pub const XN_FLAG_SEP_MASK: u32 = 983040;
pub const XN_FLAG_COMPAT: u32 = 0;
pub const XN_FLAG_SEP_COMMA_PLUS: u32 = 65536;
pub const XN_FLAG_SEP_CPLUS_SPC: u32 = 131072;
pub const XN_FLAG_SEP_SPLUS_SPC: u32 = 196608;
pub const XN_FLAG_SEP_MULTILINE: u32 = 262144;
pub const XN_FLAG_DN_REV: u32 = 1048576;
pub const XN_FLAG_FN_MASK: u32 = 6291456;
pub const XN_FLAG_FN_SN: u32 = 0;
pub const XN_FLAG_FN_LN: u32 = 2097152;
pub const XN_FLAG_FN_OID: u32 = 4194304;
pub const XN_FLAG_FN_NONE: u32 = 6291456;
pub const XN_FLAG_SPC_EQ: u32 = 8388608;
pub const XN_FLAG_DUMP_UNKNOWN_FIELDS: u32 = 16777216;
pub const XN_FLAG_FN_ALIGN: u32 = 33554432;
pub const XN_FLAG_RFC2253: u32 = 17892119;
pub const XN_FLAG_ONELINE: u32 = 8520479;
pub const XN_FLAG_MULTILINE: u32 = 44302342;
pub const LH_LOAD_MULT: u32 = 256;
pub const X509_LU_RETRY: i32 = -1;
pub const X509_LU_FAIL: u32 = 0;
pub const X509_L_FILE_LOAD: u32 = 1;
pub const X509_L_ADD_DIR: u32 = 2;
pub const X509_V_OK: u32 = 0;
pub const X509_V_ERR_UNSPECIFIED: u32 = 1;
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: u32 = 2;
pub const X509_V_ERR_UNABLE_TO_GET_CRL: u32 = 3;
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: u32 = 4;
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: u32 = 5;
pub const X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: u32 = 6;
pub const X509_V_ERR_CERT_SIGNATURE_FAILURE: u32 = 7;
pub const X509_V_ERR_CRL_SIGNATURE_FAILURE: u32 = 8;
pub const X509_V_ERR_CERT_NOT_YET_VALID: u32 = 9;
pub const X509_V_ERR_CERT_HAS_EXPIRED: u32 = 10;
pub const X509_V_ERR_CRL_NOT_YET_VALID: u32 = 11;
pub const X509_V_ERR_CRL_HAS_EXPIRED: u32 = 12;
pub const X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: u32 = 13;
pub const X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: u32 = 14;
pub const X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: u32 = 15;
pub const X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: u32 = 16;
pub const X509_V_ERR_OUT_OF_MEM: u32 = 17;
pub const X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: u32 = 18;
pub const X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: u32 = 19;
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: u32 = 20;
pub const X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: u32 = 21;
pub const X509_V_ERR_CERT_CHAIN_TOO_LONG: u32 = 22;
pub const X509_V_ERR_CERT_REVOKED: u32 = 23;
pub const X509_V_ERR_INVALID_CA: u32 = 24;
pub const X509_V_ERR_PATH_LENGTH_EXCEEDED: u32 = 25;
pub const X509_V_ERR_INVALID_PURPOSE: u32 = 26;
pub const X509_V_ERR_CERT_UNTRUSTED: u32 = 27;
pub const X509_V_ERR_CERT_REJECTED: u32 = 28;
pub const X509_V_ERR_SUBJECT_ISSUER_MISMATCH: u32 = 29;
pub const X509_V_ERR_AKID_SKID_MISMATCH: u32 = 30;
pub const X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: u32 = 31;
pub const X509_V_ERR_KEYUSAGE_NO_CERTSIGN: u32 = 32;
pub const X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER: u32 = 33;
pub const X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION: u32 = 34;
pub const X509_V_ERR_KEYUSAGE_NO_CRL_SIGN: u32 = 35;
pub const X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION: u32 = 36;
pub const X509_V_ERR_INVALID_NON_CA: u32 = 37;
pub const X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED: u32 = 38;
pub const X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE: u32 = 39;
pub const X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED: u32 = 40;
pub const X509_V_ERR_INVALID_EXTENSION: u32 = 41;
pub const X509_V_ERR_INVALID_POLICY_EXTENSION: u32 = 42;
pub const X509_V_ERR_NO_EXPLICIT_POLICY: u32 = 43;
pub const X509_V_ERR_DIFFERENT_CRL_SCOPE: u32 = 44;
pub const X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE: u32 = 45;
pub const X509_V_ERR_UNNESTED_RESOURCE: u32 = 46;
pub const X509_V_ERR_PERMITTED_VIOLATION: u32 = 47;
pub const X509_V_ERR_EXCLUDED_VIOLATION: u32 = 48;
pub const X509_V_ERR_SUBTREE_MINMAX: u32 = 49;
pub const X509_V_ERR_APPLICATION_VERIFICATION: u32 = 50;
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: u32 = 51;
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: u32 = 52;
pub const X509_V_ERR_UNSUPPORTED_NAME_SYNTAX: u32 = 53;
pub const X509_V_ERR_CRL_PATH_VALIDATION_ERROR: u32 = 54;
pub const X509_V_ERR_PATH_LOOP: u32 = 55;
pub const X509_V_ERR_SUITE_B_INVALID_VERSION: u32 = 56;
pub const X509_V_ERR_SUITE_B_INVALID_ALGORITHM: u32 = 57;
pub const X509_V_ERR_SUITE_B_INVALID_CURVE: u32 = 58;
pub const X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM: u32 = 59;
pub const X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED: u32 = 60;
pub const X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256: u32 = 61;
pub const X509_V_ERR_HOSTNAME_MISMATCH: u32 = 62;
pub const X509_V_ERR_EMAIL_MISMATCH: u32 = 63;
pub const X509_V_ERR_IP_ADDRESS_MISMATCH: u32 = 64;
pub const X509_V_ERR_DANE_NO_MATCH: u32 = 65;
pub const X509_V_ERR_EE_KEY_TOO_SMALL: u32 = 66;
pub const X509_V_ERR_CA_KEY_TOO_SMALL: u32 = 67;
pub const X509_V_ERR_CA_MD_TOO_WEAK: u32 = 68;
pub const X509_V_ERR_INVALID_CALL: u32 = 69;
pub const X509_V_ERR_STORE_LOOKUP: u32 = 70;
pub const X509_V_ERR_NO_VALID_SCTS: u32 = 71;
pub const X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION: u32 = 72;
pub const X509_V_ERR_OCSP_VERIFY_NEEDED: u32 = 73;
pub const X509_V_ERR_OCSP_VERIFY_FAILED: u32 = 74;
pub const X509_V_ERR_OCSP_CERT_UNKNOWN: u32 = 75;
pub const X509_V_ERR_SIGNATURE_ALGORITHM_MISMATCH: u32 = 76;
pub const X509_V_ERR_NO_ISSUER_PUBLIC_KEY: u32 = 77;
pub const X509_V_ERR_UNSUPPORTED_SIGNATURE_ALGORITHM: u32 = 78;
pub const X509_V_ERR_EC_KEY_EXPLICIT_PARAMS: u32 = 79;
pub const X509_V_FLAG_CB_ISSUER_CHECK: u32 = 0;
pub const X509_V_FLAG_USE_CHECK_TIME: u32 = 2;
pub const X509_V_FLAG_CRL_CHECK: u32 = 4;
pub const X509_V_FLAG_CRL_CHECK_ALL: u32 = 8;
pub const X509_V_FLAG_IGNORE_CRITICAL: u32 = 16;
pub const X509_V_FLAG_X509_STRICT: u32 = 32;
pub const X509_V_FLAG_ALLOW_PROXY_CERTS: u32 = 64;
pub const X509_V_FLAG_POLICY_CHECK: u32 = 128;
pub const X509_V_FLAG_EXPLICIT_POLICY: u32 = 256;
pub const X509_V_FLAG_INHIBIT_ANY: u32 = 512;
pub const X509_V_FLAG_INHIBIT_MAP: u32 = 1024;
pub const X509_V_FLAG_NOTIFY_POLICY: u32 = 2048;
pub const X509_V_FLAG_EXTENDED_CRL_SUPPORT: u32 = 4096;
pub const X509_V_FLAG_USE_DELTAS: u32 = 8192;
pub const X509_V_FLAG_CHECK_SS_SIGNATURE: u32 = 16384;
pub const X509_V_FLAG_TRUSTED_FIRST: u32 = 32768;
pub const X509_V_FLAG_SUITEB_128_LOS_ONLY: u32 = 65536;
pub const X509_V_FLAG_SUITEB_192_LOS: u32 = 131072;
pub const X509_V_FLAG_SUITEB_128_LOS: u32 = 196608;
pub const X509_V_FLAG_PARTIAL_CHAIN: u32 = 524288;
pub const X509_V_FLAG_NO_ALT_CHAINS: u32 = 1048576;
pub const X509_V_FLAG_NO_CHECK_TIME: u32 = 2097152;
pub const X509_VP_FLAG_DEFAULT: u32 = 1;
pub const X509_VP_FLAG_OVERWRITE: u32 = 2;
pub const X509_VP_FLAG_RESET_FLAGS: u32 = 4;
pub const X509_VP_FLAG_LOCKED: u32 = 8;
pub const X509_VP_FLAG_ONCE: u32 = 16;
pub const X509_V_FLAG_POLICY_MASK: u32 = 1920;
pub const DANE_FLAG_NO_DANE_EE_NAMECHECKS: u32 = 1;
pub const X509_PCY_TREE_FAILURE: i32 = -2;
pub const X509_PCY_TREE_INVALID: i32 = -1;
pub const X509_PCY_TREE_INTERNAL: u32 = 0;
pub const X509_PCY_TREE_VALID: u32 = 1;
pub const X509_PCY_TREE_EMPTY: u32 = 2;
pub const X509_PCY_TREE_EXPLICIT: u32 = 4;
pub const PKCS7_F_DO_PKCS7_SIGNED_ATTRIB: u32 = 136;
pub const PKCS7_F_PKCS7_ADD0_ATTRIB_SIGNING_TIME: u32 = 135;
pub const PKCS7_F_PKCS7_ADD_ATTRIB_SMIMECAP: u32 = 118;
pub const PKCS7_F_PKCS7_ADD_CERTIFICATE: u32 = 100;
pub const PKCS7_F_PKCS7_ADD_CRL: u32 = 101;
pub const PKCS7_F_PKCS7_ADD_RECIPIENT_INFO: u32 = 102;
pub const PKCS7_F_PKCS7_ADD_SIGNATURE: u32 = 131;
pub const PKCS7_F_PKCS7_ADD_SIGNER: u32 = 103;
pub const PKCS7_F_PKCS7_BIO_ADD_DIGEST: u32 = 125;
pub const PKCS7_F_PKCS7_COPY_EXISTING_DIGEST: u32 = 138;
pub const PKCS7_F_PKCS7_CTRL: u32 = 104;
pub const PKCS7_F_PKCS7_DATADECODE: u32 = 112;
pub const PKCS7_F_PKCS7_DATAFINAL: u32 = 128;
pub const PKCS7_F_PKCS7_DATAINIT: u32 = 105;
pub const PKCS7_F_PKCS7_DATAVERIFY: u32 = 107;
pub const PKCS7_F_PKCS7_DECRYPT: u32 = 114;
pub const PKCS7_F_PKCS7_DECRYPT_RINFO: u32 = 133;
pub const PKCS7_F_PKCS7_ENCODE_RINFO: u32 = 132;
pub const PKCS7_F_PKCS7_ENCRYPT: u32 = 115;
pub const PKCS7_F_PKCS7_FINAL: u32 = 134;
pub const PKCS7_F_PKCS7_FIND_DIGEST: u32 = 127;
pub const PKCS7_F_PKCS7_GET0_SIGNERS: u32 = 124;
pub const PKCS7_F_PKCS7_RECIP_INFO_SET: u32 = 130;
pub const PKCS7_F_PKCS7_SET_CIPHER: u32 = 108;
pub const PKCS7_F_PKCS7_SET_CONTENT: u32 = 109;
pub const PKCS7_F_PKCS7_SET_DIGEST: u32 = 126;
pub const PKCS7_F_PKCS7_SET_TYPE: u32 = 110;
pub const PKCS7_F_PKCS7_SIGN: u32 = 116;
pub const PKCS7_F_PKCS7_SIGNATUREVERIFY: u32 = 113;
pub const PKCS7_F_PKCS7_SIGNER_INFO_SET: u32 = 129;
pub const PKCS7_F_PKCS7_SIGNER_INFO_SIGN: u32 = 139;
pub const PKCS7_F_PKCS7_SIGN_ADD_SIGNER: u32 = 137;
pub const PKCS7_F_PKCS7_SIMPLE_SMIMECAP: u32 = 119;
pub const PKCS7_F_PKCS7_VERIFY: u32 = 117;
pub const PKCS7_R_CERTIFICATE_VERIFY_ERROR: u32 = 117;
pub const PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER: u32 = 144;
pub const PKCS7_R_CIPHER_NOT_INITIALIZED: u32 = 116;
pub const PKCS7_R_CONTENT_AND_DATA_PRESENT: u32 = 118;
pub const PKCS7_R_CTRL_ERROR: u32 = 152;
pub const PKCS7_R_DECRYPT_ERROR: u32 = 119;
pub const PKCS7_R_DIGEST_FAILURE: u32 = 101;
pub const PKCS7_R_ENCRYPTION_CTRL_FAILURE: u32 = 149;
pub const PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE: u32 = 150;
pub const PKCS7_R_ERROR_ADDING_RECIPIENT: u32 = 120;
pub const PKCS7_R_ERROR_SETTING_CIPHER: u32 = 121;
pub const PKCS7_R_INVALID_NULL_POINTER: u32 = 143;
pub const PKCS7_R_INVALID_SIGNED_DATA_TYPE: u32 = 155;
pub const PKCS7_R_NO_CONTENT: u32 = 122;
pub const PKCS7_R_NO_DEFAULT_DIGEST: u32 = 151;
pub const PKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND: u32 = 154;
pub const PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE: u32 = 115;
pub const PKCS7_R_NO_SIGNATURES_ON_DATA: u32 = 123;
pub const PKCS7_R_NO_SIGNERS: u32 = 142;
pub const PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE: u32 = 104;
pub const PKCS7_R_PKCS7_ADD_SIGNATURE_ERROR: u32 = 124;
pub const PKCS7_R_PKCS7_ADD_SIGNER_ERROR: u32 = 153;
pub const PKCS7_R_PKCS7_DATASIGN: u32 = 145;
pub const PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE: u32 = 127;
pub const PKCS7_R_SIGNATURE_FAILURE: u32 = 105;
pub const PKCS7_R_SIGNER_CERTIFICATE_NOT_FOUND: u32 = 128;
pub const PKCS7_R_SIGNING_CTRL_FAILURE: u32 = 147;
pub const PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE: u32 = 148;
pub const PKCS7_R_SMIME_TEXT_ERROR: u32 = 129;
pub const PKCS7_R_UNABLE_TO_FIND_CERTIFICATE: u32 = 106;
pub const PKCS7_R_UNABLE_TO_FIND_MEM_BIO: u32 = 107;
pub const PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST: u32 = 108;
pub const PKCS7_R_UNKNOWN_DIGEST_TYPE: u32 = 109;
pub const PKCS7_R_UNKNOWN_OPERATION: u32 = 110;
pub const PKCS7_R_UNSUPPORTED_CIPHER_TYPE: u32 = 111;
pub const PKCS7_R_UNSUPPORTED_CONTENT_TYPE: u32 = 112;
pub const PKCS7_R_WRONG_CONTENT_TYPE: u32 = 113;
pub const PKCS7_R_WRONG_PKCS7_TYPE: u32 = 114;
pub const PKCS7_S_HEADER: u32 = 0;
pub const PKCS7_S_BODY: u32 = 1;
pub const PKCS7_S_TAIL: u32 = 2;
pub const PKCS7_OP_SET_DETACHED_SIGNATURE: u32 = 1;
pub const PKCS7_OP_GET_DETACHED_SIGNATURE: u32 = 2;
pub const PKCS7_TEXT: u32 = 1;
pub const PKCS7_NOCERTS: u32 = 2;
pub const PKCS7_NOSIGS: u32 = 4;
pub const PKCS7_NOCHAIN: u32 = 8;
pub const PKCS7_NOINTERN: u32 = 16;
pub const PKCS7_NOVERIFY: u32 = 32;
pub const PKCS7_DETACHED: u32 = 64;
pub const PKCS7_BINARY: u32 = 128;
pub const PKCS7_NOATTR: u32 = 256;
pub const PKCS7_NOSMIMECAP: u32 = 512;
pub const PKCS7_NOOLDMIMETYPE: u32 = 1024;
pub const PKCS7_CRLFEOL: u32 = 2048;
pub const PKCS7_STREAM: u32 = 4096;
pub const PKCS7_NOCRL: u32 = 8192;
pub const PKCS7_PARTIAL: u32 = 16384;
pub const PKCS7_REUSE_DIGEST: u32 = 32768;
pub const PKCS7_NO_DUAL_CONTENT: u32 = 65536;
pub const SMIME_TEXT: u32 = 1;
pub const SMIME_NOCERTS: u32 = 2;
pub const SMIME_NOSIGS: u32 = 4;
pub const SMIME_NOCHAIN: u32 = 8;
pub const SMIME_NOINTERN: u32 = 16;
pub const SMIME_NOVERIFY: u32 = 32;
pub const SMIME_DETACHED: u32 = 64;
pub const SMIME_BINARY: u32 = 128;
pub const SMIME_NOATTR: u32 = 256;
pub const SMIME_ASCIICRLF: u32 = 524288;
pub const X509_EXT_PACK_UNKNOWN: u32 = 1;
pub const X509_EXT_PACK_STRING: u32 = 2;
pub const PEM_F_B2I_DSS: u32 = 127;
pub const PEM_F_B2I_PVK_BIO: u32 = 128;
pub const PEM_F_B2I_RSA: u32 = 129;
pub const PEM_F_CHECK_BITLEN_DSA: u32 = 130;
pub const PEM_F_CHECK_BITLEN_RSA: u32 = 131;
pub const PEM_F_D2I_PKCS8PRIVATEKEY_BIO: u32 = 120;
pub const PEM_F_D2I_PKCS8PRIVATEKEY_FP: u32 = 121;
pub const PEM_F_DO_B2I: u32 = 132;
pub const PEM_F_DO_B2I_BIO: u32 = 133;
pub const PEM_F_DO_BLOB_HEADER: u32 = 134;
pub const PEM_F_DO_I2B: u32 = 146;
pub const PEM_F_DO_PK8PKEY: u32 = 126;
pub const PEM_F_DO_PK8PKEY_FP: u32 = 125;
pub const PEM_F_DO_PVK_BODY: u32 = 135;
pub const PEM_F_DO_PVK_HEADER: u32 = 136;
pub const PEM_F_GET_HEADER_AND_DATA: u32 = 143;
pub const PEM_F_GET_NAME: u32 = 144;
pub const PEM_F_I2B_PVK: u32 = 137;
pub const PEM_F_I2B_PVK_BIO: u32 = 138;
pub const PEM_F_LOAD_IV: u32 = 101;
pub const PEM_F_PEM_ASN1_READ: u32 = 102;
pub const PEM_F_PEM_ASN1_READ_BIO: u32 = 103;
pub const PEM_F_PEM_ASN1_WRITE: u32 = 104;
pub const PEM_F_PEM_ASN1_WRITE_BIO: u32 = 105;
pub const PEM_F_PEM_DEF_CALLBACK: u32 = 100;
pub const PEM_F_PEM_DO_HEADER: u32 = 106;
pub const PEM_F_PEM_GET_EVP_CIPHER_INFO: u32 = 107;
pub const PEM_F_PEM_READ: u32 = 108;
pub const PEM_F_PEM_READ_BIO: u32 = 109;
pub const PEM_F_PEM_READ_BIO_DHPARAMS: u32 = 141;
pub const PEM_F_PEM_READ_BIO_EX: u32 = 145;
pub const PEM_F_PEM_READ_BIO_PARAMETERS: u32 = 140;
pub const PEM_F_PEM_READ_BIO_PRIVATEKEY: u32 = 123;
pub const PEM_F_PEM_READ_DHPARAMS: u32 = 142;
pub const PEM_F_PEM_READ_PRIVATEKEY: u32 = 124;
pub const PEM_F_PEM_SIGNFINAL: u32 = 112;
pub const PEM_F_PEM_WRITE: u32 = 113;
pub const PEM_F_PEM_WRITE_BIO: u32 = 114;
pub const PEM_F_PEM_WRITE_BIO_PRIVATEKEY_TRADITIONAL: u32 = 147;
pub const PEM_F_PEM_WRITE_PRIVATEKEY: u32 = 139;
pub const PEM_F_PEM_X509_INFO_READ: u32 = 115;
pub const PEM_F_PEM_X509_INFO_READ_BIO: u32 = 116;
pub const PEM_F_PEM_X509_INFO_WRITE_BIO: u32 = 117;
pub const PEM_R_BAD_BASE64_DECODE: u32 = 100;
pub const PEM_R_BAD_DECRYPT: u32 = 101;
pub const PEM_R_BAD_END_LINE: u32 = 102;
pub const PEM_R_BAD_IV_CHARS: u32 = 103;
pub const PEM_R_BAD_MAGIC_NUMBER: u32 = 116;
pub const PEM_R_BAD_PASSWORD_READ: u32 = 104;
pub const PEM_R_BAD_VERSION_NUMBER: u32 = 117;
pub const PEM_R_BIO_WRITE_FAILURE: u32 = 118;
pub const PEM_R_CIPHER_IS_NULL: u32 = 127;
pub const PEM_R_ERROR_CONVERTING_PRIVATE_KEY: u32 = 115;
pub const PEM_R_EXPECTING_PRIVATE_KEY_BLOB: u32 = 119;
pub const PEM_R_EXPECTING_PUBLIC_KEY_BLOB: u32 = 120;
pub const PEM_R_HEADER_TOO_LONG: u32 = 128;
pub const PEM_R_INCONSISTENT_HEADER: u32 = 121;
pub const PEM_R_KEYBLOB_HEADER_PARSE_ERROR: u32 = 122;
pub const PEM_R_KEYBLOB_TOO_SHORT: u32 = 123;
pub const PEM_R_MISSING_DEK_IV: u32 = 129;
pub const PEM_R_NOT_DEK_INFO: u32 = 105;
pub const PEM_R_NOT_ENCRYPTED: u32 = 106;
pub const PEM_R_NOT_PROC_TYPE: u32 = 107;
pub const PEM_R_NO_START_LINE: u32 = 108;
pub const PEM_R_PROBLEMS_GETTING_PASSWORD: u32 = 109;
pub const PEM_R_PVK_DATA_TOO_SHORT: u32 = 124;
pub const PEM_R_PVK_TOO_SHORT: u32 = 125;
pub const PEM_R_READ_KEY: u32 = 111;
pub const PEM_R_SHORT_HEADER: u32 = 112;
pub const PEM_R_UNEXPECTED_DEK_IV: u32 = 130;
pub const PEM_R_UNSUPPORTED_CIPHER: u32 = 113;
pub const PEM_R_UNSUPPORTED_ENCRYPTION: u32 = 114;
pub const PEM_R_UNSUPPORTED_KEY_COMPONENTS: u32 = 126;
pub const PEM_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 110;
pub const PEM_BUFSIZE: u32 = 1024;
pub const PEM_STRING_X509_OLD: &[u8; 17usize] = b"X509 CERTIFICATE\0";
pub const PEM_STRING_X509: &[u8; 12usize] = b"CERTIFICATE\0";
pub const PEM_STRING_X509_TRUSTED: &[u8; 20usize] = b"TRUSTED CERTIFICATE\0";
pub const PEM_STRING_X509_REQ_OLD: &[u8; 24usize] = b"NEW CERTIFICATE REQUEST\0";
pub const PEM_STRING_X509_REQ: &[u8; 20usize] = b"CERTIFICATE REQUEST\0";
pub const PEM_STRING_X509_CRL: &[u8; 9usize] = b"X509 CRL\0";
pub const PEM_STRING_EVP_PKEY: &[u8; 16usize] = b"ANY PRIVATE KEY\0";
pub const PEM_STRING_PUBLIC: &[u8; 11usize] = b"PUBLIC KEY\0";
pub const PEM_STRING_RSA: &[u8; 16usize] = b"RSA PRIVATE KEY\0";
pub const PEM_STRING_RSA_PUBLIC: &[u8; 15usize] = b"RSA PUBLIC KEY\0";
pub const PEM_STRING_DSA: &[u8; 16usize] = b"DSA PRIVATE KEY\0";
pub const PEM_STRING_DSA_PUBLIC: &[u8; 15usize] = b"DSA PUBLIC KEY\0";
pub const PEM_STRING_PKCS7: &[u8; 6usize] = b"PKCS7\0";
pub const PEM_STRING_PKCS7_SIGNED: &[u8; 20usize] = b"PKCS #7 SIGNED DATA\0";
pub const PEM_STRING_PKCS8: &[u8; 22usize] = b"ENCRYPTED PRIVATE KEY\0";
pub const PEM_STRING_PKCS8INF: &[u8; 12usize] = b"PRIVATE KEY\0";
pub const PEM_STRING_DHPARAMS: &[u8; 14usize] = b"DH PARAMETERS\0";
pub const PEM_STRING_DHXPARAMS: &[u8; 20usize] = b"X9.42 DH PARAMETERS\0";
pub const PEM_STRING_SSL_SESSION: &[u8; 23usize] = b"SSL SESSION PARAMETERS\0";
pub const PEM_STRING_DSAPARAMS: &[u8; 15usize] = b"DSA PARAMETERS\0";
pub const PEM_STRING_ECDSA_PUBLIC: &[u8; 17usize] = b"ECDSA PUBLIC KEY\0";
pub const PEM_STRING_ECPARAMETERS: &[u8; 14usize] = b"EC PARAMETERS\0";
pub const PEM_STRING_ECPRIVATEKEY: &[u8; 15usize] = b"EC PRIVATE KEY\0";
pub const PEM_STRING_PARAMETERS: &[u8; 11usize] = b"PARAMETERS\0";
pub const PEM_STRING_CMS: &[u8; 4usize] = b"CMS\0";
pub const PEM_TYPE_ENCRYPTED: u32 = 10;
pub const PEM_TYPE_MIC_ONLY: u32 = 20;
pub const PEM_TYPE_MIC_CLEAR: u32 = 30;
pub const PEM_TYPE_CLEAR: u32 = 40;
pub const PEM_FLAG_SECURE: u32 = 1;
pub const PEM_FLAG_EAY_COMPATIBLE: u32 = 2;
pub const PEM_FLAG_ONLY_B64: u32 = 4;
pub const HMAC_MAX_MD_CBLOCK: u32 = 128;
pub const OSSL_BAD_ASYNC_FD: i32 = -1;
pub const ASYNC_F_ASYNC_CTX_NEW: u32 = 100;
pub const ASYNC_F_ASYNC_INIT_THREAD: u32 = 101;
pub const ASYNC_F_ASYNC_JOB_NEW: u32 = 102;
pub const ASYNC_F_ASYNC_PAUSE_JOB: u32 = 103;
pub const ASYNC_F_ASYNC_START_FUNC: u32 = 104;
pub const ASYNC_F_ASYNC_START_JOB: u32 = 105;
pub const ASYNC_F_ASYNC_WAIT_CTX_SET_WAIT_FD: u32 = 106;
pub const ASYNC_R_FAILED_TO_SET_POOL: u32 = 101;
pub const ASYNC_R_FAILED_TO_SWAP_CONTEXT: u32 = 102;
pub const ASYNC_R_INIT_FAILED: u32 = 105;
pub const ASYNC_R_INVALID_POOL_SIZE: u32 = 103;
pub const ASYNC_ERR: u32 = 0;
pub const ASYNC_NO_JOBS: u32 = 1;
pub const ASYNC_PAUSE: u32 = 2;
pub const ASYNC_FINISH: u32 = 3;
pub const CT_F_CTLOG_NEW: u32 = 117;
pub const CT_F_CTLOG_NEW_FROM_BASE64: u32 = 118;
pub const CT_F_CTLOG_NEW_FROM_CONF: u32 = 119;
pub const CT_F_CTLOG_STORE_LOAD_CTX_NEW: u32 = 122;
pub const CT_F_CTLOG_STORE_LOAD_FILE: u32 = 123;
pub const CT_F_CTLOG_STORE_LOAD_LOG: u32 = 130;
pub const CT_F_CTLOG_STORE_NEW: u32 = 131;
pub const CT_F_CT_BASE64_DECODE: u32 = 124;
pub const CT_F_CT_POLICY_EVAL_CTX_NEW: u32 = 133;
pub const CT_F_CT_V1_LOG_ID_FROM_PKEY: u32 = 125;
pub const CT_F_I2O_SCT: u32 = 107;
pub const CT_F_I2O_SCT_LIST: u32 = 108;
pub const CT_F_I2O_SCT_SIGNATURE: u32 = 109;
pub const CT_F_O2I_SCT: u32 = 110;
pub const CT_F_O2I_SCT_LIST: u32 = 111;
pub const CT_F_O2I_SCT_SIGNATURE: u32 = 112;
pub const CT_F_SCT_CTX_NEW: u32 = 126;
pub const CT_F_SCT_CTX_VERIFY: u32 = 128;
pub const CT_F_SCT_NEW: u32 = 100;
pub const CT_F_SCT_NEW_FROM_BASE64: u32 = 127;
pub const CT_F_SCT_SET0_LOG_ID: u32 = 101;
pub const CT_F_SCT_SET1_EXTENSIONS: u32 = 114;
pub const CT_F_SCT_SET1_LOG_ID: u32 = 115;
pub const CT_F_SCT_SET1_SIGNATURE: u32 = 116;
pub const CT_F_SCT_SET_LOG_ENTRY_TYPE: u32 = 102;
pub const CT_F_SCT_SET_SIGNATURE_NID: u32 = 103;
pub const CT_F_SCT_SET_VERSION: u32 = 104;
pub const CT_R_BASE64_DECODE_ERROR: u32 = 108;
pub const CT_R_INVALID_LOG_ID_LENGTH: u32 = 100;
pub const CT_R_LOG_CONF_INVALID: u32 = 109;
pub const CT_R_LOG_CONF_INVALID_KEY: u32 = 110;
pub const CT_R_LOG_CONF_MISSING_DESCRIPTION: u32 = 111;
pub const CT_R_LOG_CONF_MISSING_KEY: u32 = 112;
pub const CT_R_LOG_KEY_INVALID: u32 = 113;
pub const CT_R_SCT_FUTURE_TIMESTAMP: u32 = 116;
pub const CT_R_SCT_INVALID: u32 = 104;
pub const CT_R_SCT_INVALID_SIGNATURE: u32 = 107;
pub const CT_R_SCT_LIST_INVALID: u32 = 105;
pub const CT_R_SCT_LOG_ID_MISMATCH: u32 = 114;
pub const CT_R_SCT_NOT_SET: u32 = 106;
pub const CT_R_SCT_UNSUPPORTED_VERSION: u32 = 115;
pub const CT_R_UNRECOGNIZED_SIGNATURE_NID: u32 = 101;
pub const CT_R_UNSUPPORTED_ENTRY_TYPE: u32 = 102;
pub const CT_R_UNSUPPORTED_VERSION: u32 = 103;
pub const SCT_MIN_RSA_BITS: u32 = 2048;
pub const CT_V1_HASHLEN: u32 = 32;
pub const SSL_F_ADD_CLIENT_KEY_SHARE_EXT: u32 = 438;
pub const SSL_F_ADD_KEY_SHARE: u32 = 512;
pub const SSL_F_BYTES_TO_CIPHER_LIST: u32 = 519;
pub const SSL_F_CHECK_SUITEB_CIPHER_LIST: u32 = 331;
pub const SSL_F_CIPHERSUITE_CB: u32 = 622;
pub const SSL_F_CONSTRUCT_CA_NAMES: u32 = 552;
pub const SSL_F_CONSTRUCT_KEY_EXCHANGE_TBS: u32 = 553;
pub const SSL_F_CONSTRUCT_STATEFUL_TICKET: u32 = 636;
pub const SSL_F_CONSTRUCT_STATELESS_TICKET: u32 = 637;
pub const SSL_F_CREATE_SYNTHETIC_MESSAGE_HASH: u32 = 539;
pub const SSL_F_CREATE_TICKET_PREQUEL: u32 = 638;
pub const SSL_F_CT_MOVE_SCTS: u32 = 345;
pub const SSL_F_CT_STRICT: u32 = 349;
pub const SSL_F_CUSTOM_EXT_ADD: u32 = 554;
pub const SSL_F_CUSTOM_EXT_PARSE: u32 = 555;
pub const SSL_F_D2I_SSL_SESSION: u32 = 103;
pub const SSL_F_DANE_CTX_ENABLE: u32 = 347;
pub const SSL_F_DANE_MTYPE_SET: u32 = 393;
pub const SSL_F_DANE_TLSA_ADD: u32 = 394;
pub const SSL_F_DERIVE_SECRET_KEY_AND_IV: u32 = 514;
pub const SSL_F_DO_DTLS1_WRITE: u32 = 245;
pub const SSL_F_DO_SSL3_WRITE: u32 = 104;
pub const SSL_F_DTLS1_BUFFER_RECORD: u32 = 247;
pub const SSL_F_DTLS1_CHECK_TIMEOUT_NUM: u32 = 318;
pub const SSL_F_DTLS1_HEARTBEAT: u32 = 305;
pub const SSL_F_DTLS1_HM_FRAGMENT_NEW: u32 = 623;
pub const SSL_F_DTLS1_PREPROCESS_FRAGMENT: u32 = 288;
pub const SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS: u32 = 424;
pub const SSL_F_DTLS1_PROCESS_RECORD: u32 = 257;
pub const SSL_F_DTLS1_READ_BYTES: u32 = 258;
pub const SSL_F_DTLS1_READ_FAILED: u32 = 339;
pub const SSL_F_DTLS1_RETRANSMIT_MESSAGE: u32 = 390;
pub const SSL_F_DTLS1_WRITE_APP_DATA_BYTES: u32 = 268;
pub const SSL_F_DTLS1_WRITE_BYTES: u32 = 545;
pub const SSL_F_DTLSV1_LISTEN: u32 = 350;
pub const SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC: u32 = 371;
pub const SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST: u32 = 385;
pub const SSL_F_DTLS_GET_REASSEMBLED_MESSAGE: u32 = 370;
pub const SSL_F_DTLS_PROCESS_HELLO_VERIFY: u32 = 386;
pub const SSL_F_DTLS_RECORD_LAYER_NEW: u32 = 635;
pub const SSL_F_DTLS_WAIT_FOR_DRY: u32 = 592;
pub const SSL_F_EARLY_DATA_COUNT_OK: u32 = 532;
pub const SSL_F_FINAL_EARLY_DATA: u32 = 556;
pub const SSL_F_FINAL_EC_PT_FORMATS: u32 = 485;
pub const SSL_F_FINAL_EMS: u32 = 486;
pub const SSL_F_FINAL_KEY_SHARE: u32 = 503;
pub const SSL_F_FINAL_MAXFRAGMENTLEN: u32 = 557;
pub const SSL_F_FINAL_PSK: u32 = 639;
pub const SSL_F_FINAL_RENEGOTIATE: u32 = 483;
pub const SSL_F_FINAL_SERVER_NAME: u32 = 558;
pub const SSL_F_FINAL_SIG_ALGS: u32 = 497;
pub const SSL_F_GET_CERT_VERIFY_TBS_DATA: u32 = 588;
pub const SSL_F_NSS_KEYLOG_INT: u32 = 500;
pub const SSL_F_OPENSSL_INIT_SSL: u32 = 342;
pub const SSL_F_OSSL_STATEM_CLIENT13_READ_TRANSITION: u32 = 436;
pub const SSL_F_OSSL_STATEM_CLIENT13_WRITE_TRANSITION: u32 = 598;
pub const SSL_F_OSSL_STATEM_CLIENT_CONSTRUCT_MESSAGE: u32 = 430;
pub const SSL_F_OSSL_STATEM_CLIENT_POST_PROCESS_MESSAGE: u32 = 593;
pub const SSL_F_OSSL_STATEM_CLIENT_PROCESS_MESSAGE: u32 = 594;
pub const SSL_F_OSSL_STATEM_CLIENT_READ_TRANSITION: u32 = 417;
pub const SSL_F_OSSL_STATEM_CLIENT_WRITE_TRANSITION: u32 = 599;
pub const SSL_F_OSSL_STATEM_SERVER13_READ_TRANSITION: u32 = 437;
pub const SSL_F_OSSL_STATEM_SERVER13_WRITE_TRANSITION: u32 = 600;
pub const SSL_F_OSSL_STATEM_SERVER_CONSTRUCT_MESSAGE: u32 = 431;
pub const SSL_F_OSSL_STATEM_SERVER_POST_PROCESS_MESSAGE: u32 = 601;
pub const SSL_F_OSSL_STATEM_SERVER_POST_WORK: u32 = 602;
pub const SSL_F_OSSL_STATEM_SERVER_PRE_WORK: u32 = 640;
pub const SSL_F_OSSL_STATEM_SERVER_PROCESS_MESSAGE: u32 = 603;
pub const SSL_F_OSSL_STATEM_SERVER_READ_TRANSITION: u32 = 418;
pub const SSL_F_OSSL_STATEM_SERVER_WRITE_TRANSITION: u32 = 604;
pub const SSL_F_PARSE_CA_NAMES: u32 = 541;
pub const SSL_F_PITEM_NEW: u32 = 624;
pub const SSL_F_PQUEUE_NEW: u32 = 625;
pub const SSL_F_PROCESS_KEY_SHARE_EXT: u32 = 439;
pub const SSL_F_READ_STATE_MACHINE: u32 = 352;
pub const SSL_F_SET_CLIENT_CIPHERSUITE: u32 = 540;
pub const SSL_F_SRP_GENERATE_CLIENT_MASTER_SECRET: u32 = 595;
pub const SSL_F_SRP_GENERATE_SERVER_MASTER_SECRET: u32 = 589;
pub const SSL_F_SRP_VERIFY_SERVER_PARAM: u32 = 596;
pub const SSL_F_SSL3_CHANGE_CIPHER_STATE: u32 = 129;
pub const SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM: u32 = 130;
pub const SSL_F_SSL3_CTRL: u32 = 213;
pub const SSL_F_SSL3_CTX_CTRL: u32 = 133;
pub const SSL_F_SSL3_DIGEST_CACHED_RECORDS: u32 = 293;
pub const SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC: u32 = 292;
pub const SSL_F_SSL3_ENC: u32 = 608;
pub const SSL_F_SSL3_FINAL_FINISH_MAC: u32 = 285;
pub const SSL_F_SSL3_FINISH_MAC: u32 = 587;
pub const SSL_F_SSL3_GENERATE_KEY_BLOCK: u32 = 238;
pub const SSL_F_SSL3_GENERATE_MASTER_SECRET: u32 = 388;
pub const SSL_F_SSL3_GET_RECORD: u32 = 143;
pub const SSL_F_SSL3_INIT_FINISHED_MAC: u32 = 397;
pub const SSL_F_SSL3_OUTPUT_CERT_CHAIN: u32 = 147;
pub const SSL_F_SSL3_READ_BYTES: u32 = 148;
pub const SSL_F_SSL3_READ_N: u32 = 149;
pub const SSL_F_SSL3_SETUP_KEY_BLOCK: u32 = 157;
pub const SSL_F_SSL3_SETUP_READ_BUFFER: u32 = 156;
pub const SSL_F_SSL3_SETUP_WRITE_BUFFER: u32 = 291;
pub const SSL_F_SSL3_WRITE_BYTES: u32 = 158;
pub const SSL_F_SSL3_WRITE_PENDING: u32 = 159;
pub const SSL_F_SSL_ADD_CERT_CHAIN: u32 = 316;
pub const SSL_F_SSL_ADD_CERT_TO_BUF: u32 = 319;
pub const SSL_F_SSL_ADD_CERT_TO_WPACKET: u32 = 493;
pub const SSL_F_SSL_ADD_CLIENTHELLO_RENEGOTIATE_EXT: u32 = 298;
pub const SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT: u32 = 277;
pub const SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT: u32 = 307;
pub const SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK: u32 = 215;
pub const SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK: u32 = 216;
pub const SSL_F_SSL_ADD_SERVERHELLO_RENEGOTIATE_EXT: u32 = 299;
pub const SSL_F_SSL_ADD_SERVERHELLO_TLSEXT: u32 = 278;
pub const SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT: u32 = 308;
pub const SSL_F_SSL_BAD_METHOD: u32 = 160;
pub const SSL_F_SSL_BUILD_CERT_CHAIN: u32 = 332;
pub const SSL_F_SSL_BYTES_TO_CIPHER_LIST: u32 = 161;
pub const SSL_F_SSL_CACHE_CIPHERLIST: u32 = 520;
pub const SSL_F_SSL_CERT_ADD0_CHAIN_CERT: u32 = 346;
pub const SSL_F_SSL_CERT_DUP: u32 = 221;
pub const SSL_F_SSL_CERT_NEW: u32 = 162;
pub const SSL_F_SSL_CERT_SET0_CHAIN: u32 = 340;
pub const SSL_F_SSL_CHECK_PRIVATE_KEY: u32 = 163;
pub const SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT: u32 = 280;
pub const SSL_F_SSL_CHECK_SRP_EXT_CLIENTHELLO: u32 = 606;
pub const SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG: u32 = 279;
pub const SSL_F_SSL_CHOOSE_CLIENT_VERSION: u32 = 607;
pub const SSL_F_SSL_CIPHER_DESCRIPTION: u32 = 626;
pub const SSL_F_SSL_CIPHER_LIST_TO_BYTES: u32 = 425;
pub const SSL_F_SSL_CIPHER_PROCESS_RULESTR: u32 = 230;
pub const SSL_F_SSL_CIPHER_STRENGTH_SORT: u32 = 231;
pub const SSL_F_SSL_CLEAR: u32 = 164;
pub const SSL_F_SSL_CLIENT_HELLO_GET1_EXTENSIONS_PRESENT: u32 = 627;
pub const SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD: u32 = 165;
pub const SSL_F_SSL_CONF_CMD: u32 = 334;
pub const SSL_F_SSL_CREATE_CIPHER_LIST: u32 = 166;
pub const SSL_F_SSL_CTRL: u32 = 232;
pub const SSL_F_SSL_CTX_CHECK_PRIVATE_KEY: u32 = 168;
pub const SSL_F_SSL_CTX_ENABLE_CT: u32 = 398;
pub const SSL_F_SSL_CTX_MAKE_PROFILES: u32 = 309;
pub const SSL_F_SSL_CTX_NEW: u32 = 169;
pub const SSL_F_SSL_CTX_SET_ALPN_PROTOS: u32 = 343;
pub const SSL_F_SSL_CTX_SET_CIPHER_LIST: u32 = 269;
pub const SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE: u32 = 290;
pub const SSL_F_SSL_CTX_SET_CT_VALIDATION_CALLBACK: u32 = 396;
pub const SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT: u32 = 219;
pub const SSL_F_SSL_CTX_SET_SSL_VERSION: u32 = 170;
pub const SSL_F_SSL_CTX_SET_TLSEXT_MAX_FRAGMENT_LENGTH: u32 = 551;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE: u32 = 171;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1: u32 = 172;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_FILE: u32 = 173;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY: u32 = 174;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1: u32 = 175;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE: u32 = 176;
pub const SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT: u32 = 272;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY: u32 = 177;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1: u32 = 178;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE: u32 = 179;
pub const SSL_F_SSL_CTX_USE_SERVERINFO: u32 = 336;
pub const SSL_F_SSL_CTX_USE_SERVERINFO_EX: u32 = 543;
pub const SSL_F_SSL_CTX_USE_SERVERINFO_FILE: u32 = 337;
pub const SSL_F_SSL_DANE_DUP: u32 = 403;
pub const SSL_F_SSL_DANE_ENABLE: u32 = 395;
pub const SSL_F_SSL_DERIVE: u32 = 590;
pub const SSL_F_SSL_DO_CONFIG: u32 = 391;
pub const SSL_F_SSL_DO_HANDSHAKE: u32 = 180;
pub const SSL_F_SSL_DUP_CA_LIST: u32 = 408;
pub const SSL_F_SSL_ENABLE_CT: u32 = 402;
pub const SSL_F_SSL_GENERATE_PKEY_GROUP: u32 = 559;
pub const SSL_F_SSL_GENERATE_SESSION_ID: u32 = 547;
pub const SSL_F_SSL_GET_NEW_SESSION: u32 = 181;
pub const SSL_F_SSL_GET_PREV_SESSION: u32 = 217;
pub const SSL_F_SSL_GET_SERVER_CERT_INDEX: u32 = 322;
pub const SSL_F_SSL_GET_SIGN_PKEY: u32 = 183;
pub const SSL_F_SSL_HANDSHAKE_HASH: u32 = 560;
pub const SSL_F_SSL_INIT_WBIO_BUFFER: u32 = 184;
pub const SSL_F_SSL_KEY_UPDATE: u32 = 515;
pub const SSL_F_SSL_LOAD_CLIENT_CA_FILE: u32 = 185;
pub const SSL_F_SSL_LOG_MASTER_SECRET: u32 = 498;
pub const SSL_F_SSL_LOG_RSA_CLIENT_KEY_EXCHANGE: u32 = 499;
pub const SSL_F_SSL_MODULE_INIT: u32 = 392;
pub const SSL_F_SSL_NEW: u32 = 186;
pub const SSL_F_SSL_NEXT_PROTO_VALIDATE: u32 = 565;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT: u32 = 300;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT: u32 = 302;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT: u32 = 310;
pub const SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT: u32 = 301;
pub const SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT: u32 = 303;
pub const SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT: u32 = 311;
pub const SSL_F_SSL_PEEK: u32 = 270;
pub const SSL_F_SSL_PEEK_EX: u32 = 432;
pub const SSL_F_SSL_PEEK_INTERNAL: u32 = 522;
pub const SSL_F_SSL_READ: u32 = 223;
pub const SSL_F_SSL_READ_EARLY_DATA: u32 = 529;
pub const SSL_F_SSL_READ_EX: u32 = 434;
pub const SSL_F_SSL_READ_INTERNAL: u32 = 523;
pub const SSL_F_SSL_RENEGOTIATE: u32 = 516;
pub const SSL_F_SSL_RENEGOTIATE_ABBREVIATED: u32 = 546;
pub const SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT: u32 = 320;
pub const SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT: u32 = 321;
pub const SSL_F_SSL_SESSION_DUP: u32 = 348;
pub const SSL_F_SSL_SESSION_NEW: u32 = 189;
pub const SSL_F_SSL_SESSION_PRINT_FP: u32 = 190;
pub const SSL_F_SSL_SESSION_SET1_ID: u32 = 423;
pub const SSL_F_SSL_SESSION_SET1_ID_CONTEXT: u32 = 312;
pub const SSL_F_SSL_SET_ALPN_PROTOS: u32 = 344;
pub const SSL_F_SSL_SET_CERT: u32 = 191;
pub const SSL_F_SSL_SET_CERT_AND_KEY: u32 = 621;
pub const SSL_F_SSL_SET_CIPHER_LIST: u32 = 271;
pub const SSL_F_SSL_SET_CT_VALIDATION_CALLBACK: u32 = 399;
pub const SSL_F_SSL_SET_FD: u32 = 192;
pub const SSL_F_SSL_SET_PKEY: u32 = 193;
pub const SSL_F_SSL_SET_RFD: u32 = 194;
pub const SSL_F_SSL_SET_SESSION: u32 = 195;
pub const SSL_F_SSL_SET_SESSION_ID_CONTEXT: u32 = 218;
pub const SSL_F_SSL_SET_SESSION_TICKET_EXT: u32 = 294;
pub const SSL_F_SSL_SET_TLSEXT_MAX_FRAGMENT_LENGTH: u32 = 550;
pub const SSL_F_SSL_SET_WFD: u32 = 196;
pub const SSL_F_SSL_SHUTDOWN: u32 = 224;
pub const SSL_F_SSL_SRP_CTX_INIT: u32 = 313;
pub const SSL_F_SSL_START_ASYNC_JOB: u32 = 389;
pub const SSL_F_SSL_UNDEFINED_FUNCTION: u32 = 197;
pub const SSL_F_SSL_UNDEFINED_VOID_FUNCTION: u32 = 244;
pub const SSL_F_SSL_USE_CERTIFICATE: u32 = 198;
pub const SSL_F_SSL_USE_CERTIFICATE_ASN1: u32 = 199;
pub const SSL_F_SSL_USE_CERTIFICATE_FILE: u32 = 200;
pub const SSL_F_SSL_USE_PRIVATEKEY: u32 = 201;
pub const SSL_F_SSL_USE_PRIVATEKEY_ASN1: u32 = 202;
pub const SSL_F_SSL_USE_PRIVATEKEY_FILE: u32 = 203;
pub const SSL_F_SSL_USE_PSK_IDENTITY_HINT: u32 = 273;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY: u32 = 204;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1: u32 = 205;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_FILE: u32 = 206;
pub const SSL_F_SSL_VALIDATE_CT: u32 = 400;
pub const SSL_F_SSL_VERIFY_CERT_CHAIN: u32 = 207;
pub const SSL_F_SSL_VERIFY_CLIENT_POST_HANDSHAKE: u32 = 616;
pub const SSL_F_SSL_WRITE: u32 = 208;
pub const SSL_F_SSL_WRITE_EARLY_DATA: u32 = 526;
pub const SSL_F_SSL_WRITE_EARLY_FINISH: u32 = 527;
pub const SSL_F_SSL_WRITE_EX: u32 = 433;
pub const SSL_F_SSL_WRITE_INTERNAL: u32 = 524;
pub const SSL_F_STATE_MACHINE: u32 = 353;
pub const SSL_F_TLS12_CHECK_PEER_SIGALG: u32 = 333;
pub const SSL_F_TLS12_COPY_SIGALGS: u32 = 533;
pub const SSL_F_TLS13_CHANGE_CIPHER_STATE: u32 = 440;
pub const SSL_F_TLS13_ENC: u32 = 609;
pub const SSL_F_TLS13_FINAL_FINISH_MAC: u32 = 605;
pub const SSL_F_TLS13_GENERATE_SECRET: u32 = 591;
pub const SSL_F_TLS13_HKDF_EXPAND: u32 = 561;
pub const SSL_F_TLS13_RESTORE_HANDSHAKE_DIGEST_FOR_PHA: u32 = 617;
pub const SSL_F_TLS13_SAVE_HANDSHAKE_DIGEST_FOR_PHA: u32 = 618;
pub const SSL_F_TLS13_SETUP_KEY_BLOCK: u32 = 441;
pub const SSL_F_TLS1_CHANGE_CIPHER_STATE: u32 = 209;
pub const SSL_F_TLS1_CHECK_DUPLICATE_EXTENSIONS: u32 = 341;
pub const SSL_F_TLS1_ENC: u32 = 401;
pub const SSL_F_TLS1_EXPORT_KEYING_MATERIAL: u32 = 314;
pub const SSL_F_TLS1_GET_CURVELIST: u32 = 338;
pub const SSL_F_TLS1_PRF: u32 = 284;
pub const SSL_F_TLS1_SAVE_U16: u32 = 628;
pub const SSL_F_TLS1_SETUP_KEY_BLOCK: u32 = 211;
pub const SSL_F_TLS1_SET_GROUPS: u32 = 629;
pub const SSL_F_TLS1_SET_RAW_SIGALGS: u32 = 630;
pub const SSL_F_TLS1_SET_SERVER_SIGALGS: u32 = 335;
pub const SSL_F_TLS1_SET_SHARED_SIGALGS: u32 = 631;
pub const SSL_F_TLS1_SET_SIGALGS: u32 = 632;
pub const SSL_F_TLS_CHOOSE_SIGALG: u32 = 513;
pub const SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK: u32 = 354;
pub const SSL_F_TLS_COLLECT_EXTENSIONS: u32 = 435;
pub const SSL_F_TLS_CONSTRUCT_CERTIFICATE_AUTHORITIES: u32 = 542;
pub const SSL_F_TLS_CONSTRUCT_CERTIFICATE_REQUEST: u32 = 372;
pub const SSL_F_TLS_CONSTRUCT_CERT_STATUS: u32 = 429;
pub const SSL_F_TLS_CONSTRUCT_CERT_STATUS_BODY: u32 = 494;
pub const SSL_F_TLS_CONSTRUCT_CERT_VERIFY: u32 = 496;
pub const SSL_F_TLS_CONSTRUCT_CHANGE_CIPHER_SPEC: u32 = 427;
pub const SSL_F_TLS_CONSTRUCT_CKE_DHE: u32 = 404;
pub const SSL_F_TLS_CONSTRUCT_CKE_ECDHE: u32 = 405;
pub const SSL_F_TLS_CONSTRUCT_CKE_GOST: u32 = 406;
pub const SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE: u32 = 407;
pub const SSL_F_TLS_CONSTRUCT_CKE_RSA: u32 = 409;
pub const SSL_F_TLS_CONSTRUCT_CKE_SRP: u32 = 410;
pub const SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE: u32 = 484;
pub const SSL_F_TLS_CONSTRUCT_CLIENT_HELLO: u32 = 487;
pub const SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE: u32 = 488;
pub const SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY: u32 = 489;
pub const SSL_F_TLS_CONSTRUCT_CTOS_ALPN: u32 = 466;
pub const SSL_F_TLS_CONSTRUCT_CTOS_CERTIFICATE: u32 = 355;
pub const SSL_F_TLS_CONSTRUCT_CTOS_COOKIE: u32 = 535;
pub const SSL_F_TLS_CONSTRUCT_CTOS_EARLY_DATA: u32 = 530;
pub const SSL_F_TLS_CONSTRUCT_CTOS_EC_PT_FORMATS: u32 = 467;
pub const SSL_F_TLS_CONSTRUCT_CTOS_EMS: u32 = 468;
pub const SSL_F_TLS_CONSTRUCT_CTOS_ETM: u32 = 469;
pub const SSL_F_TLS_CONSTRUCT_CTOS_HELLO: u32 = 356;
pub const SSL_F_TLS_CONSTRUCT_CTOS_KEY_EXCHANGE: u32 = 357;
pub const SSL_F_TLS_CONSTRUCT_CTOS_KEY_SHARE: u32 = 470;
pub const SSL_F_TLS_CONSTRUCT_CTOS_MAXFRAGMENTLEN: u32 = 549;
pub const SSL_F_TLS_CONSTRUCT_CTOS_NPN: u32 = 471;
pub const SSL_F_TLS_CONSTRUCT_CTOS_PADDING: u32 = 472;
pub const SSL_F_TLS_CONSTRUCT_CTOS_POST_HANDSHAKE_AUTH: u32 = 619;
pub const SSL_F_TLS_CONSTRUCT_CTOS_PSK: u32 = 501;
pub const SSL_F_TLS_CONSTRUCT_CTOS_PSK_KEX_MODES: u32 = 509;
pub const SSL_F_TLS_CONSTRUCT_CTOS_RENEGOTIATE: u32 = 473;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SCT: u32 = 474;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SERVER_NAME: u32 = 475;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SESSION_TICKET: u32 = 476;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SIG_ALGS: u32 = 477;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SRP: u32 = 478;
pub const SSL_F_TLS_CONSTRUCT_CTOS_STATUS_REQUEST: u32 = 479;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_GROUPS: u32 = 480;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_VERSIONS: u32 = 481;
pub const SSL_F_TLS_CONSTRUCT_CTOS_USE_SRTP: u32 = 482;
pub const SSL_F_TLS_CONSTRUCT_CTOS_VERIFY: u32 = 358;
pub const SSL_F_TLS_CONSTRUCT_ENCRYPTED_EXTENSIONS: u32 = 443;
pub const SSL_F_TLS_CONSTRUCT_END_OF_EARLY_DATA: u32 = 536;
pub const SSL_F_TLS_CONSTRUCT_EXTENSIONS: u32 = 447;
pub const SSL_F_TLS_CONSTRUCT_FINISHED: u32 = 359;
pub const SSL_F_TLS_CONSTRUCT_HELLO_REQUEST: u32 = 373;
pub const SSL_F_TLS_CONSTRUCT_HELLO_RETRY_REQUEST: u32 = 510;
pub const SSL_F_TLS_CONSTRUCT_KEY_UPDATE: u32 = 517;
pub const SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET: u32 = 428;
pub const SSL_F_TLS_CONSTRUCT_NEXT_PROTO: u32 = 426;
pub const SSL_F_TLS_CONSTRUCT_SERVER_CERTIFICATE: u32 = 490;
pub const SSL_F_TLS_CONSTRUCT_SERVER_HELLO: u32 = 491;
pub const SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE: u32 = 492;
pub const SSL_F_TLS_CONSTRUCT_STOC_ALPN: u32 = 451;
pub const SSL_F_TLS_CONSTRUCT_STOC_CERTIFICATE: u32 = 374;
pub const SSL_F_TLS_CONSTRUCT_STOC_COOKIE: u32 = 613;
pub const SSL_F_TLS_CONSTRUCT_STOC_CRYPTOPRO_BUG: u32 = 452;
pub const SSL_F_TLS_CONSTRUCT_STOC_DONE: u32 = 375;
pub const SSL_F_TLS_CONSTRUCT_STOC_EARLY_DATA: u32 = 531;
pub const SSL_F_TLS_CONSTRUCT_STOC_EARLY_DATA_INFO: u32 = 525;
pub const SSL_F_TLS_CONSTRUCT_STOC_EC_PT_FORMATS: u32 = 453;
pub const SSL_F_TLS_CONSTRUCT_STOC_EMS: u32 = 454;
pub const SSL_F_TLS_CONSTRUCT_STOC_ETM: u32 = 455;
pub const SSL_F_TLS_CONSTRUCT_STOC_HELLO: u32 = 376;
pub const SSL_F_TLS_CONSTRUCT_STOC_KEY_EXCHANGE: u32 = 377;
pub const SSL_F_TLS_CONSTRUCT_STOC_KEY_SHARE: u32 = 456;
pub const SSL_F_TLS_CONSTRUCT_STOC_MAXFRAGMENTLEN: u32 = 548;
pub const SSL_F_TLS_CONSTRUCT_STOC_NEXT_PROTO_NEG: u32 = 457;
pub const SSL_F_TLS_CONSTRUCT_STOC_PSK: u32 = 504;
pub const SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE: u32 = 458;
pub const SSL_F_TLS_CONSTRUCT_STOC_SERVER_NAME: u32 = 459;
pub const SSL_F_TLS_CONSTRUCT_STOC_SESSION_TICKET: u32 = 460;
pub const SSL_F_TLS_CONSTRUCT_STOC_STATUS_REQUEST: u32 = 461;
pub const SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_GROUPS: u32 = 544;
pub const SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_VERSIONS: u32 = 611;
pub const SSL_F_TLS_CONSTRUCT_STOC_USE_SRTP: u32 = 462;
pub const SSL_F_TLS_EARLY_POST_PROCESS_CLIENT_HELLO: u32 = 521;
pub const SSL_F_TLS_FINISH_HANDSHAKE: u32 = 597;
pub const SSL_F_TLS_GET_MESSAGE_BODY: u32 = 351;
pub const SSL_F_TLS_GET_MESSAGE_HEADER: u32 = 387;
pub const SSL_F_TLS_HANDLE_ALPN: u32 = 562;
pub const SSL_F_TLS_HANDLE_STATUS_REQUEST: u32 = 563;
pub const SSL_F_TLS_PARSE_CERTIFICATE_AUTHORITIES: u32 = 566;
pub const SSL_F_TLS_PARSE_CLIENTHELLO_TLSEXT: u32 = 449;
pub const SSL_F_TLS_PARSE_CTOS_ALPN: u32 = 567;
pub const SSL_F_TLS_PARSE_CTOS_COOKIE: u32 = 614;
pub const SSL_F_TLS_PARSE_CTOS_EARLY_DATA: u32 = 568;
pub const SSL_F_TLS_PARSE_CTOS_EC_PT_FORMATS: u32 = 569;
pub const SSL_F_TLS_PARSE_CTOS_EMS: u32 = 570;
pub const SSL_F_TLS_PARSE_CTOS_KEY_SHARE: u32 = 463;
pub const SSL_F_TLS_PARSE_CTOS_MAXFRAGMENTLEN: u32 = 571;
pub const SSL_F_TLS_PARSE_CTOS_POST_HANDSHAKE_AUTH: u32 = 620;
pub const SSL_F_TLS_PARSE_CTOS_PSK: u32 = 505;
pub const SSL_F_TLS_PARSE_CTOS_PSK_KEX_MODES: u32 = 572;
pub const SSL_F_TLS_PARSE_CTOS_RENEGOTIATE: u32 = 464;
pub const SSL_F_TLS_PARSE_CTOS_SERVER_NAME: u32 = 573;
pub const SSL_F_TLS_PARSE_CTOS_SESSION_TICKET: u32 = 574;
pub const SSL_F_TLS_PARSE_CTOS_SIG_ALGS: u32 = 575;
pub const SSL_F_TLS_PARSE_CTOS_SIG_ALGS_CERT: u32 = 615;
pub const SSL_F_TLS_PARSE_CTOS_SRP: u32 = 576;
pub const SSL_F_TLS_PARSE_CTOS_STATUS_REQUEST: u32 = 577;
pub const SSL_F_TLS_PARSE_CTOS_SUPPORTED_GROUPS: u32 = 578;
pub const SSL_F_TLS_PARSE_CTOS_USE_SRTP: u32 = 465;
pub const SSL_F_TLS_PARSE_STOC_ALPN: u32 = 579;
pub const SSL_F_TLS_PARSE_STOC_COOKIE: u32 = 534;
pub const SSL_F_TLS_PARSE_STOC_EARLY_DATA: u32 = 538;
pub const SSL_F_TLS_PARSE_STOC_EARLY_DATA_INFO: u32 = 528;
pub const SSL_F_TLS_PARSE_STOC_EC_PT_FORMATS: u32 = 580;
pub const SSL_F_TLS_PARSE_STOC_KEY_SHARE: u32 = 445;
pub const SSL_F_TLS_PARSE_STOC_MAXFRAGMENTLEN: u32 = 581;
pub const SSL_F_TLS_PARSE_STOC_NPN: u32 = 582;
pub const SSL_F_TLS_PARSE_STOC_PSK: u32 = 502;
pub const SSL_F_TLS_PARSE_STOC_RENEGOTIATE: u32 = 448;
pub const SSL_F_TLS_PARSE_STOC_SCT: u32 = 564;
pub const SSL_F_TLS_PARSE_STOC_SERVER_NAME: u32 = 583;
pub const SSL_F_TLS_PARSE_STOC_SESSION_TICKET: u32 = 584;
pub const SSL_F_TLS_PARSE_STOC_STATUS_REQUEST: u32 = 585;
pub const SSL_F_TLS_PARSE_STOC_SUPPORTED_VERSIONS: u32 = 612;
pub const SSL_F_TLS_PARSE_STOC_USE_SRTP: u32 = 446;
pub const SSL_F_TLS_POST_PROCESS_CLIENT_HELLO: u32 = 378;
pub const SSL_F_TLS_POST_PROCESS_CLIENT_KEY_EXCHANGE: u32 = 384;
pub const SSL_F_TLS_PREPARE_CLIENT_CERTIFICATE: u32 = 360;
pub const SSL_F_TLS_PROCESS_AS_HELLO_RETRY_REQUEST: u32 = 610;
pub const SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST: u32 = 361;
pub const SSL_F_TLS_PROCESS_CERT_STATUS: u32 = 362;
pub const SSL_F_TLS_PROCESS_CERT_STATUS_BODY: u32 = 495;
pub const SSL_F_TLS_PROCESS_CERT_VERIFY: u32 = 379;
pub const SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC: u32 = 363;
pub const SSL_F_TLS_PROCESS_CKE_DHE: u32 = 411;
pub const SSL_F_TLS_PROCESS_CKE_ECDHE: u32 = 412;
pub const SSL_F_TLS_PROCESS_CKE_GOST: u32 = 413;
pub const SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE: u32 = 414;
pub const SSL_F_TLS_PROCESS_CKE_RSA: u32 = 415;
pub const SSL_F_TLS_PROCESS_CKE_SRP: u32 = 416;
pub const SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE: u32 = 380;
pub const SSL_F_TLS_PROCESS_CLIENT_HELLO: u32 = 381;
pub const SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE: u32 = 382;
pub const SSL_F_TLS_PROCESS_ENCRYPTED_EXTENSIONS: u32 = 444;
pub const SSL_F_TLS_PROCESS_END_OF_EARLY_DATA: u32 = 537;
pub const SSL_F_TLS_PROCESS_FINISHED: u32 = 364;
pub const SSL_F_TLS_PROCESS_HELLO_REQ: u32 = 507;
pub const SSL_F_TLS_PROCESS_HELLO_RETRY_REQUEST: u32 = 511;
pub const SSL_F_TLS_PROCESS_INITIAL_SERVER_FLIGHT: u32 = 442;
pub const SSL_F_TLS_PROCESS_KEY_EXCHANGE: u32 = 365;
pub const SSL_F_TLS_PROCESS_KEY_UPDATE: u32 = 518;
pub const SSL_F_TLS_PROCESS_NEW_SESSION_TICKET: u32 = 366;
pub const SSL_F_TLS_PROCESS_NEXT_PROTO: u32 = 383;
pub const SSL_F_TLS_PROCESS_SERVER_CERTIFICATE: u32 = 367;
pub const SSL_F_TLS_PROCESS_SERVER_DONE: u32 = 368;
pub const SSL_F_TLS_PROCESS_SERVER_HELLO: u32 = 369;
pub const SSL_F_TLS_PROCESS_SKE_DHE: u32 = 419;
pub const SSL_F_TLS_PROCESS_SKE_ECDHE: u32 = 420;
pub const SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE: u32 = 421;
pub const SSL_F_TLS_PROCESS_SKE_SRP: u32 = 422;
pub const SSL_F_TLS_PSK_DO_BINDER: u32 = 506;
pub const SSL_F_TLS_SCAN_CLIENTHELLO_TLSEXT: u32 = 450;
pub const SSL_F_TLS_SETUP_HANDSHAKE: u32 = 508;
pub const SSL_F_USE_CERTIFICATE_CHAIN_FILE: u32 = 220;
pub const SSL_F_WPACKET_INTERN_INIT_LEN: u32 = 633;
pub const SSL_F_WPACKET_START_SUB_PACKET_LEN__: u32 = 634;
pub const SSL_F_WRITE_STATE_MACHINE: u32 = 586;
pub const SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY: u32 = 291;
pub const SSL_R_APP_DATA_IN_HANDSHAKE: u32 = 100;
pub const SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT: u32 = 272;
pub const SSL_R_AT_LEAST_TLS_1_0_NEEDED_IN_FIPS_MODE: u32 = 143;
pub const SSL_R_AT_LEAST_TLS_1_2_NEEDED_IN_SUITEB_MODE: u32 = 158;
pub const SSL_R_BAD_CHANGE_CIPHER_SPEC: u32 = 103;
pub const SSL_R_BAD_CIPHER: u32 = 186;
pub const SSL_R_BAD_DATA: u32 = 390;
pub const SSL_R_BAD_DATA_RETURNED_BY_CALLBACK: u32 = 106;
pub const SSL_R_BAD_DECOMPRESSION: u32 = 107;
pub const SSL_R_BAD_DH_VALUE: u32 = 102;
pub const SSL_R_BAD_DIGEST_LENGTH: u32 = 111;
pub const SSL_R_BAD_EARLY_DATA: u32 = 233;
pub const SSL_R_BAD_ECC_CERT: u32 = 304;
pub const SSL_R_BAD_ECPOINT: u32 = 306;
pub const SSL_R_BAD_EXTENSION: u32 = 110;
pub const SSL_R_BAD_HANDSHAKE_LENGTH: u32 = 332;
pub const SSL_R_BAD_HANDSHAKE_STATE: u32 = 236;
pub const SSL_R_BAD_HELLO_REQUEST: u32 = 105;
pub const SSL_R_BAD_HRR_VERSION: u32 = 263;
pub const SSL_R_BAD_KEY_SHARE: u32 = 108;
pub const SSL_R_BAD_KEY_UPDATE: u32 = 122;
pub const SSL_R_BAD_LEGACY_VERSION: u32 = 292;
pub const SSL_R_BAD_LENGTH: u32 = 271;
pub const SSL_R_BAD_PACKET: u32 = 240;
pub const SSL_R_BAD_PACKET_LENGTH: u32 = 115;
pub const SSL_R_BAD_PROTOCOL_VERSION_NUMBER: u32 = 116;
pub const SSL_R_BAD_PSK: u32 = 219;
pub const SSL_R_BAD_PSK_IDENTITY: u32 = 114;
pub const SSL_R_BAD_RECORD_TYPE: u32 = 443;
pub const SSL_R_BAD_RSA_ENCRYPT: u32 = 119;
pub const SSL_R_BAD_SIGNATURE: u32 = 123;
pub const SSL_R_BAD_SRP_A_LENGTH: u32 = 347;
pub const SSL_R_BAD_SRP_PARAMETERS: u32 = 371;
pub const SSL_R_BAD_SRTP_MKI_VALUE: u32 = 352;
pub const SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST: u32 = 353;
pub const SSL_R_BAD_SSL_FILETYPE: u32 = 124;
pub const SSL_R_BAD_VALUE: u32 = 384;
pub const SSL_R_BAD_WRITE_RETRY: u32 = 127;
pub const SSL_R_BINDER_DOES_NOT_VERIFY: u32 = 253;
pub const SSL_R_BIO_NOT_SET: u32 = 128;
pub const SSL_R_BLOCK_CIPHER_PAD_IS_WRONG: u32 = 129;
pub const SSL_R_BN_LIB: u32 = 130;
pub const SSL_R_CALLBACK_FAILED: u32 = 234;
pub const SSL_R_CANNOT_CHANGE_CIPHER: u32 = 109;
pub const SSL_R_CA_DN_LENGTH_MISMATCH: u32 = 131;
pub const SSL_R_CA_KEY_TOO_SMALL: u32 = 397;
pub const SSL_R_CA_MD_TOO_WEAK: u32 = 398;
pub const SSL_R_CCS_RECEIVED_EARLY: u32 = 133;
pub const SSL_R_CERTIFICATE_VERIFY_FAILED: u32 = 134;
pub const SSL_R_CERT_CB_ERROR: u32 = 377;
pub const SSL_R_CERT_LENGTH_MISMATCH: u32 = 135;
pub const SSL_R_CIPHERSUITE_DIGEST_HAS_CHANGED: u32 = 218;
pub const SSL_R_CIPHER_CODE_WRONG_LENGTH: u32 = 137;
pub const SSL_R_CIPHER_OR_HASH_UNAVAILABLE: u32 = 138;
pub const SSL_R_CLIENTHELLO_TLSEXT: u32 = 226;
pub const SSL_R_COMPRESSED_LENGTH_TOO_LONG: u32 = 140;
pub const SSL_R_COMPRESSION_DISABLED: u32 = 343;
pub const SSL_R_COMPRESSION_FAILURE: u32 = 141;
pub const SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE: u32 = 307;
pub const SSL_R_COMPRESSION_LIBRARY_ERROR: u32 = 142;
pub const SSL_R_CONNECTION_TYPE_NOT_SET: u32 = 144;
pub const SSL_R_CONTEXT_NOT_DANE_ENABLED: u32 = 167;
pub const SSL_R_COOKIE_GEN_CALLBACK_FAILURE: u32 = 400;
pub const SSL_R_COOKIE_MISMATCH: u32 = 308;
pub const SSL_R_CUSTOM_EXT_HANDLER_ALREADY_INSTALLED: u32 = 206;
pub const SSL_R_DANE_ALREADY_ENABLED: u32 = 172;
pub const SSL_R_DANE_CANNOT_OVERRIDE_MTYPE_FULL: u32 = 173;
pub const SSL_R_DANE_NOT_ENABLED: u32 = 175;
pub const SSL_R_DANE_TLSA_BAD_CERTIFICATE: u32 = 180;
pub const SSL_R_DANE_TLSA_BAD_CERTIFICATE_USAGE: u32 = 184;
pub const SSL_R_DANE_TLSA_BAD_DATA_LENGTH: u32 = 189;
pub const SSL_R_DANE_TLSA_BAD_DIGEST_LENGTH: u32 = 192;
pub const SSL_R_DANE_TLSA_BAD_MATCHING_TYPE: u32 = 200;
pub const SSL_R_DANE_TLSA_BAD_PUBLIC_KEY: u32 = 201;
pub const SSL_R_DANE_TLSA_BAD_SELECTOR: u32 = 202;
pub const SSL_R_DANE_TLSA_NULL_DATA: u32 = 203;
pub const SSL_R_DATA_BETWEEN_CCS_AND_FINISHED: u32 = 145;
pub const SSL_R_DATA_LENGTH_TOO_LONG: u32 = 146;
pub const SSL_R_DECRYPTION_FAILED: u32 = 147;
pub const SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC: u32 = 281;
pub const SSL_R_DH_KEY_TOO_SMALL: u32 = 394;
pub const SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG: u32 = 148;
pub const SSL_R_DIGEST_CHECK_FAILED: u32 = 149;
pub const SSL_R_DTLS_MESSAGE_TOO_BIG: u32 = 334;
pub const SSL_R_DUPLICATE_COMPRESSION_ID: u32 = 309;
pub const SSL_R_ECC_CERT_NOT_FOR_SIGNING: u32 = 318;
pub const SSL_R_ECDH_REQUIRED_FOR_SUITEB_MODE: u32 = 374;
pub const SSL_R_EE_KEY_TOO_SMALL: u32 = 399;
pub const SSL_R_EMPTY_SRTP_PROTECTION_PROFILE_LIST: u32 = 354;
pub const SSL_R_ENCRYPTED_LENGTH_TOO_LONG: u32 = 150;
pub const SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST: u32 = 151;
pub const SSL_R_ERROR_SETTING_TLSA_BASE_DOMAIN: u32 = 204;
pub const SSL_R_EXCEEDS_MAX_FRAGMENT_SIZE: u32 = 194;
pub const SSL_R_EXCESSIVE_MESSAGE_SIZE: u32 = 152;
pub const SSL_R_EXTENSION_NOT_RECEIVED: u32 = 279;
pub const SSL_R_EXTRA_DATA_IN_MESSAGE: u32 = 153;
pub const SSL_R_EXT_LENGTH_MISMATCH: u32 = 163;
pub const SSL_R_FAILED_TO_INIT_ASYNC: u32 = 405;
pub const SSL_R_FRAGMENTED_CLIENT_HELLO: u32 = 401;
pub const SSL_R_GOT_A_FIN_BEFORE_A_CCS: u32 = 154;
pub const SSL_R_HTTPS_PROXY_REQUEST: u32 = 155;
pub const SSL_R_HTTP_REQUEST: u32 = 156;
pub const SSL_R_ILLEGAL_POINT_COMPRESSION: u32 = 162;
pub const SSL_R_ILLEGAL_SUITEB_DIGEST: u32 = 380;
pub const SSL_R_INAPPROPRIATE_FALLBACK: u32 = 373;
pub const SSL_R_INCONSISTENT_COMPRESSION: u32 = 340;
pub const SSL_R_INCONSISTENT_EARLY_DATA_ALPN: u32 = 222;
pub const SSL_R_INCONSISTENT_EARLY_DATA_SNI: u32 = 231;
pub const SSL_R_INCONSISTENT_EXTMS: u32 = 104;
pub const SSL_R_INSUFFICIENT_SECURITY: u32 = 241;
pub const SSL_R_INVALID_ALERT: u32 = 205;
pub const SSL_R_INVALID_CCS_MESSAGE: u32 = 260;
pub const SSL_R_INVALID_CERTIFICATE_OR_ALG: u32 = 238;
pub const SSL_R_INVALID_COMMAND: u32 = 280;
pub const SSL_R_INVALID_COMPRESSION_ALGORITHM: u32 = 341;
pub const SSL_R_INVALID_CONFIG: u32 = 283;
pub const SSL_R_INVALID_CONFIGURATION_NAME: u32 = 113;
pub const SSL_R_INVALID_CONTEXT: u32 = 282;
pub const SSL_R_INVALID_CT_VALIDATION_TYPE: u32 = 212;
pub const SSL_R_INVALID_KEY_UPDATE_TYPE: u32 = 120;
pub const SSL_R_INVALID_MAX_EARLY_DATA: u32 = 174;
pub const SSL_R_INVALID_NULL_CMD_NAME: u32 = 385;
pub const SSL_R_INVALID_SEQUENCE_NUMBER: u32 = 402;
pub const SSL_R_INVALID_SERVERINFO_DATA: u32 = 388;
pub const SSL_R_INVALID_SESSION_ID: u32 = 999;
pub const SSL_R_INVALID_SRP_USERNAME: u32 = 357;
pub const SSL_R_INVALID_STATUS_RESPONSE: u32 = 328;
pub const SSL_R_INVALID_TICKET_KEYS_LENGTH: u32 = 325;
pub const SSL_R_LENGTH_MISMATCH: u32 = 159;
pub const SSL_R_LENGTH_TOO_LONG: u32 = 404;
pub const SSL_R_LENGTH_TOO_SHORT: u32 = 160;
pub const SSL_R_LIBRARY_BUG: u32 = 274;
pub const SSL_R_LIBRARY_HAS_NO_CIPHERS: u32 = 161;
pub const SSL_R_MISSING_DSA_SIGNING_CERT: u32 = 165;
pub const SSL_R_MISSING_ECDSA_SIGNING_CERT: u32 = 381;
pub const SSL_R_MISSING_FATAL: u32 = 256;
pub const SSL_R_MISSING_PARAMETERS: u32 = 290;
pub const SSL_R_MISSING_PSK_KEX_MODES_EXTENSION: u32 = 310;
pub const SSL_R_MISSING_RSA_CERTIFICATE: u32 = 168;
pub const SSL_R_MISSING_RSA_ENCRYPTING_CERT: u32 = 169;
pub const SSL_R_MISSING_RSA_SIGNING_CERT: u32 = 170;
pub const SSL_R_MISSING_SIGALGS_EXTENSION: u32 = 112;
pub const SSL_R_MISSING_SIGNING_CERT: u32 = 221;
pub const SSL_R_MISSING_SRP_PARAM: u32 = 358;
pub const SSL_R_MISSING_SUPPORTED_GROUPS_EXTENSION: u32 = 209;
pub const SSL_R_MISSING_TMP_DH_KEY: u32 = 171;
pub const SSL_R_MISSING_TMP_ECDH_KEY: u32 = 311;
pub const SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA: u32 = 293;
pub const SSL_R_NOT_ON_RECORD_BOUNDARY: u32 = 182;
pub const SSL_R_NOT_REPLACING_CERTIFICATE: u32 = 289;
pub const SSL_R_NOT_SERVER: u32 = 284;
pub const SSL_R_NO_APPLICATION_PROTOCOL: u32 = 235;
pub const SSL_R_NO_CERTIFICATES_RETURNED: u32 = 176;
pub const SSL_R_NO_CERTIFICATE_ASSIGNED: u32 = 177;
pub const SSL_R_NO_CERTIFICATE_SET: u32 = 179;
pub const SSL_R_NO_CHANGE_FOLLOWING_HRR: u32 = 214;
pub const SSL_R_NO_CIPHERS_AVAILABLE: u32 = 181;
pub const SSL_R_NO_CIPHERS_SPECIFIED: u32 = 183;
pub const SSL_R_NO_CIPHER_MATCH: u32 = 185;
pub const SSL_R_NO_CLIENT_CERT_METHOD: u32 = 331;
pub const SSL_R_NO_COMPRESSION_SPECIFIED: u32 = 187;
pub const SSL_R_NO_COOKIE_CALLBACK_SET: u32 = 287;
pub const SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER: u32 = 330;
pub const SSL_R_NO_METHOD_SPECIFIED: u32 = 188;
pub const SSL_R_NO_PEM_EXTENSIONS: u32 = 389;
pub const SSL_R_NO_PRIVATE_KEY_ASSIGNED: u32 = 190;
pub const SSL_R_NO_PROTOCOLS_AVAILABLE: u32 = 191;
pub const SSL_R_NO_RENEGOTIATION: u32 = 339;
pub const SSL_R_NO_REQUIRED_DIGEST: u32 = 324;
pub const SSL_R_NO_SHARED_CIPHER: u32 = 193;
pub const SSL_R_NO_SHARED_GROUPS: u32 = 410;
pub const SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS: u32 = 376;
pub const SSL_R_NO_SRTP_PROFILES: u32 = 359;
pub const SSL_R_NO_SUITABLE_KEY_SHARE: u32 = 101;
pub const SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM: u32 = 118;
pub const SSL_R_NO_VALID_SCTS: u32 = 216;
pub const SSL_R_NO_VERIFY_COOKIE_CALLBACK: u32 = 403;
pub const SSL_R_NULL_SSL_CTX: u32 = 195;
pub const SSL_R_NULL_SSL_METHOD_PASSED: u32 = 196;
pub const SSL_R_OCSP_CALLBACK_FAILURE: u32 = 294;
pub const SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED: u32 = 197;
pub const SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED: u32 = 344;
pub const SSL_R_OVERFLOW_ERROR: u32 = 237;
pub const SSL_R_PACKET_LENGTH_TOO_LONG: u32 = 198;
pub const SSL_R_PARSE_TLSEXT: u32 = 227;
pub const SSL_R_PATH_TOO_LONG: u32 = 270;
pub const SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE: u32 = 199;
pub const SSL_R_PEM_NAME_BAD_PREFIX: u32 = 391;
pub const SSL_R_PEM_NAME_TOO_SHORT: u32 = 392;
pub const SSL_R_PIPELINE_FAILURE: u32 = 406;
pub const SSL_R_POST_HANDSHAKE_AUTH_ENCODING_ERR: u32 = 278;
pub const SSL_R_PRIVATE_KEY_MISMATCH: u32 = 288;
pub const SSL_R_PROTOCOL_IS_SHUTDOWN: u32 = 207;
pub const SSL_R_PSK_IDENTITY_NOT_FOUND: u32 = 223;
pub const SSL_R_PSK_NO_CLIENT_CB: u32 = 224;
pub const SSL_R_PSK_NO_SERVER_CB: u32 = 225;
pub const SSL_R_READ_BIO_NOT_SET: u32 = 211;
pub const SSL_R_READ_TIMEOUT_EXPIRED: u32 = 312;
pub const SSL_R_RECORD_LENGTH_MISMATCH: u32 = 213;
pub const SSL_R_RECORD_TOO_SMALL: u32 = 298;
pub const SSL_R_RENEGOTIATE_EXT_TOO_LONG: u32 = 335;
pub const SSL_R_RENEGOTIATION_ENCODING_ERR: u32 = 336;
pub const SSL_R_RENEGOTIATION_MISMATCH: u32 = 337;
pub const SSL_R_REQUEST_PENDING: u32 = 285;
pub const SSL_R_REQUEST_SENT: u32 = 286;
pub const SSL_R_REQUIRED_CIPHER_MISSING: u32 = 215;
pub const SSL_R_REQUIRED_COMPRESSION_ALGORITHM_MISSING: u32 = 342;
pub const SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING: u32 = 345;
pub const SSL_R_SCT_VERIFICATION_FAILED: u32 = 208;
pub const SSL_R_SERVERHELLO_TLSEXT: u32 = 275;
pub const SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED: u32 = 277;
pub const SSL_R_SHUTDOWN_WHILE_IN_INIT: u32 = 407;
pub const SSL_R_SIGNATURE_ALGORITHMS_ERROR: u32 = 360;
pub const SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE: u32 = 220;
pub const SSL_R_SRP_A_CALC: u32 = 361;
pub const SSL_R_SRTP_COULD_NOT_ALLOCATE_PROFILES: u32 = 362;
pub const SSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG: u32 = 363;
pub const SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE: u32 = 364;
pub const SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH: u32 = 232;
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME: u32 = 319;
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE: u32 = 320;
pub const SSL_R_SSL3_SESSION_ID_TOO_LONG: u32 = 300;
pub const SSL_R_SSLV3_ALERT_BAD_CERTIFICATE: u32 = 1042;
pub const SSL_R_SSLV3_ALERT_BAD_RECORD_MAC: u32 = 1020;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED: u32 = 1045;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED: u32 = 1044;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN: u32 = 1046;
pub const SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE: u32 = 1030;
pub const SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE: u32 = 1040;
pub const SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER: u32 = 1047;
pub const SSL_R_SSLV3_ALERT_NO_CERTIFICATE: u32 = 1041;
pub const SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE: u32 = 1010;
pub const SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE: u32 = 1043;
pub const SSL_R_SSL_COMMAND_SECTION_EMPTY: u32 = 117;
pub const SSL_R_SSL_COMMAND_SECTION_NOT_FOUND: u32 = 125;
pub const SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION: u32 = 228;
pub const SSL_R_SSL_HANDSHAKE_FAILURE: u32 = 229;
pub const SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS: u32 = 230;
pub const SSL_R_SSL_NEGATIVE_LENGTH: u32 = 372;
pub const SSL_R_SSL_SECTION_EMPTY: u32 = 126;
pub const SSL_R_SSL_SECTION_NOT_FOUND: u32 = 136;
pub const SSL_R_SSL_SESSION_ID_CALLBACK_FAILED: u32 = 301;
pub const SSL_R_SSL_SESSION_ID_CONFLICT: u32 = 302;
pub const SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG: u32 = 273;
pub const SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH: u32 = 303;
pub const SSL_R_SSL_SESSION_ID_TOO_LONG: u32 = 408;
pub const SSL_R_SSL_SESSION_VERSION_MISMATCH: u32 = 210;
pub const SSL_R_STILL_IN_INIT: u32 = 121;
pub const SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED: u32 = 1116;
pub const SSL_R_TLSV13_ALERT_MISSING_EXTENSION: u32 = 1109;
pub const SSL_R_TLSV1_ALERT_ACCESS_DENIED: u32 = 1049;
pub const SSL_R_TLSV1_ALERT_DECODE_ERROR: u32 = 1050;
pub const SSL_R_TLSV1_ALERT_DECRYPTION_FAILED: u32 = 1021;
pub const SSL_R_TLSV1_ALERT_DECRYPT_ERROR: u32 = 1051;
pub const SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION: u32 = 1060;
pub const SSL_R_TLSV1_ALERT_INAPPROPRIATE_FALLBACK: u32 = 1086;
pub const SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY: u32 = 1071;
pub const SSL_R_TLSV1_ALERT_INTERNAL_ERROR: u32 = 1080;
pub const SSL_R_TLSV1_ALERT_NO_RENEGOTIATION: u32 = 1100;
pub const SSL_R_TLSV1_ALERT_PROTOCOL_VERSION: u32 = 1070;
pub const SSL_R_TLSV1_ALERT_RECORD_OVERFLOW: u32 = 1022;
pub const SSL_R_TLSV1_ALERT_UNKNOWN_CA: u32 = 1048;
pub const SSL_R_TLSV1_ALERT_USER_CANCELLED: u32 = 1090;
pub const SSL_R_TLSV1_BAD_CERTIFICATE_HASH_VALUE: u32 = 1114;
pub const SSL_R_TLSV1_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 1113;
pub const SSL_R_TLSV1_CERTIFICATE_UNOBTAINABLE: u32 = 1111;
pub const SSL_R_TLSV1_UNRECOGNIZED_NAME: u32 = 1112;
pub const SSL_R_TLSV1_UNSUPPORTED_EXTENSION: u32 = 1110;
pub const SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT: u32 = 365;
pub const SSL_R_TLS_HEARTBEAT_PENDING: u32 = 366;
pub const SSL_R_TLS_ILLEGAL_EXPORTER_LABEL: u32 = 367;
pub const SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST: u32 = 157;
pub const SSL_R_TOO_MANY_KEY_UPDATES: u32 = 132;
pub const SSL_R_TOO_MANY_WARN_ALERTS: u32 = 409;
pub const SSL_R_TOO_MUCH_EARLY_DATA: u32 = 164;
pub const SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS: u32 = 314;
pub const SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS: u32 = 239;
pub const SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES: u32 = 242;
pub const SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES: u32 = 243;
pub const SSL_R_UNEXPECTED_CCS_MESSAGE: u32 = 262;
pub const SSL_R_UNEXPECTED_END_OF_EARLY_DATA: u32 = 178;
pub const SSL_R_UNEXPECTED_MESSAGE: u32 = 244;
pub const SSL_R_UNEXPECTED_RECORD: u32 = 245;
pub const SSL_R_UNINITIALIZED: u32 = 276;
pub const SSL_R_UNKNOWN_ALERT_TYPE: u32 = 246;
pub const SSL_R_UNKNOWN_CERTIFICATE_TYPE: u32 = 247;
pub const SSL_R_UNKNOWN_CIPHER_RETURNED: u32 = 248;
pub const SSL_R_UNKNOWN_CIPHER_TYPE: u32 = 249;
pub const SSL_R_UNKNOWN_CMD_NAME: u32 = 386;
pub const SSL_R_UNKNOWN_COMMAND: u32 = 139;
pub const SSL_R_UNKNOWN_DIGEST: u32 = 368;
pub const SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE: u32 = 250;
pub const SSL_R_UNKNOWN_PKEY_TYPE: u32 = 251;
pub const SSL_R_UNKNOWN_PROTOCOL: u32 = 252;
pub const SSL_R_UNKNOWN_SSL_VERSION: u32 = 254;
pub const SSL_R_UNKNOWN_STATE: u32 = 255;
pub const SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED: u32 = 338;
pub const SSL_R_UNSOLICITED_EXTENSION: u32 = 217;
pub const SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM: u32 = 257;
pub const SSL_R_UNSUPPORTED_ELLIPTIC_CURVE: u32 = 315;
pub const SSL_R_UNSUPPORTED_PROTOCOL: u32 = 258;
pub const SSL_R_UNSUPPORTED_SSL_VERSION: u32 = 259;
pub const SSL_R_UNSUPPORTED_STATUS_TYPE: u32 = 329;
pub const SSL_R_USE_SRTP_NOT_NEGOTIATED: u32 = 369;
pub const SSL_R_VERSION_TOO_HIGH: u32 = 166;
pub const SSL_R_VERSION_TOO_LOW: u32 = 396;
pub const SSL_R_WRONG_CERTIFICATE_TYPE: u32 = 383;
pub const SSL_R_WRONG_CIPHER_RETURNED: u32 = 261;
pub const SSL_R_WRONG_CURVE: u32 = 378;
pub const SSL_R_WRONG_SIGNATURE_LENGTH: u32 = 264;
pub const SSL_R_WRONG_SIGNATURE_SIZE: u32 = 265;
pub const SSL_R_WRONG_SIGNATURE_TYPE: u32 = 370;
pub const SSL_R_WRONG_SSL_VERSION: u32 = 266;
pub const SSL_R_WRONG_VERSION_NUMBER: u32 = 267;
pub const SSL_R_X509_LIB: u32 = 268;
pub const SSL_R_X509_VERIFICATION_SETUP_PROBLEMS: u32 = 269;
pub const SSL_SESSION_ASN1_VERSION: u32 = 1;
pub const SSL_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL_MAX_SID_CTX_LENGTH: u32 = 32;
pub const SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES: u32 = 64;
pub const SSL_MAX_KEY_ARG_LENGTH: u32 = 8;
pub const SSL_MAX_MASTER_KEY_LENGTH: u32 = 48;
pub const SSL_MAX_PIPELINES: u32 = 32;
pub const SSL_TXT_LOW: &[u8; 4usize] = b"LOW\0";
pub const SSL_TXT_MEDIUM: &[u8; 7usize] = b"MEDIUM\0";
pub const SSL_TXT_HIGH: &[u8; 5usize] = b"HIGH\0";
pub const SSL_TXT_FIPS: &[u8; 5usize] = b"FIPS\0";
pub const SSL_TXT_aNULL: &[u8; 6usize] = b"aNULL\0";
pub const SSL_TXT_eNULL: &[u8; 6usize] = b"eNULL\0";
pub const SSL_TXT_NULL: &[u8; 5usize] = b"NULL\0";
pub const SSL_TXT_kRSA: &[u8; 5usize] = b"kRSA\0";
pub const SSL_TXT_kDHr: &[u8; 5usize] = b"kDHr\0";
pub const SSL_TXT_kDHd: &[u8; 5usize] = b"kDHd\0";
pub const SSL_TXT_kDH: &[u8; 4usize] = b"kDH\0";
pub const SSL_TXT_kEDH: &[u8; 5usize] = b"kEDH\0";
pub const SSL_TXT_kDHE: &[u8; 5usize] = b"kDHE\0";
pub const SSL_TXT_kECDHr: &[u8; 7usize] = b"kECDHr\0";
pub const SSL_TXT_kECDHe: &[u8; 7usize] = b"kECDHe\0";
pub const SSL_TXT_kECDH: &[u8; 6usize] = b"kECDH\0";
pub const SSL_TXT_kEECDH: &[u8; 7usize] = b"kEECDH\0";
pub const SSL_TXT_kECDHE: &[u8; 7usize] = b"kECDHE\0";
pub const SSL_TXT_kPSK: &[u8; 5usize] = b"kPSK\0";
pub const SSL_TXT_kRSAPSK: &[u8; 8usize] = b"kRSAPSK\0";
pub const SSL_TXT_kECDHEPSK: &[u8; 10usize] = b"kECDHEPSK\0";
pub const SSL_TXT_kDHEPSK: &[u8; 8usize] = b"kDHEPSK\0";
pub const SSL_TXT_kGOST: &[u8; 6usize] = b"kGOST\0";
pub const SSL_TXT_kSRP: &[u8; 5usize] = b"kSRP\0";
pub const SSL_TXT_aRSA: &[u8; 5usize] = b"aRSA\0";
pub const SSL_TXT_aDSS: &[u8; 5usize] = b"aDSS\0";
pub const SSL_TXT_aDH: &[u8; 4usize] = b"aDH\0";
pub const SSL_TXT_aECDH: &[u8; 6usize] = b"aECDH\0";
pub const SSL_TXT_aECDSA: &[u8; 7usize] = b"aECDSA\0";
pub const SSL_TXT_aPSK: &[u8; 5usize] = b"aPSK\0";
pub const SSL_TXT_aGOST94: &[u8; 8usize] = b"aGOST94\0";
pub const SSL_TXT_aGOST01: &[u8; 8usize] = b"aGOST01\0";
pub const SSL_TXT_aGOST12: &[u8; 8usize] = b"aGOST12\0";
pub const SSL_TXT_aGOST: &[u8; 6usize] = b"aGOST\0";
pub const SSL_TXT_aSRP: &[u8; 5usize] = b"aSRP\0";
pub const SSL_TXT_DSS: &[u8; 4usize] = b"DSS\0";
pub const SSL_TXT_DH: &[u8; 3usize] = b"DH\0";
pub const SSL_TXT_DHE: &[u8; 4usize] = b"DHE\0";
pub const SSL_TXT_EDH: &[u8; 4usize] = b"EDH\0";
pub const SSL_TXT_ADH: &[u8; 4usize] = b"ADH\0";
pub const SSL_TXT_RSA: &[u8; 4usize] = b"RSA\0";
pub const SSL_TXT_ECDH: &[u8; 5usize] = b"ECDH\0";
pub const SSL_TXT_EECDH: &[u8; 6usize] = b"EECDH\0";
pub const SSL_TXT_ECDHE: &[u8; 6usize] = b"ECDHE\0";
pub const SSL_TXT_AECDH: &[u8; 6usize] = b"AECDH\0";
pub const SSL_TXT_ECDSA: &[u8; 6usize] = b"ECDSA\0";
pub const SSL_TXT_PSK: &[u8; 4usize] = b"PSK\0";
pub const SSL_TXT_SRP: &[u8; 4usize] = b"SRP\0";
pub const SSL_TXT_DES: &[u8; 4usize] = b"DES\0";
pub const SSL_TXT_3DES: &[u8; 5usize] = b"3DES\0";
pub const SSL_TXT_RC4: &[u8; 4usize] = b"RC4\0";
pub const SSL_TXT_RC2: &[u8; 4usize] = b"RC2\0";
pub const SSL_TXT_IDEA: &[u8; 5usize] = b"IDEA\0";
pub const SSL_TXT_SEED: &[u8; 5usize] = b"SEED\0";
pub const SSL_TXT_AES128: &[u8; 7usize] = b"AES128\0";
pub const SSL_TXT_AES256: &[u8; 7usize] = b"AES256\0";
pub const SSL_TXT_AES: &[u8; 4usize] = b"AES\0";
pub const SSL_TXT_AES_GCM: &[u8; 7usize] = b"AESGCM\0";
pub const SSL_TXT_AES_CCM: &[u8; 7usize] = b"AESCCM\0";
pub const SSL_TXT_AES_CCM_8: &[u8; 8usize] = b"AESCCM8\0";
pub const SSL_TXT_CAMELLIA128: &[u8; 12usize] = b"CAMELLIA128\0";
pub const SSL_TXT_CAMELLIA256: &[u8; 12usize] = b"CAMELLIA256\0";
pub const SSL_TXT_CAMELLIA: &[u8; 9usize] = b"CAMELLIA\0";
pub const SSL_TXT_CHACHA20: &[u8; 9usize] = b"CHACHA20\0";
pub const SSL_TXT_GOST: &[u8; 7usize] = b"GOST89\0";
pub const SSL_TXT_ARIA: &[u8; 5usize] = b"ARIA\0";
pub const SSL_TXT_ARIA_GCM: &[u8; 8usize] = b"ARIAGCM\0";
pub const SSL_TXT_ARIA128: &[u8; 8usize] = b"ARIA128\0";
pub const SSL_TXT_ARIA256: &[u8; 8usize] = b"ARIA256\0";
pub const SSL_TXT_MD5: &[u8; 4usize] = b"MD5\0";
pub const SSL_TXT_SHA1: &[u8; 5usize] = b"SHA1\0";
pub const SSL_TXT_SHA: &[u8; 4usize] = b"SHA\0";
pub const SSL_TXT_GOST94: &[u8; 7usize] = b"GOST94\0";
pub const SSL_TXT_GOST89MAC: &[u8; 10usize] = b"GOST89MAC\0";
pub const SSL_TXT_GOST12: &[u8; 7usize] = b"GOST12\0";
pub const SSL_TXT_GOST89MAC12: &[u8; 12usize] = b"GOST89MAC12\0";
pub const SSL_TXT_SHA256: &[u8; 7usize] = b"SHA256\0";
pub const SSL_TXT_SHA384: &[u8; 7usize] = b"SHA384\0";
pub const SSL_TXT_SSLV3: &[u8; 6usize] = b"SSLv3\0";
pub const SSL_TXT_TLSV1: &[u8; 6usize] = b"TLSv1\0";
pub const SSL_TXT_TLSV1_1: &[u8; 8usize] = b"TLSv1.1\0";
pub const SSL_TXT_TLSV1_2: &[u8; 8usize] = b"TLSv1.2\0";
pub const SSL_TXT_ALL: &[u8; 4usize] = b"ALL\0";
pub const SSL_TXT_CMPALL: &[u8; 16usize] = b"COMPLEMENTOFALL\0";
pub const SSL_TXT_CMPDEF: &[u8; 20usize] = b"COMPLEMENTOFDEFAULT\0";
pub const SSL_DEFAULT_CIPHER_LIST: &[u8; 32usize] = b"ALL:!COMPLEMENTOFDEFAULT:!eNULL\0";
pub const TLS_DEFAULT_CIPHERSUITES: &[u8; 75usize] =
    b"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256\0";
pub const SSL_SENT_SHUTDOWN: u32 = 1;
pub const SSL_RECEIVED_SHUTDOWN: u32 = 2;
pub const SSL_FILETYPE_ASN1: u32 = 2;
pub const SSL_FILETYPE_PEM: u32 = 1;
pub const SSL_EXT_TLS_ONLY: u32 = 1;
pub const SSL_EXT_DTLS_ONLY: u32 = 2;
pub const SSL_EXT_TLS_IMPLEMENTATION_ONLY: u32 = 4;
pub const SSL_EXT_SSL3_ALLOWED: u32 = 8;
pub const SSL_EXT_TLS1_2_AND_BELOW_ONLY: u32 = 16;
pub const SSL_EXT_TLS1_3_ONLY: u32 = 32;
pub const SSL_EXT_IGNORE_ON_RESUMPTION: u32 = 64;
pub const SSL_EXT_CLIENT_HELLO: u32 = 128;
pub const SSL_EXT_TLS1_2_SERVER_HELLO: u32 = 256;
pub const SSL_EXT_TLS1_3_SERVER_HELLO: u32 = 512;
pub const SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS: u32 = 1024;
pub const SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST: u32 = 2048;
pub const SSL_EXT_TLS1_3_CERTIFICATE: u32 = 4096;
pub const SSL_EXT_TLS1_3_NEW_SESSION_TICKET: u32 = 8192;
pub const SSL_EXT_TLS1_3_CERTIFICATE_REQUEST: u32 = 16384;
pub const SSL_OP_LEGACY_SERVER_CONNECT: u32 = 4;
pub const SSL_OP_TLSEXT_PADDING: u32 = 16;
pub const SSL_OP_SAFARI_ECDHE_ECDSA_BUG: u32 = 64;
pub const SSL_OP_ALLOW_NO_DHE_KEX: u32 = 1024;
pub const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: u32 = 2048;
pub const SSL_OP_NO_QUERY_MTU: u32 = 4096;
pub const SSL_OP_COOKIE_EXCHANGE: u32 = 8192;
pub const SSL_OP_NO_TICKET: u32 = 16384;
pub const SSL_OP_CISCO_ANYCONNECT: u32 = 32768;
pub const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: u32 = 65536;
pub const SSL_OP_NO_COMPRESSION: u32 = 131072;
pub const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: u32 = 262144;
pub const SSL_OP_NO_ENCRYPT_THEN_MAC: u32 = 524288;
pub const SSL_OP_ENABLE_MIDDLEBOX_COMPAT: u32 = 1048576;
pub const SSL_OP_PRIORITIZE_CHACHA: u32 = 2097152;
pub const SSL_OP_CIPHER_SERVER_PREFERENCE: u32 = 4194304;
pub const SSL_OP_TLS_ROLLBACK_BUG: u32 = 8388608;
pub const SSL_OP_NO_ANTI_REPLAY: u32 = 16777216;
pub const SSL_OP_NO_SSLv3: u32 = 33554432;
pub const SSL_OP_NO_TLSv1: u32 = 67108864;
pub const SSL_OP_NO_TLSv1_2: u32 = 134217728;
pub const SSL_OP_NO_TLSv1_1: u32 = 268435456;
pub const SSL_OP_NO_TLSv1_3: u32 = 536870912;
pub const SSL_OP_NO_DTLSv1: u32 = 67108864;
pub const SSL_OP_NO_DTLSv1_2: u32 = 134217728;
pub const SSL_OP_NO_SSL_MASK: u32 = 1040187392;
pub const SSL_OP_NO_DTLS_MASK: u32 = 201326592;
pub const SSL_OP_NO_RENEGOTIATION: u32 = 1073741824;
pub const SSL_OP_CRYPTOPRO_TLSEXT_BUG: u32 = 2147483648;
pub const SSL_OP_ALL: u32 = 2147485780;
pub const SSL_OP_MICROSOFT_SESS_ID_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_CHALLENGE_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: u32 = 0;
pub const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: u32 = 0;
pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: u32 = 0;
pub const SSL_OP_MSIE_SSLV2_RSA_PADDING: u32 = 0;
pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: u32 = 0;
pub const SSL_OP_TLS_D5_BUG: u32 = 0;
pub const SSL_OP_TLS_BLOCK_PADDING_BUG: u32 = 0;
pub const SSL_OP_SINGLE_ECDH_USE: u32 = 0;
pub const SSL_OP_SINGLE_DH_USE: u32 = 0;
pub const SSL_OP_EPHEMERAL_RSA: u32 = 0;
pub const SSL_OP_NO_SSLv2: u32 = 0;
pub const SSL_OP_PKCS1_CHECK_1: u32 = 0;
pub const SSL_OP_PKCS1_CHECK_2: u32 = 0;
pub const SSL_OP_NETSCAPE_CA_DN_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: u32 = 0;
pub const SSL_MODE_ENABLE_PARTIAL_WRITE: u32 = 1;
pub const SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER: u32 = 2;
pub const SSL_MODE_AUTO_RETRY: u32 = 4;
pub const SSL_MODE_NO_AUTO_CHAIN: u32 = 8;
pub const SSL_MODE_RELEASE_BUFFERS: u32 = 16;
pub const SSL_MODE_SEND_CLIENTHELLO_TIME: u32 = 32;
pub const SSL_MODE_SEND_SERVERHELLO_TIME: u32 = 64;
pub const SSL_MODE_SEND_FALLBACK_SCSV: u32 = 128;
pub const SSL_MODE_ASYNC: u32 = 256;
pub const SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG: u32 = 1024;
pub const SSL_CERT_FLAG_TLS_STRICT: u32 = 1;
pub const SSL_CERT_FLAG_SUITEB_128_LOS_ONLY: u32 = 65536;
pub const SSL_CERT_FLAG_SUITEB_192_LOS: u32 = 131072;
pub const SSL_CERT_FLAG_SUITEB_128_LOS: u32 = 196608;
pub const SSL_CERT_FLAG_BROKEN_PROTOCOL: u32 = 268435456;
pub const SSL_BUILD_CHAIN_FLAG_UNTRUSTED: u32 = 1;
pub const SSL_BUILD_CHAIN_FLAG_NO_ROOT: u32 = 2;
pub const SSL_BUILD_CHAIN_FLAG_CHECK: u32 = 4;
pub const SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR: u32 = 8;
pub const SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR: u32 = 16;
pub const CERT_PKEY_VALID: u32 = 1;
pub const CERT_PKEY_SIGN: u32 = 2;
pub const CERT_PKEY_EE_SIGNATURE: u32 = 16;
pub const CERT_PKEY_CA_SIGNATURE: u32 = 32;
pub const CERT_PKEY_EE_PARAM: u32 = 64;
pub const CERT_PKEY_CA_PARAM: u32 = 128;
pub const CERT_PKEY_EXPLICIT_SIGN: u32 = 256;
pub const CERT_PKEY_ISSUER_NAME: u32 = 512;
pub const CERT_PKEY_CERT_TYPE: u32 = 1024;
pub const CERT_PKEY_SUITEB: u32 = 2048;
pub const SSL_CONF_FLAG_CMDLINE: u32 = 1;
pub const SSL_CONF_FLAG_FILE: u32 = 2;
pub const SSL_CONF_FLAG_CLIENT: u32 = 4;
pub const SSL_CONF_FLAG_SERVER: u32 = 8;
pub const SSL_CONF_FLAG_SHOW_ERRORS: u32 = 16;
pub const SSL_CONF_FLAG_CERTIFICATE: u32 = 32;
pub const SSL_CONF_FLAG_REQUIRE_PRIVATE: u32 = 64;
pub const SSL_CONF_TYPE_UNKNOWN: u32 = 0;
pub const SSL_CONF_TYPE_STRING: u32 = 1;
pub const SSL_CONF_TYPE_FILE: u32 = 2;
pub const SSL_CONF_TYPE_DIR: u32 = 3;
pub const SSL_CONF_TYPE_NONE: u32 = 4;
pub const SSL_COOKIE_LENGTH: u32 = 4096;
pub const SSL_MAX_CERT_LIST_DEFAULT: u32 = 102400;
pub const SSL_SESSION_CACHE_MAX_SIZE_DEFAULT: u32 = 20480;
pub const SSL_SESS_CACHE_OFF: u32 = 0;
pub const SSL_SESS_CACHE_CLIENT: u32 = 1;
pub const SSL_SESS_CACHE_SERVER: u32 = 2;
pub const SSL_SESS_CACHE_BOTH: u32 = 3;
pub const SSL_SESS_CACHE_NO_AUTO_CLEAR: u32 = 128;
pub const SSL_SESS_CACHE_NO_INTERNAL_LOOKUP: u32 = 256;
pub const SSL_SESS_CACHE_NO_INTERNAL_STORE: u32 = 512;
pub const SSL_SESS_CACHE_NO_INTERNAL: u32 = 768;
pub const OPENSSL_NPN_UNSUPPORTED: u32 = 0;
pub const OPENSSL_NPN_NEGOTIATED: u32 = 1;
pub const OPENSSL_NPN_NO_OVERLAP: u32 = 2;
pub const PSK_MAX_IDENTITY_LEN: u32 = 128;
pub const PSK_MAX_PSK_LEN: u32 = 256;
pub const SSL_NOTHING: u32 = 1;
pub const SSL_WRITING: u32 = 2;
pub const SSL_READING: u32 = 3;
pub const SSL_X509_LOOKUP: u32 = 4;
pub const SSL_ASYNC_PAUSED: u32 = 5;
pub const SSL_ASYNC_NO_JOBS: u32 = 6;
pub const SSL_CLIENT_HELLO_CB: u32 = 7;
pub const SSL_MAC_FLAG_READ_MAC_STREAM: u32 = 1;
pub const SSL_MAC_FLAG_WRITE_MAC_STREAM: u32 = 2;
pub const SSL2_VERSION: u32 = 2;
pub const SSL2_MT_CLIENT_HELLO: u32 = 1;
pub const SSL3_CK_SCSV: u32 = 50331903;
pub const SSL3_CK_FALLBACK_SCSV: u32 = 50353664;
pub const SSL3_CK_RSA_NULL_MD5: u32 = 50331649;
pub const SSL3_CK_RSA_NULL_SHA: u32 = 50331650;
pub const SSL3_CK_RSA_RC4_40_MD5: u32 = 50331651;
pub const SSL3_CK_RSA_RC4_128_MD5: u32 = 50331652;
pub const SSL3_CK_RSA_RC4_128_SHA: u32 = 50331653;
pub const SSL3_CK_RSA_RC2_40_MD5: u32 = 50331654;
pub const SSL3_CK_RSA_IDEA_128_SHA: u32 = 50331655;
pub const SSL3_CK_RSA_DES_40_CBC_SHA: u32 = 50331656;
pub const SSL3_CK_RSA_DES_64_CBC_SHA: u32 = 50331657;
pub const SSL3_CK_RSA_DES_192_CBC3_SHA: u32 = 50331658;
pub const SSL3_CK_DH_DSS_DES_40_CBC_SHA: u32 = 50331659;
pub const SSL3_CK_DH_DSS_DES_64_CBC_SHA: u32 = 50331660;
pub const SSL3_CK_DH_DSS_DES_192_CBC3_SHA: u32 = 50331661;
pub const SSL3_CK_DH_RSA_DES_40_CBC_SHA: u32 = 50331662;
pub const SSL3_CK_DH_RSA_DES_64_CBC_SHA: u32 = 50331663;
pub const SSL3_CK_DH_RSA_DES_192_CBC3_SHA: u32 = 50331664;
pub const SSL3_CK_DHE_DSS_DES_40_CBC_SHA: u32 = 50331665;
pub const SSL3_CK_EDH_DSS_DES_40_CBC_SHA: u32 = 50331665;
pub const SSL3_CK_DHE_DSS_DES_64_CBC_SHA: u32 = 50331666;
pub const SSL3_CK_EDH_DSS_DES_64_CBC_SHA: u32 = 50331666;
pub const SSL3_CK_DHE_DSS_DES_192_CBC3_SHA: u32 = 50331667;
pub const SSL3_CK_EDH_DSS_DES_192_CBC3_SHA: u32 = 50331667;
pub const SSL3_CK_DHE_RSA_DES_40_CBC_SHA: u32 = 50331668;
pub const SSL3_CK_EDH_RSA_DES_40_CBC_SHA: u32 = 50331668;
pub const SSL3_CK_DHE_RSA_DES_64_CBC_SHA: u32 = 50331669;
pub const SSL3_CK_EDH_RSA_DES_64_CBC_SHA: u32 = 50331669;
pub const SSL3_CK_DHE_RSA_DES_192_CBC3_SHA: u32 = 50331670;
pub const SSL3_CK_EDH_RSA_DES_192_CBC3_SHA: u32 = 50331670;
pub const SSL3_CK_ADH_RC4_40_MD5: u32 = 50331671;
pub const SSL3_CK_ADH_RC4_128_MD5: u32 = 50331672;
pub const SSL3_CK_ADH_DES_40_CBC_SHA: u32 = 50331673;
pub const SSL3_CK_ADH_DES_64_CBC_SHA: u32 = 50331674;
pub const SSL3_CK_ADH_DES_192_CBC_SHA: u32 = 50331675;
pub const SSL3_RFC_RSA_NULL_MD5: &[u8; 22usize] = b"TLS_RSA_WITH_NULL_MD5\0";
pub const SSL3_RFC_RSA_NULL_SHA: &[u8; 22usize] = b"TLS_RSA_WITH_NULL_SHA\0";
pub const SSL3_RFC_RSA_DES_192_CBC3_SHA: &[u8; 30usize] = b"TLS_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const SSL3_RFC_DHE_DSS_DES_192_CBC3_SHA: &[u8; 34usize] =
    b"TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\0";
pub const SSL3_RFC_DHE_RSA_DES_192_CBC3_SHA: &[u8; 34usize] =
    b"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const SSL3_RFC_ADH_DES_192_CBC_SHA: &[u8; 34usize] = b"TLS_DH_anon_WITH_3DES_EDE_CBC_SHA\0";
pub const SSL3_RFC_RSA_IDEA_128_SHA: &[u8; 26usize] = b"TLS_RSA_WITH_IDEA_CBC_SHA\0";
pub const SSL3_RFC_RSA_RC4_128_MD5: &[u8; 25usize] = b"TLS_RSA_WITH_RC4_128_MD5\0";
pub const SSL3_RFC_RSA_RC4_128_SHA: &[u8; 25usize] = b"TLS_RSA_WITH_RC4_128_SHA\0";
pub const SSL3_RFC_ADH_RC4_128_MD5: &[u8; 29usize] = b"TLS_DH_anon_WITH_RC4_128_MD5\0";
pub const SSL3_TXT_RSA_NULL_MD5: &[u8; 9usize] = b"NULL-MD5\0";
pub const SSL3_TXT_RSA_NULL_SHA: &[u8; 9usize] = b"NULL-SHA\0";
pub const SSL3_TXT_RSA_RC4_40_MD5: &[u8; 12usize] = b"EXP-RC4-MD5\0";
pub const SSL3_TXT_RSA_RC4_128_MD5: &[u8; 8usize] = b"RC4-MD5\0";
pub const SSL3_TXT_RSA_RC4_128_SHA: &[u8; 8usize] = b"RC4-SHA\0";
pub const SSL3_TXT_RSA_RC2_40_MD5: &[u8; 16usize] = b"EXP-RC2-CBC-MD5\0";
pub const SSL3_TXT_RSA_IDEA_128_SHA: &[u8; 13usize] = b"IDEA-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_40_CBC_SHA: &[u8; 16usize] = b"EXP-DES-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_64_CBC_SHA: &[u8; 12usize] = b"DES-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_192_CBC3_SHA: &[u8; 13usize] = b"DES-CBC3-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_40_CBC_SHA: &[u8; 23usize] = b"EXP-DH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_64_CBC_SHA: &[u8; 19usize] = b"DH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_192_CBC3_SHA: &[u8; 20usize] = b"DH-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_40_CBC_SHA: &[u8; 23usize] = b"EXP-DH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_64_CBC_SHA: &[u8; 19usize] = b"DH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_192_CBC3_SHA: &[u8; 20usize] = b"DH-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_40_CBC_SHA: &[u8; 24usize] = b"EXP-DHE-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_64_CBC_SHA: &[u8; 20usize] = b"DHE-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_192_CBC3_SHA: &[u8; 21usize] = b"DHE-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_40_CBC_SHA: &[u8; 24usize] = b"EXP-DHE-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_64_CBC_SHA: &[u8; 20usize] = b"DHE-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_192_CBC3_SHA: &[u8; 21usize] = b"DHE-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_40_CBC_SHA: &[u8; 24usize] = b"EXP-EDH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_64_CBC_SHA: &[u8; 20usize] = b"EDH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA: &[u8; 21usize] = b"EDH-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_40_CBC_SHA: &[u8; 24usize] = b"EXP-EDH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_64_CBC_SHA: &[u8; 20usize] = b"EDH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA: &[u8; 21usize] = b"EDH-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_ADH_RC4_40_MD5: &[u8; 16usize] = b"EXP-ADH-RC4-MD5\0";
pub const SSL3_TXT_ADH_RC4_128_MD5: &[u8; 12usize] = b"ADH-RC4-MD5\0";
pub const SSL3_TXT_ADH_DES_40_CBC_SHA: &[u8; 20usize] = b"EXP-ADH-DES-CBC-SHA\0";
pub const SSL3_TXT_ADH_DES_64_CBC_SHA: &[u8; 16usize] = b"ADH-DES-CBC-SHA\0";
pub const SSL3_TXT_ADH_DES_192_CBC_SHA: &[u8; 17usize] = b"ADH-DES-CBC3-SHA\0";
pub const SSL3_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL3_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL3_MASTER_SECRET_SIZE: u32 = 48;
pub const SSL3_RANDOM_SIZE: u32 = 32;
pub const SSL3_SESSION_ID_SIZE: u32 = 32;
pub const SSL3_RT_HEADER_LENGTH: u32 = 5;
pub const SSL3_HM_HEADER_LENGTH: u32 = 4;
pub const SSL3_ALIGN_PAYLOAD: u32 = 8;
pub const SSL3_RT_MAX_MD_SIZE: u32 = 64;
pub const SSL_RT_MAX_CIPHER_BLOCK_SIZE: u32 = 16;
pub const SSL3_RT_MAX_EXTRA: u32 = 16384;
pub const SSL3_RT_MAX_PLAIN_LENGTH: u32 = 16384;
pub const SSL3_RT_MAX_COMPRESSED_OVERHEAD: u32 = 1024;
pub const SSL3_RT_MAX_ENCRYPTED_OVERHEAD: u32 = 320;
pub const SSL3_RT_MAX_TLS13_ENCRYPTED_OVERHEAD: u32 = 256;
pub const SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD: u32 = 80;
pub const SSL3_RT_MAX_COMPRESSED_LENGTH: u32 = 17408;
pub const SSL3_RT_MAX_ENCRYPTED_LENGTH: u32 = 17728;
pub const SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH: u32 = 16640;
pub const SSL3_RT_MAX_PACKET_SIZE: u32 = 17733;
pub const SSL3_MD_CLIENT_FINISHED_CONST: &[u8; 5usize] = b"CLNT\0";
pub const SSL3_MD_SERVER_FINISHED_CONST: &[u8; 5usize] = b"SRVR\0";
pub const SSL3_VERSION: u32 = 768;
pub const SSL3_VERSION_MAJOR: u32 = 3;
pub const SSL3_VERSION_MINOR: u32 = 0;
pub const SSL3_RT_CHANGE_CIPHER_SPEC: u32 = 20;
pub const SSL3_RT_ALERT: u32 = 21;
pub const SSL3_RT_HANDSHAKE: u32 = 22;
pub const SSL3_RT_APPLICATION_DATA: u32 = 23;
pub const DTLS1_RT_HEARTBEAT: u32 = 24;
pub const TLS1_RT_CRYPTO: u32 = 4096;
pub const TLS1_RT_CRYPTO_PREMASTER: u32 = 4097;
pub const TLS1_RT_CRYPTO_CLIENT_RANDOM: u32 = 4098;
pub const TLS1_RT_CRYPTO_SERVER_RANDOM: u32 = 4099;
pub const TLS1_RT_CRYPTO_MASTER: u32 = 4100;
pub const TLS1_RT_CRYPTO_READ: u32 = 0;
pub const TLS1_RT_CRYPTO_WRITE: u32 = 256;
pub const TLS1_RT_CRYPTO_MAC: u32 = 4101;
pub const TLS1_RT_CRYPTO_KEY: u32 = 4102;
pub const TLS1_RT_CRYPTO_IV: u32 = 4103;
pub const TLS1_RT_CRYPTO_FIXED_IV: u32 = 4104;
pub const SSL3_RT_HEADER: u32 = 256;
pub const SSL3_RT_INNER_CONTENT_TYPE: u32 = 257;
pub const SSL3_AL_WARNING: u32 = 1;
pub const SSL3_AL_FATAL: u32 = 2;
pub const SSL3_AD_CLOSE_NOTIFY: u32 = 0;
pub const SSL3_AD_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL3_AD_BAD_RECORD_MAC: u32 = 20;
pub const SSL3_AD_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL3_AD_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL3_AD_NO_CERTIFICATE: u32 = 41;
pub const SSL3_AD_BAD_CERTIFICATE: u32 = 42;
pub const SSL3_AD_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const SSL3_AD_CERTIFICATE_REVOKED: u32 = 44;
pub const SSL3_AD_CERTIFICATE_EXPIRED: u32 = 45;
pub const SSL3_AD_CERTIFICATE_UNKNOWN: u32 = 46;
pub const SSL3_AD_ILLEGAL_PARAMETER: u32 = 47;
pub const TLS1_HB_REQUEST: u32 = 1;
pub const TLS1_HB_RESPONSE: u32 = 2;
pub const SSL3_CT_RSA_SIGN: u32 = 1;
pub const SSL3_CT_DSS_SIGN: u32 = 2;
pub const SSL3_CT_RSA_FIXED_DH: u32 = 3;
pub const SSL3_CT_DSS_FIXED_DH: u32 = 4;
pub const SSL3_CT_RSA_EPHEMERAL_DH: u32 = 5;
pub const SSL3_CT_DSS_EPHEMERAL_DH: u32 = 6;
pub const SSL3_CT_FORTEZZA_DMS: u32 = 20;
pub const SSL3_CT_NUMBER: u32 = 10;
pub const SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS: u32 = 1;
pub const TLS1_FLAGS_TLS_PADDING_BUG: u32 = 0;
pub const TLS1_FLAGS_SKIP_CERT_VERIFY: u32 = 16;
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC_READ: u32 = 256;
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC: u32 = 256;
pub const TLS1_FLAGS_RECEIVED_EXTMS: u32 = 512;
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE: u32 = 1024;
pub const TLS1_FLAGS_STATELESS: u32 = 2048;
pub const TLS1_FLAGS_REQUIRED_EXTMS: u32 = 4096;
pub const SSL3_MT_HELLO_REQUEST: u32 = 0;
pub const SSL3_MT_CLIENT_HELLO: u32 = 1;
pub const SSL3_MT_SERVER_HELLO: u32 = 2;
pub const SSL3_MT_NEWSESSION_TICKET: u32 = 4;
pub const SSL3_MT_END_OF_EARLY_DATA: u32 = 5;
pub const SSL3_MT_ENCRYPTED_EXTENSIONS: u32 = 8;
pub const SSL3_MT_CERTIFICATE: u32 = 11;
pub const SSL3_MT_SERVER_KEY_EXCHANGE: u32 = 12;
pub const SSL3_MT_CERTIFICATE_REQUEST: u32 = 13;
pub const SSL3_MT_SERVER_DONE: u32 = 14;
pub const SSL3_MT_CERTIFICATE_VERIFY: u32 = 15;
pub const SSL3_MT_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const SSL3_MT_FINISHED: u32 = 20;
pub const SSL3_MT_CERTIFICATE_URL: u32 = 21;
pub const SSL3_MT_CERTIFICATE_STATUS: u32 = 22;
pub const SSL3_MT_SUPPLEMENTAL_DATA: u32 = 23;
pub const SSL3_MT_KEY_UPDATE: u32 = 24;
pub const SSL3_MT_NEXT_PROTO: u32 = 67;
pub const SSL3_MT_MESSAGE_HASH: u32 = 254;
pub const DTLS1_MT_HELLO_VERIFY_REQUEST: u32 = 3;
pub const SSL3_MT_CHANGE_CIPHER_SPEC: u32 = 257;
pub const SSL3_MT_CCS: u32 = 1;
pub const SSL3_CC_READ: u32 = 1;
pub const SSL3_CC_WRITE: u32 = 2;
pub const SSL3_CC_CLIENT: u32 = 16;
pub const SSL3_CC_SERVER: u32 = 32;
pub const SSL3_CC_EARLY: u32 = 64;
pub const SSL3_CC_HANDSHAKE: u32 = 128;
pub const SSL3_CC_APPLICATION: u32 = 256;
pub const SSL3_CHANGE_CIPHER_CLIENT_WRITE: u32 = 18;
pub const SSL3_CHANGE_CIPHER_SERVER_READ: u32 = 33;
pub const SSL3_CHANGE_CIPHER_CLIENT_READ: u32 = 17;
pub const SSL3_CHANGE_CIPHER_SERVER_WRITE: u32 = 34;
pub const OPENSSL_TLS_SECURITY_LEVEL: u32 = 1;
pub const TLS1_VERSION: u32 = 769;
pub const TLS1_1_VERSION: u32 = 770;
pub const TLS1_2_VERSION: u32 = 771;
pub const TLS1_3_VERSION: u32 = 772;
pub const TLS_MAX_VERSION: u32 = 772;
pub const TLS_ANY_VERSION: u32 = 65536;
pub const TLS1_VERSION_MAJOR: u32 = 3;
pub const TLS1_VERSION_MINOR: u32 = 1;
pub const TLS1_1_VERSION_MAJOR: u32 = 3;
pub const TLS1_1_VERSION_MINOR: u32 = 2;
pub const TLS1_2_VERSION_MAJOR: u32 = 3;
pub const TLS1_2_VERSION_MINOR: u32 = 3;
pub const TLS1_AD_DECRYPTION_FAILED: u32 = 21;
pub const TLS1_AD_RECORD_OVERFLOW: u32 = 22;
pub const TLS1_AD_UNKNOWN_CA: u32 = 48;
pub const TLS1_AD_ACCESS_DENIED: u32 = 49;
pub const TLS1_AD_DECODE_ERROR: u32 = 50;
pub const TLS1_AD_DECRYPT_ERROR: u32 = 51;
pub const TLS1_AD_EXPORT_RESTRICTION: u32 = 60;
pub const TLS1_AD_PROTOCOL_VERSION: u32 = 70;
pub const TLS1_AD_INSUFFICIENT_SECURITY: u32 = 71;
pub const TLS1_AD_INTERNAL_ERROR: u32 = 80;
pub const TLS1_AD_INAPPROPRIATE_FALLBACK: u32 = 86;
pub const TLS1_AD_USER_CANCELLED: u32 = 90;
pub const TLS1_AD_NO_RENEGOTIATION: u32 = 100;
pub const TLS13_AD_MISSING_EXTENSION: u32 = 109;
pub const TLS13_AD_CERTIFICATE_REQUIRED: u32 = 116;
pub const TLS1_AD_UNSUPPORTED_EXTENSION: u32 = 110;
pub const TLS1_AD_CERTIFICATE_UNOBTAINABLE: u32 = 111;
pub const TLS1_AD_UNRECOGNIZED_NAME: u32 = 112;
pub const TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 113;
pub const TLS1_AD_BAD_CERTIFICATE_HASH_VALUE: u32 = 114;
pub const TLS1_AD_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const TLS1_AD_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const TLSEXT_TYPE_server_name: u32 = 0;
pub const TLSEXT_TYPE_max_fragment_length: u32 = 1;
pub const TLSEXT_TYPE_client_certificate_url: u32 = 2;
pub const TLSEXT_TYPE_trusted_ca_keys: u32 = 3;
pub const TLSEXT_TYPE_truncated_hmac: u32 = 4;
pub const TLSEXT_TYPE_status_request: u32 = 5;
pub const TLSEXT_TYPE_user_mapping: u32 = 6;
pub const TLSEXT_TYPE_client_authz: u32 = 7;
pub const TLSEXT_TYPE_server_authz: u32 = 8;
pub const TLSEXT_TYPE_cert_type: u32 = 9;
pub const TLSEXT_TYPE_supported_groups: u32 = 10;
pub const TLSEXT_TYPE_elliptic_curves: u32 = 10;
pub const TLSEXT_TYPE_ec_point_formats: u32 = 11;
pub const TLSEXT_TYPE_srp: u32 = 12;
pub const TLSEXT_TYPE_signature_algorithms: u32 = 13;
pub const TLSEXT_TYPE_use_srtp: u32 = 14;
pub const TLSEXT_TYPE_heartbeat: u32 = 15;
pub const TLSEXT_TYPE_application_layer_protocol_negotiation: u32 = 16;
pub const TLSEXT_TYPE_signed_certificate_timestamp: u32 = 18;
pub const TLSEXT_TYPE_padding: u32 = 21;
pub const TLSEXT_TYPE_encrypt_then_mac: u32 = 22;
pub const TLSEXT_TYPE_extended_master_secret: u32 = 23;
pub const TLSEXT_TYPE_session_ticket: u32 = 35;
pub const TLSEXT_TYPE_psk: u32 = 41;
pub const TLSEXT_TYPE_early_data: u32 = 42;
pub const TLSEXT_TYPE_supported_versions: u32 = 43;
pub const TLSEXT_TYPE_cookie: u32 = 44;
pub const TLSEXT_TYPE_psk_kex_modes: u32 = 45;
pub const TLSEXT_TYPE_certificate_authorities: u32 = 47;
pub const TLSEXT_TYPE_post_handshake_auth: u32 = 49;
pub const TLSEXT_TYPE_signature_algorithms_cert: u32 = 50;
pub const TLSEXT_TYPE_key_share: u32 = 51;
pub const TLSEXT_TYPE_renegotiate: u32 = 65281;
pub const TLSEXT_TYPE_next_proto_neg: u32 = 13172;
pub const TLSEXT_NAMETYPE_host_name: u32 = 0;
pub const TLSEXT_STATUSTYPE_ocsp: u32 = 1;
pub const TLSEXT_ECPOINTFORMAT_first: u32 = 0;
pub const TLSEXT_ECPOINTFORMAT_uncompressed: u32 = 0;
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime: u32 = 1;
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2: u32 = 2;
pub const TLSEXT_ECPOINTFORMAT_last: u32 = 2;
pub const TLSEXT_signature_anonymous: u32 = 0;
pub const TLSEXT_signature_rsa: u32 = 1;
pub const TLSEXT_signature_dsa: u32 = 2;
pub const TLSEXT_signature_ecdsa: u32 = 3;
pub const TLSEXT_signature_gostr34102001: u32 = 237;
pub const TLSEXT_signature_gostr34102012_256: u32 = 238;
pub const TLSEXT_signature_gostr34102012_512: u32 = 239;
pub const TLSEXT_signature_num: u32 = 7;
pub const TLSEXT_hash_none: u32 = 0;
pub const TLSEXT_hash_md5: u32 = 1;
pub const TLSEXT_hash_sha1: u32 = 2;
pub const TLSEXT_hash_sha224: u32 = 3;
pub const TLSEXT_hash_sha256: u32 = 4;
pub const TLSEXT_hash_sha384: u32 = 5;
pub const TLSEXT_hash_sha512: u32 = 6;
pub const TLSEXT_hash_gostr3411: u32 = 237;
pub const TLSEXT_hash_gostr34112012_256: u32 = 238;
pub const TLSEXT_hash_gostr34112012_512: u32 = 239;
pub const TLSEXT_hash_num: u32 = 10;
pub const TLSEXT_nid_unknown: u32 = 16777216;
pub const TLSEXT_curve_P_256: u32 = 23;
pub const TLSEXT_curve_P_384: u32 = 24;
pub const TLSEXT_max_fragment_length_DISABLED: u32 = 0;
pub const TLSEXT_max_fragment_length_512: u32 = 1;
pub const TLSEXT_max_fragment_length_1024: u32 = 2;
pub const TLSEXT_max_fragment_length_2048: u32 = 3;
pub const TLSEXT_max_fragment_length_4096: u32 = 4;
pub const TLSEXT_MAXLEN_host_name: u32 = 255;
pub const SSL_TLSEXT_ERR_OK: u32 = 0;
pub const SSL_TLSEXT_ERR_ALERT_WARNING: u32 = 1;
pub const SSL_TLSEXT_ERR_ALERT_FATAL: u32 = 2;
pub const SSL_TLSEXT_ERR_NOACK: u32 = 3;
pub const TLS1_CK_PSK_WITH_RC4_128_SHA: u32 = 50331786;
pub const TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50331787;
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA: u32 = 50331788;
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA: u32 = 50331789;
pub const TLS1_CK_DHE_PSK_WITH_RC4_128_SHA: u32 = 50331790;
pub const TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50331791;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 50331792;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 50331793;
pub const TLS1_CK_RSA_PSK_WITH_RC4_128_SHA: u32 = 50331794;
pub const TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50331795;
pub const TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 50331796;
pub const TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 50331797;
pub const TLS1_CK_PSK_WITH_AES_128_GCM_SHA256: u32 = 50331816;
pub const TLS1_CK_PSK_WITH_AES_256_GCM_SHA384: u32 = 50331817;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 50331818;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 50331819;
pub const TLS1_CK_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 50331820;
pub const TLS1_CK_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 50331821;
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA256: u32 = 50331822;
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA384: u32 = 50331823;
pub const TLS1_CK_PSK_WITH_NULL_SHA256: u32 = 50331824;
pub const TLS1_CK_PSK_WITH_NULL_SHA384: u32 = 50331825;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 50331826;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 50331827;
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA256: u32 = 50331828;
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA384: u32 = 50331829;
pub const TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 50331830;
pub const TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 50331831;
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA256: u32 = 50331832;
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA384: u32 = 50331833;
pub const TLS1_CK_PSK_WITH_NULL_SHA: u32 = 50331692;
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA: u32 = 50331693;
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA: u32 = 50331694;
pub const TLS1_CK_RSA_WITH_AES_128_SHA: u32 = 50331695;
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA: u32 = 50331696;
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA: u32 = 50331697;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA: u32 = 50331698;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA: u32 = 50331699;
pub const TLS1_CK_ADH_WITH_AES_128_SHA: u32 = 50331700;
pub const TLS1_CK_RSA_WITH_AES_256_SHA: u32 = 50331701;
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA: u32 = 50331702;
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA: u32 = 50331703;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA: u32 = 50331704;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA: u32 = 50331705;
pub const TLS1_CK_ADH_WITH_AES_256_SHA: u32 = 50331706;
pub const TLS1_CK_RSA_WITH_NULL_SHA256: u32 = 50331707;
pub const TLS1_CK_RSA_WITH_AES_128_SHA256: u32 = 50331708;
pub const TLS1_CK_RSA_WITH_AES_256_SHA256: u32 = 50331709;
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA256: u32 = 50331710;
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA256: u32 = 50331711;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA256: u32 = 50331712;
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331713;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331714;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331715;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331716;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331717;
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331718;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA256: u32 = 50331751;
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA256: u32 = 50331752;
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA256: u32 = 50331753;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA256: u32 = 50331754;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA256: u32 = 50331755;
pub const TLS1_CK_ADH_WITH_AES_128_SHA256: u32 = 50331756;
pub const TLS1_CK_ADH_WITH_AES_256_SHA256: u32 = 50331757;
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331780;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331781;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331782;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331783;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331784;
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331785;
pub const TLS1_CK_RSA_WITH_SEED_SHA: u32 = 50331798;
pub const TLS1_CK_DH_DSS_WITH_SEED_SHA: u32 = 50331799;
pub const TLS1_CK_DH_RSA_WITH_SEED_SHA: u32 = 50331800;
pub const TLS1_CK_DHE_DSS_WITH_SEED_SHA: u32 = 50331801;
pub const TLS1_CK_DHE_RSA_WITH_SEED_SHA: u32 = 50331802;
pub const TLS1_CK_ADH_WITH_SEED_SHA: u32 = 50331803;
pub const TLS1_CK_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331804;
pub const TLS1_CK_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331805;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331806;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331807;
pub const TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331808;
pub const TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331809;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256: u32 = 50331810;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384: u32 = 50331811;
pub const TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256: u32 = 50331812;
pub const TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384: u32 = 50331813;
pub const TLS1_CK_ADH_WITH_AES_128_GCM_SHA256: u32 = 50331814;
pub const TLS1_CK_ADH_WITH_AES_256_GCM_SHA384: u32 = 50331815;
pub const TLS1_CK_RSA_WITH_AES_128_CCM: u32 = 50380956;
pub const TLS1_CK_RSA_WITH_AES_256_CCM: u32 = 50380957;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_CCM: u32 = 50380958;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_CCM: u32 = 50380959;
pub const TLS1_CK_RSA_WITH_AES_128_CCM_8: u32 = 50380960;
pub const TLS1_CK_RSA_WITH_AES_256_CCM_8: u32 = 50380961;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_CCM_8: u32 = 50380962;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_CCM_8: u32 = 50380963;
pub const TLS1_CK_PSK_WITH_AES_128_CCM: u32 = 50380964;
pub const TLS1_CK_PSK_WITH_AES_256_CCM: u32 = 50380965;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CCM: u32 = 50380966;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CCM: u32 = 50380967;
pub const TLS1_CK_PSK_WITH_AES_128_CCM_8: u32 = 50380968;
pub const TLS1_CK_PSK_WITH_AES_256_CCM_8: u32 = 50380969;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CCM_8: u32 = 50380970;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CCM_8: u32 = 50380971;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 50380972;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 50380973;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 50380974;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 50380975;
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331834;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331835;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331836;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331837;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331838;
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331839;
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331840;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331841;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331842;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331843;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331844;
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331845;
pub const TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA: u32 = 50380801;
pub const TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 50380802;
pub const TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: u32 = 50380803;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 50380804;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 50380805;
pub const TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 50380806;
pub const TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 50380807;
pub const TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: u32 = 50380808;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 50380809;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 50380810;
pub const TLS1_CK_ECDH_RSA_WITH_NULL_SHA: u32 = 50380811;
pub const TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA: u32 = 50380812;
pub const TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA: u32 = 50380813;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 50380814;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 50380815;
pub const TLS1_CK_ECDHE_RSA_WITH_NULL_SHA: u32 = 50380816;
pub const TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 50380817;
pub const TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA: u32 = 50380818;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 50380819;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 50380820;
pub const TLS1_CK_ECDH_anon_WITH_NULL_SHA: u32 = 50380821;
pub const TLS1_CK_ECDH_anon_WITH_RC4_128_SHA: u32 = 50380822;
pub const TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA: u32 = 50380823;
pub const TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA: u32 = 50380824;
pub const TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA: u32 = 50380825;
pub const TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA: u32 = 50380826;
pub const TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 50380827;
pub const TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: u32 = 50380828;
pub const TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA: u32 = 50380829;
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: u32 = 50380830;
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: u32 = 50380831;
pub const TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA: u32 = 50380832;
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: u32 = 50380833;
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: u32 = 50380834;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256: u32 = 50380835;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384: u32 = 50380836;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256: u32 = 50380837;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384: u32 = 50380838;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256: u32 = 50380839;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384: u32 = 50380840;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256: u32 = 50380841;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384: u32 = 50380842;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 50380843;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 50380844;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 50380845;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 50380846;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 50380847;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 50380848;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 50380849;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 50380850;
pub const TLS1_CK_ECDHE_PSK_WITH_RC4_128_SHA: u32 = 50380851;
pub const TLS1_CK_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50380852;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 50380853;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 50380854;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 50380855;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 50380856;
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA: u32 = 50380857;
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA256: u32 = 50380858;
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA384: u32 = 50380859;
pub const TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380914;
pub const TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380915;
pub const TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380916;
pub const TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380917;
pub const TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380918;
pub const TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380919;
pub const TLS1_CK_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380920;
pub const TLS1_CK_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380921;
pub const TLS1_CK_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380948;
pub const TLS1_CK_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380949;
pub const TLS1_CK_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380950;
pub const TLS1_CK_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380951;
pub const TLS1_CK_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380952;
pub const TLS1_CK_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380953;
pub const TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380954;
pub const TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380955;
pub const TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305: u32 = 50384040;
pub const TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: u32 = 50384041;
pub const TLS1_CK_DHE_RSA_WITH_CHACHA20_POLY1305: u32 = 50384042;
pub const TLS1_CK_PSK_WITH_CHACHA20_POLY1305: u32 = 50384043;
pub const TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305: u32 = 50384044;
pub const TLS1_CK_DHE_PSK_WITH_CHACHA20_POLY1305: u32 = 50384045;
pub const TLS1_CK_RSA_PSK_WITH_CHACHA20_POLY1305: u32 = 50384046;
pub const TLS1_3_CK_AES_128_GCM_SHA256: u32 = 50336513;
pub const TLS1_3_CK_AES_256_GCM_SHA384: u32 = 50336514;
pub const TLS1_3_CK_CHACHA20_POLY1305_SHA256: u32 = 50336515;
pub const TLS1_3_CK_AES_128_CCM_SHA256: u32 = 50336516;
pub const TLS1_3_CK_AES_128_CCM_8_SHA256: u32 = 50336517;
pub const TLS1_CK_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380880;
pub const TLS1_CK_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380881;
pub const TLS1_CK_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380882;
pub const TLS1_CK_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380883;
pub const TLS1_CK_DH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380884;
pub const TLS1_CK_DH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380885;
pub const TLS1_CK_DHE_DSS_WITH_ARIA_128_GCM_SHA256: u32 = 50380886;
pub const TLS1_CK_DHE_DSS_WITH_ARIA_256_GCM_SHA384: u32 = 50380887;
pub const TLS1_CK_DH_DSS_WITH_ARIA_128_GCM_SHA256: u32 = 50380888;
pub const TLS1_CK_DH_DSS_WITH_ARIA_256_GCM_SHA384: u32 = 50380889;
pub const TLS1_CK_DH_anon_WITH_ARIA_128_GCM_SHA256: u32 = 50380890;
pub const TLS1_CK_DH_anon_WITH_ARIA_256_GCM_SHA384: u32 = 50380891;
pub const TLS1_CK_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380892;
pub const TLS1_CK_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380893;
pub const TLS1_CK_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380894;
pub const TLS1_CK_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380895;
pub const TLS1_CK_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380896;
pub const TLS1_CK_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380897;
pub const TLS1_CK_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380898;
pub const TLS1_CK_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380899;
pub const TLS1_CK_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 50380906;
pub const TLS1_CK_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 50380907;
pub const TLS1_CK_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 50380908;
pub const TLS1_CK_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 50380909;
pub const TLS1_CK_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 50380910;
pub const TLS1_CK_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 50380911;
pub const TLS1_RFC_RSA_WITH_AES_128_SHA: &[u8; 29usize] = b"TLS_RSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_SHA: &[u8; 33usize] = b"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_SHA: &[u8; 33usize] = b"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_AES_128_SHA: &[u8; 33usize] = b"TLS_DH_anon_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_RSA_WITH_AES_256_SHA: &[u8; 29usize] = b"TLS_RSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_SHA: &[u8; 33usize] = b"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_SHA: &[u8; 33usize] = b"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_AES_256_SHA: &[u8; 33usize] = b"TLS_DH_anon_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_RSA_WITH_NULL_SHA256: &[u8; 25usize] = b"TLS_RSA_WITH_NULL_SHA256\0";
pub const TLS1_RFC_RSA_WITH_AES_128_SHA256: &[u8; 32usize] = b"TLS_RSA_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_RSA_WITH_AES_256_SHA256: &[u8; 32usize] = b"TLS_RSA_WITH_AES_256_CBC_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_SHA256: &[u8; 36usize] =
    b"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_SHA256: &[u8; 36usize] =
    b"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_SHA256: &[u8; 36usize] =
    b"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_SHA256: &[u8; 36usize] =
    b"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\0";
pub const TLS1_RFC_ADH_WITH_AES_128_SHA256: &[u8; 36usize] =
    b"TLS_DH_anon_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_ADH_WITH_AES_256_SHA256: &[u8; 36usize] =
    b"TLS_DH_anon_WITH_AES_256_CBC_SHA256\0";
pub const TLS1_RFC_RSA_WITH_AES_128_GCM_SHA256: &[u8; 32usize] =
    b"TLS_RSA_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_RSA_WITH_AES_256_GCM_SHA384: &[u8; 32usize] =
    b"TLS_RSA_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 36usize] =
    b"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 36usize] =
    b"TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_GCM_SHA256: &[u8; 36usize] =
    b"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_GCM_SHA384: &[u8; 36usize] =
    b"TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_ADH_WITH_AES_128_GCM_SHA256: &[u8; 36usize] =
    b"TLS_DH_anon_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_ADH_WITH_AES_256_GCM_SHA384: &[u8; 36usize] =
    b"TLS_DH_anon_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_RSA_WITH_AES_128_CCM: &[u8; 25usize] = b"TLS_RSA_WITH_AES_128_CCM\0";
pub const TLS1_RFC_RSA_WITH_AES_256_CCM: &[u8; 25usize] = b"TLS_RSA_WITH_AES_256_CCM\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_CCM: &[u8; 29usize] = b"TLS_DHE_RSA_WITH_AES_128_CCM\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_CCM: &[u8; 29usize] = b"TLS_DHE_RSA_WITH_AES_256_CCM\0";
pub const TLS1_RFC_RSA_WITH_AES_128_CCM_8: &[u8; 27usize] = b"TLS_RSA_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_RSA_WITH_AES_256_CCM_8: &[u8; 27usize] = b"TLS_RSA_WITH_AES_256_CCM_8\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_CCM_8: &[u8; 31usize] = b"TLS_DHE_RSA_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_CCM_8: &[u8; 31usize] = b"TLS_DHE_RSA_WITH_AES_256_CCM_8\0";
pub const TLS1_RFC_PSK_WITH_AES_128_CCM: &[u8; 25usize] = b"TLS_PSK_WITH_AES_128_CCM\0";
pub const TLS1_RFC_PSK_WITH_AES_256_CCM: &[u8; 25usize] = b"TLS_PSK_WITH_AES_256_CCM\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CCM: &[u8; 29usize] = b"TLS_DHE_PSK_WITH_AES_128_CCM\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CCM: &[u8; 29usize] = b"TLS_DHE_PSK_WITH_AES_256_CCM\0";
pub const TLS1_RFC_PSK_WITH_AES_128_CCM_8: &[u8; 27usize] = b"TLS_PSK_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_PSK_WITH_AES_256_CCM_8: &[u8; 27usize] = b"TLS_PSK_WITH_AES_256_CCM_8\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CCM_8: &[u8; 31usize] = b"TLS_PSK_DHE_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CCM_8: &[u8; 31usize] = b"TLS_PSK_DHE_WITH_AES_256_CCM_8\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CCM: &[u8; 33usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_128_CCM\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CCM: &[u8; 33usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_256_CCM\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CCM_8: &[u8; 35usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CCM_8: &[u8; 35usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8\0";
pub const TLS1_3_RFC_AES_128_GCM_SHA256: &[u8; 23usize] = b"TLS_AES_128_GCM_SHA256\0";
pub const TLS1_3_RFC_AES_256_GCM_SHA384: &[u8; 23usize] = b"TLS_AES_256_GCM_SHA384\0";
pub const TLS1_3_RFC_CHACHA20_POLY1305_SHA256: &[u8; 29usize] = b"TLS_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_3_RFC_AES_128_CCM_SHA256: &[u8; 23usize] = b"TLS_AES_128_CCM_SHA256\0";
pub const TLS1_3_RFC_AES_128_CCM_8_SHA256: &[u8; 25usize] = b"TLS_AES_128_CCM_8_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_NULL_SHA: &[u8; 30usize] = b"TLS_ECDHE_ECDSA_WITH_NULL_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: &[u8; 38usize] =
    b"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: &[u8; 37usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: &[u8; 37usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_NULL_SHA: &[u8; 28usize] = b"TLS_ECDHE_RSA_WITH_NULL_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_DES_192_CBC3_SHA: &[u8; 36usize] =
    b"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_CBC_SHA: &[u8; 35usize] =
    b"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_CBC_SHA: &[u8; 35usize] =
    b"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_NULL_SHA: &[u8; 28usize] = b"TLS_ECDH_anon_WITH_NULL_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_DES_192_CBC3_SHA: &[u8; 36usize] =
    b"TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_AES_128_CBC_SHA: &[u8; 35usize] =
    b"TLS_ECDH_anon_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_AES_256_CBC_SHA: &[u8; 35usize] =
    b"TLS_ECDH_anon_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_SHA256: &[u8; 40usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_SHA384: &[u8; 40usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_SHA256: &[u8; 38usize] =
    b"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_SHA384: &[u8; 38usize] =
    b"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: &[u8; 40usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: &[u8; 40usize] =
    b"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 38usize] =
    b"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 38usize] =
    b"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_PSK_WITH_NULL_SHA: &[u8; 22usize] = b"TLS_PSK_WITH_NULL_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA: &[u8; 26usize] = b"TLS_DHE_PSK_WITH_NULL_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA: &[u8; 26usize] = b"TLS_RSA_PSK_WITH_NULL_SHA\0";
pub const TLS1_RFC_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 30usize] = b"TLS_PSK_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_PSK_WITH_AES_128_CBC_SHA: &[u8; 29usize] = b"TLS_PSK_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_PSK_WITH_AES_256_CBC_SHA: &[u8; 29usize] = b"TLS_PSK_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 34usize] =
    b"TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 33usize] =
    b"TLS_DHE_PSK_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 33usize] =
    b"TLS_DHE_PSK_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 34usize] =
    b"TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_CBC_SHA: &[u8; 33usize] =
    b"TLS_RSA_PSK_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_CBC_SHA: &[u8; 33usize] =
    b"TLS_RSA_PSK_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_PSK_WITH_AES_128_GCM_SHA256: &[u8; 32usize] =
    b"TLS_PSK_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_PSK_WITH_AES_256_GCM_SHA384: &[u8; 32usize] =
    b"TLS_PSK_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_GCM_SHA256: &[u8; 36usize] =
    b"TLS_DHE_PSK_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_GCM_SHA384: &[u8; 36usize] =
    b"TLS_DHE_PSK_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_GCM_SHA256: &[u8; 36usize] =
    b"TLS_RSA_PSK_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_GCM_SHA384: &[u8; 36usize] =
    b"TLS_RSA_PSK_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_PSK_WITH_AES_128_CBC_SHA256: &[u8; 32usize] =
    b"TLS_PSK_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_PSK_WITH_AES_256_CBC_SHA384: &[u8; 32usize] =
    b"TLS_PSK_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_PSK_WITH_NULL_SHA256: &[u8; 25usize] = b"TLS_PSK_WITH_NULL_SHA256\0";
pub const TLS1_RFC_PSK_WITH_NULL_SHA384: &[u8; 25usize] = b"TLS_PSK_WITH_NULL_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CBC_SHA256: &[u8; 36usize] =
    b"TLS_DHE_PSK_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CBC_SHA384: &[u8; 36usize] =
    b"TLS_DHE_PSK_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA256: &[u8; 29usize] = b"TLS_DHE_PSK_WITH_NULL_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA384: &[u8; 29usize] = b"TLS_DHE_PSK_WITH_NULL_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_CBC_SHA256: &[u8; 36usize] =
    b"TLS_RSA_PSK_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_CBC_SHA384: &[u8; 36usize] =
    b"TLS_RSA_PSK_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA256: &[u8; 29usize] = b"TLS_RSA_PSK_WITH_NULL_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA384: &[u8; 29usize] = b"TLS_RSA_PSK_WITH_NULL_SHA384\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 36usize] =
    b"TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 35usize] =
    b"TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 35usize] =
    b"TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_128_CBC_SHA256: &[u8; 38usize] =
    b"TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_256_CBC_SHA384: &[u8; 38usize] =
    b"TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA: &[u8; 28usize] = b"TLS_ECDHE_PSK_WITH_NULL_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA256: &[u8; 31usize] = b"TLS_ECDHE_PSK_WITH_NULL_SHA256\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA384: &[u8; 31usize] = b"TLS_ECDHE_PSK_WITH_NULL_SHA384\0";
pub const TLS1_RFC_SRP_SHA_WITH_3DES_EDE_CBC_SHA: &[u8; 34usize] =
    b"TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: &[u8; 38usize] =
    b"TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: &[u8; 38usize] =
    b"TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_WITH_AES_128_CBC_SHA: &[u8; 33usize] =
    b"TLS_SRP_SHA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: &[u8; 37usize] =
    b"TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: &[u8; 37usize] =
    b"TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_WITH_AES_256_CBC_SHA: &[u8; 33usize] =
    b"TLS_SRP_SHA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: &[u8; 37usize] =
    b"TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: &[u8; 37usize] =
    b"TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_CHACHA20_POLY1305: &[u8; 42usize] =
    b"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_CHACHA20_POLY1305: &[u8; 44usize] =
    b"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: &[u8; 46usize] =
    b"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_PSK_WITH_CHACHA20_POLY1305: &[u8; 38usize] =
    b"TLS_PSK_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_CHACHA20_POLY1305: &[u8; 44usize] =
    b"TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_CHACHA20_POLY1305: &[u8; 42usize] =
    b"TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_CHACHA20_POLY1305: &[u8; 42usize] =
    b"TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 37usize] =
    b"TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41usize] =
    b"TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41usize] =
    b"TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41usize] =
    b"TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 37usize] =
    b"TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 41usize] =
    b"TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 41usize] =
    b"TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256\0";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 41usize] =
    b"TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256\0";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 34usize] =
    b"TLS_RSA_WITH_CAMELLIA_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: &[u8; 38usize] =
    b"TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 38usize] =
    b"TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_256_CBC_SHA: &[u8; 38usize] =
    b"TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA\0";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 34usize] =
    b"TLS_RSA_WITH_CAMELLIA_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: &[u8; 38usize] =
    b"TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 38usize] =
    b"TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_128_CBC_SHA: &[u8; 38usize] =
    b"TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 45usize] =
    b"TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 45usize] =
    b"TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 43usize] =
    b"TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 43usize] =
    b"TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 37usize] =
    b"TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 37usize] =
    b"TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41usize] =
    b"TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 41usize] =
    b"TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41usize] =
    b"TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 41usize] =
    b"TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 43usize] =
    b"TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 43usize] =
    b"TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_RSA_WITH_SEED_SHA: &[u8; 26usize] = b"TLS_RSA_WITH_SEED_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_SEED_SHA: &[u8; 30usize] = b"TLS_DHE_DSS_WITH_SEED_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_SEED_SHA: &[u8; 30usize] = b"TLS_DHE_RSA_WITH_SEED_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_SEED_SHA: &[u8; 30usize] = b"TLS_DH_anon_WITH_SEED_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_RC4_128_SHA: &[u8; 31usize] = b"TLS_ECDHE_PSK_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_RC4_128_SHA: &[u8; 31usize] = b"TLS_ECDH_anon_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_RC4_128_SHA: &[u8; 33usize] =
    b"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_RC4_128_SHA: &[u8; 31usize] = b"TLS_ECDHE_RSA_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_PSK_WITH_RC4_128_SHA: &[u8; 25usize] = b"TLS_PSK_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_RC4_128_SHA: &[u8; 29usize] = b"TLS_RSA_PSK_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_RC4_128_SHA: &[u8; 29usize] = b"TLS_DHE_PSK_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 33usize] =
    b"TLS_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 33usize] =
    b"TLS_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 37usize] =
    b"TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 37usize] =
    b"TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DH_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 36usize] =
    b"TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DH_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 36usize] =
    b"TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_DSS_WITH_ARIA_128_GCM_SHA256: &[u8; 37usize] =
    b"TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_ARIA_256_GCM_SHA384: &[u8; 37usize] =
    b"TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DH_DSS_WITH_ARIA_128_GCM_SHA256: &[u8; 36usize] =
    b"TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DH_DSS_WITH_ARIA_256_GCM_SHA384: &[u8; 36usize] =
    b"TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DH_anon_WITH_ARIA_128_GCM_SHA256: &[u8; 37usize] =
    b"TLS_DH_anon_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DH_anon_WITH_ARIA_256_GCM_SHA384: &[u8; 37usize] =
    b"TLS_DH_anon_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: &[u8; 41usize] =
    b"TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: &[u8; 41usize] =
    b"TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: &[u8; 40usize] =
    b"TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: &[u8; 40usize] =
    b"TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 39usize] =
    b"TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 39usize] =
    b"TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 38usize] =
    b"TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 38usize] =
    b"TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 33usize] =
    b"TLS_PSK_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 33usize] =
    b"TLS_PSK_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 37usize] =
    b"TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 37usize] =
    b"TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 37usize] =
    b"TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 37usize] =
    b"TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_TXT_DHE_DSS_WITH_RC4_128_SHA: &[u8; 16usize] = b"DHE-DSS-RC4-SHA\0";
pub const TLS1_TXT_PSK_WITH_NULL_SHA: &[u8; 13usize] = b"PSK-NULL-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA: &[u8; 17usize] = b"DHE-PSK-NULL-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA: &[u8; 17usize] = b"RSA-PSK-NULL-SHA\0";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA: &[u8; 11usize] = b"AES128-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA: &[u8; 18usize] = b"DH-DSS-AES128-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA: &[u8; 18usize] = b"DH-RSA-AES128-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA: &[u8; 19usize] = b"DHE-DSS-AES128-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA: &[u8; 19usize] = b"DHE-RSA-AES128-SHA\0";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA: &[u8; 15usize] = b"ADH-AES128-SHA\0";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA: &[u8; 11usize] = b"AES256-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA: &[u8; 18usize] = b"DH-DSS-AES256-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA: &[u8; 18usize] = b"DH-RSA-AES256-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA: &[u8; 19usize] = b"DHE-DSS-AES256-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA: &[u8; 19usize] = b"DHE-RSA-AES256-SHA\0";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA: &[u8; 15usize] = b"ADH-AES256-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_NULL_SHA: &[u8; 20usize] = b"ECDH-ECDSA-NULL-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_RC4_128_SHA: &[u8; 19usize] = b"ECDH-ECDSA-RC4-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: &[u8; 24usize] = b"ECDH-ECDSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_CBC_SHA: &[u8; 22usize] = b"ECDH-ECDSA-AES128-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_CBC_SHA: &[u8; 22usize] = b"ECDH-ECDSA-AES256-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_NULL_SHA: &[u8; 21usize] = b"ECDHE-ECDSA-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_RC4_128_SHA: &[u8; 20usize] = b"ECDHE-ECDSA-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: &[u8; 25usize] =
    b"ECDHE-ECDSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: &[u8; 23usize] = b"ECDHE-ECDSA-AES128-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: &[u8; 23usize] = b"ECDHE-ECDSA-AES256-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_NULL_SHA: &[u8; 18usize] = b"ECDH-RSA-NULL-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_RC4_128_SHA: &[u8; 17usize] = b"ECDH-RSA-RC4-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_DES_192_CBC3_SHA: &[u8; 22usize] = b"ECDH-RSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_CBC_SHA: &[u8; 20usize] = b"ECDH-RSA-AES128-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_CBC_SHA: &[u8; 20usize] = b"ECDH-RSA-AES256-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_NULL_SHA: &[u8; 19usize] = b"ECDHE-RSA-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_RC4_128_SHA: &[u8; 18usize] = b"ECDHE-RSA-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA: &[u8; 23usize] = b"ECDHE-RSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA: &[u8; 21usize] = b"ECDHE-RSA-AES128-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_CBC_SHA: &[u8; 21usize] = b"ECDHE-RSA-AES256-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_NULL_SHA: &[u8; 15usize] = b"AECDH-NULL-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_RC4_128_SHA: &[u8; 14usize] = b"AECDH-RC4-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_DES_192_CBC3_SHA: &[u8; 19usize] = b"AECDH-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_AES_128_CBC_SHA: &[u8; 17usize] = b"AECDH-AES128-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_AES_256_CBC_SHA: &[u8; 17usize] = b"AECDH-AES256-SHA\0";
pub const TLS1_TXT_PSK_WITH_RC4_128_SHA: &[u8; 12usize] = b"PSK-RC4-SHA\0";
pub const TLS1_TXT_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 21usize] = b"PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA: &[u8; 19usize] = b"PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA: &[u8; 19usize] = b"PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_RC4_128_SHA: &[u8; 16usize] = b"DHE-PSK-RC4-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 25usize] = b"DHE-PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 23usize] = b"DHE-PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 23usize] = b"DHE-PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_RC4_128_SHA: &[u8; 16usize] = b"RSA-PSK-RC4-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 25usize] = b"RSA-PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_CBC_SHA: &[u8; 23usize] = b"RSA-PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_CBC_SHA: &[u8; 23usize] = b"RSA-PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_128_GCM_SHA256: &[u8; 22usize] = b"PSK-AES128-GCM-SHA256\0";
pub const TLS1_TXT_PSK_WITH_AES_256_GCM_SHA384: &[u8; 22usize] = b"PSK-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_GCM_SHA256: &[u8; 26usize] = b"DHE-PSK-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_GCM_SHA384: &[u8; 26usize] = b"DHE-PSK-AES256-GCM-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_GCM_SHA256: &[u8; 26usize] = b"RSA-PSK-AES128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_GCM_SHA384: &[u8; 26usize] = b"RSA-PSK-AES256-GCM-SHA384\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA256: &[u8; 22usize] = b"PSK-AES128-CBC-SHA256\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA384: &[u8; 22usize] = b"PSK-AES256-CBC-SHA384\0";
pub const TLS1_TXT_PSK_WITH_NULL_SHA256: &[u8; 16usize] = b"PSK-NULL-SHA256\0";
pub const TLS1_TXT_PSK_WITH_NULL_SHA384: &[u8; 16usize] = b"PSK-NULL-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA256: &[u8; 26usize] = b"DHE-PSK-AES128-CBC-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA384: &[u8; 26usize] = b"DHE-PSK-AES256-CBC-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA256: &[u8; 20usize] = b"DHE-PSK-NULL-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA384: &[u8; 20usize] = b"DHE-PSK-NULL-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_CBC_SHA256: &[u8; 26usize] = b"RSA-PSK-AES128-CBC-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_CBC_SHA384: &[u8; 26usize] = b"RSA-PSK-AES256-CBC-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA256: &[u8; 20usize] = b"RSA-PSK-NULL-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA384: &[u8; 20usize] = b"RSA-PSK-NULL-SHA384\0";
pub const TLS1_TXT_SRP_SHA_WITH_3DES_EDE_CBC_SHA: &[u8; 21usize] = b"SRP-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: &[u8; 25usize] =
    b"SRP-RSA-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: &[u8; 25usize] =
    b"SRP-DSS-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_AES_128_CBC_SHA: &[u8; 20usize] = b"SRP-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: &[u8; 24usize] = b"SRP-RSA-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: &[u8; 24usize] = b"SRP-DSS-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_AES_256_CBC_SHA: &[u8; 20usize] = b"SRP-AES-256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: &[u8; 24usize] = b"SRP-RSA-AES-256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: &[u8; 24usize] = b"SRP-DSS-AES-256-CBC-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 16usize] = b"CAMELLIA128-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: &[u8; 23usize] = b"DH-DSS-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 23usize] = b"DH-RSA-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: &[u8; 24usize] = b"DHE-DSS-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 24usize] = b"DHE-RSA-CAMELLIA128-SHA\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA: &[u8; 20usize] = b"ADH-CAMELLIA128-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 16usize] = b"CAMELLIA256-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: &[u8; 23usize] = b"DH-DSS-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 23usize] = b"DH-RSA-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: &[u8; 24usize] = b"DHE-DSS-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 24usize] = b"DHE-RSA-CAMELLIA256-SHA\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA: &[u8; 20usize] = b"ADH-CAMELLIA256-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 19usize] = b"CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 26usize] =
    b"DH-DSS-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 26usize] =
    b"DH-RSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 27usize] =
    b"DHE-DSS-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 27usize] =
    b"DHE-RSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 23usize] = b"ADH-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 19usize] = b"CAMELLIA256-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 26usize] =
    b"DH-DSS-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 26usize] =
    b"DH-RSA-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 27usize] =
    b"DHE-DSS-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 27usize] =
    b"DHE-RSA-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 23usize] = b"ADH-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 23usize] = b"PSK-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 23usize] = b"PSK-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 27usize] =
    b"DHE-PSK-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 27usize] =
    b"DHE-PSK-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 27usize] =
    b"RSA-PSK-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 27usize] =
    b"RSA-PSK-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 29usize] =
    b"ECDHE-PSK-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 29usize] =
    b"ECDHE-PSK-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_RSA_WITH_SEED_SHA: &[u8; 9usize] = b"SEED-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_SEED_SHA: &[u8; 16usize] = b"DH-DSS-SEED-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_SEED_SHA: &[u8; 16usize] = b"DH-RSA-SEED-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_SEED_SHA: &[u8; 17usize] = b"DHE-DSS-SEED-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_SEED_SHA: &[u8; 17usize] = b"DHE-RSA-SEED-SHA\0";
pub const TLS1_TXT_ADH_WITH_SEED_SHA: &[u8; 13usize] = b"ADH-SEED-SHA\0";
pub const TLS1_TXT_RSA_WITH_NULL_SHA256: &[u8; 12usize] = b"NULL-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA256: &[u8; 14usize] = b"AES128-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA256: &[u8; 14usize] = b"AES256-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA256: &[u8; 21usize] = b"DH-DSS-AES128-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA256: &[u8; 21usize] = b"DH-RSA-AES128-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA256: &[u8; 22usize] = b"DHE-DSS-AES128-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256: &[u8; 22usize] = b"DHE-RSA-AES128-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA256: &[u8; 21usize] = b"DH-DSS-AES256-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA256: &[u8; 21usize] = b"DH-RSA-AES256-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA256: &[u8; 22usize] = b"DHE-DSS-AES256-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256: &[u8; 22usize] = b"DHE-RSA-AES256-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA256: &[u8; 18usize] = b"ADH-AES128-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA256: &[u8; 18usize] = b"ADH-AES256-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_128_GCM_SHA256: &[u8; 18usize] = b"AES128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_256_GCM_SHA384: &[u8; 18usize] = b"AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 26usize] = b"DHE-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 26usize] = b"DHE-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_GCM_SHA256: &[u8; 25usize] = b"DH-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_GCM_SHA384: &[u8; 25usize] = b"DH-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_GCM_SHA256: &[u8; 26usize] = b"DHE-DSS-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_GCM_SHA384: &[u8; 26usize] = b"DHE-DSS-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_GCM_SHA256: &[u8; 25usize] = b"DH-DSS-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_GCM_SHA384: &[u8; 25usize] = b"DH-DSS-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ADH_WITH_AES_128_GCM_SHA256: &[u8; 22usize] = b"ADH-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_256_GCM_SHA384: &[u8; 22usize] = b"ADH-AES256-GCM-SHA384\0";
pub const TLS1_TXT_RSA_WITH_AES_128_CCM: &[u8; 11usize] = b"AES128-CCM\0";
pub const TLS1_TXT_RSA_WITH_AES_256_CCM: &[u8; 11usize] = b"AES256-CCM\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_CCM: &[u8; 19usize] = b"DHE-RSA-AES128-CCM\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_CCM: &[u8; 19usize] = b"DHE-RSA-AES256-CCM\0";
pub const TLS1_TXT_RSA_WITH_AES_128_CCM_8: &[u8; 12usize] = b"AES128-CCM8\0";
pub const TLS1_TXT_RSA_WITH_AES_256_CCM_8: &[u8; 12usize] = b"AES256-CCM8\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_CCM_8: &[u8; 20usize] = b"DHE-RSA-AES128-CCM8\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_CCM_8: &[u8; 20usize] = b"DHE-RSA-AES256-CCM8\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CCM: &[u8; 15usize] = b"PSK-AES128-CCM\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CCM: &[u8; 15usize] = b"PSK-AES256-CCM\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CCM: &[u8; 19usize] = b"DHE-PSK-AES128-CCM\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CCM: &[u8; 19usize] = b"DHE-PSK-AES256-CCM\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CCM_8: &[u8; 16usize] = b"PSK-AES128-CCM8\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CCM_8: &[u8; 16usize] = b"PSK-AES256-CCM8\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CCM_8: &[u8; 20usize] = b"DHE-PSK-AES128-CCM8\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CCM_8: &[u8; 20usize] = b"DHE-PSK-AES256-CCM8\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM: &[u8; 23usize] = b"ECDHE-ECDSA-AES128-CCM\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CCM: &[u8; 23usize] = b"ECDHE-ECDSA-AES256-CCM\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM_8: &[u8; 24usize] = b"ECDHE-ECDSA-AES128-CCM8\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CCM_8: &[u8; 24usize] = b"ECDHE-ECDSA-AES256-CCM8\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256: &[u8; 26usize] = b"ECDHE-ECDSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384: &[u8; 26usize] = b"ECDHE-ECDSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_SHA256: &[u8; 25usize] = b"ECDH-ECDSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_SHA384: &[u8; 25usize] = b"ECDH-ECDSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_SHA256: &[u8; 24usize] = b"ECDHE-RSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384: &[u8; 24usize] = b"ECDHE-RSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_SHA256: &[u8; 23usize] = b"ECDH-RSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_SHA384: &[u8; 23usize] = b"ECDH-RSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: &[u8; 30usize] =
    b"ECDHE-ECDSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: &[u8; 30usize] =
    b"ECDHE-ECDSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: &[u8; 29usize] =
    b"ECDH-ECDSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: &[u8; 29usize] =
    b"ECDH-ECDSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 28usize] =
    b"ECDHE-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 28usize] =
    b"ECDHE-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256: &[u8; 27usize] =
    b"ECDH-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384: &[u8; 27usize] =
    b"ECDH-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_RC4_128_SHA: &[u8; 18usize] = b"ECDHE-PSK-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 27usize] =
    b"ECDHE-PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 25usize] = b"ECDHE-PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 25usize] = b"ECDHE-PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA256: &[u8; 28usize] =
    b"ECDHE-PSK-AES128-CBC-SHA256\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA384: &[u8; 28usize] =
    b"ECDHE-PSK-AES256-CBC-SHA384\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA: &[u8; 19usize] = b"ECDHE-PSK-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA256: &[u8; 22usize] = b"ECDHE-PSK-NULL-SHA256\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA384: &[u8; 22usize] = b"ECDHE-PSK-NULL-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 31usize] =
    b"ECDHE-ECDSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 31usize] =
    b"ECDHE-ECDSA-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 30usize] =
    b"ECDH-ECDSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 30usize] =
    b"ECDH-ECDSA-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 29usize] =
    b"ECDHE-RSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 29usize] =
    b"ECDHE-RSA-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 28usize] =
    b"ECDH-RSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 28usize] =
    b"ECDH-RSA-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_CHACHA20_POLY1305: &[u8; 28usize] =
    b"ECDHE-RSA-CHACHA20-POLY1305\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: &[u8; 30usize] =
    b"ECDHE-ECDSA-CHACHA20-POLY1305\0";
pub const TLS1_TXT_DHE_RSA_WITH_CHACHA20_POLY1305: &[u8; 26usize] = b"DHE-RSA-CHACHA20-POLY1305\0";
pub const TLS1_TXT_PSK_WITH_CHACHA20_POLY1305: &[u8; 22usize] = b"PSK-CHACHA20-POLY1305\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_CHACHA20_POLY1305: &[u8; 28usize] =
    b"ECDHE-PSK-CHACHA20-POLY1305\0";
pub const TLS1_TXT_DHE_PSK_WITH_CHACHA20_POLY1305: &[u8; 26usize] = b"DHE-PSK-CHACHA20-POLY1305\0";
pub const TLS1_TXT_RSA_PSK_WITH_CHACHA20_POLY1305: &[u8; 26usize] = b"RSA-PSK-CHACHA20-POLY1305\0";
pub const TLS1_TXT_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 19usize] = b"ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 19usize] = b"ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 27usize] =
    b"DHE-RSA-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 27usize] =
    b"DHE-RSA-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DH_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 26usize] = b"DH-RSA-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 26usize] = b"DH-RSA-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_DSS_WITH_ARIA_128_GCM_SHA256: &[u8; 27usize] =
    b"DHE-DSS-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_ARIA_256_GCM_SHA384: &[u8; 27usize] =
    b"DHE-DSS-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DH_DSS_WITH_ARIA_128_GCM_SHA256: &[u8; 26usize] = b"DH-DSS-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_ARIA_256_GCM_SHA384: &[u8; 26usize] = b"DH-DSS-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DH_anon_WITH_ARIA_128_GCM_SHA256: &[u8; 23usize] = b"ADH-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DH_anon_WITH_ARIA_256_GCM_SHA384: &[u8; 23usize] = b"ADH-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: &[u8; 31usize] =
    b"ECDHE-ECDSA-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: &[u8; 31usize] =
    b"ECDHE-ECDSA-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: &[u8; 30usize] =
    b"ECDH-ECDSA-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: &[u8; 30usize] =
    b"ECDH-ECDSA-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 25usize] =
    b"ECDHE-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 25usize] =
    b"ECDHE-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 24usize] = b"ECDH-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 24usize] = b"ECDH-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 23usize] = b"PSK-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 23usize] = b"PSK-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 27usize] =
    b"DHE-PSK-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 27usize] =
    b"DHE-PSK-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 27usize] =
    b"RSA-PSK-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 27usize] =
    b"RSA-PSK-ARIA256-GCM-SHA384\0";
pub const TLS_CT_RSA_SIGN: u32 = 1;
pub const TLS_CT_DSS_SIGN: u32 = 2;
pub const TLS_CT_RSA_FIXED_DH: u32 = 3;
pub const TLS_CT_DSS_FIXED_DH: u32 = 4;
pub const TLS_CT_ECDSA_SIGN: u32 = 64;
pub const TLS_CT_RSA_FIXED_ECDH: u32 = 65;
pub const TLS_CT_ECDSA_FIXED_ECDH: u32 = 66;
pub const TLS_CT_GOST01_SIGN: u32 = 22;
pub const TLS_CT_GOST12_SIGN: u32 = 238;
pub const TLS_CT_GOST12_512_SIGN: u32 = 239;
pub const TLS_CT_NUMBER: u32 = 10;
pub const TLS1_FINISH_MAC_LENGTH: u32 = 12;
pub const TLS_MD_MAX_CONST_SIZE: u32 = 22;
pub const TLS_MD_CLIENT_FINISH_CONST: &[u8; 16usize] = b"client finished\0";
pub const TLS_MD_CLIENT_FINISH_CONST_SIZE: u32 = 15;
pub const TLS_MD_SERVER_FINISH_CONST: &[u8; 16usize] = b"server finished\0";
pub const TLS_MD_SERVER_FINISH_CONST_SIZE: u32 = 15;
pub const TLS_MD_KEY_EXPANSION_CONST: &[u8; 14usize] = b"key expansion\0";
pub const TLS_MD_KEY_EXPANSION_CONST_SIZE: u32 = 13;
pub const TLS_MD_CLIENT_WRITE_KEY_CONST: &[u8; 17usize] = b"client write key\0";
pub const TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE: u32 = 16;
pub const TLS_MD_SERVER_WRITE_KEY_CONST: &[u8; 17usize] = b"server write key\0";
pub const TLS_MD_SERVER_WRITE_KEY_CONST_SIZE: u32 = 16;
pub const TLS_MD_IV_BLOCK_CONST: &[u8; 9usize] = b"IV block\0";
pub const TLS_MD_IV_BLOCK_CONST_SIZE: u32 = 8;
pub const TLS_MD_MASTER_SECRET_CONST: &[u8; 14usize] = b"master secret\0";
pub const TLS_MD_MASTER_SECRET_CONST_SIZE: u32 = 13;
pub const TLS_MD_EXTENDED_MASTER_SECRET_CONST: &[u8; 23usize] = b"extended master secret\0";
pub const TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE: u32 = 22;
pub const DTLS1_VERSION: u32 = 65279;
pub const DTLS1_2_VERSION: u32 = 65277;
pub const DTLS_MIN_VERSION: u32 = 65279;
pub const DTLS_MAX_VERSION: u32 = 65277;
pub const DTLS1_VERSION_MAJOR: u32 = 254;
pub const DTLS1_BAD_VER: u32 = 256;
pub const DTLS_ANY_VERSION: u32 = 131071;
pub const DTLS1_COOKIE_LENGTH: u32 = 256;
pub const DTLS1_RT_HEADER_LENGTH: u32 = 13;
pub const DTLS1_HM_HEADER_LENGTH: u32 = 12;
pub const DTLS1_HM_BAD_FRAGMENT: i32 = -2;
pub const DTLS1_HM_FRAGMENT_RETRY: i32 = -3;
pub const DTLS1_CCS_HEADER_LENGTH: u32 = 1;
pub const DTLS1_AL_HEADER_LENGTH: u32 = 2;
pub const DTLS1_TMO_READ_COUNT: u32 = 2;
pub const DTLS1_TMO_WRITE_COUNT: u32 = 2;
pub const DTLS1_TMO_ALERT_COUNT: u32 = 12;
pub const SRTP_AES128_CM_SHA1_80: u32 = 1;
pub const SRTP_AES128_CM_SHA1_32: u32 = 2;
pub const SRTP_AES128_F8_SHA1_80: u32 = 3;
pub const SRTP_AES128_F8_SHA1_32: u32 = 4;
pub const SRTP_NULL_SHA1_80: u32 = 5;
pub const SRTP_NULL_SHA1_32: u32 = 6;
pub const SRTP_AEAD_AES_128_GCM: u32 = 7;
pub const SRTP_AEAD_AES_256_GCM: u32 = 8;
pub const SSL_KEY_UPDATE_NONE: i32 = -1;
pub const SSL_KEY_UPDATE_NOT_REQUESTED: u32 = 0;
pub const SSL_KEY_UPDATE_REQUESTED: u32 = 1;
pub const SSL_ST_CONNECT: u32 = 4096;
pub const SSL_ST_ACCEPT: u32 = 8192;
pub const SSL_ST_MASK: u32 = 4095;
pub const SSL_CB_LOOP: u32 = 1;
pub const SSL_CB_EXIT: u32 = 2;
pub const SSL_CB_READ: u32 = 4;
pub const SSL_CB_WRITE: u32 = 8;
pub const SSL_CB_ALERT: u32 = 16384;
pub const SSL_CB_READ_ALERT: u32 = 16388;
pub const SSL_CB_WRITE_ALERT: u32 = 16392;
pub const SSL_CB_ACCEPT_LOOP: u32 = 8193;
pub const SSL_CB_ACCEPT_EXIT: u32 = 8194;
pub const SSL_CB_CONNECT_LOOP: u32 = 4097;
pub const SSL_CB_CONNECT_EXIT: u32 = 4098;
pub const SSL_CB_HANDSHAKE_START: u32 = 16;
pub const SSL_CB_HANDSHAKE_DONE: u32 = 32;
pub const SSL_ST_READ_HEADER: u32 = 240;
pub const SSL_ST_READ_BODY: u32 = 241;
pub const SSL_ST_READ_DONE: u32 = 242;
pub const SSL_VERIFY_NONE: u32 = 0;
pub const SSL_VERIFY_PEER: u32 = 1;
pub const SSL_VERIFY_FAIL_IF_NO_PEER_CERT: u32 = 2;
pub const SSL_VERIFY_CLIENT_ONCE: u32 = 4;
pub const SSL_VERIFY_POST_HANDSHAKE: u32 = 8;
pub const SSL_AD_REASON_OFFSET: u32 = 1000;
pub const SSL_AD_CLOSE_NOTIFY: u32 = 0;
pub const SSL_AD_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL_AD_BAD_RECORD_MAC: u32 = 20;
pub const SSL_AD_DECRYPTION_FAILED: u32 = 21;
pub const SSL_AD_RECORD_OVERFLOW: u32 = 22;
pub const SSL_AD_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL_AD_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL_AD_NO_CERTIFICATE: u32 = 41;
pub const SSL_AD_BAD_CERTIFICATE: u32 = 42;
pub const SSL_AD_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const SSL_AD_CERTIFICATE_REVOKED: u32 = 44;
pub const SSL_AD_CERTIFICATE_EXPIRED: u32 = 45;
pub const SSL_AD_CERTIFICATE_UNKNOWN: u32 = 46;
pub const SSL_AD_ILLEGAL_PARAMETER: u32 = 47;
pub const SSL_AD_UNKNOWN_CA: u32 = 48;
pub const SSL_AD_ACCESS_DENIED: u32 = 49;
pub const SSL_AD_DECODE_ERROR: u32 = 50;
pub const SSL_AD_DECRYPT_ERROR: u32 = 51;
pub const SSL_AD_EXPORT_RESTRICTION: u32 = 60;
pub const SSL_AD_PROTOCOL_VERSION: u32 = 70;
pub const SSL_AD_INSUFFICIENT_SECURITY: u32 = 71;
pub const SSL_AD_INTERNAL_ERROR: u32 = 80;
pub const SSL_AD_USER_CANCELLED: u32 = 90;
pub const SSL_AD_NO_RENEGOTIATION: u32 = 100;
pub const SSL_AD_MISSING_EXTENSION: u32 = 109;
pub const SSL_AD_CERTIFICATE_REQUIRED: u32 = 116;
pub const SSL_AD_UNSUPPORTED_EXTENSION: u32 = 110;
pub const SSL_AD_CERTIFICATE_UNOBTAINABLE: u32 = 111;
pub const SSL_AD_UNRECOGNIZED_NAME: u32 = 112;
pub const SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 113;
pub const SSL_AD_BAD_CERTIFICATE_HASH_VALUE: u32 = 114;
pub const SSL_AD_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const SSL_AD_INAPPROPRIATE_FALLBACK: u32 = 86;
pub const SSL_AD_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const SSL_ERROR_NONE: u32 = 0;
pub const SSL_ERROR_SSL: u32 = 1;
pub const SSL_ERROR_WANT_READ: u32 = 2;
pub const SSL_ERROR_WANT_WRITE: u32 = 3;
pub const SSL_ERROR_WANT_X509_LOOKUP: u32 = 4;
pub const SSL_ERROR_SYSCALL: u32 = 5;
pub const SSL_ERROR_ZERO_RETURN: u32 = 6;
pub const SSL_ERROR_WANT_CONNECT: u32 = 7;
pub const SSL_ERROR_WANT_ACCEPT: u32 = 8;
pub const SSL_ERROR_WANT_ASYNC: u32 = 9;
pub const SSL_ERROR_WANT_ASYNC_JOB: u32 = 10;
pub const SSL_ERROR_WANT_CLIENT_HELLO_CB: u32 = 11;
pub const SSL_CTRL_SET_TMP_DH: u32 = 3;
pub const SSL_CTRL_SET_TMP_ECDH: u32 = 4;
pub const SSL_CTRL_SET_TMP_DH_CB: u32 = 6;
pub const SSL_CTRL_GET_CLIENT_CERT_REQUEST: u32 = 9;
pub const SSL_CTRL_GET_NUM_RENEGOTIATIONS: u32 = 10;
pub const SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS: u32 = 11;
pub const SSL_CTRL_GET_TOTAL_RENEGOTIATIONS: u32 = 12;
pub const SSL_CTRL_GET_FLAGS: u32 = 13;
pub const SSL_CTRL_EXTRA_CHAIN_CERT: u32 = 14;
pub const SSL_CTRL_SET_MSG_CALLBACK: u32 = 15;
pub const SSL_CTRL_SET_MSG_CALLBACK_ARG: u32 = 16;
pub const SSL_CTRL_SET_MTU: u32 = 17;
pub const SSL_CTRL_SESS_NUMBER: u32 = 20;
pub const SSL_CTRL_SESS_CONNECT: u32 = 21;
pub const SSL_CTRL_SESS_CONNECT_GOOD: u32 = 22;
pub const SSL_CTRL_SESS_CONNECT_RENEGOTIATE: u32 = 23;
pub const SSL_CTRL_SESS_ACCEPT: u32 = 24;
pub const SSL_CTRL_SESS_ACCEPT_GOOD: u32 = 25;
pub const SSL_CTRL_SESS_ACCEPT_RENEGOTIATE: u32 = 26;
pub const SSL_CTRL_SESS_HIT: u32 = 27;
pub const SSL_CTRL_SESS_CB_HIT: u32 = 28;
pub const SSL_CTRL_SESS_MISSES: u32 = 29;
pub const SSL_CTRL_SESS_TIMEOUTS: u32 = 30;
pub const SSL_CTRL_SESS_CACHE_FULL: u32 = 31;
pub const SSL_CTRL_MODE: u32 = 33;
pub const SSL_CTRL_GET_READ_AHEAD: u32 = 40;
pub const SSL_CTRL_SET_READ_AHEAD: u32 = 41;
pub const SSL_CTRL_SET_SESS_CACHE_SIZE: u32 = 42;
pub const SSL_CTRL_GET_SESS_CACHE_SIZE: u32 = 43;
pub const SSL_CTRL_SET_SESS_CACHE_MODE: u32 = 44;
pub const SSL_CTRL_GET_SESS_CACHE_MODE: u32 = 45;
pub const SSL_CTRL_GET_MAX_CERT_LIST: u32 = 50;
pub const SSL_CTRL_SET_MAX_CERT_LIST: u32 = 51;
pub const SSL_CTRL_SET_MAX_SEND_FRAGMENT: u32 = 52;
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_CB: u32 = 53;
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG: u32 = 54;
pub const SSL_CTRL_SET_TLSEXT_HOSTNAME: u32 = 55;
pub const SSL_CTRL_SET_TLSEXT_DEBUG_CB: u32 = 56;
pub const SSL_CTRL_SET_TLSEXT_DEBUG_ARG: u32 = 57;
pub const SSL_CTRL_GET_TLSEXT_TICKET_KEYS: u32 = 58;
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEYS: u32 = 59;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB: u32 = 63;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG: u32 = 64;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE: u32 = 65;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS: u32 = 66;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS: u32 = 67;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS: u32 = 68;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS: u32 = 69;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP: u32 = 70;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP: u32 = 71;
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB: u32 = 72;
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB: u32 = 75;
pub const SSL_CTRL_SET_SRP_VERIFY_PARAM_CB: u32 = 76;
pub const SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB: u32 = 77;
pub const SSL_CTRL_SET_SRP_ARG: u32 = 78;
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME: u32 = 79;
pub const SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH: u32 = 80;
pub const SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD: u32 = 81;
pub const DTLS_CTRL_GET_TIMEOUT: u32 = 73;
pub const DTLS_CTRL_HANDLE_TIMEOUT: u32 = 74;
pub const SSL_CTRL_GET_RI_SUPPORT: u32 = 76;
pub const SSL_CTRL_CLEAR_MODE: u32 = 78;
pub const SSL_CTRL_SET_NOT_RESUMABLE_SESS_CB: u32 = 79;
pub const SSL_CTRL_GET_EXTRA_CHAIN_CERTS: u32 = 82;
pub const SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS: u32 = 83;
pub const SSL_CTRL_CHAIN: u32 = 88;
pub const SSL_CTRL_CHAIN_CERT: u32 = 89;
pub const SSL_CTRL_GET_GROUPS: u32 = 90;
pub const SSL_CTRL_SET_GROUPS: u32 = 91;
pub const SSL_CTRL_SET_GROUPS_LIST: u32 = 92;
pub const SSL_CTRL_GET_SHARED_GROUP: u32 = 93;
pub const SSL_CTRL_SET_SIGALGS: u32 = 97;
pub const SSL_CTRL_SET_SIGALGS_LIST: u32 = 98;
pub const SSL_CTRL_CERT_FLAGS: u32 = 99;
pub const SSL_CTRL_CLEAR_CERT_FLAGS: u32 = 100;
pub const SSL_CTRL_SET_CLIENT_SIGALGS: u32 = 101;
pub const SSL_CTRL_SET_CLIENT_SIGALGS_LIST: u32 = 102;
pub const SSL_CTRL_GET_CLIENT_CERT_TYPES: u32 = 103;
pub const SSL_CTRL_SET_CLIENT_CERT_TYPES: u32 = 104;
pub const SSL_CTRL_BUILD_CERT_CHAIN: u32 = 105;
pub const SSL_CTRL_SET_VERIFY_CERT_STORE: u32 = 106;
pub const SSL_CTRL_SET_CHAIN_CERT_STORE: u32 = 107;
pub const SSL_CTRL_GET_PEER_SIGNATURE_NID: u32 = 108;
pub const SSL_CTRL_GET_PEER_TMP_KEY: u32 = 109;
pub const SSL_CTRL_GET_RAW_CIPHERLIST: u32 = 110;
pub const SSL_CTRL_GET_EC_POINT_FORMATS: u32 = 111;
pub const SSL_CTRL_GET_CHAIN_CERTS: u32 = 115;
pub const SSL_CTRL_SELECT_CURRENT_CERT: u32 = 116;
pub const SSL_CTRL_SET_CURRENT_CERT: u32 = 117;
pub const SSL_CTRL_SET_DH_AUTO: u32 = 118;
pub const DTLS_CTRL_SET_LINK_MTU: u32 = 120;
pub const DTLS_CTRL_GET_LINK_MIN_MTU: u32 = 121;
pub const SSL_CTRL_GET_EXTMS_SUPPORT: u32 = 122;
pub const SSL_CTRL_SET_MIN_PROTO_VERSION: u32 = 123;
pub const SSL_CTRL_SET_MAX_PROTO_VERSION: u32 = 124;
pub const SSL_CTRL_SET_SPLIT_SEND_FRAGMENT: u32 = 125;
pub const SSL_CTRL_SET_MAX_PIPELINES: u32 = 126;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE: u32 = 127;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB: u32 = 128;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG: u32 = 129;
pub const SSL_CTRL_GET_MIN_PROTO_VERSION: u32 = 130;
pub const SSL_CTRL_GET_MAX_PROTO_VERSION: u32 = 131;
pub const SSL_CTRL_GET_SIGNATURE_NID: u32 = 132;
pub const SSL_CTRL_GET_TMP_KEY: u32 = 133;
pub const SSL_CERT_SET_FIRST: u32 = 1;
pub const SSL_CERT_SET_NEXT: u32 = 2;
pub const SSL_CERT_SET_SERVER: u32 = 3;
pub const SSL_CTRL_GET_SERVER_TMP_KEY: u32 = 109;
pub const SSL_CTRL_GET_CURVES: u32 = 90;
pub const SSL_CTRL_SET_CURVES: u32 = 91;
pub const SSL_CTRL_SET_CURVES_LIST: u32 = 92;
pub const SSL_CTRL_GET_SHARED_CURVE: u32 = 93;
pub const SSL_SERVERINFOV1: u32 = 1;
pub const SSL_SERVERINFOV2: u32 = 2;
pub const SSL_CLIENT_HELLO_SUCCESS: u32 = 1;
pub const SSL_CLIENT_HELLO_ERROR: u32 = 0;
pub const SSL_CLIENT_HELLO_RETRY: i32 = -1;
pub const SSL_READ_EARLY_DATA_ERROR: u32 = 0;
pub const SSL_READ_EARLY_DATA_SUCCESS: u32 = 1;
pub const SSL_READ_EARLY_DATA_FINISH: u32 = 2;
pub const SSL_EARLY_DATA_NOT_SENT: u32 = 0;
pub const SSL_EARLY_DATA_REJECTED: u32 = 1;
pub const SSL_EARLY_DATA_ACCEPTED: u32 = 2;
pub const SSL_SECOP_OTHER_TYPE: u32 = 4294901760;
pub const SSL_SECOP_OTHER_NONE: u32 = 0;
pub const SSL_SECOP_OTHER_CIPHER: u32 = 65536;
pub const SSL_SECOP_OTHER_CURVE: u32 = 131072;
pub const SSL_SECOP_OTHER_DH: u32 = 196608;
pub const SSL_SECOP_OTHER_PKEY: u32 = 262144;
pub const SSL_SECOP_OTHER_SIGALG: u32 = 327680;
pub const SSL_SECOP_OTHER_CERT: u32 = 393216;
pub const SSL_SECOP_PEER: u32 = 4096;
pub const SSL_SECOP_CIPHER_SUPPORTED: u32 = 65537;
pub const SSL_SECOP_CIPHER_SHARED: u32 = 65538;
pub const SSL_SECOP_CIPHER_CHECK: u32 = 65539;
pub const SSL_SECOP_CURVE_SUPPORTED: u32 = 131076;
pub const SSL_SECOP_CURVE_SHARED: u32 = 131077;
pub const SSL_SECOP_CURVE_CHECK: u32 = 131078;
pub const SSL_SECOP_TMP_DH: u32 = 262151;
pub const SSL_SECOP_VERSION: u32 = 9;
pub const SSL_SECOP_TICKET: u32 = 10;
pub const SSL_SECOP_SIGALG_SUPPORTED: u32 = 327691;
pub const SSL_SECOP_SIGALG_SHARED: u32 = 327692;
pub const SSL_SECOP_SIGALG_CHECK: u32 = 327693;
pub const SSL_SECOP_SIGALG_MASK: u32 = 327694;
pub const SSL_SECOP_COMPRESSION: u32 = 15;
pub const SSL_SECOP_EE_KEY: u32 = 393232;
pub const SSL_SECOP_CA_KEY: u32 = 393233;
pub const SSL_SECOP_CA_MD: u32 = 393234;
pub const SSL_SECOP_PEER_EE_KEY: u32 = 397328;
pub const SSL_SECOP_PEER_CA_KEY: u32 = 397329;
pub const SSL_SECOP_PEER_CA_MD: u32 = 397330;
pub const OPENSSL_INIT_NO_LOAD_SSL_STRINGS: u32 = 1048576;
pub const OPENSSL_INIT_LOAD_SSL_STRINGS: u32 = 2097152;
pub const OPENSSL_INIT_SSL_DEFAULT: u32 = 2097154;
pub const SSL_TICKET_FATAL_ERR_MALLOC: u32 = 0;
pub const SSL_TICKET_FATAL_ERR_OTHER: u32 = 1;
pub const SSL_TICKET_NONE: u32 = 2;
pub const SSL_TICKET_EMPTY: u32 = 3;
pub const SSL_TICKET_NO_DECRYPT: u32 = 4;
pub const SSL_TICKET_SUCCESS: u32 = 5;
pub const SSL_TICKET_SUCCESS_RENEW: u32 = 6;
pub const SSL_TICKET_RETURN_ABORT: u32 = 0;
pub const SSL_TICKET_RETURN_IGNORE: u32 = 1;
pub const SSL_TICKET_RETURN_IGNORE_RENEW: u32 = 2;
pub const SSL_TICKET_RETURN_USE: u32 = 3;
pub const SSL_TICKET_RETURN_USE_RENEW: u32 = 4;
pub const _ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const EPOISONED: u32 = 134;
pub const ENOTSUP: u32 = 95;
pub const ERR_TXT_MALLOCED: u32 = 1;
pub const ERR_TXT_STRING: u32 = 2;
pub const ERR_FLAG_MARK: u32 = 1;
pub const ERR_FLAG_CLEAR: u32 = 2;
pub const ERR_NUM_ERRORS: u32 = 16;
pub const ERR_LIB_NONE: u32 = 1;
pub const ERR_LIB_SYS: u32 = 2;
pub const ERR_LIB_BN: u32 = 3;
pub const ERR_LIB_RSA: u32 = 4;
pub const ERR_LIB_DH: u32 = 5;
pub const ERR_LIB_EVP: u32 = 6;
pub const ERR_LIB_BUF: u32 = 7;
pub const ERR_LIB_OBJ: u32 = 8;
pub const ERR_LIB_PEM: u32 = 9;
pub const ERR_LIB_DSA: u32 = 10;
pub const ERR_LIB_X509: u32 = 11;
pub const ERR_LIB_ASN1: u32 = 13;
pub const ERR_LIB_CONF: u32 = 14;
pub const ERR_LIB_CRYPTO: u32 = 15;
pub const ERR_LIB_EC: u32 = 16;
pub const ERR_LIB_SSL: u32 = 20;
pub const ERR_LIB_BIO: u32 = 32;
pub const ERR_LIB_PKCS7: u32 = 33;
pub const ERR_LIB_X509V3: u32 = 34;
pub const ERR_LIB_PKCS12: u32 = 35;
pub const ERR_LIB_RAND: u32 = 36;
pub const ERR_LIB_DSO: u32 = 37;
pub const ERR_LIB_ENGINE: u32 = 38;
pub const ERR_LIB_OCSP: u32 = 39;
pub const ERR_LIB_UI: u32 = 40;
pub const ERR_LIB_COMP: u32 = 41;
pub const ERR_LIB_ECDSA: u32 = 42;
pub const ERR_LIB_ECDH: u32 = 43;
pub const ERR_LIB_OSSL_STORE: u32 = 44;
pub const ERR_LIB_FIPS: u32 = 45;
pub const ERR_LIB_CMS: u32 = 46;
pub const ERR_LIB_TS: u32 = 47;
pub const ERR_LIB_HMAC: u32 = 48;
pub const ERR_LIB_CT: u32 = 50;
pub const ERR_LIB_ASYNC: u32 = 51;
pub const ERR_LIB_KDF: u32 = 52;
pub const ERR_LIB_SM2: u32 = 53;
pub const ERR_LIB_USER: u32 = 128;
pub const SYS_F_FOPEN: u32 = 1;
pub const SYS_F_CONNECT: u32 = 2;
pub const SYS_F_GETSERVBYNAME: u32 = 3;
pub const SYS_F_SOCKET: u32 = 4;
pub const SYS_F_IOCTLSOCKET: u32 = 5;
pub const SYS_F_BIND: u32 = 6;
pub const SYS_F_LISTEN: u32 = 7;
pub const SYS_F_ACCEPT: u32 = 8;
pub const SYS_F_WSASTARTUP: u32 = 9;
pub const SYS_F_OPENDIR: u32 = 10;
pub const SYS_F_FREAD: u32 = 11;
pub const SYS_F_GETADDRINFO: u32 = 12;
pub const SYS_F_GETNAMEINFO: u32 = 13;
pub const SYS_F_SETSOCKOPT: u32 = 14;
pub const SYS_F_GETSOCKOPT: u32 = 15;
pub const SYS_F_GETSOCKNAME: u32 = 16;
pub const SYS_F_GETHOSTBYNAME: u32 = 17;
pub const SYS_F_FFLUSH: u32 = 18;
pub const SYS_F_OPEN: u32 = 19;
pub const SYS_F_CLOSE: u32 = 20;
pub const SYS_F_IOCTL: u32 = 21;
pub const SYS_F_STAT: u32 = 22;
pub const SYS_F_FCNTL: u32 = 23;
pub const SYS_F_FSTAT: u32 = 24;
pub const ERR_R_SYS_LIB: u32 = 2;
pub const ERR_R_BN_LIB: u32 = 3;
pub const ERR_R_RSA_LIB: u32 = 4;
pub const ERR_R_DH_LIB: u32 = 5;
pub const ERR_R_EVP_LIB: u32 = 6;
pub const ERR_R_BUF_LIB: u32 = 7;
pub const ERR_R_OBJ_LIB: u32 = 8;
pub const ERR_R_PEM_LIB: u32 = 9;
pub const ERR_R_DSA_LIB: u32 = 10;
pub const ERR_R_X509_LIB: u32 = 11;
pub const ERR_R_ASN1_LIB: u32 = 13;
pub const ERR_R_EC_LIB: u32 = 16;
pub const ERR_R_BIO_LIB: u32 = 32;
pub const ERR_R_PKCS7_LIB: u32 = 33;
pub const ERR_R_X509V3_LIB: u32 = 34;
pub const ERR_R_ENGINE_LIB: u32 = 38;
pub const ERR_R_UI_LIB: u32 = 40;
pub const ERR_R_ECDSA_LIB: u32 = 42;
pub const ERR_R_OSSL_STORE_LIB: u32 = 44;
pub const ERR_R_NESTED_ASN1_ERROR: u32 = 58;
pub const ERR_R_MISSING_ASN1_EOS: u32 = 63;
pub const ERR_R_FATAL: u32 = 64;
pub const ERR_R_MALLOC_FAILURE: u32 = 65;
pub const ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED: u32 = 66;
pub const ERR_R_PASSED_NULL_PARAMETER: u32 = 67;
pub const ERR_R_INTERNAL_ERROR: u32 = 68;
pub const ERR_R_DISABLED: u32 = 69;
pub const ERR_R_INIT_FAIL: u32 = 70;
pub const ERR_R_PASSED_INVALID_ARGUMENT: u32 = 7;
pub const ERR_R_OPERATION_FAIL: u32 = 72;
pub const STAT64_OK: u32 = 1;
pub const _SYS_STAT_H: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 0;
pub const _STAT_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_LINUX: u32 = 0;
pub const _STAT_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const _MKNOD_VER: u32 = 0;
pub const _SF64_PREFIX: &[u8; 2usize] = b"l\0";
pub const STDu64: &[u8; 4usize] = b"%lu\0";
pub const STDi64: &[u8; 4usize] = b"%li\0";
pub const STDx64: &[u8; 4usize] = b"%lx\0";
pub const STDu32: &[u8; 3usize] = b"%u\0";
pub const STDi32: &[u8; 3usize] = b"%i\0";
pub const STDx32: &[u8; 3usize] = b"%x\0";
pub const CLAMAV_VERSION: &[u8; 8usize] = b"0.104.3\0";
pub const CLAMAV_VERSION_NUM: u32 = 26627;
pub const LIBCLAMAV_VERSION: &[u8; 6usize] = b"9.1.0\0";
pub const LIBCLAMAV_VERSION_NUM: u32 = 655361;
pub const LIBFRESHCLAM_VERSION: &[u8; 6usize] = b"2.0.2\0";
pub const LIBFRESHCLAM_VERSION_NUM: u32 = 131584;
pub const CL_COUNT_PRECISION: u32 = 4096;
pub const CL_DB_PHISHING: u32 = 2;
pub const CL_DB_PHISHING_URLS: u32 = 8;
pub const CL_DB_PUA: u32 = 16;
pub const CL_DB_CVDNOTMP: u32 = 32;
pub const CL_DB_OFFICIAL: u32 = 64;
pub const CL_DB_PUA_MODE: u32 = 128;
pub const CL_DB_PUA_INCLUDE: u32 = 256;
pub const CL_DB_PUA_EXCLUDE: u32 = 512;
pub const CL_DB_COMPILED: u32 = 1024;
pub const CL_DB_DIRECTORY: u32 = 2048;
pub const CL_DB_OFFICIAL_ONLY: u32 = 4096;
pub const CL_DB_BYTECODE: u32 = 8192;
pub const CL_DB_SIGNED: u32 = 16384;
pub const CL_DB_BYTECODE_UNSIGNED: u32 = 32768;
pub const CL_DB_UNSIGNED: u32 = 65536;
pub const CL_DB_BYTECODE_STATS: u32 = 131072;
pub const CL_DB_ENHANCED: u32 = 262144;
pub const CL_DB_PCRE_STATS: u32 = 524288;
pub const CL_DB_YARA_EXCLUDE: u32 = 1048576;
pub const CL_DB_YARA_ONLY: u32 = 2097152;
pub const CL_DB_STDOPT: u32 = 8202;
pub const CL_SCAN_GENERAL_ALLMATCHES: u32 = 1;
pub const CL_SCAN_GENERAL_COLLECT_METADATA: u32 = 2;
pub const CL_SCAN_GENERAL_HEURISTICS: u32 = 4;
pub const CL_SCAN_GENERAL_HEURISTIC_PRECEDENCE: u32 = 8;
pub const CL_SCAN_GENERAL_UNPRIVILEGED: u32 = 16;
pub const CL_SCAN_PARSE_ARCHIVE: u32 = 1;
pub const CL_SCAN_PARSE_ELF: u32 = 2;
pub const CL_SCAN_PARSE_PDF: u32 = 4;
pub const CL_SCAN_PARSE_SWF: u32 = 8;
pub const CL_SCAN_PARSE_HWP3: u32 = 16;
pub const CL_SCAN_PARSE_XMLDOCS: u32 = 32;
pub const CL_SCAN_PARSE_MAIL: u32 = 64;
pub const CL_SCAN_PARSE_OLE2: u32 = 128;
pub const CL_SCAN_PARSE_HTML: u32 = 256;
pub const CL_SCAN_PARSE_PE: u32 = 512;
pub const CL_SCAN_HEURISTIC_BROKEN: u32 = 2;
pub const CL_SCAN_HEURISTIC_EXCEEDS_MAX: u32 = 4;
pub const CL_SCAN_HEURISTIC_PHISHING_SSL_MISMATCH: u32 = 8;
pub const CL_SCAN_HEURISTIC_PHISHING_CLOAK: u32 = 16;
pub const CL_SCAN_HEURISTIC_MACROS: u32 = 32;
pub const CL_SCAN_HEURISTIC_ENCRYPTED_ARCHIVE: u32 = 64;
pub const CL_SCAN_HEURISTIC_ENCRYPTED_DOC: u32 = 128;
pub const CL_SCAN_HEURISTIC_PARTITION_INTXN: u32 = 256;
pub const CL_SCAN_HEURISTIC_STRUCTURED: u32 = 512;
pub const CL_SCAN_HEURISTIC_STRUCTURED_SSN_NORMAL: u32 = 1024;
pub const CL_SCAN_HEURISTIC_STRUCTURED_SSN_STRIPPED: u32 = 2048;
pub const CL_SCAN_HEURISTIC_STRUCTURED_CC: u32 = 4096;
pub const CL_SCAN_HEURISTIC_BROKEN_MEDIA: u32 = 8192;
pub const CL_SCAN_MAIL_PARTIAL_MESSAGE: u32 = 1;
pub const CL_SCAN_DEV_COLLECT_SHA: u32 = 1;
pub const CL_SCAN_DEV_COLLECT_PERFORMANCE_INFO: u32 = 2;
pub const CL_COUNTSIGS_OFFICIAL: u32 = 1;
pub const CL_COUNTSIGS_UNOFFICIAL: u32 = 2;
pub const CL_COUNTSIGS_ALL: u32 = 3;
pub const ENGINE_OPTIONS_NONE: u32 = 0;
pub const ENGINE_OPTIONS_DISABLE_CACHE: u32 = 1;
pub const ENGINE_OPTIONS_FORCE_TO_DISK: u32 = 2;
pub const ENGINE_OPTIONS_DISABLE_PE_STATS: u32 = 4;
pub const ENGINE_OPTIONS_DISABLE_PE_CERTS: u32 = 8;
pub const ENGINE_OPTIONS_PE_DUMPCERTS: u32 = 16;
pub const CL_INIT_DEFAULT: u32 = 0;
pub const MD5_HASH_SIZE: u32 = 16;
pub const SHA1_HASH_SIZE: u32 = 20;
pub const SHA256_HASH_SIZE: u32 = 32;
pub const SHA384_HASH_SIZE: u32 = 48;
pub const SHA512_HASH_SIZE: u32 = 64;
pub const CLAMAVGROUP: &[u8; 7usize] = b"clamav\0";
pub const CLAMAVUSER: &[u8; 7usize] = b"clamav\0";
pub const CL_THREAD_SAFE: u32 = 1;
pub const C_LINUX: u32 = 1;
pub const DATADIR: &[u8; 16usize] = b"/var/lib/clamav\0";
pub const CONFDIR: &[u8; 12usize] = b"/etc/clamav\0";
pub const HAVE_SYS_FANOTIFY_H: u32 = 1;
pub const FILEBUFF: u32 = 8192;
pub const SCANBUFF: u32 = 131072;
pub const HAVE_ATTRIB_ALIGNED: u32 = 1;
pub const HAVE_ATTRIB_PACKED: u32 = 1;
pub const HAVE_BZLIB_H: u32 = 1;
pub const HAVE_DIRENT_H: u32 = 1;
pub const HAVE_DLFCN_H: u32 = 1;
pub const HAVE_FD_PASSING: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_GETADDRINFO: u32 = 1;
pub const HAVE_GETPAGESIZE: u32 = 1;
pub const HAVE_GRP_H: u32 = 1;
pub const HAVE_ICONV: u32 = 1;
pub const HAVE_INITGROUPS: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const JSON_C_HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_JSON: u32 = 1;
pub const HAVE_LIBSSL: u32 = 1;
pub const HAVE_LIBXML2: u32 = 1;
pub const HAVE_LIBZ: u32 = 1;
pub const HAVE_LIMITS_H: u32 = 1;
pub const HAVE_MALLOC_H: u32 = 1;
pub const HAVE_MMAP: u32 = 1;
pub const HAVE_PCRE: u32 = 1;
pub const USING_PCRE2: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_POLL_H: u32 = 1;
pub const HAVE_PTHREAD_H: u32 = 1;
pub const HAVE_PWD_H: u32 = 1;
pub const HAVE_RECVMSG: u32 = 1;
pub const HAVE_RESOLV_H: u32 = 1;
pub const HAVE_SAR: u32 = 1;
pub const HAVE_SENDMSG: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_SNPRINTF: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRERROR_R: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRNDUP: u32 = 1;
pub const HAVE_STRNLEN: u32 = 1;
pub const HAVE_SYSCONF_SC_PAGESIZE: u32 = 1;
pub const HAVE_SYSTEM_LFS_FTS: u32 = 1;
pub const HAVE_SYS_CDEFS_H: u32 = 1;
pub const HAVE_SYS_MMAN_H: u32 = 1;
pub const HAVE_SYS_PARAM_H: u32 = 1;
pub const HAVE_SYS_QUEUE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TIMES_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_UIO_H: u32 = 1;
pub const HAVE_TERMIOS_H: u32 = 1;
pub const HAVE_TIMEGM: u32 = 1;
pub const HAVE_UNAME_SYSCALL: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_VSNPRINTF: u32 = 1;
pub const HAVE_YARA: u32 = 1;
pub const HAVE_ZLIB_H: u32 = 1;
pub const UNRAR_LINKED: u32 = 1;
pub const LIBCLAMAV_FULLVER: &[u8; 6usize] = b"9.1.0\0";
pub const LIBCLAMAV_MAJORVER: u32 = 9;
pub const LIBFRESHCLAM_FULLVER: &[u8; 6usize] = b"2.0.2\0";
pub const LIBFRESHCLAM_MAJORVER: u32 = 2;
pub const LT_LIBEXT: &[u8; 3usize] = b".a\0";
pub const LT_LIBPREFIX: &[u8; 4usize] = b"lib\0";
pub const LT_MODULE_EXT: &[u8; 4usize] = b".so\0";
pub const SEARCH_LIBDIR: &[u8; 83usize] =
    b"/Elkeid/plugins/scanner/clamav/build/install/lib\0";
pub const LT_SHARED_EXT: &[u8; 4usize] = b".so\0";
pub const PACKAGE: &[u8; 7usize] = b"ClamAV\0";
pub const PACKAGE_BUGREPORT: &[u8; 45usize] = b"https://github.com/Cisco-Talos/clamav/issues\0";
pub const PACKAGE_NAME: &[u8; 7usize] = b"ClamAV\0";
pub const PACKAGE_STRING: &[u8; 15usize] = b"ClamAV 0.104.3\0";
pub const PACKAGE_URL: &[u8; 24usize] = b"https://www.clamav.net/\0";
pub const PACKAGE_VERSION: &[u8; 8usize] = b"0.104.3\0";
pub const SIZEOF_INT: u32 = 4;
pub const SIZEOF_LONG: u32 = 8;
pub const SIZEOF_LONG_LONG: u32 = 8;
pub const SIZEOF_SHORT: u32 = 2;
pub const SIZEOF_VOID_P: u32 = 8;
pub const USE_MPOOL: u32 = 1;
pub const USE_SYSLOG: u32 = 1;
pub const _GNU_SOURCE: u32 = 1;
pub const VERSION: &[u8; 8usize] = b"0.104.3\0";
pub const VERSION_SUFFIX: &[u8; 1usize] = b"\0";
pub const _DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _REENTRANT: u32 = 1;
pub const O_BINARY: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const PATHSEP: &[u8; 2usize] = b"/\0";
pub const CONFDIR_CLAMD: &[u8; 23usize] = b"/etc/clamav/clamd.conf\0";
pub const CONFDIR_FRESHCLAM: &[u8; 27usize] = b"/etc/clamav/freshclam.conf\0";
pub const CONFDIR_MILTER: &[u8; 31usize] = b"/etc/clamav/clamav-milter.conf\0";
pub const WORDS_BIGENDIAN: u32 = 0;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _STRING_H: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CL_FILE_MBUFF_SIZE: u32 = 1024;
pub const CL_PART_MBUFF_SIZE: u32 = 1028;
pub const MAGIC_BUFFER_SIZE: u32 = 1028;
pub const CL_TYPENO: u32 = 500;
pub const MAX_EMBEDDED_OBJ: u32 = 10;
pub const ARRAY_LIST_DEFAULT_SIZE: u32 = 32;
pub const JSON_C_MAJOR_VERSION: u32 = 0;
pub const JSON_C_MINOR_VERSION: u32 = 16;
pub const JSON_C_MICRO_VERSION: u32 = 0;
pub const JSON_C_VERSION_NUM: u32 = 4096;
pub const JSON_C_VERSION: &[u8; 5usize] = b"0.16\0";
pub const JSON_OBJECT_DEF_HASH_ENTRIES: u32 = 16;
pub const JSON_C_TO_STRING_PLAIN: u32 = 0;
pub const JSON_C_TO_STRING_SPACED: u32 = 1;
pub const JSON_C_TO_STRING_PRETTY: u32 = 2;
pub const JSON_C_TO_STRING_PRETTY_TAB: u32 = 8;
pub const JSON_C_TO_STRING_NOZERO: u32 = 4;
pub const JSON_C_TO_STRING_NOSLASHESCAPE: u32 = 16;
pub const JSON_C_OBJECT_ADD_KEY_IS_NEW: u32 = 2;
pub const JSON_C_OBJECT_ADD_CONSTANT_KEY: u32 = 4;
pub const JSON_C_OBJECT_KEY_IS_CONSTANT: u32 = 4;
pub const JSON_C_OPTION_GLOBAL: u32 = 0;
pub const JSON_C_OPTION_THREAD: u32 = 1;
pub const JSON_TOKENER_DEFAULT_DEPTH: u32 = 32;
pub const JSON_TOKENER_STRICT: u32 = 1;
pub const JSON_TOKENER_ALLOW_TRAILING_CHARS: u32 = 2;
pub const JSON_TOKENER_VALIDATE_UTF8: u32 = 16;
pub const JSON_FILE_BUF_SIZE: u32 = 4096;
pub const LH_PRIME: u32 = 2654404609;
pub const LH_LOAD_FACTOR: f64 = 0.66;
pub const JSON_C_STR_HASH_DFLT: u32 = 0;
pub const JSON_C_STR_HASH_PERLLIKE: u32 = 1;
pub const MAX_MEM_LEVEL: u32 = 9;
pub const MAX_WBITS: u32 = 15;
pub const ZLIB_VERSION: &[u8; 7usize] = b"1.2.12\0";
pub const ZLIB_VERNUM: u32 = 4800;
pub const ZLIB_VER_MAJOR: u32 = 1;
pub const ZLIB_VER_MINOR: u32 = 2;
pub const ZLIB_VER_REVISION: u32 = 12;
pub const ZLIB_VER_SUBREVISION: u32 = 0;
pub const Z_NO_FLUSH: u32 = 0;
pub const Z_PARTIAL_FLUSH: u32 = 1;
pub const Z_SYNC_FLUSH: u32 = 2;
pub const Z_FULL_FLUSH: u32 = 3;
pub const Z_FINISH: u32 = 4;
pub const Z_BLOCK: u32 = 5;
pub const Z_TREES: u32 = 6;
pub const Z_OK: u32 = 0;
pub const Z_STREAM_END: u32 = 1;
pub const Z_NEED_DICT: u32 = 2;
pub const Z_ERRNO: i32 = -1;
pub const Z_STREAM_ERROR: i32 = -2;
pub const Z_DATA_ERROR: i32 = -3;
pub const Z_MEM_ERROR: i32 = -4;
pub const Z_BUF_ERROR: i32 = -5;
pub const Z_VERSION_ERROR: i32 = -6;
pub const Z_NO_COMPRESSION: u32 = 0;
pub const Z_BEST_SPEED: u32 = 1;
pub const Z_BEST_COMPRESSION: u32 = 9;
pub const Z_DEFAULT_COMPRESSION: i32 = -1;
pub const Z_FILTERED: u32 = 1;
pub const Z_HUFFMAN_ONLY: u32 = 2;
pub const Z_RLE: u32 = 3;
pub const Z_FIXED: u32 = 4;
pub const Z_DEFAULT_STRATEGY: u32 = 0;
pub const Z_BINARY: u32 = 0;
pub const Z_TEXT: u32 = 1;
pub const Z_ASCII: u32 = 1;
pub const Z_UNKNOWN: u32 = 2;
pub const Z_DEFLATED: u32 = 8;
pub const Z_NULL: u32 = 0;
pub const _CTYPE_H: u32 = 1;
pub const MAX_LDB_SUBSIGS: u32 = 64;
pub const PE_CONF_PARITE: u32 = 1;
pub const PE_CONF_KRIZ: u32 = 2;
pub const PE_CONF_MAGISTR: u32 = 4;
pub const PE_CONF_POLIPOS: u32 = 8;
pub const PE_CONF_MD5SECT: u32 = 16;
pub const PE_CONF_UPX: u32 = 32;
pub const PE_CONF_FSG: u32 = 64;
pub const PE_CONF_SWIZZOR: u32 = 128;
pub const PE_CONF_PETITE: u32 = 256;
pub const PE_CONF_PESPIN: u32 = 512;
pub const PE_CONF_YC: u32 = 1024;
pub const PE_CONF_WWPACK: u32 = 2048;
pub const PE_CONF_NSPACK: u32 = 4096;
pub const PE_CONF_MEW: u32 = 8192;
pub const PE_CONF_UPACK: u32 = 16384;
pub const PE_CONF_ASPACK: u32 = 32768;
pub const PE_CONF_CATALOG: u32 = 65536;
pub const PE_CONF_CERTS: u32 = 131072;
pub const PE_CONF_MATCHICON: u32 = 262144;
pub const PE_CONF_IMPTBL: u32 = 524288;
pub const ARCH_CONF_RAR: u32 = 1;
pub const ARCH_CONF_ZIP: u32 = 2;
pub const ARCH_CONF_GZ: u32 = 4;
pub const ARCH_CONF_BZ: u32 = 8;
pub const ARCH_CONF_SZDD: u32 = 16;
pub const ARCH_CONF_CAB: u32 = 32;
pub const ARCH_CONF_CHM: u32 = 64;
pub const ARCH_CONF_OLE2: u32 = 128;
pub const ARCH_CONF_TAR: u32 = 256;
pub const ARCH_CONF_BINHEX: u32 = 512;
pub const ARCH_CONF_SIS: u32 = 1024;
pub const ARCH_CONF_NSIS: u32 = 2048;
pub const ARCH_CONF_ARJ: u32 = 4096;
pub const ARCH_CONF_AUTOIT: u32 = 8192;
pub const ARCH_CONF_CPIO: u32 = 16384;
pub const ARCH_CONF_ISHIELD: u32 = 32768;
pub const ARCH_CONF_7Z: u32 = 65536;
pub const ARCH_CONF_ISO9660: u32 = 131072;
pub const ARCH_CONF_DMG: u32 = 262144;
pub const ARCH_CONF_XAR: u32 = 524288;
pub const ARCH_CONF_HFSPLUS: u32 = 1048576;
pub const ARCH_CONF_XZ: u32 = 2097152;
pub const ARCH_CONF_PASSWD: u32 = 4194304;
pub const ARCH_CONF_MBR: u32 = 8388608;
pub const ARCH_CONF_GPT: u32 = 16777216;
pub const ARCH_CONF_APM: u32 = 33554432;
pub const ARCH_CONF_EGG: u32 = 67108864;
pub const DOC_CONF_HTML: u32 = 1;
pub const DOC_CONF_RTF: u32 = 2;
pub const DOC_CONF_PDF: u32 = 4;
pub const DOC_CONF_SCRIPT: u32 = 8;
pub const DOC_CONF_HTML_SKIPRAW: u32 = 16;
pub const DOC_CONF_JSNORM: u32 = 32;
pub const DOC_CONF_SWF: u32 = 64;
pub const DOC_CONF_MSXML: u32 = 128;
pub const DOC_CONF_OOXML: u32 = 256;
pub const DOC_CONF_HWP: u32 = 512;
pub const MAIL_CONF_MBOX: u32 = 1;
pub const MAIL_CONF_TNEF: u32 = 2;
pub const OTHER_CONF_UUENC: u32 = 1;
pub const OTHER_CONF_SCRENC: u32 = 2;
pub const OTHER_CONF_RIFF: u32 = 4;
pub const OTHER_CONF_JPEG: u32 = 8;
pub const OTHER_CONF_CRYPTFF: u32 = 16;
pub const OTHER_CONF_DLP: u32 = 32;
pub const OTHER_CONF_MYDOOMLOG: u32 = 64;
pub const OTHER_CONF_PREFILTERING: u32 = 128;
pub const OTHER_CONF_PDFNAMEOBJ: u32 = 256;
pub const OTHER_CONF_PRTNINTXN: u32 = 512;
pub const OTHER_CONF_LZW: u32 = 1024;
pub const OTHER_CONF_PNG: u32 = 2048;
pub const OTHER_CONF_GIF: u32 = 4096;
pub const OTHER_CONF_TIFF: u32 = 8192;
pub const PHISHING_CONF_ENGINE: u32 = 1;
pub const PHISHING_CONF_ENTCONV: u32 = 2;
pub const BYTECODE_INTERPRETER: u32 = 1;
pub const BYTECODE_JIT_X86: u32 = 2;
pub const BYTECODE_JIT_PPC: u32 = 4;
pub const BYTECODE_JIT_ARM: u32 = 8;
pub const DCONF_STATS_DISABLED: u32 = 1;
pub const DCONF_STATS_PE_SECTION_DISABLED: u32 = 2;
pub const PCRE_CONF_SUPPORT: u32 = 1;
pub const PCRE_CONF_OPTIONS: u32 = 2;
pub const PCRE_CONF_GLOBAL: u32 = 4;
pub const BYTECODE_ENGINE_MASK: u32 = 15;
pub const REG_BASIC: u32 = 0;
pub const REG_EXTENDED: u32 = 1;
pub const REG_ICASE: u32 = 2;
pub const REG_NOSUB: u32 = 4;
pub const REG_NEWLINE: u32 = 8;
pub const REG_NOSPEC: u32 = 16;
pub const REG_PEND: u32 = 32;
pub const REG_DUMP: u32 = 128;
pub const REG_NOMATCH: u32 = 1;
pub const REG_BADPAT: u32 = 2;
pub const REG_ECOLLATE: u32 = 3;
pub const REG_ECTYPE: u32 = 4;
pub const REG_EESCAPE: u32 = 5;
pub const REG_ESUBREG: u32 = 6;
pub const REG_EBRACK: u32 = 7;
pub const REG_EPAREN: u32 = 8;
pub const REG_EBRACE: u32 = 9;
pub const REG_BADBR: u32 = 10;
pub const REG_ERANGE: u32 = 11;
pub const REG_ESPACE: u32 = 12;
pub const REG_BADRPT: u32 = 13;
pub const REG_EMPTY: u32 = 14;
pub const REG_ASSERT: u32 = 15;
pub const REG_INVARG: u32 = 16;
pub const REG_ATOI: u32 = 255;
pub const REG_ITOA: u32 = 256;
pub const REG_NOTBOL: u32 = 1;
pub const REG_NOTEOL: u32 = 2;
pub const REG_STARTEND: u32 = 4;
pub const REG_TRACE: u32 = 256;
pub const REG_LARGE: u32 = 512;
pub const REG_BACKR: u32 = 1024;
pub const BC_FORMAT_096: u32 = 6;
pub const BC_FORMAT_LEVEL: u32 = 7;
pub const BC_HEADER: &[u8; 7usize] = b"ClamBC\0";
pub const BC_START_TID: u32 = 69;
pub const PE_INVALID_RVA: u32 = 4294967295;
pub const FP_ZPOS: u32 = 0;
pub const FP_NEG: u32 = 1;
pub const FP_OKAY: u32 = 0;
pub const FP_VAL: u32 = 1;
pub const FP_MEM: u32 = 2;
pub const FP_LT: i32 = -1;
pub const FP_EQ: u32 = 0;
pub const FP_GT: u32 = 1;
pub const FP_YES: u32 = 1;
pub const FP_NO: u32 = 0;
pub const TFM_PRIME_BBS: u32 = 1;
pub const TFM_PRIME_SAFE: u32 = 2;
pub const TFM_PRIME_2MSB_OFF: u32 = 4;
pub const TFM_PRIME_2MSB_ON: u32 = 8;
pub const CRT_RAWMAXLEN: u32 = 64;
pub const META_TYPE_NULL: u32 = 0;
pub const META_TYPE_INTEGER: u32 = 1;
pub const META_TYPE_STRING: u32 = 2;
pub const META_TYPE_BOOLEAN: u32 = 3;
pub const STRING_GFLAGS_REFERENCED: u32 = 1;
pub const STRING_GFLAGS_HEXADECIMAL: u32 = 2;
pub const STRING_GFLAGS_NO_CASE: u32 = 4;
pub const STRING_GFLAGS_ASCII: u32 = 8;
pub const STRING_GFLAGS_WIDE: u32 = 16;
pub const STRING_GFLAGS_REGEXP: u32 = 32;
pub const STRING_GFLAGS_FAST_HEX_REGEXP: u32 = 64;
pub const STRING_GFLAGS_FULL_WORD: u32 = 128;
pub const STRING_GFLAGS_ANONYMOUS: u32 = 256;
pub const STRING_GFLAGS_SINGLE_MATCH: u32 = 512;
pub const STRING_GFLAGS_LITERAL: u32 = 1024;
pub const STRING_GFLAGS_FITS_IN_ATOM: u32 = 2048;
pub const STRING_GFLAGS_NULL: u32 = 4096;
pub const STRING_GFLAGS_CHAIN_PART: u32 = 8192;
pub const STRING_GFLAGS_CHAIN_TAIL: u32 = 16384;
pub const STRING_GFLAGS_REGEXP_DOT_ALL: u32 = 32768;
pub const RULE_TFLAGS_MATCH: u32 = 1;
pub const RULE_GFLAGS_PRIVATE: u32 = 1;
pub const RULE_GFLAGS_GLOBAL: u32 = 2;
pub const RULE_GFLAGS_REQUIRE_EXECUTABLE: u32 = 4;
pub const RULE_GFLAGS_REQUIRE_FILE: u32 = 8;
pub const RULE_GFLAGS_NULL: u32 = 4096;
pub const EXTERNAL_VARIABLE_TYPE_NULL: u32 = 0;
pub const EXTERNAL_VARIABLE_TYPE_ANY: u32 = 1;
pub const EXTERNAL_VARIABLE_TYPE_INTEGER: u32 = 2;
pub const EXTERNAL_VARIABLE_TYPE_BOOLEAN: u32 = 3;
pub const EXTERNAL_VARIABLE_TYPE_FIXED_STRING: u32 = 4;
pub const EXTERNAL_VARIABLE_TYPE_MALLOC_STRING: u32 = 5;
pub const SIZED_STRING_FLAGS_NO_CASE: u32 = 1;
pub const SIZED_STRING_FLAGS_DOT_ALL: u32 = 2;
pub const ERROR_SUCCESS: u32 = 0;
pub const ERROR_INSUFICIENT_MEMORY: u32 = 1;
pub const ERROR_COULD_NOT_ATTACH_TO_PROCESS: u32 = 2;
pub const ERROR_COULD_NOT_OPEN_FILE: u32 = 3;
pub const ERROR_COULD_NOT_MAP_FILE: u32 = 4;
pub const ERROR_INVALID_FILE: u32 = 6;
pub const ERROR_CORRUPT_FILE: u32 = 7;
pub const ERROR_UNSUPPORTED_FILE_VERSION: u32 = 8;
pub const ERROR_INVALID_REGULAR_EXPRESSION: u32 = 9;
pub const ERROR_INVALID_HEX_STRING: u32 = 10;
pub const ERROR_SYNTAX_ERROR: u32 = 11;
pub const ERROR_LOOP_NESTING_LIMIT_EXCEEDED: u32 = 12;
pub const ERROR_DUPLICATE_LOOP_IDENTIFIER: u32 = 13;
pub const ERROR_DUPLICATE_IDENTIFIER: u32 = 14;
pub const ERROR_DUPLICATE_TAG_IDENTIFIER: u32 = 15;
pub const ERROR_DUPLICATE_META_IDENTIFIER: u32 = 16;
pub const ERROR_DUPLICATE_STRING_IDENTIFIER: u32 = 17;
pub const ERROR_UNREFERENCED_STRING: u32 = 18;
pub const ERROR_UNDEFINED_STRING: u32 = 19;
pub const ERROR_UNDEFINED_IDENTIFIER: u32 = 20;
pub const ERROR_MISPLACED_ANONYMOUS_STRING: u32 = 21;
pub const ERROR_INCLUDES_CIRCULAR_REFERENCE: u32 = 22;
pub const ERROR_INCLUDE_DEPTH_EXCEEDED: u32 = 23;
pub const ERROR_WRONG_TYPE: u32 = 24;
pub const ERROR_EXEC_STACK_OVERFLOW: u32 = 25;
pub const ERROR_SCAN_TIMEOUT: u32 = 26;
pub const ERROR_TOO_MANY_SCAN_THREADS: u32 = 27;
pub const ERROR_CALLBACK_ERROR: u32 = 28;
pub const ERROR_INVALID_ARGUMENT: u32 = 29;
pub const ERROR_TOO_MANY_MATCHES: u32 = 30;
pub const ERROR_INTERNAL_FATAL_ERROR: u32 = 31;
pub const ERROR_NESTED_FOR_OF_LOOP: u32 = 32;
pub const ERROR_INVALID_FIELD_NAME: u32 = 33;
pub const ERROR_UNKNOWN_MODULE: u32 = 34;
pub const ERROR_NOT_A_STRUCTURE: u32 = 35;
pub const ERROR_NOT_AN_ARRAY: u32 = 36;
pub const ERROR_NOT_A_FUNCTION: u32 = 37;
pub const ERROR_INVALID_FORMAT: u32 = 38;
pub const ERROR_TOO_MANY_ARGUMENTS: u32 = 39;
pub const ERROR_WRONG_NUMBER_OF_ARGUMENTS: u32 = 40;
pub const RE_FLAGS_FAST_HEX_REGEXP: u32 = 2;
pub const RE_FLAGS_BACKWARDS: u32 = 4;
pub const RE_FLAGS_EXHAUSTIVE: u32 = 8;
pub const RE_FLAGS_WIDE: u32 = 16;
pub const RE_FLAGS_NO_CASE: u32 = 32;
pub const RE_FLAGS_SCAN: u32 = 64;
pub const RE_FLAGS_DOT_ALL: u32 = 128;
pub const RE_FLAGS_NOT_AT_START: u32 = 256;
pub const MAX_COMPILER_ERROR_EXTRA_INFO: u32 = 256;
pub const MAX_LOOP_NESTING: u32 = 4;
pub const MAX_FUNCTION_ARGS: u32 = 128;
pub const LOOP_LOCAL_VARS: u32 = 4;
pub const LEX_BUF_SIZE: u32 = 1024;
pub const MAX_INCLUDE_DEPTH: u32 = 16;
pub const MAX_PATH: u32 = 1024;
pub const OBJECT_TYPE_INTEGER: u32 = 1;
pub const OBJECT_TYPE_STRING: u32 = 2;
pub const OBJECT_TYPE_STRUCTURE: u32 = 3;
pub const OBJECT_TYPE_ARRAY: u32 = 4;
pub const OBJECT_TYPE_FUNCTION: u32 = 5;
pub const OBJECT_TYPE_REGEXP: u32 = 6;
pub const RULE_ANY: u32 = 1;
pub const RULE_ALL: u32 = 2;
pub const RULE_ONE: u32 = 4;
pub const RULE_THEM: u32 = 8;
pub const RULE_EP: u32 = 16;
pub const RULE_OFFSETS: u32 = 32;
pub const CL_FLEVEL: u32 = 143;
pub const CL_FLEVEL_DCONF: u32 = 143;
pub const CL_FLEVEL_SIGTOOL: u32 = 143;
pub const CLI_MAX_ALLOCATION: u32 = 190840832;
pub const _SYS_PARAM_H: u32 = 1;
pub const _SIGSET_H_fns: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const _NSIG: u32 = 65;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const __have_sigval_t: u32 = 1;
pub const __have_siginfo_t: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const __have_sigevent_t: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const NSIG: u32 = 65;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const NGREG: u32 = 23;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const MAXSYMLINKS: u32 = 20;
pub const NOFILE: u32 = 256;
pub const NCARGS: u32 = 131072;
pub const NGROUPS: u32 = 65536;
pub const CANBSIZ: u32 = 255;
pub const MAXPATHLEN: u32 = 4096;
pub const DEV_BSIZE: u32 = 512;
pub const STATS_ANON_UUID: &[u8; 37usize] = b"5b585e8f-3be5-11e3-bf0b-18037319526c\0";
pub const STATS_MAX_SAMPLES: u32 = 50;
pub const STATS_MAX_MEM: u32 = 1048576;
pub const CLI_PWDB_COUNT: u32 = 3;
pub const HAVE_CLI_GETPAGESIZE: u32 = 1;
pub const CLI_FTW_FOLLOW_FILE_SYMLINK: u32 = 1;
pub const CLI_FTW_FOLLOW_DIR_SYMLINK: u32 = 2;
pub const CLI_FTW_NEED_STAT: u32 = 4;
pub const CLI_FTW_TRIM_SLASHES: u32 = 8;
pub const CLI_FTW_STD: u32 = 12;
pub const WIN_CERT_REV_2: u32 = 512;
pub const WIN_CERT_TYPE_PKCS7: u32 = 2;
pub const AC_CH_MAXDIST: u32 = 32;
pub const ACPATT_ALTN_MAXNEST: u32 = 15;
pub const AC_SCAN_VIR: u32 = 1;
pub const AC_SCAN_FT: u32 = 2;
pub const ACPATT_OPTION_NOOPTS: u32 = 0;
pub const ACPATT_OPTION_NOCASE: u32 = 1;
pub const ACPATT_OPTION_FULLWORD: u32 = 2;
pub const ACPATT_OPTION_WIDE: u32 = 4;
pub const ACPATT_OPTION_ASCII: u32 = 8;
pub const ACPATT_OPTION_ONCE: u32 = 128;
pub const BM_BOUNDARY_EOL: u32 = 1;
pub const CLI_HASHLEN_MD5: u32 = 16;
pub const CLI_HASHLEN_SHA1: u32 = 20;
pub const CLI_HASHLEN_SHA256: u32 = 32;
pub const CLI_HASHLEN_MAX: u32 = 32;
pub const PCRE2_CODE_UNIT_WIDTH: u32 = 8;
pub const PCRE2_MAJOR: u32 = 10;
pub const PCRE2_MINOR: u32 = 40;
pub const PCRE2_DATE: u32 = 2004;
pub const PCRE2_ANCHORED: u32 = 2147483648;
pub const PCRE2_NO_UTF_CHECK: u32 = 1073741824;
pub const PCRE2_ENDANCHORED: u32 = 536870912;
pub const PCRE2_ALLOW_EMPTY_CLASS: u32 = 1;
pub const PCRE2_ALT_BSUX: u32 = 2;
pub const PCRE2_AUTO_CALLOUT: u32 = 4;
pub const PCRE2_CASELESS: u32 = 8;
pub const PCRE2_DOLLAR_ENDONLY: u32 = 16;
pub const PCRE2_DOTALL: u32 = 32;
pub const PCRE2_DUPNAMES: u32 = 64;
pub const PCRE2_EXTENDED: u32 = 128;
pub const PCRE2_FIRSTLINE: u32 = 256;
pub const PCRE2_MATCH_UNSET_BACKREF: u32 = 512;
pub const PCRE2_MULTILINE: u32 = 1024;
pub const PCRE2_NEVER_UCP: u32 = 2048;
pub const PCRE2_NEVER_UTF: u32 = 4096;
pub const PCRE2_NO_AUTO_CAPTURE: u32 = 8192;
pub const PCRE2_NO_AUTO_POSSESS: u32 = 16384;
pub const PCRE2_NO_DOTSTAR_ANCHOR: u32 = 32768;
pub const PCRE2_NO_START_OPTIMIZE: u32 = 65536;
pub const PCRE2_UCP: u32 = 131072;
pub const PCRE2_UNGREEDY: u32 = 262144;
pub const PCRE2_UTF: u32 = 524288;
pub const PCRE2_NEVER_BACKSLASH_C: u32 = 1048576;
pub const PCRE2_ALT_CIRCUMFLEX: u32 = 2097152;
pub const PCRE2_ALT_VERBNAMES: u32 = 4194304;
pub const PCRE2_USE_OFFSET_LIMIT: u32 = 8388608;
pub const PCRE2_EXTENDED_MORE: u32 = 16777216;
pub const PCRE2_LITERAL: u32 = 33554432;
pub const PCRE2_MATCH_INVALID_UTF: u32 = 67108864;
pub const PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES: u32 = 1;
pub const PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL: u32 = 2;
pub const PCRE2_EXTRA_MATCH_WORD: u32 = 4;
pub const PCRE2_EXTRA_MATCH_LINE: u32 = 8;
pub const PCRE2_EXTRA_ESCAPED_CR_IS_LF: u32 = 16;
pub const PCRE2_EXTRA_ALT_BSUX: u32 = 32;
pub const PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK: u32 = 64;
pub const PCRE2_JIT_COMPLETE: u32 = 1;
pub const PCRE2_JIT_PARTIAL_SOFT: u32 = 2;
pub const PCRE2_JIT_PARTIAL_HARD: u32 = 4;
pub const PCRE2_JIT_INVALID_UTF: u32 = 256;
pub const PCRE2_NOTBOL: u32 = 1;
pub const PCRE2_NOTEOL: u32 = 2;
pub const PCRE2_NOTEMPTY: u32 = 4;
pub const PCRE2_NOTEMPTY_ATSTART: u32 = 8;
pub const PCRE2_PARTIAL_SOFT: u32 = 16;
pub const PCRE2_PARTIAL_HARD: u32 = 32;
pub const PCRE2_DFA_RESTART: u32 = 64;
pub const PCRE2_DFA_SHORTEST: u32 = 128;
pub const PCRE2_SUBSTITUTE_GLOBAL: u32 = 256;
pub const PCRE2_SUBSTITUTE_EXTENDED: u32 = 512;
pub const PCRE2_SUBSTITUTE_UNSET_EMPTY: u32 = 1024;
pub const PCRE2_SUBSTITUTE_UNKNOWN_UNSET: u32 = 2048;
pub const PCRE2_SUBSTITUTE_OVERFLOW_LENGTH: u32 = 4096;
pub const PCRE2_NO_JIT: u32 = 8192;
pub const PCRE2_COPY_MATCHED_SUBJECT: u32 = 16384;
pub const PCRE2_SUBSTITUTE_LITERAL: u32 = 32768;
pub const PCRE2_SUBSTITUTE_MATCHED: u32 = 65536;
pub const PCRE2_SUBSTITUTE_REPLACEMENT_ONLY: u32 = 131072;
pub const PCRE2_CONVERT_UTF: u32 = 1;
pub const PCRE2_CONVERT_NO_UTF_CHECK: u32 = 2;
pub const PCRE2_CONVERT_POSIX_BASIC: u32 = 4;
pub const PCRE2_CONVERT_POSIX_EXTENDED: u32 = 8;
pub const PCRE2_CONVERT_GLOB: u32 = 16;
pub const PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR: u32 = 48;
pub const PCRE2_CONVERT_GLOB_NO_STARSTAR: u32 = 80;
pub const PCRE2_NEWLINE_CR: u32 = 1;
pub const PCRE2_NEWLINE_LF: u32 = 2;
pub const PCRE2_NEWLINE_CRLF: u32 = 3;
pub const PCRE2_NEWLINE_ANY: u32 = 4;
pub const PCRE2_NEWLINE_ANYCRLF: u32 = 5;
pub const PCRE2_NEWLINE_NUL: u32 = 6;
pub const PCRE2_BSR_UNICODE: u32 = 1;
pub const PCRE2_BSR_ANYCRLF: u32 = 2;
pub const PCRE2_ERROR_END_BACKSLASH: u32 = 101;
pub const PCRE2_ERROR_END_BACKSLASH_C: u32 = 102;
pub const PCRE2_ERROR_UNKNOWN_ESCAPE: u32 = 103;
pub const PCRE2_ERROR_QUANTIFIER_OUT_OF_ORDER: u32 = 104;
pub const PCRE2_ERROR_QUANTIFIER_TOO_BIG: u32 = 105;
pub const PCRE2_ERROR_MISSING_SQUARE_BRACKET: u32 = 106;
pub const PCRE2_ERROR_ESCAPE_INVALID_IN_CLASS: u32 = 107;
pub const PCRE2_ERROR_CLASS_RANGE_ORDER: u32 = 108;
pub const PCRE2_ERROR_QUANTIFIER_INVALID: u32 = 109;
pub const PCRE2_ERROR_INTERNAL_UNEXPECTED_REPEAT: u32 = 110;
pub const PCRE2_ERROR_INVALID_AFTER_PARENS_QUERY: u32 = 111;
pub const PCRE2_ERROR_POSIX_CLASS_NOT_IN_CLASS: u32 = 112;
pub const PCRE2_ERROR_POSIX_NO_SUPPORT_COLLATING: u32 = 113;
pub const PCRE2_ERROR_MISSING_CLOSING_PARENTHESIS: u32 = 114;
pub const PCRE2_ERROR_BAD_SUBPATTERN_REFERENCE: u32 = 115;
pub const PCRE2_ERROR_NULL_PATTERN: u32 = 116;
pub const PCRE2_ERROR_BAD_OPTIONS: u32 = 117;
pub const PCRE2_ERROR_MISSING_COMMENT_CLOSING: u32 = 118;
pub const PCRE2_ERROR_PARENTHESES_NEST_TOO_DEEP: u32 = 119;
pub const PCRE2_ERROR_PATTERN_TOO_LARGE: u32 = 120;
pub const PCRE2_ERROR_HEAP_FAILED: u32 = 121;
pub const PCRE2_ERROR_UNMATCHED_CLOSING_PARENTHESIS: u32 = 122;
pub const PCRE2_ERROR_INTERNAL_CODE_OVERFLOW: u32 = 123;
pub const PCRE2_ERROR_MISSING_CONDITION_CLOSING: u32 = 124;
pub const PCRE2_ERROR_LOOKBEHIND_NOT_FIXED_LENGTH: u32 = 125;
pub const PCRE2_ERROR_ZERO_RELATIVE_REFERENCE: u32 = 126;
pub const PCRE2_ERROR_TOO_MANY_CONDITION_BRANCHES: u32 = 127;
pub const PCRE2_ERROR_CONDITION_ASSERTION_EXPECTED: u32 = 128;
pub const PCRE2_ERROR_BAD_RELATIVE_REFERENCE: u32 = 129;
pub const PCRE2_ERROR_UNKNOWN_POSIX_CLASS: u32 = 130;
pub const PCRE2_ERROR_INTERNAL_STUDY_ERROR: u32 = 131;
pub const PCRE2_ERROR_UNICODE_NOT_SUPPORTED: u32 = 132;
pub const PCRE2_ERROR_PARENTHESES_STACK_CHECK: u32 = 133;
pub const PCRE2_ERROR_CODE_POINT_TOO_BIG: u32 = 134;
pub const PCRE2_ERROR_LOOKBEHIND_TOO_COMPLICATED: u32 = 135;
pub const PCRE2_ERROR_LOOKBEHIND_INVALID_BACKSLASH_C: u32 = 136;
pub const PCRE2_ERROR_UNSUPPORTED_ESCAPE_SEQUENCE: u32 = 137;
pub const PCRE2_ERROR_CALLOUT_NUMBER_TOO_BIG: u32 = 138;
pub const PCRE2_ERROR_MISSING_CALLOUT_CLOSING: u32 = 139;
pub const PCRE2_ERROR_ESCAPE_INVALID_IN_VERB: u32 = 140;
pub const PCRE2_ERROR_UNRECOGNIZED_AFTER_QUERY_P: u32 = 141;
pub const PCRE2_ERROR_MISSING_NAME_TERMINATOR: u32 = 142;
pub const PCRE2_ERROR_DUPLICATE_SUBPATTERN_NAME: u32 = 143;
pub const PCRE2_ERROR_INVALID_SUBPATTERN_NAME: u32 = 144;
pub const PCRE2_ERROR_UNICODE_PROPERTIES_UNAVAILABLE: u32 = 145;
pub const PCRE2_ERROR_MALFORMED_UNICODE_PROPERTY: u32 = 146;
pub const PCRE2_ERROR_UNKNOWN_UNICODE_PROPERTY: u32 = 147;
pub const PCRE2_ERROR_SUBPATTERN_NAME_TOO_LONG: u32 = 148;
pub const PCRE2_ERROR_TOO_MANY_NAMED_SUBPATTERNS: u32 = 149;
pub const PCRE2_ERROR_CLASS_INVALID_RANGE: u32 = 150;
pub const PCRE2_ERROR_OCTAL_BYTE_TOO_BIG: u32 = 151;
pub const PCRE2_ERROR_INTERNAL_OVERRAN_WORKSPACE: u32 = 152;
pub const PCRE2_ERROR_INTERNAL_MISSING_SUBPATTERN: u32 = 153;
pub const PCRE2_ERROR_DEFINE_TOO_MANY_BRANCHES: u32 = 154;
pub const PCRE2_ERROR_BACKSLASH_O_MISSING_BRACE: u32 = 155;
pub const PCRE2_ERROR_INTERNAL_UNKNOWN_NEWLINE: u32 = 156;
pub const PCRE2_ERROR_BACKSLASH_G_SYNTAX: u32 = 157;
pub const PCRE2_ERROR_PARENS_QUERY_R_MISSING_CLOSING: u32 = 158;
pub const PCRE2_ERROR_VERB_ARGUMENT_NOT_ALLOWED: u32 = 159;
pub const PCRE2_ERROR_VERB_UNKNOWN: u32 = 160;
pub const PCRE2_ERROR_SUBPATTERN_NUMBER_TOO_BIG: u32 = 161;
pub const PCRE2_ERROR_SUBPATTERN_NAME_EXPECTED: u32 = 162;
pub const PCRE2_ERROR_INTERNAL_PARSED_OVERFLOW: u32 = 163;
pub const PCRE2_ERROR_INVALID_OCTAL: u32 = 164;
pub const PCRE2_ERROR_SUBPATTERN_NAMES_MISMATCH: u32 = 165;
pub const PCRE2_ERROR_MARK_MISSING_ARGUMENT: u32 = 166;
pub const PCRE2_ERROR_INVALID_HEXADECIMAL: u32 = 167;
pub const PCRE2_ERROR_BACKSLASH_C_SYNTAX: u32 = 168;
pub const PCRE2_ERROR_BACKSLASH_K_SYNTAX: u32 = 169;
pub const PCRE2_ERROR_INTERNAL_BAD_CODE_LOOKBEHINDS: u32 = 170;
pub const PCRE2_ERROR_BACKSLASH_N_IN_CLASS: u32 = 171;
pub const PCRE2_ERROR_CALLOUT_STRING_TOO_LONG: u32 = 172;
pub const PCRE2_ERROR_UNICODE_DISALLOWED_CODE_POINT: u32 = 173;
pub const PCRE2_ERROR_UTF_IS_DISABLED: u32 = 174;
pub const PCRE2_ERROR_UCP_IS_DISABLED: u32 = 175;
pub const PCRE2_ERROR_VERB_NAME_TOO_LONG: u32 = 176;
pub const PCRE2_ERROR_BACKSLASH_U_CODE_POINT_TOO_BIG: u32 = 177;
pub const PCRE2_ERROR_MISSING_OCTAL_OR_HEX_DIGITS: u32 = 178;
pub const PCRE2_ERROR_VERSION_CONDITION_SYNTAX: u32 = 179;
pub const PCRE2_ERROR_INTERNAL_BAD_CODE_AUTO_POSSESS: u32 = 180;
pub const PCRE2_ERROR_CALLOUT_NO_STRING_DELIMITER: u32 = 181;
pub const PCRE2_ERROR_CALLOUT_BAD_STRING_DELIMITER: u32 = 182;
pub const PCRE2_ERROR_BACKSLASH_C_CALLER_DISABLED: u32 = 183;
pub const PCRE2_ERROR_QUERY_BARJX_NEST_TOO_DEEP: u32 = 184;
pub const PCRE2_ERROR_BACKSLASH_C_LIBRARY_DISABLED: u32 = 185;
pub const PCRE2_ERROR_PATTERN_TOO_COMPLICATED: u32 = 186;
pub const PCRE2_ERROR_LOOKBEHIND_TOO_LONG: u32 = 187;
pub const PCRE2_ERROR_PATTERN_STRING_TOO_LONG: u32 = 188;
pub const PCRE2_ERROR_INTERNAL_BAD_CODE: u32 = 189;
pub const PCRE2_ERROR_INTERNAL_BAD_CODE_IN_SKIP: u32 = 190;
pub const PCRE2_ERROR_NO_SURROGATES_IN_UTF16: u32 = 191;
pub const PCRE2_ERROR_BAD_LITERAL_OPTIONS: u32 = 192;
pub const PCRE2_ERROR_SUPPORTED_ONLY_IN_UNICODE: u32 = 193;
pub const PCRE2_ERROR_INVALID_HYPHEN_IN_OPTIONS: u32 = 194;
pub const PCRE2_ERROR_ALPHA_ASSERTION_UNKNOWN: u32 = 195;
pub const PCRE2_ERROR_SCRIPT_RUN_NOT_AVAILABLE: u32 = 196;
pub const PCRE2_ERROR_TOO_MANY_CAPTURES: u32 = 197;
pub const PCRE2_ERROR_CONDITION_ATOMIC_ASSERTION_EXPECTED: u32 = 198;
pub const PCRE2_ERROR_BACKSLASH_K_IN_LOOKAROUND: u32 = 199;
pub const PCRE2_ERROR_NOMATCH: i32 = -1;
pub const PCRE2_ERROR_PARTIAL: i32 = -2;
pub const PCRE2_ERROR_UTF8_ERR1: i32 = -3;
pub const PCRE2_ERROR_UTF8_ERR2: i32 = -4;
pub const PCRE2_ERROR_UTF8_ERR3: i32 = -5;
pub const PCRE2_ERROR_UTF8_ERR4: i32 = -6;
pub const PCRE2_ERROR_UTF8_ERR5: i32 = -7;
pub const PCRE2_ERROR_UTF8_ERR6: i32 = -8;
pub const PCRE2_ERROR_UTF8_ERR7: i32 = -9;
pub const PCRE2_ERROR_UTF8_ERR8: i32 = -10;
pub const PCRE2_ERROR_UTF8_ERR9: i32 = -11;
pub const PCRE2_ERROR_UTF8_ERR10: i32 = -12;
pub const PCRE2_ERROR_UTF8_ERR11: i32 = -13;
pub const PCRE2_ERROR_UTF8_ERR12: i32 = -14;
pub const PCRE2_ERROR_UTF8_ERR13: i32 = -15;
pub const PCRE2_ERROR_UTF8_ERR14: i32 = -16;
pub const PCRE2_ERROR_UTF8_ERR15: i32 = -17;
pub const PCRE2_ERROR_UTF8_ERR16: i32 = -18;
pub const PCRE2_ERROR_UTF8_ERR17: i32 = -19;
pub const PCRE2_ERROR_UTF8_ERR18: i32 = -20;
pub const PCRE2_ERROR_UTF8_ERR19: i32 = -21;
pub const PCRE2_ERROR_UTF8_ERR20: i32 = -22;
pub const PCRE2_ERROR_UTF8_ERR21: i32 = -23;
pub const PCRE2_ERROR_UTF16_ERR1: i32 = -24;
pub const PCRE2_ERROR_UTF16_ERR2: i32 = -25;
pub const PCRE2_ERROR_UTF16_ERR3: i32 = -26;
pub const PCRE2_ERROR_UTF32_ERR1: i32 = -27;
pub const PCRE2_ERROR_UTF32_ERR2: i32 = -28;
pub const PCRE2_ERROR_BADDATA: i32 = -29;
pub const PCRE2_ERROR_MIXEDTABLES: i32 = -30;
pub const PCRE2_ERROR_BADMAGIC: i32 = -31;
pub const PCRE2_ERROR_BADMODE: i32 = -32;
pub const PCRE2_ERROR_BADOFFSET: i32 = -33;
pub const PCRE2_ERROR_BADOPTION: i32 = -34;
pub const PCRE2_ERROR_BADREPLACEMENT: i32 = -35;
pub const PCRE2_ERROR_BADUTFOFFSET: i32 = -36;
pub const PCRE2_ERROR_CALLOUT: i32 = -37;
pub const PCRE2_ERROR_DFA_BADRESTART: i32 = -38;
pub const PCRE2_ERROR_DFA_RECURSE: i32 = -39;
pub const PCRE2_ERROR_DFA_UCOND: i32 = -40;
pub const PCRE2_ERROR_DFA_UFUNC: i32 = -41;
pub const PCRE2_ERROR_DFA_UITEM: i32 = -42;
pub const PCRE2_ERROR_DFA_WSSIZE: i32 = -43;
pub const PCRE2_ERROR_INTERNAL: i32 = -44;
pub const PCRE2_ERROR_JIT_BADOPTION: i32 = -45;
pub const PCRE2_ERROR_JIT_STACKLIMIT: i32 = -46;
pub const PCRE2_ERROR_MATCHLIMIT: i32 = -47;
pub const PCRE2_ERROR_NOMEMORY: i32 = -48;
pub const PCRE2_ERROR_NOSUBSTRING: i32 = -49;
pub const PCRE2_ERROR_NOUNIQUESUBSTRING: i32 = -50;
pub const PCRE2_ERROR_NULL: i32 = -51;
pub const PCRE2_ERROR_RECURSELOOP: i32 = -52;
pub const PCRE2_ERROR_DEPTHLIMIT: i32 = -53;
pub const PCRE2_ERROR_RECURSIONLIMIT: i32 = -53;
pub const PCRE2_ERROR_UNAVAILABLE: i32 = -54;
pub const PCRE2_ERROR_UNSET: i32 = -55;
pub const PCRE2_ERROR_BADOFFSETLIMIT: i32 = -56;
pub const PCRE2_ERROR_BADREPESCAPE: i32 = -57;
pub const PCRE2_ERROR_REPMISSINGBRACE: i32 = -58;
pub const PCRE2_ERROR_BADSUBSTITUTION: i32 = -59;
pub const PCRE2_ERROR_BADSUBSPATTERN: i32 = -60;
pub const PCRE2_ERROR_TOOMANYREPLACE: i32 = -61;
pub const PCRE2_ERROR_BADSERIALIZEDDATA: i32 = -62;
pub const PCRE2_ERROR_HEAPLIMIT: i32 = -63;
pub const PCRE2_ERROR_CONVERT_SYNTAX: i32 = -64;
pub const PCRE2_ERROR_INTERNAL_DUPMATCH: i32 = -65;
pub const PCRE2_ERROR_DFA_UINVALID_UTF: i32 = -66;
pub const PCRE2_INFO_ALLOPTIONS: u32 = 0;
pub const PCRE2_INFO_ARGOPTIONS: u32 = 1;
pub const PCRE2_INFO_BACKREFMAX: u32 = 2;
pub const PCRE2_INFO_BSR: u32 = 3;
pub const PCRE2_INFO_CAPTURECOUNT: u32 = 4;
pub const PCRE2_INFO_FIRSTCODEUNIT: u32 = 5;
pub const PCRE2_INFO_FIRSTCODETYPE: u32 = 6;
pub const PCRE2_INFO_FIRSTBITMAP: u32 = 7;
pub const PCRE2_INFO_HASCRORLF: u32 = 8;
pub const PCRE2_INFO_JCHANGED: u32 = 9;
pub const PCRE2_INFO_JITSIZE: u32 = 10;
pub const PCRE2_INFO_LASTCODEUNIT: u32 = 11;
pub const PCRE2_INFO_LASTCODETYPE: u32 = 12;
pub const PCRE2_INFO_MATCHEMPTY: u32 = 13;
pub const PCRE2_INFO_MATCHLIMIT: u32 = 14;
pub const PCRE2_INFO_MAXLOOKBEHIND: u32 = 15;
pub const PCRE2_INFO_MINLENGTH: u32 = 16;
pub const PCRE2_INFO_NAMECOUNT: u32 = 17;
pub const PCRE2_INFO_NAMEENTRYSIZE: u32 = 18;
pub const PCRE2_INFO_NAMETABLE: u32 = 19;
pub const PCRE2_INFO_NEWLINE: u32 = 20;
pub const PCRE2_INFO_DEPTHLIMIT: u32 = 21;
pub const PCRE2_INFO_RECURSIONLIMIT: u32 = 21;
pub const PCRE2_INFO_SIZE: u32 = 22;
pub const PCRE2_INFO_HASBACKSLASHC: u32 = 23;
pub const PCRE2_INFO_FRAMESIZE: u32 = 24;
pub const PCRE2_INFO_HEAPLIMIT: u32 = 25;
pub const PCRE2_INFO_EXTRAOPTIONS: u32 = 26;
pub const PCRE2_CONFIG_BSR: u32 = 0;
pub const PCRE2_CONFIG_JIT: u32 = 1;
pub const PCRE2_CONFIG_JITTARGET: u32 = 2;
pub const PCRE2_CONFIG_LINKSIZE: u32 = 3;
pub const PCRE2_CONFIG_MATCHLIMIT: u32 = 4;
pub const PCRE2_CONFIG_NEWLINE: u32 = 5;
pub const PCRE2_CONFIG_PARENSLIMIT: u32 = 6;
pub const PCRE2_CONFIG_DEPTHLIMIT: u32 = 7;
pub const PCRE2_CONFIG_RECURSIONLIMIT: u32 = 7;
pub const PCRE2_CONFIG_STACKRECURSE: u32 = 8;
pub const PCRE2_CONFIG_UNICODE: u32 = 9;
pub const PCRE2_CONFIG_UNICODE_VERSION: u32 = 10;
pub const PCRE2_CONFIG_VERSION: u32 = 11;
pub const PCRE2_CONFIG_HEAPLIMIT: u32 = 12;
pub const PCRE2_CONFIG_NEVER_BACKSLASH_C: u32 = 13;
pub const PCRE2_CONFIG_COMPILED_WIDTHS: u32 = 14;
pub const PCRE2_CONFIG_TABLES_LENGTH: u32 = 15;
pub const PCRE2_SIZE_MAX: i32 = -1;
pub const PCRE2_CALLOUT_STARTMATCH: u32 = 1;
pub const PCRE2_CALLOUT_BACKTRACK: u32 = 2;
pub const PCRE2_LOCAL_WIDTH: u32 = 8;
pub const CLI_PCREMATCH_NOOFFSETOVERRIDE: i32 = -1;
pub const OVECCOUNT: u32 = 300;
pub const PCRE_SCAN_NONE: u32 = 0;
pub const PCRE_SCAN_BUFF: u32 = 1;
pub const PCRE_SCAN_FMAP: u32 = 2;
pub const PCRE_BYPASS: &[u8; 31usize] = b"7374756c747a676574737265676578\0";
pub const CLI_PCRE_GLOBAL: u32 = 1;
pub const CLI_PCRE_ENCOMPASS: u32 = 2;
pub const CLI_PCRE_ROLLING: u32 = 4;
pub const CLI_PCRE_DISABLED: u32 = 2147483648;
pub const CLI_BCOMP_MAX_BIN_BLEN: u32 = 8;
pub const CLI_BCOMP_MAX_HEX_BLEN: u32 = 18;
pub const CLI_BCOMP_HEX: u32 = 1;
pub const CLI_BCOMP_DEC: u32 = 2;
pub const CLI_BCOMP_BIN: u32 = 4;
pub const CLI_BCOMP_AUTO: u32 = 8;
pub const CLI_BCOMP_LE: u32 = 16;
pub const CLI_BCOMP_BE: u32 = 32;
pub const CLI_BCOMP_EXACT: u32 = 256;
pub const CLI_MATCH_METADATA: u32 = 65280;
pub const CLI_MATCH_WILDCARD: u32 = 3840;
pub const CLI_MATCH_CHAR: u32 = 0;
pub const CLI_MATCH_NOCASE: u32 = 4096;
pub const CLI_MATCH_IGNORE: u32 = 256;
pub const CLI_MATCH_SPECIAL: u32 = 512;
pub const CLI_MATCH_NIBBLE_HIGH: u32 = 768;
pub const CLI_MATCH_NIBBLE_LOW: u32 = 1024;
pub const CLI_LSIG_FLAG_PRIVATE: u32 = 1;
pub const CLI_MAX_TARGETS: u32 = 10;
pub const CLI_MTARGETS: u32 = 15;
pub const CLI_OFF_ANY: u32 = 4294967295;
pub const CLI_OFF_NONE: u32 = 4294967294;
pub const CLI_OFF_ABSOLUTE: u32 = 1;
pub const CLI_OFF_EOF_MINUS: u32 = 2;
pub const CLI_OFF_EP_PLUS: u32 = 3;
pub const CLI_OFF_EP_MINUS: u32 = 4;
pub const CLI_OFF_SL_PLUS: u32 = 5;
pub const CLI_OFF_SX_PLUS: u32 = 6;
pub const CLI_OFF_VERSION: u32 = 7;
pub const CLI_OFF_MACRO: u32 = 8;
pub const CLI_OFF_SE: u32 = 9;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__spins as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__elision as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__list as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__futex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__total_seq as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__wakeup_seq as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__woken_seq as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__mutex as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__nwaiters as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__broadcast_seq as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__readers_wakeup as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__readers_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer_wakeup as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers_queued
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers_queued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_writers_queued
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_writers_queued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__rwelision as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad1 as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad2 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__flags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__flags)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: __locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(
        arg1: *mut _IO_FILE,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st {
    _unused: [u8; 0],
}
pub type OPENSSL_STACK = stack_st;
pub type OPENSSL_sk_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type OPENSSL_sk_freefunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type OPENSSL_sk_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn OPENSSL_sk_num(arg1: *const OPENSSL_STACK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_value(
        arg1: *const OPENSSL_STACK,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_set(
        st: *mut OPENSSL_STACK,
        i: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_new(cmp: OPENSSL_sk_compfunc) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_new_null() -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_new_reserve(
        c: OPENSSL_sk_compfunc,
        n: ::std::os::raw::c_int,
    ) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_reserve(
        st: *mut OPENSSL_STACK,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_free(arg1: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_pop_free(
        st: *mut OPENSSL_STACK,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn OPENSSL_sk_deep_copy(
        arg1: *const OPENSSL_STACK,
        c: OPENSSL_sk_copyfunc,
        f: OPENSSL_sk_freefunc,
    ) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_insert(
        sk: *mut OPENSSL_STACK,
        data: *const ::std::os::raw::c_void,
        where_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_delete(
        st: *mut OPENSSL_STACK,
        loc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_delete_ptr(
        st: *mut OPENSSL_STACK,
        p: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_find(
        st: *mut OPENSSL_STACK,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_find_ex(
        st: *mut OPENSSL_STACK,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_push(
        st: *mut OPENSSL_STACK,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_unshift(
        st: *mut OPENSSL_STACK,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_shift(st: *mut OPENSSL_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_pop(st: *mut OPENSSL_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_zero(st: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_set_cmp_func(
        sk: *mut OPENSSL_STACK,
        cmp: OPENSSL_sk_compfunc,
    ) -> OPENSSL_sk_compfunc;
}
extern "C" {
    pub fn OPENSSL_sk_dup(st: *const OPENSSL_STACK) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_sort(st: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_is_sorted(st: *const OPENSSL_STACK) -> ::std::os::raw::c_int;
}
pub type OPENSSL_STRING = *mut ::std::os::raw::c_char;
pub type OPENSSL_CSTRING = *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_STRING {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_STRING_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::std::os::raw::c_char,
        b: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_OPENSSL_STRING_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut ::std::os::raw::c_char)>;
pub type sk_OPENSSL_STRING_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_CSTRING {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_CSTRING_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::std::os::raw::c_char,
        b: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_OPENSSL_CSTRING_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut ::std::os::raw::c_char)>;
pub type sk_OPENSSL_CSTRING_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type OPENSSL_BLOCK = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_BLOCK {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_BLOCK_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::std::os::raw::c_void,
        b: *const *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_OPENSSL_BLOCK_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut ::std::os::raw::c_void)>;
pub type sk_OPENSSL_BLOCK_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type ASN1_INTEGER = asn1_string_st;
pub type ASN1_ENUMERATED = asn1_string_st;
pub type ASN1_BIT_STRING = asn1_string_st;
pub type ASN1_OCTET_STRING = asn1_string_st;
pub type ASN1_PRINTABLESTRING = asn1_string_st;
pub type ASN1_T61STRING = asn1_string_st;
pub type ASN1_IA5STRING = asn1_string_st;
pub type ASN1_GENERALSTRING = asn1_string_st;
pub type ASN1_UNIVERSALSTRING = asn1_string_st;
pub type ASN1_BMPSTRING = asn1_string_st;
pub type ASN1_UTCTIME = asn1_string_st;
pub type ASN1_TIME = asn1_string_st;
pub type ASN1_GENERALIZEDTIME = asn1_string_st;
pub type ASN1_VISIBLESTRING = asn1_string_st;
pub type ASN1_UTF8STRING = asn1_string_st;
pub type ASN1_STRING = asn1_string_st;
pub type ASN1_BOOLEAN = ::std::os::raw::c_int;
pub type ASN1_NULL = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_object_st {
    _unused: [u8; 0],
}
pub type ASN1_OBJECT = asn1_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ITEM_st {
    _unused: [u8; 0],
}
pub type ASN1_ITEM = ASN1_ITEM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_pctx_st {
    _unused: [u8; 0],
}
pub type ASN1_PCTX = asn1_pctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_sctx_st {
    _unused: [u8; 0],
}
pub type ASN1_SCTX = asn1_sctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dane_st {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_st {
    _unused: [u8; 0],
}
pub type BIO = bio_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_st {
    _unused: [u8; 0],
}
pub type BIGNUM = bignum_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_ctx {
    _unused: [u8; 0],
}
pub type BN_CTX = bignum_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_blinding_st {
    _unused: [u8; 0],
}
pub type BN_BLINDING = bn_blinding_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_mont_ctx_st {
    _unused: [u8; 0],
}
pub type BN_MONT_CTX = bn_mont_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_recp_ctx_st {
    _unused: [u8; 0],
}
pub type BN_RECP_CTX = bn_recp_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_gencb_st {
    _unused: [u8; 0],
}
pub type BN_GENCB = bn_gencb_st;
pub type BUF_MEM = buf_mem_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_st {
    _unused: [u8; 0],
}
pub type EVP_CIPHER = evp_cipher_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_CIPHER_CTX = evp_cipher_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_st {
    _unused: [u8; 0],
}
pub type EVP_MD = evp_md_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_MD_CTX = evp_md_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY = evp_pkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_asn1_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_ASN1_METHOD = evp_pkey_asn1_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_METHOD = evp_pkey_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_CTX = evp_pkey_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_Encode_Ctx_st {
    _unused: [u8; 0],
}
pub type EVP_ENCODE_CTX = evp_Encode_Ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_ctx_st {
    _unused: [u8; 0],
}
pub type HMAC_CTX = hmac_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_st {
    _unused: [u8; 0],
}
pub type DH = dh_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_method {
    _unused: [u8; 0],
}
pub type DH_METHOD = dh_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_st {
    _unused: [u8; 0],
}
pub type DSA = dsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_method {
    _unused: [u8; 0],
}
pub type DSA_METHOD = dsa_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_st {
    _unused: [u8; 0],
}
pub type RSA = rsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_meth_st {
    _unused: [u8; 0],
}
pub type RSA_METHOD = rsa_meth_st;
pub type RSA_PSS_PARAMS = rsa_pss_params_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_st {
    _unused: [u8; 0],
}
pub type EC_KEY = ec_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_method_st {
    _unused: [u8; 0],
}
pub type EC_KEY_METHOD = ec_key_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_meth_st {
    _unused: [u8; 0],
}
pub type RAND_METHOD = rand_meth_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_drbg_st {
    _unused: [u8; 0],
}
pub type RAND_DRBG = rand_drbg_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_dane_st {
    _unused: [u8; 0],
}
pub type SSL_DANE = ssl_dane_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_st {
    _unused: [u8; 0],
}
pub type X509 = x509_st;
pub type X509_ALGOR = X509_algor_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_crl_st {
    _unused: [u8; 0],
}
pub type X509_CRL = X509_crl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crl_method_st {
    _unused: [u8; 0],
}
pub type X509_CRL_METHOD = x509_crl_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_revoked_st {
    _unused: [u8; 0],
}
pub type X509_REVOKED = x509_revoked_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_st {
    _unused: [u8; 0],
}
pub type X509_NAME = X509_name_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_pubkey_st {
    _unused: [u8; 0],
}
pub type X509_PUBKEY = X509_pubkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_st {
    _unused: [u8; 0],
}
pub type X509_STORE = x509_store_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_ctx_st {
    _unused: [u8; 0],
}
pub type X509_STORE_CTX = x509_store_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_object_st {
    _unused: [u8; 0],
}
pub type X509_OBJECT = x509_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_st {
    _unused: [u8; 0],
}
pub type X509_LOOKUP = x509_lookup_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_method_st {
    _unused: [u8; 0],
}
pub type X509_LOOKUP_METHOD = x509_lookup_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_VERIFY_PARAM_st {
    _unused: [u8; 0],
}
pub type X509_VERIFY_PARAM = X509_VERIFY_PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_sig_info_st {
    _unused: [u8; 0],
}
pub type X509_SIG_INFO = x509_sig_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs8_priv_key_info_st {
    _unused: [u8; 0],
}
pub type PKCS8_PRIV_KEY_INFO = pkcs8_priv_key_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v3_ext_ctx {
    _unused: [u8; 0],
}
pub type X509V3_CTX = v3_ext_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_st {
    _unused: [u8; 0],
}
pub type CONF = conf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_init_settings_st {
    _unused: [u8; 0],
}
pub type OPENSSL_INIT_SETTINGS = ossl_init_settings_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_st {
    _unused: [u8; 0],
}
pub type UI = ui_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_method_st {
    _unused: [u8; 0],
}
pub type UI_METHOD = ui_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine_st {
    _unused: [u8; 0],
}
pub type ENGINE = engine_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_st {
    _unused: [u8; 0],
}
pub type SSL = ssl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ctx_st {
    _unused: [u8; 0],
}
pub type SSL_CTX = ssl_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comp_ctx_st {
    _unused: [u8; 0],
}
pub type COMP_CTX = comp_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comp_method_st {
    _unused: [u8; 0],
}
pub type COMP_METHOD = comp_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_NODE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_NODE = X509_POLICY_NODE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_LEVEL_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_LEVEL = X509_POLICY_LEVEL_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_TREE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_TREE = X509_POLICY_TREE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_CACHE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_CACHE = X509_POLICY_CACHE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUTHORITY_KEYID_st {
    _unused: [u8; 0],
}
pub type AUTHORITY_KEYID = AUTHORITY_KEYID_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIST_POINT_st {
    _unused: [u8; 0],
}
pub type DIST_POINT = DIST_POINT_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISSUING_DIST_POINT_st {
    _unused: [u8; 0],
}
pub type ISSUING_DIST_POINT = ISSUING_DIST_POINT_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAME_CONSTRAINTS_st {
    _unused: [u8; 0],
}
pub type NAME_CONSTRAINTS = NAME_CONSTRAINTS_st;
pub type CRYPTO_EX_DATA = crypto_ex_data_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_req_ctx_st {
    _unused: [u8; 0],
}
pub type OCSP_REQ_CTX = ocsp_req_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_response_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPONSE = ocsp_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_responder_id_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPID = ocsp_responder_id_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sct_st {
    _unused: [u8; 0],
}
pub type SCT = sct_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sct_ctx_st {
    _unused: [u8; 0],
}
pub type SCT_CTX = sct_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctlog_st {
    _unused: [u8; 0],
}
pub type CTLOG = ctlog_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctlog_store_st {
    _unused: [u8; 0],
}
pub type CTLOG_STORE = ctlog_store_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ct_policy_eval_ctx_st {
    _unused: [u8; 0],
}
pub type CT_POLICY_EVAL_CTX = ct_policy_eval_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_store_info_st {
    _unused: [u8; 0],
}
pub type OSSL_STORE_INFO = ossl_store_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_store_search_st {
    _unused: [u8; 0],
}
pub type OSSL_STORE_SEARCH = ossl_store_search_st;
pub type ossl_intmax_t = intmax_t;
pub type ossl_uintmax_t = uintmax_t;
extern "C" {
    pub fn ERR_load_CRYPTO_strings() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CRYPTO_dynlock() {
    assert_eq!(
        ::std::mem::size_of::<CRYPTO_dynlock>(),
        4usize,
        concat!("Size of: ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CRYPTO_dynlock>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CRYPTO_dynlock>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_dynlock),
            "::",
            stringify!(dummy)
        )
    );
}
pub type CRYPTO_RWLOCK = ::std::os::raw::c_void;
extern "C" {
    pub fn CRYPTO_THREAD_lock_new() -> *mut CRYPTO_RWLOCK;
}
extern "C" {
    pub fn CRYPTO_THREAD_read_lock(lock: *mut CRYPTO_RWLOCK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_write_lock(lock: *mut CRYPTO_RWLOCK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_unlock(lock: *mut CRYPTO_RWLOCK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_lock_free(lock: *mut CRYPTO_RWLOCK);
}
extern "C" {
    pub fn CRYPTO_atomic_add(
        val: *mut ::std::os::raw::c_int,
        amount: ::std::os::raw::c_int,
        ret: *mut ::std::os::raw::c_int,
        lock: *mut CRYPTO_RWLOCK,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_ex_data_st {
    pub sk: *mut stack_st_void,
}
#[test]
fn bindgen_test_layout_crypto_ex_data_st() {
    assert_eq!(
        ::std::mem::size_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Size of: ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_ex_data_st>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_st),
            "::",
            stringify!(sk)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_void {
    _unused: [u8; 0],
}
pub type sk_void_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::std::os::raw::c_void,
        b: *const *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_void_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut ::std::os::raw::c_void)>;
pub type sk_void_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn CRYPTO_mem_ctrl(mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OPENSSL_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn OPENSSL_strnlen(str_: *const ::std::os::raw::c_char, maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn OPENSSL_buf2hexstr(
        buffer: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn OPENSSL_hexstr2buf(
        str_: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn OPENSSL_hexchar2int(c: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OpenSSL_version_num() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn OpenSSL_version(type_: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OPENSSL_issetugid() -> ::std::os::raw::c_int;
}
pub type CRYPTO_EX_new = ::std::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ),
>;
pub type CRYPTO_EX_free = ::std::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ),
>;
pub type CRYPTO_EX_dup = ::std::option::Option<
    unsafe extern "C" fn(
        to: *mut CRYPTO_EX_DATA,
        from: *const CRYPTO_EX_DATA,
        from_d: *mut ::std::os::raw::c_void,
        idx: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn CRYPTO_get_ex_new_index(
        class_index: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_free_ex_index(
        class_index: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_new_ex_data(
        class_index: ::std::os::raw::c_int,
        obj: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_dup_ex_data(
        class_index: ::std::os::raw::c_int,
        to: *mut CRYPTO_EX_DATA,
        from: *const CRYPTO_EX_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_free_ex_data(
        class_index: ::std::os::raw::c_int,
        obj: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
    );
}
extern "C" {
    pub fn CRYPTO_set_ex_data(
        ad: *mut CRYPTO_EX_DATA,
        idx: ::std::os::raw::c_int,
        val: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_get_ex_data(
        ad: *const CRYPTO_EX_DATA,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_threadid_st {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_crypto_threadid_st() {
    assert_eq!(
        ::std::mem::size_of::<crypto_threadid_st>(),
        4usize,
        concat!("Size of: ", stringify!(crypto_threadid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_threadid_st>(),
        4usize,
        concat!("Alignment of ", stringify!(crypto_threadid_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_threadid_st>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_threadid_st),
            "::",
            stringify!(dummy)
        )
    );
}
pub type CRYPTO_THREADID = crypto_threadid_st;
extern "C" {
    pub fn CRYPTO_set_mem_functions(
        m: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        r: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: size_t,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_set_mem_debug(flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_get_mem_functions(
        m: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        r: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: size_t,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        f: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_malloc(
        num: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_zalloc(
        num: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_memdup(
        str_: *const ::std::os::raw::c_void,
        siz: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_strdup(
        str_: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn CRYPTO_strndup(
        str_: *const ::std::os::raw::c_char,
        s: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn CRYPTO_free(
        ptr: *mut ::std::os::raw::c_void,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_clear_free(
        ptr: *mut ::std::os::raw::c_void,
        num: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_realloc(
        addr: *mut ::std::os::raw::c_void,
        num: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_clear_realloc(
        addr: *mut ::std::os::raw::c_void,
        old_num: size_t,
        num: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_init(
        sz: size_t,
        minsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_done() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc(
        num: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_zalloc(
        num: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_free(
        ptr: *mut ::std::os::raw::c_void,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_secure_clear_free(
        ptr: *mut ::std::os::raw::c_void,
        num: size_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_secure_allocated(ptr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_initialized() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_actual_size(ptr: *mut ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn CRYPTO_secure_used() -> size_t;
}
extern "C" {
    pub fn OPENSSL_cleanse(ptr: *mut ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn OPENSSL_die(
        assertion: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn OPENSSL_isservice() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FIPS_mode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FIPS_mode_set(r: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_init();
}
extern "C" {
    pub fn OPENSSL_fork_prepare();
}
extern "C" {
    pub fn OPENSSL_fork_parent();
}
extern "C" {
    pub fn OPENSSL_fork_child();
}
extern "C" {
    pub fn OPENSSL_gmtime(timer: *const time_t, result: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn OPENSSL_gmtime_adj(
        tm: *mut tm,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_gmtime_diff(
        pday: *mut ::std::os::raw::c_int,
        psec: *mut ::std::os::raw::c_int,
        from: *const tm,
        to: *const tm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_memcmp(
        in_a: *const ::std::os::raw::c_void,
        in_b: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_cleanup();
}
extern "C" {
    pub fn OPENSSL_init_crypto(
        opts: u64,
        settings: *const OPENSSL_INIT_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_atexit(
        handler: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_thread_stop();
}
extern "C" {
    pub fn OPENSSL_INIT_new() -> *mut OPENSSL_INIT_SETTINGS;
}
extern "C" {
    pub fn OPENSSL_INIT_set_config_filename(
        settings: *mut OPENSSL_INIT_SETTINGS,
        config_filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_INIT_set_config_file_flags(
        settings: *mut OPENSSL_INIT_SETTINGS,
        flags: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn OPENSSL_INIT_set_config_appname(
        settings: *mut OPENSSL_INIT_SETTINGS,
        config_appname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_INIT_free(settings: *mut OPENSSL_INIT_SETTINGS);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(__sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(__sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::std::os::raw::c_uint = 3;
pub const PTHREAD_MUTEX_NORMAL: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_STALLED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_ROBUST: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: ::std::os::raw::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type CRYPTO_ONCE = pthread_once_t;
pub type CRYPTO_THREAD_LOCAL = pthread_key_t;
pub type CRYPTO_THREAD_ID = pthread_t;
extern "C" {
    pub fn CRYPTO_THREAD_run_once(
        once: *mut CRYPTO_ONCE,
        init: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_init_local(
        key: *mut CRYPTO_THREAD_LOCAL,
        cleanup: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_get_local(key: *mut CRYPTO_THREAD_LOCAL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_THREAD_set_local(
        key: *mut CRYPTO_THREAD_LOCAL,
        val: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_cleanup_local(key: *mut CRYPTO_THREAD_LOCAL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_get_current_id() -> CRYPTO_THREAD_ID;
}
extern "C" {
    pub fn CRYPTO_THREAD_compare_id(
        a: CRYPTO_THREAD_ID,
        b: CRYPTO_THREAD_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_COMP_strings() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn COMP_CTX_new(meth: *mut COMP_METHOD) -> *mut COMP_CTX;
}
extern "C" {
    pub fn COMP_CTX_get_method(ctx: *const COMP_CTX) -> *const COMP_METHOD;
}
extern "C" {
    pub fn COMP_CTX_get_type(comp: *const COMP_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn COMP_get_type(meth: *const COMP_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn COMP_get_name(meth: *const COMP_METHOD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn COMP_CTX_free(ctx: *mut COMP_CTX);
}
extern "C" {
    pub fn COMP_compress_block(
        ctx: *mut COMP_CTX,
        out: *mut ::std::os::raw::c_uchar,
        olen: ::std::os::raw::c_int,
        in_: *mut ::std::os::raw::c_uchar,
        ilen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn COMP_expand_block(
        ctx: *mut COMP_CTX,
        out: *mut ::std::os::raw::c_uchar,
        olen: ::std::os::raw::c_int,
        in_: *mut ::std::os::raw::c_uchar,
        ilen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn COMP_zlib() -> *mut COMP_METHOD;
}
extern "C" {
    pub fn ERR_load_BIO_strings() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_addr_st {
    _unused: [u8; 0],
}
pub type BIO_ADDR = bio_addr_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_addrinfo_st {
    _unused: [u8; 0],
}
pub type BIO_ADDRINFO = bio_addrinfo_st;
extern "C" {
    pub fn BIO_get_new_index() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_flags(b: *mut BIO, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_test_flags(b: *const BIO, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_clear_flags(b: *mut BIO, flags: ::std::os::raw::c_int);
}
pub type BIO_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        oper: ::std::os::raw::c_int,
        argp: *const ::std::os::raw::c_char,
        argi: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        ret: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
>;
pub type BIO_callback_fn_ex = ::std::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        oper: ::std::os::raw::c_int,
        argp: *const ::std::os::raw::c_char,
        len: size_t,
        argi: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        ret: ::std::os::raw::c_int,
        processed: *mut size_t,
    ) -> ::std::os::raw::c_long,
>;
extern "C" {
    pub fn BIO_get_callback(b: *const BIO) -> BIO_callback_fn;
}
extern "C" {
    pub fn BIO_set_callback(b: *mut BIO, callback: BIO_callback_fn);
}
extern "C" {
    pub fn BIO_get_callback_ex(b: *const BIO) -> BIO_callback_fn_ex;
}
extern "C" {
    pub fn BIO_set_callback_ex(b: *mut BIO, callback: BIO_callback_fn_ex);
}
extern "C" {
    pub fn BIO_get_callback_arg(b: *const BIO) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_set_callback_arg(b: *mut BIO, arg: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_method_st {
    _unused: [u8; 0],
}
pub type BIO_METHOD = bio_method_st;
extern "C" {
    pub fn BIO_method_name(b: *const BIO) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_method_type(b: *const BIO) -> ::std::os::raw::c_int;
}
pub type BIO_info_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut BIO,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type bio_info_cb = BIO_info_cb;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_BIO {
    _unused: [u8; 0],
}
pub type sk_BIO_compfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const *const BIO, b: *const *const BIO) -> ::std::os::raw::c_int,
>;
pub type sk_BIO_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut BIO)>;
pub type sk_BIO_copyfunc = ::std::option::Option<unsafe extern "C" fn(a: *const BIO) -> *mut BIO>;
pub type asn1_ps_func = ::std::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        pbuf: *mut *mut ::std::os::raw::c_uchar,
        plen: *mut ::std::os::raw::c_int,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn BIO_ctrl_pending(b: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_wpending(b: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_get_write_guarantee(b: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_get_read_request(b: *mut BIO) -> size_t;
}
extern "C" {
    pub fn BIO_ctrl_reset_read_request(b: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_ex_data(
        bio: *mut BIO,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_ex_data(
        bio: *mut BIO,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BIO_number_read(bio: *mut BIO) -> u64;
}
extern "C" {
    pub fn BIO_number_written(bio: *mut BIO) -> u64;
}
extern "C" {
    pub fn BIO_asn1_set_prefix(
        b: *mut BIO,
        prefix: asn1_ps_func,
        prefix_free: asn1_ps_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_asn1_get_prefix(
        b: *mut BIO,
        pprefix: *mut asn1_ps_func,
        pprefix_free: *mut asn1_ps_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_asn1_set_suffix(
        b: *mut BIO,
        suffix: asn1_ps_func,
        suffix_free: asn1_ps_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_asn1_get_suffix(
        b: *mut BIO,
        psuffix: *mut asn1_ps_func,
        psuffix_free: *mut asn1_ps_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_s_file() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_file(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fp(stream: *mut FILE, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new(type_: *const BIO_METHOD) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free(a: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_data(a: *mut BIO, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn BIO_get_data(a: *mut BIO) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BIO_set_init(a: *mut BIO, init: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_get_init(a: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_shutdown(a: *mut BIO, shut: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_get_shutdown(a: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vfree(a: *mut BIO);
}
extern "C" {
    pub fn BIO_up_ref(a: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_read(
        b: *mut BIO,
        data: *mut ::std::os::raw::c_void,
        dlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_read_ex(
        b: *mut BIO,
        data: *mut ::std::os::raw::c_void,
        dlen: size_t,
        readbytes: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_gets(
        bp: *mut BIO,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write(
        b: *mut BIO,
        data: *const ::std::os::raw::c_void,
        dlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write_ex(
        b: *mut BIO,
        data: *const ::std::os::raw::c_void,
        dlen: size_t,
        written: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_puts(bp: *mut BIO, buf: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_indent(
        b: *mut BIO,
        indent: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_callback_ctrl(
        b: *mut BIO,
        cmd: ::std::os::raw::c_int,
        fp: BIO_info_cb,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_ptr_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BIO_int_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        iarg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_push(b: *mut BIO, append: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_pop(b: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free_all(a: *mut BIO);
}
extern "C" {
    pub fn BIO_find_type(b: *mut BIO, bio_type: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_next(b: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_set_next(b: *mut BIO, next: *mut BIO);
}
extern "C" {
    pub fn BIO_get_retry_BIO(bio: *mut BIO, reason: *mut ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_get_retry_reason(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_retry_reason(bio: *mut BIO, reason: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_dup_chain(in_: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_nread0(
        bio: *mut BIO,
        buf: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_nread(
        bio: *mut BIO,
        buf: *mut *mut ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_nwrite0(
        bio: *mut BIO,
        buf: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_nwrite(
        bio: *mut BIO,
        buf: *mut *mut ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_debug_callback(
        bio: *mut BIO,
        cmd: ::std::os::raw::c_int,
        argp: *const ::std::os::raw::c_char,
        argi: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        ret: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_s_mem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_secmem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_mem_buf(
        buf: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_s_socket() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_connect() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_accept() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_fd() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_log() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_bio() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_null() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_null() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_buffer() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_linebuffer() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_nbio_test() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_datagram() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_dgram_non_fatal_error(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_new_dgram(fd: ::std::os::raw::c_int, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_sock_should_retry(i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_sock_non_fatal_error(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_fd_should_retry(i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_fd_non_fatal_error(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_cb(
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                data: *const ::std::os::raw::c_void,
                len: size_t,
                u: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        u: *mut ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_indent_cb(
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                data: *const ::std::os::raw::c_void,
                len: size_t,
                u: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        u: *mut ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump(
        b: *mut BIO,
        bytes: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_indent(
        b: *mut BIO,
        bytes: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_fp(
        fp: *mut FILE,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_dump_indent_fp(
        fp: *mut FILE,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_hex_string(
        out: *mut BIO,
        indent: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        datalen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ADDR_new() -> *mut BIO_ADDR;
}
extern "C" {
    pub fn BIO_ADDR_rawmake(
        ap: *mut BIO_ADDR,
        family: ::std::os::raw::c_int,
        where_: *const ::std::os::raw::c_void,
        wherelen: size_t,
        port: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ADDR_free(arg1: *mut BIO_ADDR);
}
extern "C" {
    pub fn BIO_ADDR_clear(ap: *mut BIO_ADDR);
}
extern "C" {
    pub fn BIO_ADDR_family(ap: *const BIO_ADDR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ADDR_rawaddress(
        ap: *const BIO_ADDR,
        p: *mut ::std::os::raw::c_void,
        l: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ADDR_rawport(ap: *const BIO_ADDR) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn BIO_ADDR_hostname_string(
        ap: *const BIO_ADDR,
        numeric: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_ADDR_service_string(
        ap: *const BIO_ADDR,
        numeric: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_ADDR_path_string(ap: *const BIO_ADDR) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_ADDRINFO_next(bai: *const BIO_ADDRINFO) -> *const BIO_ADDRINFO;
}
extern "C" {
    pub fn BIO_ADDRINFO_family(bai: *const BIO_ADDRINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_socktype(bai: *const BIO_ADDRINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_protocol(bai: *const BIO_ADDRINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_address(bai: *const BIO_ADDRINFO) -> *const BIO_ADDR;
}
extern "C" {
    pub fn BIO_ADDRINFO_free(bai: *mut BIO_ADDRINFO);
}
pub const BIO_hostserv_priorities_BIO_PARSE_PRIO_HOST: BIO_hostserv_priorities = 0;
pub const BIO_hostserv_priorities_BIO_PARSE_PRIO_SERV: BIO_hostserv_priorities = 1;
pub type BIO_hostserv_priorities = ::std::os::raw::c_uint;
extern "C" {
    pub fn BIO_parse_hostserv(
        hostserv: *const ::std::os::raw::c_char,
        host: *mut *mut ::std::os::raw::c_char,
        service: *mut *mut ::std::os::raw::c_char,
        hostserv_prio: BIO_hostserv_priorities,
    ) -> ::std::os::raw::c_int;
}
pub const BIO_lookup_type_BIO_LOOKUP_CLIENT: BIO_lookup_type = 0;
pub const BIO_lookup_type_BIO_LOOKUP_SERVER: BIO_lookup_type = 1;
pub type BIO_lookup_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn BIO_lookup(
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        lookup_type: BIO_lookup_type,
        family: ::std::os::raw::c_int,
        socktype: ::std::os::raw::c_int,
        res: *mut *mut BIO_ADDRINFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_lookup_ex(
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        lookup_type: ::std::os::raw::c_int,
        family: ::std::os::raw::c_int,
        socktype: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        res: *mut *mut BIO_ADDRINFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_sock_error(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_socket_ioctl(
        fd: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_long,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_socket_nbio(
        fd: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_sock_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_tcp_ndelay(
        sock: ::std::os::raw::c_int,
        turn_on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn BIO_gethostbyname(name: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn BIO_get_port(
        str_: *const ::std::os::raw::c_char,
        port_ptr: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_host_ip(
        str_: *const ::std::os::raw::c_char,
        ip: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_accept_socket(
        host_port: *mut ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_accept(
        sock: ::std::os::raw::c_int,
        ip_port: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BIO_sock_info_u {
    pub addr: *mut BIO_ADDR,
}
#[test]
fn bindgen_test_layout_BIO_sock_info_u() {
    assert_eq!(
        ::std::mem::size_of::<BIO_sock_info_u>(),
        8usize,
        concat!("Size of: ", stringify!(BIO_sock_info_u))
    );
    assert_eq!(
        ::std::mem::align_of::<BIO_sock_info_u>(),
        8usize,
        concat!("Alignment of ", stringify!(BIO_sock_info_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BIO_sock_info_u>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BIO_sock_info_u),
            "::",
            stringify!(addr)
        )
    );
}
pub const BIO_sock_info_type_BIO_SOCK_INFO_ADDRESS: BIO_sock_info_type = 0;
pub type BIO_sock_info_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn BIO_sock_info(
        sock: ::std::os::raw::c_int,
        type_: BIO_sock_info_type,
        info: *mut BIO_sock_info_u,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_socket(
        domain: ::std::os::raw::c_int,
        socktype: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_connect(
        sock: ::std::os::raw::c_int,
        addr: *const BIO_ADDR,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_bind(
        sock: ::std::os::raw::c_int,
        addr: *const BIO_ADDR,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_listen(
        sock: ::std::os::raw::c_int,
        addr: *const BIO_ADDR,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_accept_ex(
        accept_sock: ::std::os::raw::c_int,
        addr: *mut BIO_ADDR,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_closesocket(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_new_socket(
        sock: ::std::os::raw::c_int,
        close_flag: ::std::os::raw::c_int,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_connect(host_port: *const ::std::os::raw::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_accept(host_port: *const ::std::os::raw::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fd(fd: ::std::os::raw::c_int, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_bio_pair(
        bio1: *mut *mut BIO,
        writebuf1: size_t,
        bio2: *mut *mut BIO,
        writebuf2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_copy_next_retry(b: *mut BIO);
}
extern "C" {
    pub fn BIO_printf(
        bio: *mut BIO,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vprintf(
        bio: *mut BIO,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_snprintf(
        buf: *mut ::std::os::raw::c_char,
        n: size_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        n: size_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_new(
        type_: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_meth_free(biom: *mut BIO_METHOD);
}
extern "C" {
    pub fn BIO_meth_get_write(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_get_write_ex(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *const ::std::os::raw::c_char,
            arg2: size_t,
            arg3: *mut size_t,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_write(
        biom: *mut BIO_METHOD,
        write: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_write_ex(
        biom: *mut BIO_METHOD,
        bwrite: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::std::os::raw::c_char,
                arg3: size_t,
                arg4: *mut size_t,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_read(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_get_read_ex(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut ::std::os::raw::c_char,
            arg2: size_t,
            arg3: *mut size_t,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_read(
        biom: *mut BIO_METHOD,
        read: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_read_ex(
        biom: *mut BIO_METHOD,
        bread: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::std::os::raw::c_char,
                arg3: size_t,
                arg4: *mut size_t,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_puts(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_puts(
        biom: *mut BIO_METHOD,
        puts: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_gets(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_gets(
        biom: *mut BIO_METHOD,
        gets: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_ctrl(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_long,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long,
    >;
}
extern "C" {
    pub fn BIO_meth_set_ctrl(
        biom: *mut BIO_METHOD,
        ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_long,
                arg4: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_long,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_create(
        bion: *const BIO_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(bion: *mut BIO) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn BIO_meth_set_create(
        biom: *mut BIO_METHOD,
        create: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_destroy(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(biom: *mut BIO) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn BIO_meth_set_destroy(
        biom: *mut BIO_METHOD,
        destroy: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_callback_ctrl(
        biom: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: ::std::os::raw::c_int,
            arg2: BIO_info_cb,
        ) -> ::std::os::raw::c_long,
    >;
}
extern "C" {
    pub fn BIO_meth_set_callback_ctrl(
        biom: *mut BIO_METHOD,
        callback_ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: ::std::os::raw::c_int,
                arg3: BIO_info_cb,
            ) -> ::std::os::raw::c_long,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_BUF_strings() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf_mem_st {
    pub length: size_t,
    pub data: *mut ::std::os::raw::c_char,
    pub max: size_t,
    pub flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_buf_mem_st() {
    assert_eq!(
        ::std::mem::size_of::<buf_mem_st>(),
        32usize,
        concat!("Size of: ", stringify!(buf_mem_st))
    );
    assert_eq!(
        ::std::mem::align_of::<buf_mem_st>(),
        8usize,
        concat!("Alignment of ", stringify!(buf_mem_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buf_mem_st>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn BUF_MEM_new() -> *mut BUF_MEM;
}
extern "C" {
    pub fn BUF_MEM_new_ex(flags: ::std::os::raw::c_ulong) -> *mut BUF_MEM;
}
extern "C" {
    pub fn BUF_MEM_free(a: *mut BUF_MEM);
}
extern "C" {
    pub fn BUF_MEM_grow(str_: *mut BUF_MEM, len: size_t) -> size_t;
}
extern "C" {
    pub fn BUF_MEM_grow_clean(str_: *mut BUF_MEM, len: size_t) -> size_t;
}
extern "C" {
    pub fn BUF_reverse(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        siz: size_t,
    );
}
extern "C" {
    pub fn ERR_load_EVP_strings() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_ASN1_strings() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_BN_strings() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_flags(b: *mut BIGNUM, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BN_get_flags(b: *const BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_with_flags(dest: *mut BIGNUM, b: *const BIGNUM, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BN_GENCB_call(
        cb: *mut BN_GENCB,
        a: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GENCB_new() -> *mut BN_GENCB;
}
extern "C" {
    pub fn BN_GENCB_free(cb: *mut BN_GENCB);
}
extern "C" {
    pub fn BN_GENCB_set_old(
        gencb: *mut BN_GENCB,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn BN_GENCB_set(
        gencb: *mut BN_GENCB,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut BN_GENCB,
            ) -> ::std::os::raw::c_int,
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn BN_GENCB_get_arg(cb: *mut BN_GENCB) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BN_abs_is_word(a: *const BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_zero(a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_one(a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_word(a: *const BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_odd(a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_zero_ex(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_value_one() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_options() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_CTX_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_secure_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_free(c: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_start(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_get(ctx: *mut BN_CTX) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_CTX_end(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_priv_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_priv_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_num_bits(a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_num_bits_word(l: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_security_bits(
        L: ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_secure_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_clear_free(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_copy(a: *mut BIGNUM, b: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_swap(a: *mut BIGNUM, b: *mut BIGNUM);
}
extern "C" {
    pub fn BN_bin2bn(
        s: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        ret: *mut BIGNUM,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2bin(a: *const BIGNUM, to: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2binpad(
        a: *const BIGNUM,
        to: *mut ::std::os::raw::c_uchar,
        tolen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lebin2bn(
        s: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        ret: *mut BIGNUM,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2lebinpad(
        a: *const BIGNUM,
        to: *mut ::std::os::raw::c_uchar,
        tolen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mpi2bn(
        s: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        ret: *mut BIGNUM,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2mpi(a: *const BIGNUM, to: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_usub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_uadd(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sqr(r: *mut BIGNUM, a: *const BIGNUM, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " BN_set_negative sets sign of a BIGNUM"]
    #[doc = " \\param  b  pointer to the BIGNUM object"]
    #[doc = " \\param  n  0 if the BIGNUM b should be positive and a value != 0 otherwise"]
    pub fn BN_set_negative(b: *mut BIGNUM, n: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " BN_is_negative returns 1 if the BIGNUM is negative"]
    #[doc = " \\param  b  pointer to the BIGNUM object"]
    #[doc = " \\return 1 if a < 0 and 0 otherwise"]
    pub fn BN_is_negative(b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_div(
        dv: *mut BIGNUM,
        rem: *mut BIGNUM,
        m: *const BIGNUM,
        d: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nnmod(
        r: *mut BIGNUM,
        m: *const BIGNUM,
        d: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_add(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_add_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sub(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sub_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_word(a: *const BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_div_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_mul_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_add_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sub_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_word(a: *mut BIGNUM, w: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get_word(a: *const BIGNUM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_cmp(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_free(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_is_bit_set(a: *const BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_consttime(
        rr: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        in_mont: *mut BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_word(
        r: *mut BIGNUM,
        a: ::std::os::raw::c_ulong,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp2_mont(
        r: *mut BIGNUM,
        a1: *const BIGNUM,
        p1: *const BIGNUM,
        a2: *const BIGNUM,
        p2: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_simple(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mask_bits(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_print_fp(fp: *mut FILE, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_print(bio: *mut BIO, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_reciprocal(
        r: *mut BIGNUM,
        m: *const BIGNUM,
        len: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_clear(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_dup(a: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_ucmp(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_bit(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_clear_bit(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2hex(a: *const BIGNUM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_bn2dec(a: *const BIGNUM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_hex2bn(
        a: *mut *mut BIGNUM,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_dec2bn(
        a: *mut *mut BIGNUM,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_asc2bn(
        a: *mut *mut BIGNUM,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_gcd(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_kronecker(
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_inverse(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_mod_sqrt(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_consttime_swap(
        swap: ::std::os::raw::c_ulong,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        nwords: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn BN_generate_prime(
        ret: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        safe: ::std::os::raw::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_is_prime(
        p: *const BIGNUM,
        nchecks: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        ctx: *mut BN_CTX,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest(
        p: *const BIGNUM,
        nchecks: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        ctx: *mut BN_CTX,
        cb_arg: *mut ::std::os::raw::c_void,
        do_trial_division: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_generate_prime_ex(
        ret: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        safe: ::std::os::raw::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_ex(
        p: *const BIGNUM,
        nchecks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest_ex(
        p: *const BIGNUM,
        nchecks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        do_trial_division: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_X931_generate_Xpq(
        Xp: *mut BIGNUM,
        Xq: *mut BIGNUM,
        nbits: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_X931_derive_prime_ex(
        p: *mut BIGNUM,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        Xp: *const BIGNUM,
        Xp1: *const BIGNUM,
        Xp2: *const BIGNUM,
        e: *const BIGNUM,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_X931_generate_prime_ex(
        p: *mut BIGNUM,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        Xp1: *mut BIGNUM,
        Xp2: *mut BIGNUM,
        Xp: *const BIGNUM,
        e: *const BIGNUM,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_new() -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_mod_mul_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_to_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_from_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_free(mont: *mut BN_MONT_CTX);
}
extern "C" {
    pub fn BN_MONT_CTX_set(
        mont: *mut BN_MONT_CTX,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_copy(to: *mut BN_MONT_CTX, from: *mut BN_MONT_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_set_locked(
        pmont: *mut *mut BN_MONT_CTX,
        lock: *mut CRYPTO_RWLOCK,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_BLINDING_new(
        A: *const BIGNUM,
        Ai: *const BIGNUM,
        mod_: *mut BIGNUM,
    ) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn BN_BLINDING_free(b: *mut BN_BLINDING);
}
extern "C" {
    pub fn BN_BLINDING_update(b: *mut BN_BLINDING, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_convert(
        n: *mut BIGNUM,
        b: *mut BN_BLINDING,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_invert(
        n: *mut BIGNUM,
        b: *mut BN_BLINDING,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_convert_ex(
        n: *mut BIGNUM,
        r: *mut BIGNUM,
        b: *mut BN_BLINDING,
        arg1: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_invert_ex(
        n: *mut BIGNUM,
        r: *const BIGNUM,
        b: *mut BN_BLINDING,
        arg1: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_is_current_thread(b: *mut BN_BLINDING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_set_current_thread(b: *mut BN_BLINDING);
}
extern "C" {
    pub fn BN_BLINDING_lock(b: *mut BN_BLINDING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_unlock(b: *mut BN_BLINDING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_BLINDING_get_flags(arg1: *const BN_BLINDING) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn BN_BLINDING_set_flags(arg1: *mut BN_BLINDING, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn BN_BLINDING_create_param(
        b: *mut BN_BLINDING,
        e: *const BIGNUM,
        m: *mut BIGNUM,
        ctx: *mut BN_CTX,
        bn_mod_exp: ::std::option::Option<
            unsafe extern "C" fn(
                r: *mut BIGNUM,
                a: *const BIGNUM,
                p: *const BIGNUM,
                m: *const BIGNUM,
                ctx: *mut BN_CTX,
                m_ctx: *mut BN_MONT_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        m_ctx: *mut BN_MONT_CTX,
    ) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn BN_set_params(
        mul: ::std::os::raw::c_int,
        high: ::std::os::raw::c_int,
        low: ::std::os::raw::c_int,
        mont: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn BN_get_params(which: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_RECP_CTX_new() -> *mut BN_RECP_CTX;
}
extern "C" {
    pub fn BN_RECP_CTX_free(recp: *mut BN_RECP_CTX);
}
extern "C" {
    pub fn BN_RECP_CTX_set(
        recp: *mut BN_RECP_CTX,
        rdiv: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_mul_reciprocal(
        r: *mut BIGNUM,
        x: *const BIGNUM,
        y: *const BIGNUM,
        recp: *mut BN_RECP_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_recp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_div_recp(
        dv: *mut BIGNUM,
        rem: *mut BIGNUM,
        m: *const BIGNUM,
        recp: *mut BN_RECP_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod(r: *mut BIGNUM, a: *const BIGNUM, p: *const BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_inv(
        r: *mut BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_div(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqrt(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_solve_quad(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_mul_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqr_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_inv_arr(
        r: *mut BIGNUM,
        b: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_div_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_exp_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqrt_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_solve_quad_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_poly2arr(
        a: *const BIGNUM,
        p: *mut ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GF2m_arr2poly(
        p: *const ::std::os::raw::c_int,
        a: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_192(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_224(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_256(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_384(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nist_mod_521(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get0_nist_prime_192() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_224() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_256() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_384() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_521() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_nist_mod_func(
        p: *const BIGNUM,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            p: *mut BIGNUM,
            arg1: *const BIGNUM,
            arg2: *const BIGNUM,
            arg3: *mut BN_CTX,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BN_generate_dsa_nonce(
        out: *mut BIGNUM,
        range: *const BIGNUM,
        priv_: *const BIGNUM,
        message: *const ::std::os::raw::c_uchar,
        message_len: size_t,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get_rfc2409_prime_768(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc2409_prime_1024(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_1536(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_2048(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_3072(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_4096(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_6144(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_8192(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bntest_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ALGOR {
    _unused: [u8; 0],
}
pub type sk_X509_ALGOR_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_ALGOR,
        b: *const *const X509_ALGOR,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_ALGOR_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut X509_ALGOR)>;
pub type sk_X509_ALGOR_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_ALGOR) -> *mut X509_ALGOR>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_st {
    pub length: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_asn1_string_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_string_st>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_string_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_string_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_string_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ENCODING_st {
    pub enc: *mut ::std::os::raw::c_uchar,
    pub len: ::std::os::raw::c_long,
    pub modified: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ASN1_ENCODING_st() {
    assert_eq!(
        ::std::mem::size_of::<ASN1_ENCODING_st>(),
        24usize,
        concat!("Size of: ", stringify!(ASN1_ENCODING_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_ENCODING_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ENCODING_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ENCODING_st>())).enc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ENCODING_st>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ASN1_ENCODING_st>())).modified as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ENCODING_st),
            "::",
            stringify!(modified)
        )
    );
}
pub type ASN1_ENCODING = ASN1_ENCODING_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_table_st {
    pub nid: ::std::os::raw::c_int,
    pub minsize: ::std::os::raw::c_long,
    pub maxsize: ::std::os::raw::c_long,
    pub mask: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_asn1_string_table_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_string_table_st>(),
        40usize,
        concat!("Size of: ", stringify!(asn1_string_table_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_string_table_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_string_table_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).nid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).minsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(minsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).maxsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_string_table_st>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_table_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type ASN1_STRING_TABLE = asn1_string_table_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_STRING_TABLE {
    _unused: [u8; 0],
}
pub type sk_ASN1_STRING_TABLE_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_STRING_TABLE,
        b: *const *const ASN1_STRING_TABLE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_STRING_TABLE_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut ASN1_STRING_TABLE)>;
pub type sk_ASN1_STRING_TABLE_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const ASN1_STRING_TABLE) -> *mut ASN1_STRING_TABLE,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TEMPLATE_st {
    _unused: [u8; 0],
}
pub type ASN1_TEMPLATE = ASN1_TEMPLATE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TLC_st {
    _unused: [u8; 0],
}
pub type ASN1_TLC = ASN1_TLC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_VALUE_st {
    _unused: [u8; 0],
}
pub type ASN1_VALUE = ASN1_VALUE_st;
pub type d2i_of_void = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *mut *const ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type i2d_of_void = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ITEM_EXP = ASN1_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_INTEGER {
    _unused: [u8; 0],
}
pub type sk_ASN1_INTEGER_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_INTEGER,
        b: *const *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_INTEGER_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut ASN1_INTEGER)>;
pub type sk_ASN1_INTEGER_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const ASN1_INTEGER) -> *mut ASN1_INTEGER>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_GENERALSTRING {
    _unused: [u8; 0],
}
pub type sk_ASN1_GENERALSTRING_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_GENERALSTRING,
        b: *const *const ASN1_GENERALSTRING,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_GENERALSTRING_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut ASN1_GENERALSTRING)>;
pub type sk_ASN1_GENERALSTRING_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const ASN1_GENERALSTRING) -> *mut ASN1_GENERALSTRING,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_UTF8STRING {
    _unused: [u8; 0],
}
pub type sk_ASN1_UTF8STRING_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_UTF8STRING,
        b: *const *const ASN1_UTF8STRING,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_UTF8STRING_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut ASN1_UTF8STRING)>;
pub type sk_ASN1_UTF8STRING_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const ASN1_UTF8STRING) -> *mut ASN1_UTF8STRING>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_type_st {
    pub type_: ::std::os::raw::c_int,
    pub value: asn1_type_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union asn1_type_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub boolean: ASN1_BOOLEAN,
    pub asn1_string: *mut ASN1_STRING,
    pub object: *mut ASN1_OBJECT,
    pub integer: *mut ASN1_INTEGER,
    pub enumerated: *mut ASN1_ENUMERATED,
    pub bit_string: *mut ASN1_BIT_STRING,
    pub octet_string: *mut ASN1_OCTET_STRING,
    pub printablestring: *mut ASN1_PRINTABLESTRING,
    pub t61string: *mut ASN1_T61STRING,
    pub ia5string: *mut ASN1_IA5STRING,
    pub generalstring: *mut ASN1_GENERALSTRING,
    pub bmpstring: *mut ASN1_BMPSTRING,
    pub universalstring: *mut ASN1_UNIVERSALSTRING,
    pub utctime: *mut ASN1_UTCTIME,
    pub generalizedtime: *mut ASN1_GENERALIZEDTIME,
    pub visiblestring: *mut ASN1_VISIBLESTRING,
    pub utf8string: *mut ASN1_UTF8STRING,
    pub set: *mut ASN1_STRING,
    pub sequence: *mut ASN1_STRING,
    pub asn1_value: *mut ASN1_VALUE,
}
#[test]
fn bindgen_test_layout_asn1_type_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).boolean as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).asn1_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).integer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).enumerated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(enumerated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).bit_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bit_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).octet_string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(octet_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).printablestring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(printablestring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).t61string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(t61string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).ia5string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ia5string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).generalstring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).bmpstring as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bmpstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).universalstring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(universalstring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).utctime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utctime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).generalizedtime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalizedtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).visiblestring as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(visiblestring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).utf8string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utf8string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<asn1_type_st__bindgen_ty_1>())).asn1_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_value)
        )
    );
}
#[test]
fn bindgen_test_layout_asn1_type_st() {
    assert_eq!(
        ::std::mem::size_of::<asn1_type_st>(),
        16usize,
        concat!("Size of: ", stringify!(asn1_type_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_type_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<asn1_type_st>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st),
            "::",
            stringify!(value)
        )
    );
}
pub type ASN1_TYPE = asn1_type_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_TYPE {
    _unused: [u8; 0],
}
pub type sk_ASN1_TYPE_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_TYPE,
        b: *const *const ASN1_TYPE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_TYPE_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut ASN1_TYPE)>;
pub type sk_ASN1_TYPE_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const ASN1_TYPE) -> *mut ASN1_TYPE>;
pub type ASN1_SEQUENCE_ANY = stack_st_ASN1_TYPE;
extern "C" {
    pub fn d2i_ASN1_SEQUENCE_ANY(
        a: *mut *mut ASN1_SEQUENCE_ANY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SEQUENCE_ANY(
        a: *const ASN1_SEQUENCE_ANY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_SEQUENCE_ANY_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_ASN1_SET_ANY(
        a: *mut *mut ASN1_SEQUENCE_ANY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SET_ANY(
        a: *const ASN1_SEQUENCE_ANY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_SET_ANY_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BIT_STRING_BITNAME_st {
    pub bitnum: ::std::os::raw::c_int,
    pub lname: *const ::std::os::raw::c_char,
    pub sname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_BIT_STRING_BITNAME_st() {
    assert_eq!(
        ::std::mem::size_of::<BIT_STRING_BITNAME_st>(),
        24usize,
        concat!("Size of: ", stringify!(BIT_STRING_BITNAME_st))
    );
    assert_eq!(
        ::std::mem::align_of::<BIT_STRING_BITNAME_st>(),
        8usize,
        concat!("Alignment of ", stringify!(BIT_STRING_BITNAME_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BIT_STRING_BITNAME_st>())).bitnum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(bitnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BIT_STRING_BITNAME_st>())).lname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(lname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BIT_STRING_BITNAME_st>())).sname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BIT_STRING_BITNAME_st),
            "::",
            stringify!(sname)
        )
    );
}
pub type BIT_STRING_BITNAME = BIT_STRING_BITNAME_st;
extern "C" {
    pub fn ASN1_TYPE_new() -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_free(a: *mut ASN1_TYPE);
}
extern "C" {
    pub fn d2i_ASN1_TYPE(
        a: *mut *mut ASN1_TYPE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn i2d_ASN1_TYPE(
        a: *mut ASN1_TYPE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_ANY_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TYPE_get(a: *const ASN1_TYPE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set(
        a: *mut ASN1_TYPE,
        type_: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ASN1_TYPE_set1(
        a: *mut ASN1_TYPE,
        type_: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_cmp(a: *const ASN1_TYPE, b: *const ASN1_TYPE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_pack_sequence(
        it: *const ASN1_ITEM,
        s: *mut ::std::os::raw::c_void,
        t: *mut *mut ASN1_TYPE,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_unpack_sequence(
        it: *const ASN1_ITEM,
        t: *const ASN1_TYPE,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_OBJECT_new() -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_OBJECT_free(a: *mut ASN1_OBJECT);
}
extern "C" {
    pub fn i2d_ASN1_OBJECT(
        a: *const ASN1_OBJECT,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ASN1_OBJECT(
        a: *mut *mut ASN1_OBJECT,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub static ASN1_OBJECT_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_OBJECT {
    _unused: [u8; 0],
}
pub type sk_ASN1_OBJECT_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_OBJECT,
        b: *const *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_OBJECT_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut ASN1_OBJECT)>;
pub type sk_ASN1_OBJECT_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const ASN1_OBJECT) -> *mut ASN1_OBJECT>;
extern "C" {
    pub fn ASN1_STRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_clear_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_copy(
        dst: *mut ASN1_STRING,
        str_: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_dup(a: *const ASN1_STRING) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_type_new(type_: ::std::os::raw::c_int) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_cmp(a: *const ASN1_STRING, b: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set(
        str_: *mut ASN1_STRING,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set0(
        str_: *mut ASN1_STRING,
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASN1_STRING_length(x: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_length_set(x: *mut ASN1_STRING, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ASN1_STRING_type(x: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_data(x: *mut ASN1_STRING) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASN1_STRING_get0_data(x: *const ASN1_STRING) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASN1_BIT_STRING_new() -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn ASN1_BIT_STRING_free(a: *mut ASN1_BIT_STRING);
}
extern "C" {
    pub fn d2i_ASN1_BIT_STRING(
        a: *mut *mut ASN1_BIT_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn i2d_ASN1_BIT_STRING(
        a: *mut ASN1_BIT_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_BIT_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set(
        a: *mut ASN1_BIT_STRING,
        d: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_bit(
        a: *mut ASN1_BIT_STRING,
        n: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_get_bit(
        a: *const ASN1_BIT_STRING,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_check(
        a: *const ASN1_BIT_STRING,
        flags: *const ::std::os::raw::c_uchar,
        flags_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_name_print(
        out: *mut BIO,
        bs: *mut ASN1_BIT_STRING,
        tbl: *mut BIT_STRING_BITNAME,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_num_asc(
        name: *const ::std::os::raw::c_char,
        tbl: *mut BIT_STRING_BITNAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_asc(
        bs: *mut ASN1_BIT_STRING,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
        tbl: *mut BIT_STRING_BITNAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_new() -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_free(a: *mut ASN1_INTEGER);
}
extern "C" {
    pub fn d2i_ASN1_INTEGER(
        a: *mut *mut ASN1_INTEGER,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn i2d_ASN1_INTEGER(
        a: *mut ASN1_INTEGER,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_INTEGER_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_ASN1_UINTEGER(
        a: *mut *mut ASN1_INTEGER,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_dup(x: *const ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_cmp(
        x: *const ASN1_INTEGER,
        y: *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_new() -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_free(a: *mut ASN1_ENUMERATED);
}
extern "C" {
    pub fn d2i_ASN1_ENUMERATED(
        a: *mut *mut ASN1_ENUMERATED,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn i2d_ASN1_ENUMERATED(
        a: *mut ASN1_ENUMERATED,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_ENUMERATED_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_check(a: *const ASN1_UTCTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_set(s: *mut ASN1_UTCTIME, t: time_t) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_adj(
        s: *mut ASN1_UTCTIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_set_string(
        s: *mut ASN1_UTCTIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_cmp_time_t(s: *const ASN1_UTCTIME, t: time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_check(a: *const ASN1_GENERALIZEDTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_adj(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set_string(
        s: *mut ASN1_GENERALIZEDTIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_diff(
        pday: *mut ::std::os::raw::c_int,
        psec: *mut ::std::os::raw::c_int,
        from: *const ASN1_TIME,
        to: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_new() -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_free(a: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn d2i_ASN1_OCTET_STRING(
        a: *mut *mut ASN1_OCTET_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn i2d_ASN1_OCTET_STRING(
        a: *mut ASN1_OCTET_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_OCTET_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_dup(a: *const ASN1_OCTET_STRING) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_cmp(
        a: *const ASN1_OCTET_STRING,
        b: *const ASN1_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_set(
        str_: *mut ASN1_OCTET_STRING,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_new() -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_free(a: *mut ASN1_VISIBLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_VISIBLESTRING(
        a: *mut *mut ASN1_VISIBLESTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_VISIBLESTRING(
        a: *mut ASN1_VISIBLESTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_VISIBLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_new() -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_free(a: *mut ASN1_UNIVERSALSTRING);
}
extern "C" {
    pub fn d2i_ASN1_UNIVERSALSTRING(
        a: *mut *mut ASN1_UNIVERSALSTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn i2d_ASN1_UNIVERSALSTRING(
        a: *mut ASN1_UNIVERSALSTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_UNIVERSALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTF8STRING_new() -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn ASN1_UTF8STRING_free(a: *mut ASN1_UTF8STRING);
}
extern "C" {
    pub fn d2i_ASN1_UTF8STRING(
        a: *mut *mut ASN1_UTF8STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn i2d_ASN1_UTF8STRING(
        a: *mut ASN1_UTF8STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_UTF8STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_NULL_new() -> *mut ASN1_NULL;
}
extern "C" {
    pub fn ASN1_NULL_free(a: *mut ASN1_NULL);
}
extern "C" {
    pub fn d2i_ASN1_NULL(
        a: *mut *mut ASN1_NULL,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_NULL;
}
extern "C" {
    pub fn i2d_ASN1_NULL(
        a: *mut ASN1_NULL,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_NULL_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BMPSTRING_new() -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn ASN1_BMPSTRING_free(a: *mut ASN1_BMPSTRING);
}
extern "C" {
    pub fn d2i_ASN1_BMPSTRING(
        a: *mut *mut ASN1_BMPSTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn i2d_ASN1_BMPSTRING(
        a: *mut ASN1_BMPSTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_BMPSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn UTF8_getc(
        str_: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        val: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn UTF8_putc(
        str_: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        value: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_PRINTABLE_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_PRINTABLE_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLE(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLE(
        a: *mut ASN1_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_PRINTABLE_it: ASN1_ITEM;
}
extern "C" {
    pub fn DIRECTORYSTRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DIRECTORYSTRING_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DIRECTORYSTRING(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DIRECTORYSTRING(
        a: *mut ASN1_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static DIRECTORYSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn DISPLAYTEXT_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DISPLAYTEXT_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DISPLAYTEXT(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DISPLAYTEXT(
        a: *mut ASN1_STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static DISPLAYTEXT_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_new() -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_free(a: *mut ASN1_PRINTABLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLESTRING(
        a: *mut *mut ASN1_PRINTABLESTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLESTRING(
        a: *mut ASN1_PRINTABLESTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_PRINTABLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_T61STRING_new() -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn ASN1_T61STRING_free(a: *mut ASN1_T61STRING);
}
extern "C" {
    pub fn d2i_ASN1_T61STRING(
        a: *mut *mut ASN1_T61STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn i2d_ASN1_T61STRING(
        a: *mut ASN1_T61STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_T61STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_IA5STRING_new() -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn ASN1_IA5STRING_free(a: *mut ASN1_IA5STRING);
}
extern "C" {
    pub fn d2i_ASN1_IA5STRING(
        a: *mut *mut ASN1_IA5STRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn i2d_ASN1_IA5STRING(
        a: *mut ASN1_IA5STRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_IA5STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_new() -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_free(a: *mut ASN1_GENERALSTRING);
}
extern "C" {
    pub fn d2i_ASN1_GENERALSTRING(
        a: *mut *mut ASN1_GENERALSTRING,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn i2d_ASN1_GENERALSTRING(
        a: *mut ASN1_GENERALSTRING,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_GENERALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_new() -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_free(a: *mut ASN1_UTCTIME);
}
extern "C" {
    pub fn d2i_ASN1_UTCTIME(
        a: *mut *mut ASN1_UTCTIME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn i2d_ASN1_UTCTIME(
        a: *mut ASN1_UTCTIME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_UTCTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_new() -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_free(a: *mut ASN1_GENERALIZEDTIME);
}
extern "C" {
    pub fn d2i_ASN1_GENERALIZEDTIME(
        a: *mut *mut ASN1_GENERALIZEDTIME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn i2d_ASN1_GENERALIZEDTIME(
        a: *mut ASN1_GENERALIZEDTIME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_GENERALIZEDTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_new() -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_free(a: *mut ASN1_TIME);
}
extern "C" {
    pub fn d2i_ASN1_TIME(
        a: *mut *mut ASN1_TIME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn i2d_ASN1_TIME(
        a: *mut ASN1_TIME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_TIME_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_OCTET_STRING_NDEF_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_set(s: *mut ASN1_TIME, t: time_t) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_adj(
        s: *mut ASN1_TIME,
        t: time_t,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_check(t: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_generalizedtime(
        t: *const ASN1_TIME,
        out: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_TIME_set_string(
        s: *mut ASN1_TIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_set_string_X509(
        s: *mut ASN1_TIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_tm(s: *const ASN1_TIME, tm: *mut tm) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_normalize(s: *mut ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_cmp_time_t(s: *const ASN1_TIME, t: time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_compare(a: *const ASN1_TIME, b: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_INTEGER(bp: *mut BIO, a: *const ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a2i_ASN1_INTEGER(
        bp: *mut BIO,
        bs: *mut ASN1_INTEGER,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_ENUMERATED(bp: *mut BIO, a: *const ASN1_ENUMERATED) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a2i_ASN1_ENUMERATED(
        bp: *mut BIO,
        bs: *mut ASN1_ENUMERATED,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_OBJECT(bp: *mut BIO, a: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a2i_ASN1_STRING(
        bp: *mut BIO,
        bs: *mut ASN1_STRING,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_STRING(
        bp: *mut BIO,
        a: *const ASN1_STRING,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2t_ASN1_OBJECT(
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        a: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a2d_ASN1_OBJECT(
        out: *mut ::std::os::raw::c_uchar,
        olen: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OBJECT_create(
        nid: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        sn: *const ::std::os::raw::c_char,
        ln: *const ::std::os::raw::c_char,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_INTEGER_get_int64(pr: *mut i64, a: *const ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set_int64(a: *mut ASN1_INTEGER, r: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get_uint64(pr: *mut u64, a: *const ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set_uint64(a: *mut ASN1_INTEGER, r: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set(
        a: *mut ASN1_INTEGER,
        v: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get(a: *const ASN1_INTEGER) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_INTEGER(bn: *const BIGNUM, ai: *mut ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_to_BN(ai: *const ASN1_INTEGER, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get_int64(
        pr: *mut i64,
        a: *const ASN1_ENUMERATED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set_int64(a: *mut ASN1_ENUMERATED, r: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set(
        a: *mut ASN1_ENUMERATED,
        v: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get(a: *const ASN1_ENUMERATED) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_ENUMERATED(
        bn: *const BIGNUM,
        ai: *mut ASN1_ENUMERATED,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_to_BN(ai: *const ASN1_ENUMERATED, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_PRINTABLE_type(
        s: *const ::std::os::raw::c_uchar,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_tag2bit(tag: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_get_object(
        pp: *mut *const ::std::os::raw::c_uchar,
        plength: *mut ::std::os::raw::c_long,
        ptag: *mut ::std::os::raw::c_int,
        pclass: *mut ::std::os::raw::c_int,
        omax: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_check_infinite_end(
        p: *mut *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_const_check_infinite_end(
        p: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_put_object(
        pp: *mut *mut ::std::os::raw::c_uchar,
        constructed: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
        xclass: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASN1_put_eoc(pp: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_object_size(
        constructed: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_dup(
        i2d: i2d_of_void,
        d2i: d2i_of_void,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_dup(
        it: *const ASN1_ITEM,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_d2i_fp(
        xnew: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
        d2i: d2i_of_void,
        in_: *mut FILE,
        x: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_fp(
        it: *const ASN1_ITEM,
        in_: *mut FILE,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_i2d_fp(
        i2d: i2d_of_void,
        out: *mut FILE,
        x: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_fp(
        it: *const ASN1_ITEM,
        out: *mut FILE,
        x: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex_fp(
        fp: *mut FILE,
        str_: *const ASN1_STRING,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_to_UTF8(
        out: *mut *mut ::std::os::raw::c_uchar,
        in_: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_d2i_bio(
        xnew: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
        d2i: d2i_of_void,
        in_: *mut BIO,
        x: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_bio(
        it: *const ASN1_ITEM,
        in_: *mut BIO,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_i2d_bio(
        i2d: i2d_of_void,
        out: *mut BIO,
        x: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_bio(
        it: *const ASN1_ITEM,
        out: *mut BIO,
        x: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_print(fp: *mut BIO, a: *const ASN1_UTCTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_print(
        fp: *mut BIO,
        a: *const ASN1_GENERALIZEDTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_print(fp: *mut BIO, a: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print(bp: *mut BIO, v: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex(
        out: *mut BIO,
        str_: *const ASN1_STRING,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_buf_print(
        bp: *mut BIO,
        buf: *const ::std::os::raw::c_uchar,
        buflen: size_t,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_bn_print(
        bp: *mut BIO,
        number: *const ::std::os::raw::c_char,
        num: *const BIGNUM,
        buf: *mut ::std::os::raw::c_uchar,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_parse(
        bp: *mut BIO,
        pp: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_parse_dump(
        bp: *mut BIO,
        pp: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        indent: ::std::os::raw::c_int,
        dump: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_tag2str(tag: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_to_string(s: *mut ASN1_UNIVERSALSTRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set_octetstring(
        a: *mut ASN1_TYPE,
        data: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_get_octetstring(
        a: *const ASN1_TYPE,
        data: *mut ::std::os::raw::c_uchar,
        max_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set_int_octetstring(
        a: *mut ASN1_TYPE,
        num: ::std::os::raw::c_long,
        data: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_get_int_octetstring(
        a: *const ASN1_TYPE,
        num: *mut ::std::os::raw::c_long,
        data: *mut ::std::os::raw::c_uchar,
        max_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_unpack(
        oct: *const ASN1_STRING,
        it: *const ASN1_ITEM,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_pack(
        obj: *mut ::std::os::raw::c_void,
        it: *const ASN1_ITEM,
        oct: *mut *mut ASN1_OCTET_STRING,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask(mask: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask_asc(
        p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_get_default_mask() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_mbstring_copy(
        out: *mut *mut ASN1_STRING,
        in_: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_mbstring_ncopy(
        out: *mut *mut ASN1_STRING,
        in_: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_ulong,
        minsize: ::std::os::raw::c_long,
        maxsize: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set_by_NID(
        out: *mut *mut ASN1_STRING,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_int,
        inform: ::std::os::raw::c_int,
        nid: ::std::os::raw::c_int,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_get(nid: ::std::os::raw::c_int) -> *mut ASN1_STRING_TABLE;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_add(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_cleanup();
}
extern "C" {
    pub fn ASN1_item_new(it: *const ASN1_ITEM) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_free(val: *mut ASN1_VALUE, it: *const ASN1_ITEM);
}
extern "C" {
    pub fn ASN1_item_d2i(
        val: *mut *mut ASN1_VALUE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_i2d(
        val: *mut ASN1_VALUE,
        out: *mut *mut ::std::os::raw::c_uchar,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_ndef_i2d(
        val: *mut ASN1_VALUE,
        out: *mut *mut ::std::os::raw::c_uchar,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_add_oid_module();
}
extern "C" {
    pub fn ASN1_add_stable_module();
}
extern "C" {
    pub fn ASN1_generate_nconf(
        str_: *const ::std::os::raw::c_char,
        nconf: *mut CONF,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_generate_v3(
        str_: *const ::std::os::raw::c_char,
        cnf: *mut X509V3_CTX,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_str2mask(
        str_: *const ::std::os::raw::c_char,
        pmask: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_print(
        out: *mut BIO,
        ifld: *mut ASN1_VALUE,
        indent: ::std::os::raw::c_int,
        it: *const ASN1_ITEM,
        pctx: *const ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_PCTX_new() -> *mut ASN1_PCTX;
}
extern "C" {
    pub fn ASN1_PCTX_free(p: *mut ASN1_PCTX);
}
extern "C" {
    pub fn ASN1_PCTX_get_flags(p: *const ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_nm_flags(p: *const ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_nm_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_cert_flags(p: *const ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_cert_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_oid_flags(p: *const ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_oid_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_str_flags(p: *const ASN1_PCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_str_flags(p: *mut ASN1_PCTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_SCTX_new(
        scan_cb: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut ASN1_SCTX) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ASN1_SCTX;
}
extern "C" {
    pub fn ASN1_SCTX_free(p: *mut ASN1_SCTX);
}
extern "C" {
    pub fn ASN1_SCTX_get_item(p: *mut ASN1_SCTX) -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_SCTX_get_template(p: *mut ASN1_SCTX) -> *const ASN1_TEMPLATE;
}
extern "C" {
    pub fn ASN1_SCTX_get_flags(p: *mut ASN1_SCTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_SCTX_set_app_data(p: *mut ASN1_SCTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ASN1_SCTX_get_app_data(p: *mut ASN1_SCTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BIO_f_asn1() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_NDEF(out: *mut BIO, val: *mut ASN1_VALUE, it: *const ASN1_ITEM) -> *mut BIO;
}
extern "C" {
    pub fn i2d_ASN1_bio_stream(
        out: *mut BIO,
        val: *mut ASN1_VALUE,
        in_: *mut BIO,
        flags: ::std::os::raw::c_int,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_ASN1_stream(
        out: *mut BIO,
        val: *mut ASN1_VALUE,
        in_: *mut BIO,
        flags: ::std::os::raw::c_int,
        hdr: *const ::std::os::raw::c_char,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_write_ASN1(
        bio: *mut BIO,
        val: *mut ASN1_VALUE,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
        ctype_nid: ::std::os::raw::c_int,
        econt_nid: ::std::os::raw::c_int,
        mdalgs: *mut stack_st_X509_ALGOR,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_read_ASN1(
        bio: *mut BIO,
        bcont: *mut *mut BIO,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn SMIME_crlf_copy(
        in_: *mut BIO,
        out: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_text(in_: *mut BIO, out: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ITEM_lookup(name: *const ::std::os::raw::c_char) -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_ITEM_get(i: size_t) -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ERR_load_OBJ_strings() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obj_name_st {
    pub type_: ::std::os::raw::c_int,
    pub alias: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obj_name_st() {
    assert_eq!(
        ::std::mem::size_of::<obj_name_st>(),
        24usize,
        concat!("Size of: ", stringify!(obj_name_st))
    );
    assert_eq!(
        ::std::mem::align_of::<obj_name_st>(),
        8usize,
        concat!("Alignment of ", stringify!(obj_name_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obj_name_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obj_name_st>())).alias as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obj_name_st>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obj_name_st>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(data)
        )
    );
}
pub type OBJ_NAME = obj_name_st;
extern "C" {
    pub fn OBJ_NAME_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_NAME_new_index(
        hash_func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong,
        >,
        cmp_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
        free_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_NAME_get(
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OBJ_NAME_add(
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_NAME_remove(
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_NAME_cleanup(type_: ::std::os::raw::c_int);
}
extern "C" {
    pub fn OBJ_NAME_do_all(
        type_: ::std::os::raw::c_int,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn OBJ_NAME_do_all_sorted(
        type_: ::std::os::raw::c_int,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn OBJ_dup(o: *const ASN1_OBJECT) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2obj(n: ::std::os::raw::c_int) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2ln(n: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OBJ_nid2sn(n: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OBJ_obj2nid(o: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_txt2obj(
        s: *const ::std::os::raw::c_char,
        no_name: ::std::os::raw::c_int,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_obj2txt(
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        a: *const ASN1_OBJECT,
        no_name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_txt2nid(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_ln2nid(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_sn2nid(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_cmp(a: *const ASN1_OBJECT, b: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_bsearch_(
        key: *const ::std::os::raw::c_void,
        base: *const ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn OBJ_bsearch_ex_(
        key: *const ::std::os::raw::c_void,
        base: *const ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        flags: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn OBJ_new_nid(num: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_add_object(obj: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_create(
        oid: *const ::std::os::raw::c_char,
        sn: *const ::std::os::raw::c_char,
        ln: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_create_objects(in_: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_length(obj: *const ASN1_OBJECT) -> size_t;
}
extern "C" {
    pub fn OBJ_get0_data(obj: *const ASN1_OBJECT) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn OBJ_find_sigid_algs(
        signid: ::std::os::raw::c_int,
        pdig_nid: *mut ::std::os::raw::c_int,
        ppkey_nid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_find_sigid_by_algs(
        psignid: *mut ::std::os::raw::c_int,
        dig_nid: ::std::os::raw::c_int,
        pkey_nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_add_sigid(
        signid: ::std::os::raw::c_int,
        dig_id: ::std::os::raw::c_int,
        pkey_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_sigid_free();
}
extern "C" {
    pub fn EVP_MD_meth_new(
        md_type: ::std::os::raw::c_int,
        pkey_type: ::std::os::raw::c_int,
    ) -> *mut EVP_MD;
}
extern "C" {
    pub fn EVP_MD_meth_dup(md: *const EVP_MD) -> *mut EVP_MD;
}
extern "C" {
    pub fn EVP_MD_meth_free(md: *mut EVP_MD);
}
extern "C" {
    pub fn EVP_MD_meth_set_input_blocksize(
        md: *mut EVP_MD,
        blocksize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_result_size(
        md: *mut EVP_MD,
        resultsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_app_datasize(
        md: *mut EVP_MD,
        datasize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_flags(
        md: *mut EVP_MD,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_init(
        md: *mut EVP_MD,
        init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_update(
        md: *mut EVP_MD,
        update: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                data: *const ::std::os::raw::c_void,
                count: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_final(
        md: *mut EVP_MD,
        final_: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                md: *mut ::std::os::raw::c_uchar,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_copy(
        md: *mut EVP_MD,
        copy: ::std::option::Option<
            unsafe extern "C" fn(
                to: *mut EVP_MD_CTX,
                from: *const EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_cleanup(
        md: *mut EVP_MD,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_ctrl(
        md: *mut EVP_MD,
        ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                cmd: ::std::os::raw::c_int,
                p1: ::std::os::raw::c_int,
                p2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_input_blocksize(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_result_size(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_app_datasize(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_flags(md: *const EVP_MD) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn EVP_MD_meth_get_init(
        md: *const EVP_MD,
    ) -> ::std::option::Option<unsafe extern "C" fn(md: *mut EVP_MD_CTX) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn EVP_MD_meth_get_update(
        md: *const EVP_MD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            md: *mut EVP_MD_CTX,
            arg1: *const ::std::os::raw::c_void,
            arg2: size_t,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_final(
        md: *const EVP_MD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            md: *mut EVP_MD_CTX,
            arg1: *mut ::std::os::raw::c_uchar,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_copy(
        md: *const EVP_MD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(md: *mut EVP_MD_CTX, arg1: *const EVP_MD_CTX) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_cleanup(
        md: *const EVP_MD,
    ) -> ::std::option::Option<unsafe extern "C" fn(md: *mut EVP_MD_CTX) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn EVP_MD_meth_get_ctrl(
        md: *const EVP_MD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            md: *mut EVP_MD_CTX,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_new(
        cipher_type: ::std::os::raw::c_int,
        block_size: ::std::os::raw::c_int,
        key_len: ::std::os::raw::c_int,
    ) -> *mut EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_meth_dup(cipher: *const EVP_CIPHER) -> *mut EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_meth_free(cipher: *mut EVP_CIPHER);
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_iv_length(
        cipher: *mut EVP_CIPHER,
        iv_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_flags(
        cipher: *mut EVP_CIPHER,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_impl_ctx_size(
        cipher: *mut EVP_CIPHER,
        ctx_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_init(
        cipher: *mut EVP_CIPHER,
        init: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_CIPHER_CTX,
                key: *const ::std::os::raw::c_uchar,
                iv: *const ::std::os::raw::c_uchar,
                enc: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_do_cipher(
        cipher: *mut EVP_CIPHER,
        do_cipher: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_CIPHER_CTX,
                out: *mut ::std::os::raw::c_uchar,
                in_: *const ::std::os::raw::c_uchar,
                inl: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_cleanup(
        cipher: *mut EVP_CIPHER,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_set_asn1_params(
        cipher: *mut EVP_CIPHER,
        set_asn1_parameters: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut EVP_CIPHER_CTX,
                arg2: *mut ASN1_TYPE,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_get_asn1_params(
        cipher: *mut EVP_CIPHER,
        get_asn1_parameters: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut EVP_CIPHER_CTX,
                arg2: *mut ASN1_TYPE,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_ctrl(
        cipher: *mut EVP_CIPHER,
        ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut EVP_CIPHER_CTX,
                type_: ::std::os::raw::c_int,
                arg: ::std::os::raw::c_int,
                ptr: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_init(
        cipher: *const EVP_CIPHER,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *const ::std::os::raw::c_uchar,
            arg2: *const ::std::os::raw::c_uchar,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_do_cipher(
        cipher: *const EVP_CIPHER,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *mut ::std::os::raw::c_uchar,
            arg2: *const ::std::os::raw::c_uchar,
            arg3: size_t,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_cleanup(
        cipher: *const EVP_CIPHER,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(cipher: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_set_asn1_params(
        cipher: *const EVP_CIPHER,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *mut ASN1_TYPE,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_get_asn1_params(
        cipher: *const EVP_CIPHER,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *mut ASN1_TYPE,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_ctrl(
        cipher: *const EVP_CIPHER,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM {
    pub out: *mut ::std::os::raw::c_uchar,
    pub inp: *const ::std::os::raw::c_uchar,
    pub len: size_t,
    pub interleave: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM() {
    assert_eq!(
        ::std::mem::size_of::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>(),
        32usize,
        concat!("Size of: ", stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).out as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).inp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(inp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM>())).interleave as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM),
            "::",
            stringify!(interleave)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_info_st {
    pub cipher: *const EVP_CIPHER,
    pub iv: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_evp_cipher_info_st() {
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_info_st>(),
        24usize,
        concat!("Size of: ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_info_st>())).cipher as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_info_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<evp_cipher_info_st>())).iv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_info_st),
            "::",
            stringify!(iv)
        )
    );
}
pub type EVP_CIPHER_INFO = evp_cipher_info_st;
pub type EVP_PBE_KEYGEN = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn EVP_MD_type(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_pkey_type(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_size(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_block_size(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_flags(md: *const EVP_MD) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn EVP_MD_CTX_md(ctx: *const EVP_MD_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_update_fn(
        ctx: *mut EVP_MD_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_MD_CTX,
            arg1: *const ::std::os::raw::c_void,
            arg2: size_t,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_CTX_set_update_fn(
        ctx: *mut EVP_MD_CTX,
        update: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                data: *const ::std::os::raw::c_void,
                count: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_MD_CTX_pkey_ctx(ctx: *const EVP_MD_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_set_pkey_ctx(ctx: *mut EVP_MD_CTX, pctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_md_data(ctx: *const EVP_MD_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_nid(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_block_size(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_impl_ctx_size(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_key_length(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_iv_length(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_flags(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cipher(ctx: *const EVP_CIPHER_CTX) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_encrypting(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_nid(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_block_size(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_key_length(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv_length(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv(ctx: *const EVP_CIPHER_CTX) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_original_iv(ctx: *const EVP_CIPHER_CTX)
        -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv_noconst(ctx: *mut EVP_CIPHER_CTX) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_buf_noconst(ctx: *mut EVP_CIPHER_CTX) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_num(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_num(ctx: *mut EVP_CIPHER_CTX, num: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_copy(
        out: *mut EVP_CIPHER_CTX,
        in_: *const EVP_CIPHER_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_app_data(ctx: *const EVP_CIPHER_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_app_data(ctx: *mut EVP_CIPHER_CTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_cipher_data(
        ctx: *const EVP_CIPHER_CTX,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_cipher_data(
        ctx: *mut EVP_CIPHER_CTX,
        cipher_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_Cipher(
        c: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_ctrl(
        ctx: *mut EVP_MD_CTX,
        cmd: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_new() -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_reset(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_free(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_copy_ex(
        out: *mut EVP_MD_CTX,
        in_: *const EVP_MD_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_set_flags(ctx: *mut EVP_MD_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_MD_CTX_clear_flags(ctx: *mut EVP_MD_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_MD_CTX_test_flags(
        ctx: *const EVP_MD_CTX,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestUpdate(
        ctx: *mut EVP_MD_CTX,
        d: *const ::std::os::raw::c_void,
        cnt: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal_ex(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::std::os::raw::c_uchar,
        s: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_Digest(
        data: *const ::std::os::raw::c_void,
        count: size_t,
        md: *mut ::std::os::raw::c_uchar,
        size: *mut ::std::os::raw::c_uint,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_copy(out: *mut EVP_MD_CTX, in_: *const EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::std::os::raw::c_uchar,
        s: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinalXOF(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_read_pw_string(
        buf: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        prompt: *const ::std::os::raw::c_char,
        verify: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_read_pw_string_min(
        buf: *mut ::std::os::raw::c_char,
        minlen: ::std::os::raw::c_int,
        maxlen: ::std::os::raw::c_int,
        prompt: *const ::std::os::raw::c_char,
        verify: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_set_pw_prompt(prompt: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn EVP_get_pw_prompt() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn EVP_BytesToKey(
        type_: *const EVP_CIPHER,
        md: *const EVP_MD,
        salt: *const ::std::os::raw::c_uchar,
        data: *const ::std::os::raw::c_uchar,
        datal: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_uchar,
        iv: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_flags(ctx: *mut EVP_CIPHER_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_clear_flags(ctx: *mut EVP_CIPHER_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_test_flags(
        ctx: *const EVP_CIPHER_CTX,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::std::os::raw::c_uchar,
        iv: *const ::std::os::raw::c_uchar,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignFinal(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::std::os::raw::c_uchar,
        s: *mut ::std::os::raw::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSign(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut size_t,
        tbs: *const ::std::os::raw::c_uchar,
        tbslen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sigbuf: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerify(
        ctx: *mut EVP_MD_CTX,
        sigret: *const ::std::os::raw::c_uchar,
        siglen: size_t,
        tbs: *const ::std::os::raw::c_uchar,
        tbslen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignFinal(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sig: *const ::std::os::raw::c_uchar,
        siglen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_OpenInit(
        ctx: *mut EVP_CIPHER_CTX,
        type_: *const EVP_CIPHER,
        ek: *const ::std::os::raw::c_uchar,
        ekl: ::std::os::raw::c_int,
        iv: *const ::std::os::raw::c_uchar,
        priv_: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_OpenFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SealInit(
        ctx: *mut EVP_CIPHER_CTX,
        type_: *const EVP_CIPHER,
        ek: *mut *mut ::std::os::raw::c_uchar,
        ekl: *mut ::std::os::raw::c_int,
        iv: *mut ::std::os::raw::c_uchar,
        pubk: *mut *mut EVP_PKEY,
        npubk: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SealFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_new() -> *mut EVP_ENCODE_CTX;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_free(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_ENCODE_CTX_copy(
        dctx: *mut EVP_ENCODE_CTX,
        sctx: *mut EVP_ENCODE_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_num(ctx: *mut EVP_ENCODE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_EncodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EVP_EncodeBlock(
        t: *mut ::std::os::raw::c_uchar,
        f: *const ::std::os::raw::c_uchar,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_DecodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
        in_: *const ::std::os::raw::c_uchar,
        inl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeBlock(
        t: *mut ::std::os::raw::c_uchar,
        f: *const ::std::os::raw::c_uchar,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_new() -> *mut EVP_CIPHER_CTX;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_reset(c: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_free(c: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_key_length(
        x: *mut EVP_CIPHER_CTX,
        keylen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_padding(
        c: *mut EVP_CIPHER_CTX,
        pad: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_ctrl(
        ctx: *mut EVP_CIPHER_CTX,
        type_: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_rand_key(
        ctx: *mut EVP_CIPHER_CTX,
        key: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_f_md() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_base64() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_cipher() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_reliable() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_cipher(
        b: *mut BIO,
        c: *const EVP_CIPHER,
        k: *const ::std::os::raw::c_uchar,
        i: *const ::std::os::raw::c_uchar,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_md_null() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md4() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_blake2b512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_blake2s256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_shake128() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_shake256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_mdc2() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_ripemd160() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_whirlpool() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sm3() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_enc_null() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_desx_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4_40() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4_hmac_md5() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_idea_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_idea_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_idea_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_idea_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_40_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_64_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_chacha20() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_chacha20_poly1305() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_add_cipher(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_add_digest(digest: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_get_cipherbyname(name: *const ::std::os::raw::c_char) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_get_digestbyname(name: *const ::std::os::raw::c_char) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_CIPHER_do_all(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_CIPHER,
                from: *const ::std::os::raw::c_char,
                to: *const ::std::os::raw::c_char,
                x: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_CIPHER_do_all_sorted(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_CIPHER,
                from: *const ::std::os::raw::c_char,
                to: *const ::std::os::raw::c_char,
                x: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_MD,
                from: *const ::std::os::raw::c_char,
                to: *const ::std::os::raw::c_char,
                x: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all_sorted(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_MD,
                from: *const ::std::os::raw::c_char,
                to: *const ::std::os::raw::c_char,
                x: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_PKEY_decrypt_old(
        dec_key: *mut ::std::os::raw::c_uchar,
        enc_key: *const ::std::os::raw::c_uchar,
        enc_key_len: ::std::os::raw::c_int,
        private_key: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_old(
        enc_key: *mut ::std::os::raw::c_uchar,
        key: *const ::std::os::raw::c_uchar,
        key_len: ::std::os::raw::c_int,
        pub_key: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_type(type_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_id(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_base_id(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_bits(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_security_bits(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_size(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type_str(
        pkey: *mut EVP_PKEY,
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_alias_type(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_engine(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_engine(pkey: *const EVP_PKEY) -> *mut ENGINE;
}
extern "C" {
    pub fn EVP_PKEY_assign(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0(pkey: *const EVP_PKEY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_PKEY_get0_hmac(
        pkey: *const EVP_PKEY,
        len: *mut size_t,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_get0_poly1305(
        pkey: *const EVP_PKEY,
        len: *mut size_t,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_get0_siphash(
        pkey: *const EVP_PKEY,
        len: *mut size_t,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_set1_RSA(pkey: *mut EVP_PKEY, key: *mut rsa_st) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_RSA(pkey: *mut EVP_PKEY) -> *mut rsa_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_RSA(pkey: *mut EVP_PKEY) -> *mut rsa_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_DSA(pkey: *mut EVP_PKEY, key: *mut dsa_st) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DSA(pkey: *mut EVP_PKEY) -> *mut dsa_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_DSA(pkey: *mut EVP_PKEY) -> *mut dsa_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_DH(pkey: *mut EVP_PKEY, key: *mut dh_st) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DH(pkey: *mut EVP_PKEY) -> *mut dh_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_DH(pkey: *mut EVP_PKEY) -> *mut dh_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_EC_KEY(pkey: *mut EVP_PKEY, key: *mut ec_key_st) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_EC_KEY(pkey: *mut EVP_PKEY) -> *mut ec_key_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_EC_KEY(pkey: *mut EVP_PKEY) -> *mut ec_key_st;
}
extern "C" {
    pub fn EVP_PKEY_new() -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_up_ref(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_free(pkey: *mut EVP_PKEY);
}
extern "C" {
    pub fn d2i_PublicKey(
        type_: ::std::os::raw::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PublicKey(
        a: *mut EVP_PKEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey(
        type_: ::std::os::raw::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_AutoPrivateKey(
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PrivateKey(
        a: *mut EVP_PKEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_copy_parameters(
        to: *mut EVP_PKEY,
        from: *const EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_missing_parameters(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_save_parameters(
        pkey: *mut EVP_PKEY,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp_parameters(a: *const EVP_PKEY, b: *const EVP_PKEY)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_public(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_private(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_params(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_default_digest_nid(
        pkey: *mut EVP_PKEY,
        pnid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_tls_encodedpoint(
        pkey: *mut EVP_PKEY,
        pt: *const ::std::os::raw::c_uchar,
        ptlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_tls_encodedpoint(
        pkey: *mut EVP_PKEY,
        ppt: *mut *mut ::std::os::raw::c_uchar,
    ) -> size_t;
}
extern "C" {
    pub fn EVP_CIPHER_type(ctx: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_param_to_asn1(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_asn1_to_param(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_set_asn1_iv(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_asn1_iv(
        c: *mut EVP_CIPHER_CTX,
        type_: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC_SHA1(
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        iter: ::std::os::raw::c_int,
        keylen: ::std::os::raw::c_int,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC(
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        iter: ::std::os::raw::c_int,
        digest: *const EVP_MD,
        keylen: ::std::os::raw::c_int,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_v2_PBE_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_scrypt(
        pass: *const ::std::os::raw::c_char,
        passlen: size_t,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: size_t,
        N: u64,
        r: u64,
        p: u64,
        maxmem: u64,
        key: *mut ::std::os::raw::c_uchar,
        keylen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_v2_scrypt_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        c: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_add();
}
extern "C" {
    pub fn EVP_PBE_CipherInit(
        pbe_obj: *mut ASN1_OBJECT,
        pass: *const ::std::os::raw::c_char,
        passlen: ::std::os::raw::c_int,
        param: *mut ASN1_TYPE,
        ctx: *mut EVP_CIPHER_CTX,
        en_de: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_alg_add_type(
        pbe_type: ::std::os::raw::c_int,
        pbe_nid: ::std::os::raw::c_int,
        cipher_nid: ::std::os::raw::c_int,
        md_nid: ::std::os::raw::c_int,
        keygen: EVP_PBE_KEYGEN,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_alg_add(
        nid: ::std::os::raw::c_int,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        keygen: EVP_PBE_KEYGEN,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_find(
        type_: ::std::os::raw::c_int,
        pbe_nid: ::std::os::raw::c_int,
        pcnid: *mut ::std::os::raw::c_int,
        pmnid: *mut ::std::os::raw::c_int,
        pkeygen: *mut EVP_PBE_KEYGEN,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_cleanup();
}
extern "C" {
    pub fn EVP_PBE_get(
        ptype: *mut ::std::os::raw::c_int,
        ppbe_nid: *mut ::std::os::raw::c_int,
        num: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get0(idx: ::std::os::raw::c_int) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_find(
        pe: *mut *mut ENGINE,
        type_: ::std::os::raw::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_find_str(
        pe: *mut *mut ENGINE,
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_add0(ameth: *const EVP_PKEY_ASN1_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_add_alias(
        to: ::std::os::raw::c_int,
        from: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get0_info(
        ppkey_id: *mut ::std::os::raw::c_int,
        pkey_base_id: *mut ::std::os::raw::c_int,
        ppkey_flags: *mut ::std::os::raw::c_int,
        pinfo: *mut *const ::std::os::raw::c_char,
        ppem_str: *mut *const ::std::os::raw::c_char,
        ameth: *const EVP_PKEY_ASN1_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_asn1(pkey: *const EVP_PKEY) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_new(
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        pem_str: *const ::std::os::raw::c_char,
        info: *const ::std::os::raw::c_char,
    ) -> *mut EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_copy(dst: *mut EVP_PKEY_ASN1_METHOD, src: *const EVP_PKEY_ASN1_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_asn1_free(ameth: *mut EVP_PKEY_ASN1_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_public(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pub_decode: ::std::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                pub_: *mut X509_PUBKEY,
            ) -> ::std::os::raw::c_int,
        >,
        pub_encode: ::std::option::Option<
            unsafe extern "C" fn(
                pub_: *mut X509_PUBKEY,
                pk: *const EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
        pub_cmp: ::std::option::Option<
            unsafe extern "C" fn(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        pub_print: ::std::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::std::os::raw::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::std::os::raw::c_int,
        >,
        pkey_size: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        pkey_bits: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_private(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        priv_decode: ::std::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                p8inf: *const PKCS8_PRIV_KEY_INFO,
            ) -> ::std::os::raw::c_int,
        >,
        priv_encode: ::std::option::Option<
            unsafe extern "C" fn(
                p8: *mut PKCS8_PRIV_KEY_INFO,
                pk: *const EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
        priv_print: ::std::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::std::os::raw::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_param(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        param_decode: ::std::option::Option<
            unsafe extern "C" fn(
                pkey: *mut EVP_PKEY,
                pder: *mut *const ::std::os::raw::c_uchar,
                derlen: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        param_encode: ::std::option::Option<
            unsafe extern "C" fn(
                pkey: *const EVP_PKEY,
                pder: *mut *mut ::std::os::raw::c_uchar,
            ) -> ::std::os::raw::c_int,
        >,
        param_missing: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        param_copy: ::std::option::Option<
            unsafe extern "C" fn(to: *mut EVP_PKEY, from: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        param_cmp: ::std::option::Option<
            unsafe extern "C" fn(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
        param_print: ::std::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::std::os::raw::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_free(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_free: ::std::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_ctrl(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                pkey: *mut EVP_PKEY,
                op: ::std::os::raw::c_int,
                arg1: ::std::os::raw::c_long,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_item(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        item_verify: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                it: *const ASN1_ITEM,
                asn: *mut ::std::os::raw::c_void,
                a: *mut X509_ALGOR,
                sig: *mut ASN1_BIT_STRING,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
        item_sign: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                it: *const ASN1_ITEM,
                asn: *mut ::std::os::raw::c_void,
                alg1: *mut X509_ALGOR,
                alg2: *mut X509_ALGOR,
                sig: *mut ASN1_BIT_STRING,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_siginf(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        siginf_set: ::std::option::Option<
            unsafe extern "C" fn(
                siginf: *mut X509_SIG_INFO,
                alg: *const X509_ALGOR,
                sig: *const ASN1_STRING,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_check: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_public_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_pub_check: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_param_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_param_check: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_set_priv_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        set_priv_key: ::std::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                priv_: *const ::std::os::raw::c_uchar,
                len: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_set_pub_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        set_pub_key: ::std::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                pub_: *const ::std::os::raw::c_uchar,
                len: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_get_priv_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        get_priv_key: ::std::option::Option<
            unsafe extern "C" fn(
                pk: *const EVP_PKEY,
                priv_: *mut ::std::os::raw::c_uchar,
                len: *mut size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_get_pub_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        get_pub_key: ::std::option::Option<
            unsafe extern "C" fn(
                pk: *const EVP_PKEY,
                pub_: *mut ::std::os::raw::c_uchar,
                len: *mut size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_security_bits(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_security_bits: ::std::option::Option<
            unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_find(type_: ::std::os::raw::c_int) -> *const EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_meth_new(
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> *mut EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_meth_get0_info(
        ppkey_id: *mut ::std::os::raw::c_int,
        pflags: *mut ::std::os::raw::c_int,
        meth: *const EVP_PKEY_METHOD,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_copy(dst: *mut EVP_PKEY_METHOD, src: *const EVP_PKEY_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_meth_free(pmeth: *mut EVP_PKEY_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_meth_add0(pmeth: *const EVP_PKEY_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_remove(pmeth: *const EVP_PKEY_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_get_count() -> size_t;
}
extern "C" {
    pub fn EVP_PKEY_meth_get0(idx: size_t) -> *const EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new_id(id: ::std::os::raw::c_int, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_dup(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_free(ctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl(
        ctx: *mut EVP_PKEY_CTX,
        keytype: ::std::os::raw::c_int,
        optype: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl_str(
        ctx: *mut EVP_PKEY_CTX,
        type_: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl_uint64(
        ctx: *mut EVP_PKEY_CTX,
        keytype: ::std::os::raw::c_int,
        optype: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_str2ctrl(
        ctx: *mut EVP_PKEY_CTX,
        cmd: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_hex2ctrl(
        ctx: *mut EVP_PKEY_CTX,
        cmd: ::std::os::raw::c_int,
        hex: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_md(
        ctx: *mut EVP_PKEY_CTX,
        optype: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        md: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_operation(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_keygen_info(
        ctx: *mut EVP_PKEY_CTX,
        dat: *mut ::std::os::raw::c_int,
        datlen: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EVP_PKEY_new_mac_key(
        type_: ::std::os::raw::c_int,
        e: *mut ENGINE,
        key: *const ::std::os::raw::c_uchar,
        keylen: ::std::os::raw::c_int,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_private_key(
        type_: ::std::os::raw::c_int,
        e: *mut ENGINE,
        priv_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_public_key(
        type_: ::std::os::raw::c_int,
        e: *mut ENGINE,
        pub_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_private_key(
        pkey: *const EVP_PKEY,
        priv_: *mut ::std::os::raw::c_uchar,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_public_key(
        pkey: *const EVP_PKEY,
        pub_: *mut ::std::os::raw::c_uchar,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_new_CMAC_key(
        e: *mut ENGINE,
        priv_: *const ::std::os::raw::c_uchar,
        len: size_t,
        cipher: *const EVP_CIPHER,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_data(ctx: *mut EVP_PKEY_CTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_data(ctx: *mut EVP_PKEY_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_pkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_peerkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_app_data(ctx: *mut EVP_PKEY_CTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_app_data(ctx: *mut EVP_PKEY_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_PKEY_sign_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_sign(
        ctx: *mut EVP_PKEY_CTX,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: *mut size_t,
        tbs: *const ::std::os::raw::c_uchar,
        tbslen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify(
        ctx: *mut EVP_PKEY_CTX,
        sig: *const ::std::os::raw::c_uchar,
        siglen: size_t,
        tbs: *const ::std::os::raw::c_uchar,
        tbslen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover(
        ctx: *mut EVP_PKEY_CTX,
        rout: *mut ::std::os::raw::c_uchar,
        routlen: *mut size_t,
        sig: *const ::std::os::raw::c_uchar,
        siglen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outlen: *mut size_t,
        in_: *const ::std::os::raw::c_uchar,
        inlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut ::std::os::raw::c_uchar,
        outlen: *mut size_t,
        in_: *const ::std::os::raw::c_uchar,
        inlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_set_peer(
        ctx: *mut EVP_PKEY_CTX,
        peer: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive(
        ctx: *mut EVP_PKEY_CTX,
        key: *mut ::std::os::raw::c_uchar,
        keylen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
pub type EVP_PKEY_gen_cb =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn EVP_PKEY_paramgen_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_paramgen(
        ctx: *mut EVP_PKEY_CTX,
        ppkey: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen(
        ctx: *mut EVP_PKEY_CTX,
        ppkey: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_check(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_public_check(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_param_check(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_cb(ctx: *mut EVP_PKEY_CTX, cb: EVP_PKEY_gen_cb);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_cb(ctx: *mut EVP_PKEY_CTX) -> EVP_PKEY_gen_cb;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_keygen_info(
        ctx: *mut EVP_PKEY_CTX,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_set_init(
        pmeth: *mut EVP_PKEY_METHOD,
        init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_copy(
        pmeth: *mut EVP_PKEY_METHOD,
        copy: ::std::option::Option<
            unsafe extern "C" fn(
                dst: *mut EVP_PKEY_CTX,
                src: *mut EVP_PKEY_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_cleanup(
        pmeth: *mut EVP_PKEY_METHOD,
        cleanup: ::std::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_paramgen(
        pmeth: *mut EVP_PKEY_METHOD,
        paramgen_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        paramgen: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_keygen(
        pmeth: *mut EVP_PKEY_METHOD,
        keygen_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        keygen: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_sign(
        pmeth: *mut EVP_PKEY_METHOD,
        sign_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        sign: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verify(
        pmeth: *mut EVP_PKEY_METHOD,
        verify_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        verify: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verify_recover(
        pmeth: *mut EVP_PKEY_METHOD,
        verify_recover_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        verify_recover: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_signctx(
        pmeth: *mut EVP_PKEY_METHOD,
        signctx_init: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        signctx: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut size_t,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verifyctx(
        pmeth: *mut EVP_PKEY_METHOD,
        verifyctx_init: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        verifyctx: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: ::std::os::raw::c_int,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_encrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        encrypt_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        encryptfn: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::std::os::raw::c_uchar,
                outlen: *mut size_t,
                in_: *const ::std::os::raw::c_uchar,
                inlen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_decrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        decrypt_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        decrypt: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::std::os::raw::c_uchar,
                outlen: *mut size_t,
                in_: *const ::std::os::raw::c_uchar,
                inlen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_derive(
        pmeth: *mut EVP_PKEY_METHOD,
        derive_init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        derive: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                key: *mut ::std::os::raw::c_uchar,
                keylen: *mut size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_ctrl(
        pmeth: *mut EVP_PKEY_METHOD,
        ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: ::std::os::raw::c_int,
                p1: ::std::os::raw::c_int,
                p2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        ctrl_str: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: *const ::std::os::raw::c_char,
                value: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_digestsign(
        pmeth: *mut EVP_PKEY_METHOD,
        digestsign: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_digestverify(
        pmeth: *mut EVP_PKEY_METHOD,
        digestverify: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::std::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_public_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::std::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_param_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::std::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_digest_custom(
        pmeth: *mut EVP_PKEY_METHOD,
        digest_custom: ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_init(
        pmeth: *const EVP_PKEY_METHOD,
        pinit: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_copy(
        pmeth: *const EVP_PKEY_METHOD,
        pcopy: *mut ::std::option::Option<
            unsafe extern "C" fn(
                dst: *mut EVP_PKEY_CTX,
                src: *mut EVP_PKEY_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_cleanup(
        pmeth: *const EVP_PKEY_METHOD,
        pcleanup: *mut ::std::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_paramgen(
        pmeth: *const EVP_PKEY_METHOD,
        pparamgen_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pparamgen: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_keygen(
        pmeth: *const EVP_PKEY_METHOD,
        pkeygen_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pkeygen: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                pkey: *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_sign(
        pmeth: *const EVP_PKEY_METHOD,
        psign_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        psign: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verify(
        pmeth: *const EVP_PKEY_METHOD,
        pverify_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pverify: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verify_recover(
        pmeth: *const EVP_PKEY_METHOD,
        pverify_recover_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pverify_recover: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_signctx(
        pmeth: *const EVP_PKEY_METHOD,
        psignctx_init: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        psignctx: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut size_t,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verifyctx(
        pmeth: *const EVP_PKEY_METHOD,
        pverifyctx_init: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
        pverifyctx: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: ::std::os::raw::c_int,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_encrypt(
        pmeth: *const EVP_PKEY_METHOD,
        pencrypt_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pencryptfn: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::std::os::raw::c_uchar,
                outlen: *mut size_t,
                in_: *const ::std::os::raw::c_uchar,
                inlen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_decrypt(
        pmeth: *const EVP_PKEY_METHOD,
        pdecrypt_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pdecrypt: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::std::os::raw::c_uchar,
                outlen: *mut size_t,
                in_: *const ::std::os::raw::c_uchar,
                inlen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_derive(
        pmeth: *const EVP_PKEY_METHOD,
        pderive_init: *mut ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int,
        >,
        pderive: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                key: *mut ::std::os::raw::c_uchar,
                keylen: *mut size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_ctrl(
        pmeth: *const EVP_PKEY_METHOD,
        pctrl: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: ::std::os::raw::c_int,
                p1: ::std::os::raw::c_int,
                p2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pctrl_str: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: *const ::std::os::raw::c_char,
                value: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_digestsign(
        pmeth: *mut EVP_PKEY_METHOD,
        digestsign: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_digestverify(
        pmeth: *mut EVP_PKEY_METHOD,
        digestverify: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                sig: *const ::std::os::raw::c_uchar,
                siglen: size_t,
                tbs: *const ::std::os::raw::c_uchar,
                tbslen: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::std::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_public_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::std::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_param_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::std::option::Option<
            unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_digest_custom(
        pmeth: *mut EVP_PKEY_METHOD,
        pdigest_custom: *mut ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                mctx: *mut EVP_MD_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_add_alg_module();
}
extern "C" {
    pub fn ERR_load_EC_strings() -> ::std::os::raw::c_int;
}
#[doc = " the point is encoded as z||x, where the octet z specifies"]
#[doc = "  which solution of the quadratic equation y is"]
pub const point_conversion_form_t_POINT_CONVERSION_COMPRESSED: point_conversion_form_t = 2;
#[doc = " the point is encoded as z||x||y, where z is the octet 0x04"]
pub const point_conversion_form_t_POINT_CONVERSION_UNCOMPRESSED: point_conversion_form_t = 4;
#[doc = " the point is encoded as z||x||y, where the octet z specifies"]
#[doc = "  which solution of the quadratic equation y is"]
pub const point_conversion_form_t_POINT_CONVERSION_HYBRID: point_conversion_form_t = 6;
#[doc = " Enum for the point conversion form as defined in X9.62 (ECDSA)"]
#[doc = "  for the encoding of a elliptic curve point (x,y)"]
pub type point_conversion_form_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_method_st {
    _unused: [u8; 0],
}
pub type EC_METHOD = ec_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_group_st {
    _unused: [u8; 0],
}
pub type EC_GROUP = ec_group_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_point_st {
    _unused: [u8; 0],
}
pub type EC_POINT = ec_point_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecpk_parameters_st {
    _unused: [u8; 0],
}
pub type ECPKPARAMETERS = ecpk_parameters_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_parameters_st {
    _unused: [u8; 0],
}
pub type ECPARAMETERS = ec_parameters_st;
extern "C" {
    #[doc = " Returns the basic GFp ec methods which provides the basis for the"]
    #[doc = "  optimized methods."]
    #[doc = "  \\return  EC_METHOD object"]
    pub fn EC_GFp_simple_method() -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Returns GFp methods using montgomery multiplication."]
    #[doc = "  \\return  EC_METHOD object"]
    pub fn EC_GFp_mont_method() -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Returns GFp methods using optimized methods for NIST recommended curves"]
    #[doc = "  \\return  EC_METHOD object"]
    pub fn EC_GFp_nist_method() -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Returns the basic GF2m ec method"]
    #[doc = "  \\return  EC_METHOD object"]
    pub fn EC_GF2m_simple_method() -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object"]
    #[doc = "  \\param   meth  EC_METHOD to use"]
    #[doc = "  \\return  newly created EC_GROUP object or NULL in case of an error."]
    pub fn EC_GROUP_new(meth: *const EC_METHOD) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Frees a EC_GROUP object"]
    #[doc = "  \\param  group  EC_GROUP object to be freed."]
    pub fn EC_GROUP_free(group: *mut EC_GROUP);
}
extern "C" {
    #[doc = " Clears and frees a EC_GROUP object"]
    #[doc = "  \\param  group  EC_GROUP object to be cleared and freed."]
    pub fn EC_GROUP_clear_free(group: *mut EC_GROUP);
}
extern "C" {
    #[doc = " Copies EC_GROUP objects. Note: both EC_GROUPs must use the same EC_METHOD."]
    #[doc = "  \\param  dst  destination EC_GROUP object"]
    #[doc = "  \\param  src  source EC_GROUP object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_GROUP_copy(dst: *mut EC_GROUP, src: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object and copies the copies the content"]
    #[doc = "  form src to the newly created EC_KEY object"]
    #[doc = "  \\param  src  source EC_GROUP object"]
    #[doc = "  \\return newly created EC_GROUP object or NULL in case of an error."]
    pub fn EC_GROUP_dup(src: *const EC_GROUP) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Returns the EC_METHOD of the EC_GROUP object."]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return EC_METHOD used in this EC_GROUP object."]
    pub fn EC_GROUP_method_of(group: *const EC_GROUP) -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Returns the field type of the EC_METHOD."]
    #[doc = "  \\param  meth  EC_METHOD object"]
    #[doc = "  \\return NID of the underlying field type OID."]
    pub fn EC_METHOD_get_field_type(meth: *const EC_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the generator and its order/cofactor of a EC_GROUP object."]
    #[doc = "  \\param  group      EC_GROUP object"]
    #[doc = "  \\param  generator  EC_POINT object with the generator."]
    #[doc = "  \\param  order      the order of the group generated by the generator."]
    #[doc = "  \\param  cofactor   the index of the sub-group generated by the generator"]
    #[doc = "                     in the group of all points on the elliptic curve."]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_GROUP_set_generator(
        group: *mut EC_GROUP,
        generator: *const EC_POINT,
        order: *const BIGNUM,
        cofactor: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the generator of a EC_GROUP object."]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return the currently used generator (possibly NULL)."]
    pub fn EC_GROUP_get0_generator(group: *const EC_GROUP) -> *const EC_POINT;
}
extern "C" {
    #[doc = " Returns the montgomery data for order(Generator)"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return the currently used montgomery data (possibly NULL)."]
    pub fn EC_GROUP_get_mont_data(group: *const EC_GROUP) -> *mut BN_MONT_CTX;
}
extern "C" {
    #[doc = " Gets the order of a EC_GROUP"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  order  BIGNUM to which the order is copied"]
    #[doc = "  \\param  ctx    unused"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_GROUP_get_order(
        group: *const EC_GROUP,
        order: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the order of an EC_GROUP"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return the group order"]
    pub fn EC_GROUP_get0_order(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    #[doc = " Gets the number of bits of the order of an EC_GROUP"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return number of bits of group order."]
    pub fn EC_GROUP_order_bits(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the cofactor of a EC_GROUP"]
    #[doc = "  \\param  group     EC_GROUP object"]
    #[doc = "  \\param  cofactor  BIGNUM to which the cofactor is copied"]
    #[doc = "  \\param  ctx       unused"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_GROUP_get_cofactor(
        group: *const EC_GROUP,
        cofactor: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the cofactor of an EC_GROUP"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return the group cofactor"]
    pub fn EC_GROUP_get0_cofactor(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    #[doc = " Sets the name of a EC_GROUP object"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  nid    NID of the curve name OID"]
    pub fn EC_GROUP_set_curve_name(group: *mut EC_GROUP, nid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Returns the curve name of a EC_GROUP object"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return NID of the curve name OID or 0 if not set."]
    pub fn EC_GROUP_get_curve_name(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_asn1_flag(group: *mut EC_GROUP, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EC_GROUP_get_asn1_flag(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_point_conversion_form(group: *mut EC_GROUP, form: point_conversion_form_t);
}
extern "C" {
    pub fn EC_GROUP_get_point_conversion_form(arg1: *const EC_GROUP) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_GROUP_get0_seed(x: *const EC_GROUP) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EC_GROUP_get_seed_len(arg1: *const EC_GROUP) -> size_t;
}
extern "C" {
    pub fn EC_GROUP_set_seed(
        arg1: *mut EC_GROUP,
        arg2: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Sets the parameters of a ec curve defined by y^2 = x^3 + a*x + b (for GFp)"]
    #[doc = "  or y^2 + x*y = x^3 + a*x^2 + b (for GF2m)"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  p      BIGNUM with the prime number (GFp) or the polynomial"]
    #[doc = "                 defining the underlying field (GF2m)"]
    #[doc = "  \\param  a      BIGNUM with parameter a of the equation"]
    #[doc = "  \\param  b      BIGNUM with parameter b of the equation"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_GROUP_set_curve(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the parameters of the ec curve defined by y^2 = x^3 + a*x + b (for GFp)"]
    #[doc = "  or y^2 + x*y = x^3 + a*x^2 + b (for GF2m)"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  p      BIGNUM with the prime number (GFp) or the polynomial"]
    #[doc = "                 defining the underlying field (GF2m)"]
    #[doc = "  \\param  a      BIGNUM for parameter a of the equation"]
    #[doc = "  \\param  b      BIGNUM for parameter b of the equation"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_GROUP_get_curve(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_curve_GFp(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_GFp(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_curve_GF2m(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_GF2m(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of bits needed to represent a field element"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return number of bits needed to represent a field element"]
    pub fn EC_GROUP_get_degree(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the parameter in the EC_GROUP define a valid ec group"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 if group is a valid ec group and 0 otherwise"]
    pub fn EC_GROUP_check(group: *const EC_GROUP, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the discriminant of the elliptic curve is zero or not"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 if the discriminant is not zero and 0 otherwise"]
    pub fn EC_GROUP_check_discriminant(
        group: *const EC_GROUP,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares two EC_GROUP objects"]
    #[doc = "  \\param  a    first EC_GROUP object"]
    #[doc = "  \\param  b    second EC_GROUP object"]
    #[doc = "  \\param  ctx  BN_CTX object (optional)"]
    #[doc = "  \\return 0 if the groups are equal, 1 if not, or -1 on error"]
    pub fn EC_GROUP_cmp(
        a: *const EC_GROUP,
        b: *const EC_GROUP,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object with the specified parameters defined"]
    #[doc = "  over GFp (defined by the equation y^2 = x^3 + a*x + b)"]
    #[doc = "  \\param  p    BIGNUM with the prime number"]
    #[doc = "  \\param  a    BIGNUM with the parameter a of the equation"]
    #[doc = "  \\param  b    BIGNUM with the parameter b of the equation"]
    #[doc = "  \\param  ctx  BN_CTX object (optional)"]
    #[doc = "  \\return newly created EC_GROUP object with the specified parameters"]
    pub fn EC_GROUP_new_curve_GFp(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object with the specified parameters defined"]
    #[doc = "  over GF2m (defined by the equation y^2 + x*y = x^3 + a*x^2 + b)"]
    #[doc = "  \\param  p    BIGNUM with the polynomial defining the underlying field"]
    #[doc = "  \\param  a    BIGNUM with the parameter a of the equation"]
    #[doc = "  \\param  b    BIGNUM with the parameter b of the equation"]
    #[doc = "  \\param  ctx  BN_CTX object (optional)"]
    #[doc = "  \\return newly created EC_GROUP object with the specified parameters"]
    pub fn EC_GROUP_new_curve_GF2m(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Creates a EC_GROUP object with a curve specified by a NID"]
    #[doc = "  \\param  nid  NID of the OID of the curve name"]
    #[doc = "  \\return newly created EC_GROUP object with specified curve or NULL"]
    #[doc = "          if an error occurred"]
    pub fn EC_GROUP_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object from an ECPARAMETERS object"]
    #[doc = "  \\param  params  pointer to the ECPARAMETERS object"]
    #[doc = "  \\return newly created EC_GROUP object with specified curve or NULL"]
    #[doc = "          if an error occurred"]
    pub fn EC_GROUP_new_from_ecparameters(params: *const ECPARAMETERS) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Creates an ECPARAMETERS object for the given EC_GROUP object."]
    #[doc = "  \\param  group   pointer to the EC_GROUP object"]
    #[doc = "  \\param  params  pointer to an existing ECPARAMETERS object or NULL"]
    #[doc = "  \\return pointer to the new ECPARAMETERS object or NULL"]
    #[doc = "          if an error occurred."]
    pub fn EC_GROUP_get_ecparameters(
        group: *const EC_GROUP,
        params: *mut ECPARAMETERS,
    ) -> *mut ECPARAMETERS;
}
extern "C" {
    #[doc = " Creates a new EC_GROUP object from an ECPKPARAMETERS object"]
    #[doc = "  \\param  params  pointer to an existing ECPKPARAMETERS object, or NULL"]
    #[doc = "  \\return newly created EC_GROUP object with specified curve, or NULL"]
    #[doc = "          if an error occurred"]
    pub fn EC_GROUP_new_from_ecpkparameters(params: *const ECPKPARAMETERS) -> *mut EC_GROUP;
}
extern "C" {
    #[doc = " Creates an ECPKPARAMETERS object for the given EC_GROUP object."]
    #[doc = "  \\param  group   pointer to the EC_GROUP object"]
    #[doc = "  \\param  params  pointer to an existing ECPKPARAMETERS object or NULL"]
    #[doc = "  \\return pointer to the new ECPKPARAMETERS object or NULL"]
    #[doc = "          if an error occurred."]
    pub fn EC_GROUP_get_ecpkparameters(
        group: *const EC_GROUP,
        params: *mut ECPKPARAMETERS,
    ) -> *mut ECPKPARAMETERS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EC_builtin_curve {
    pub nid: ::std::os::raw::c_int,
    pub comment: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EC_builtin_curve() {
    assert_eq!(
        ::std::mem::size_of::<EC_builtin_curve>(),
        16usize,
        concat!("Size of: ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        ::std::mem::align_of::<EC_builtin_curve>(),
        8usize,
        concat!("Alignment of ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EC_builtin_curve>())).nid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EC_builtin_curve),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EC_builtin_curve>())).comment as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EC_builtin_curve),
            "::",
            stringify!(comment)
        )
    );
}
extern "C" {
    pub fn EC_get_builtin_curves(r: *mut EC_builtin_curve, nitems: size_t) -> size_t;
}
extern "C" {
    pub fn EC_curve_nid2nist(nid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EC_curve_nist2nid(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_POINT object for the specified EC_GROUP"]
    #[doc = "  \\param  group  EC_GROUP the underlying EC_GROUP object"]
    #[doc = "  \\return newly created EC_POINT object or NULL if an error occurred"]
    pub fn EC_POINT_new(group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    #[doc = " Frees a EC_POINT object"]
    #[doc = "  \\param  point  EC_POINT object to be freed"]
    pub fn EC_POINT_free(point: *mut EC_POINT);
}
extern "C" {
    #[doc = " Clears and frees a EC_POINT object"]
    #[doc = "  \\param  point  EC_POINT object to be cleared and freed"]
    pub fn EC_POINT_clear_free(point: *mut EC_POINT);
}
extern "C" {
    #[doc = " Copies EC_POINT object"]
    #[doc = "  \\param  dst  destination EC_POINT object"]
    #[doc = "  \\param  src  source EC_POINT object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_copy(dst: *mut EC_POINT, src: *const EC_POINT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_POINT object and copies the content of the supplied"]
    #[doc = "  EC_POINT"]
    #[doc = "  \\param  src    source EC_POINT object"]
    #[doc = "  \\param  group  underlying the EC_GROUP object"]
    #[doc = "  \\return newly created EC_POINT object or NULL if an error occurred"]
    pub fn EC_POINT_dup(src: *const EC_POINT, group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    #[doc = " Returns the EC_METHOD used in EC_POINT object"]
    #[doc = "  \\param  point  EC_POINT object"]
    #[doc = "  \\return the EC_METHOD used"]
    pub fn EC_POINT_method_of(point: *const EC_POINT) -> *const EC_METHOD;
}
extern "C" {
    #[doc = " Sets a point to infinity (neutral element)"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  point  EC_POINT to set to infinity"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_set_to_infinity(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the jacobian projective coordinates of a EC_POINT over GFp"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM with the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM with the y-coordinate"]
    #[doc = "  \\param  z      BIGNUM with the z-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_set_Jprojective_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        z: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the jacobian projective coordinates of a EC_POINT over GFp"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM for the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM for the y-coordinate"]
    #[doc = "  \\param  z      BIGNUM for the z-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_get_Jprojective_coordinates_GFp(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        z: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the affine coordinates of an EC_POINT"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM with the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM with the y-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_set_affine_coordinates(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the affine coordinates of an EC_POINT."]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM for the x-coordinate"]
    #[doc = "  \\param  y      BIGNUM for the y-coordinate"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_get_affine_coordinates(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates_GFp(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the x9.62 compressed coordinates of a EC_POINT"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  x      BIGNUM with x-coordinate"]
    #[doc = "  \\param  y_bit  integer with the y-Bit (either 0 or 1)"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_set_compressed_coordinates(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes a EC_POINT object to a octet string"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  form   point conversion form"]
    #[doc = "  \\param  buf    memory buffer for the result. If NULL the function returns"]
    #[doc = "                 required buffer size."]
    #[doc = "  \\param  len    length of the memory buffer"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return the length of the encoded octet string or 0 if an error occurred"]
    pub fn EC_POINT_point2oct(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        form: point_conversion_form_t,
        buf: *mut ::std::os::raw::c_uchar,
        len: size_t,
        ctx: *mut BN_CTX,
    ) -> size_t;
}
extern "C" {
    #[doc = " Decodes a EC_POINT from a octet string"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\param  buf    memory buffer with the encoded ec point"]
    #[doc = "  \\param  len    length of the encoded ec point"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_oct2point(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        buf: *const ::std::os::raw::c_uchar,
        len: size_t,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes an EC_POINT object to an allocated octet string"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  point  EC_POINT object"]
    #[doc = "  \\param  form   point conversion form"]
    #[doc = "  \\param  pbuf   returns pointer to allocated buffer"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return the length of the encoded octet string or 0 if an error occurred"]
    pub fn EC_POINT_point2buf(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        form: point_conversion_form_t,
        pbuf: *mut *mut ::std::os::raw::c_uchar,
        ctx: *mut BN_CTX,
    ) -> size_t;
}
extern "C" {
    pub fn EC_POINT_point2bn(
        arg1: *const EC_GROUP,
        arg2: *const EC_POINT,
        form: point_conversion_form_t,
        arg3: *mut BIGNUM,
        arg4: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn EC_POINT_bn2point(
        arg1: *const EC_GROUP,
        arg2: *const BIGNUM,
        arg3: *mut EC_POINT,
        arg4: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_point2hex(
        arg1: *const EC_GROUP,
        arg2: *const EC_POINT,
        form: point_conversion_form_t,
        arg3: *mut BN_CTX,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn EC_POINT_hex2point(
        arg1: *const EC_GROUP,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut EC_POINT,
        arg4: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    #[doc = " Computes the sum of two EC_POINT"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  r      EC_POINT object for the result (r = a + b)"]
    #[doc = "  \\param  a      EC_POINT object with the first summand"]
    #[doc = "  \\param  b      EC_POINT object with the second summand"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_add(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes the double of a EC_POINT"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  r      EC_POINT object for the result (r = 2 * a)"]
    #[doc = "  \\param  a      EC_POINT object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_dbl(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes the inverse of a EC_POINT"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  a      EC_POINT object to be inverted (it's used for the result as well)"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_invert(
        group: *const EC_GROUP,
        a: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the point is the neutral element of the group"]
    #[doc = "  \\param  group  the underlying EC_GROUP object"]
    #[doc = "  \\param  p      EC_POINT object"]
    #[doc = "  \\return 1 if the point is the neutral element and 0 otherwise"]
    pub fn EC_POINT_is_at_infinity(
        group: *const EC_GROUP,
        p: *const EC_POINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the point is on the curve"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  point  EC_POINT object to check"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 if the point is on the curve, 0 if not, or -1 on error"]
    pub fn EC_POINT_is_on_curve(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares two EC_POINTs"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  a      first EC_POINT object"]
    #[doc = "  \\param  b      second EC_POINT object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 if the points are not equal, 0 if they are, or -1 on error"]
    pub fn EC_POINT_cmp(
        group: *const EC_GROUP,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_make_affine(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINTs_make_affine(
        group: *const EC_GROUP,
        num: size_t,
        points: *mut *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes r = generator * n + sum_{i=0}^{num-1} p[i] * m[i]"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  r      EC_POINT object for the result"]
    #[doc = "  \\param  n      BIGNUM with the multiplier for the group generator (optional)"]
    #[doc = "  \\param  num    number further summands"]
    #[doc = "  \\param  p      array of size num of EC_POINT objects"]
    #[doc = "  \\param  m      array of size num of BIGNUM objects"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINTs_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        num: size_t,
        p: *mut *const EC_POINT,
        m: *mut *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes r = generator * n + q * m"]
    #[doc = "  \\param  group  underlying EC_GROUP object"]
    #[doc = "  \\param  r      EC_POINT object for the result"]
    #[doc = "  \\param  n      BIGNUM with the multiplier for the group generator (optional)"]
    #[doc = "  \\param  q      EC_POINT object with the first factor of the second summand"]
    #[doc = "  \\param  m      BIGNUM with the second factor of the second summand"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_POINT_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        q: *const EC_POINT,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stores multiples of generator for faster point multiplication"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_GROUP_precompute_mult(
        group: *mut EC_GROUP,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reports whether a precomputation has been done"]
    #[doc = "  \\param  group  EC_GROUP object"]
    #[doc = "  \\return 1 if a pre-computation has been done and 0 otherwise"]
    pub fn EC_GROUP_have_precompute_mult(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ECPKPARAMETERS_it: ASN1_ITEM;
}
extern "C" {
    pub fn ECPKPARAMETERS_new() -> *mut ECPKPARAMETERS;
}
extern "C" {
    pub fn ECPKPARAMETERS_free(a: *mut ECPKPARAMETERS);
}
extern "C" {
    pub static ECPARAMETERS_it: ASN1_ITEM;
}
extern "C" {
    pub fn ECPARAMETERS_new() -> *mut ECPARAMETERS;
}
extern "C" {
    pub fn ECPARAMETERS_free(a: *mut ECPARAMETERS);
}
extern "C" {
    pub fn EC_GROUP_get_basis_type(arg1: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_trinomial_basis(
        arg1: *const EC_GROUP,
        k: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_pentanomial_basis(
        arg1: *const EC_GROUP,
        k1: *mut ::std::os::raw::c_uint,
        k2: *mut ::std::os::raw::c_uint,
        k3: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ECPKParameters(
        arg1: *mut *mut EC_GROUP,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn i2d_ECPKParameters(
        arg1: *const EC_GROUP,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECPKParameters_print(
        bp: *mut BIO,
        x: *const EC_GROUP,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECPKParameters_print_fp(
        fp: *mut FILE,
        x: *const EC_GROUP,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_KEY object."]
    #[doc = "  \\return EC_KEY object or NULL if an error occurred."]
    pub fn EC_KEY_new() -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_get_flags(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_set_flags(key: *mut EC_KEY, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EC_KEY_clear_flags(key: *mut EC_KEY, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EC_KEY_decoded_from_explicit_params(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new EC_KEY object using a named curve as underlying"]
    #[doc = "  EC_GROUP object."]
    #[doc = "  \\param  nid  NID of the named curve."]
    #[doc = "  \\return EC_KEY object or NULL if an error occurred."]
    pub fn EC_KEY_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Frees a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object to be freed."]
    pub fn EC_KEY_free(key: *mut EC_KEY);
}
extern "C" {
    #[doc = " Copies a EC_KEY object."]
    #[doc = "  \\param  dst  destination EC_KEY object"]
    #[doc = "  \\param  src  src EC_KEY object"]
    #[doc = "  \\return dst or NULL if an error occurred."]
    pub fn EC_KEY_copy(dst: *mut EC_KEY, src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Creates a new EC_KEY object and copies the content from src to it."]
    #[doc = "  \\param  src  the source EC_KEY object"]
    #[doc = "  \\return newly created EC_KEY object or NULL if an error occurred."]
    pub fn EC_KEY_dup(src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Increases the internal reference count of a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_up_ref(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ENGINE object of a EC_KEY object"]
    #[doc = "  \\param  eckey  EC_KEY object"]
    #[doc = "  \\return the ENGINE object (possibly NULL)."]
    pub fn EC_KEY_get0_engine(eckey: *const EC_KEY) -> *mut ENGINE;
}
extern "C" {
    #[doc = " Returns the EC_GROUP object of a EC_KEY object"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return the EC_GROUP object (possibly NULL)."]
    pub fn EC_KEY_get0_group(key: *const EC_KEY) -> *const EC_GROUP;
}
extern "C" {
    #[doc = " Sets the EC_GROUP of a EC_KEY object."]
    #[doc = "  \\param  key    EC_KEY object"]
    #[doc = "  \\param  group  EC_GROUP to use in the EC_KEY object (note: the EC_KEY"]
    #[doc = "                 object will use an own copy of the EC_GROUP)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_set_group(key: *mut EC_KEY, group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the private key of a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return a BIGNUM with the private key (possibly NULL)."]
    pub fn EC_KEY_get0_private_key(key: *const EC_KEY) -> *const BIGNUM;
}
extern "C" {
    #[doc = " Sets the private key of a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  prv  BIGNUM with the private key (note: the EC_KEY object"]
    #[doc = "               will use an own copy of the BIGNUM)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_set_private_key(key: *mut EC_KEY, prv: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the public key of a EC_KEY object."]
    #[doc = "  \\param  key  the EC_KEY object"]
    #[doc = "  \\return a EC_POINT object with the public key (possibly NULL)"]
    pub fn EC_KEY_get0_public_key(key: *const EC_KEY) -> *const EC_POINT;
}
extern "C" {
    #[doc = " Sets the public key of a EC_KEY object."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  pub  EC_POINT object with the public key (note: the EC_KEY object"]
    #[doc = "               will use an own copy of the EC_POINT object)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_set_public_key(key: *mut EC_KEY, pub_: *const EC_POINT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get_enc_flags(key: *const EC_KEY) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EC_KEY_set_enc_flags(eckey: *mut EC_KEY, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn EC_KEY_get_conv_form(key: *const EC_KEY) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_KEY_set_conv_form(eckey: *mut EC_KEY, cform: point_conversion_form_t);
}
extern "C" {
    pub fn EC_KEY_set_ex_data(
        key: *mut EC_KEY,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get_ex_data(
        key: *const EC_KEY,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EC_KEY_set_asn1_flag(eckey: *mut EC_KEY, asn1_flag: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Creates a table of pre-computed multiples of the generator to"]
    #[doc = "  accelerate further EC_KEY operations."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  ctx  BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_precompute_mult(key: *mut EC_KEY, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new ec private (and optional a new public) key."]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn EC_KEY_generate_key(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verifies that a private and/or public key is valid."]
    #[doc = "  \\param  key  the EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 otherwise."]
    pub fn EC_KEY_check_key(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Indicates if an EC_KEY can be used for signing."]
    #[doc = "  \\param  eckey  the EC_KEY object"]
    #[doc = "  \\return 1 if can can sign and 0 otherwise."]
    pub fn EC_KEY_can_sign(eckey: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets a public key from affine coordinates performing"]
    #[doc = "  necessary NIST PKV tests."]
    #[doc = "  \\param  key  the EC_KEY object"]
    #[doc = "  \\param  x    public key x coordinate"]
    #[doc = "  \\param  y    public key y coordinate"]
    #[doc = "  \\return 1 on success and 0 otherwise."]
    pub fn EC_KEY_set_public_key_affine_coordinates(
        key: *mut EC_KEY,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes an EC_KEY public key to an allocated octet string"]
    #[doc = "  \\param  key    key to encode"]
    #[doc = "  \\param  form   point conversion form"]
    #[doc = "  \\param  pbuf   returns pointer to allocated buffer"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return the length of the encoded octet string or 0 if an error occurred"]
    pub fn EC_KEY_key2buf(
        key: *const EC_KEY,
        form: point_conversion_form_t,
        pbuf: *mut *mut ::std::os::raw::c_uchar,
        ctx: *mut BN_CTX,
    ) -> size_t;
}
extern "C" {
    #[doc = " Decodes a EC_KEY public key from a octet string"]
    #[doc = "  \\param  key    key to decode"]
    #[doc = "  \\param  buf    memory buffer with the encoded ec point"]
    #[doc = "  \\param  len    length of the encoded ec point"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_KEY_oct2key(
        key: *mut EC_KEY,
        buf: *const ::std::os::raw::c_uchar,
        len: size_t,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes an EC_KEY private key from an octet string"]
    #[doc = "  \\param  key    key to decode"]
    #[doc = "  \\param  buf    memory buffer with the encoded private key"]
    #[doc = "  \\param  len    length of the encoded key"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_KEY_oct2priv(
        key: *mut EC_KEY,
        buf: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes a EC_KEY private key to an octet string"]
    #[doc = "  \\param  key    key to encode"]
    #[doc = "  \\param  buf    memory buffer for the result. If NULL the function returns"]
    #[doc = "                 required buffer size."]
    #[doc = "  \\param  len    length of the memory buffer"]
    #[doc = "  \\return the length of the encoded octet string or 0 if an error occurred"]
    pub fn EC_KEY_priv2oct(
        key: *const EC_KEY,
        buf: *mut ::std::os::raw::c_uchar,
        len: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Encodes an EC_KEY private key to an allocated octet string"]
    #[doc = "  \\param  eckey  key to encode"]
    #[doc = "  \\param  pbuf   returns pointer to allocated buffer"]
    #[doc = "  \\return the length of the encoded octet string or 0 if an error occurred"]
    pub fn EC_KEY_priv2buf(eckey: *const EC_KEY, pbuf: *mut *mut ::std::os::raw::c_uchar)
        -> size_t;
}
extern "C" {
    #[doc = " Decodes a private key from a memory buffer."]
    #[doc = "  \\param  key  a pointer to a EC_KEY object which should be used (or NULL)"]
    #[doc = "  \\param  in   pointer to memory with the DER encoded private key"]
    #[doc = "  \\param  len  length of the DER encoded private key"]
    #[doc = "  \\return the decoded private key or NULL if an error occurred."]
    pub fn d2i_ECPrivateKey(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Encodes a private key object and stores the result in a buffer."]
    #[doc = "  \\param  key  the EC_KEY object to encode"]
    #[doc = "  \\param  out  the buffer for the result (if NULL the function returns number"]
    #[doc = "               of bytes needed)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn i2d_ECPrivateKey(
        key: *mut EC_KEY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes ec parameter from a memory buffer."]
    #[doc = "  \\param  key  a pointer to a EC_KEY object which should be used (or NULL)"]
    #[doc = "  \\param  in   pointer to memory with the DER encoded ec parameters"]
    #[doc = "  \\param  len  length of the DER encoded ec parameters"]
    #[doc = "  \\return a EC_KEY object with the decoded parameters or NULL if an error"]
    #[doc = "          occurred."]
    pub fn d2i_ECParameters(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Encodes ec parameter and stores the result in a buffer."]
    #[doc = "  \\param  key  the EC_KEY object with ec parameters to encode"]
    #[doc = "  \\param  out  the buffer for the result (if NULL the function returns number"]
    #[doc = "               of bytes needed)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred."]
    pub fn i2d_ECParameters(
        key: *mut EC_KEY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes a ec public key from a octet string."]
    #[doc = "  \\param  key  a pointer to a EC_KEY object which should be used"]
    #[doc = "  \\param  in   memory buffer with the encoded public key"]
    #[doc = "  \\param  len  length of the encoded public key"]
    #[doc = "  \\return EC_KEY object with decoded public key or NULL if an error"]
    #[doc = "          occurred."]
    pub fn o2i_ECPublicKey(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " Encodes a ec public key in an octet string."]
    #[doc = "  \\param  key  the EC_KEY object with the public key"]
    #[doc = "  \\param  out  the buffer for the result (if NULL the function returns number"]
    #[doc = "               of bytes needed)."]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn i2o_ECPublicKey(
        key: *const EC_KEY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints out the ec parameters on human readable form."]
    #[doc = "  \\param  bp   BIO object to which the information is printed"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn ECParameters_print(bp: *mut BIO, key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints out the contents of a EC_KEY object"]
    #[doc = "  \\param  bp   BIO object to which the information is printed"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  off  line offset"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_KEY_print(
        bp: *mut BIO,
        key: *const EC_KEY,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints out the ec parameters on human readable form."]
    #[doc = "  \\param  fp   file descriptor to which the information is printed"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn ECParameters_print_fp(fp: *mut FILE, key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints out the contents of a EC_KEY object"]
    #[doc = "  \\param  fp   file descriptor to which the information is printed"]
    #[doc = "  \\param  key  EC_KEY object"]
    #[doc = "  \\param  off  line offset"]
    #[doc = "  \\return 1 on success and 0 if an error occurred"]
    pub fn EC_KEY_print_fp(
        fp: *mut FILE,
        key: *const EC_KEY,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_OpenSSL() -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_get_default_method() -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_set_default_method(meth: *const EC_KEY_METHOD);
}
extern "C" {
    pub fn EC_KEY_get_method(key: *const EC_KEY) -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_set_method(key: *mut EC_KEY, meth: *const EC_KEY_METHOD)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_new_method(engine: *mut ENGINE) -> *mut EC_KEY;
}
extern "C" {
    #[doc = " The old name for ecdh_KDF_X9_63"]
    #[doc = "  The ECDH KDF specification has been mistakingly attributed to ANSI X9.62,"]
    #[doc = "  it is actually specified in ANSI X9.63."]
    #[doc = "  This identifier is retained for backwards compatibility"]
    pub fn ECDH_KDF_X9_62(
        out: *mut ::std::os::raw::c_uchar,
        outlen: size_t,
        Z: *const ::std::os::raw::c_uchar,
        Zlen: size_t,
        sinfo: *const ::std::os::raw::c_uchar,
        sinfolen: size_t,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDH_compute_key(
        out: *mut ::std::os::raw::c_void,
        outlen: size_t,
        pub_key: *const EC_POINT,
        ecdh: *const EC_KEY,
        KDF: ::std::option::Option<
            unsafe extern "C" fn(
                in_: *const ::std::os::raw::c_void,
                inlen: size_t,
                out: *mut ::std::os::raw::c_void,
                outlen: *mut size_t,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ECDSA_SIG_st {
    _unused: [u8; 0],
}
pub type ECDSA_SIG = ECDSA_SIG_st;
extern "C" {
    #[doc = " Allocates and initialize a ECDSA_SIG structure"]
    #[doc = "  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred"]
    pub fn ECDSA_SIG_new() -> *mut ECDSA_SIG;
}
extern "C" {
    #[doc = " frees a ECDSA_SIG structure"]
    #[doc = "  \\param  sig  pointer to the ECDSA_SIG structure"]
    pub fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);
}
extern "C" {
    #[doc = " DER encode content of ECDSA_SIG object (note: this function modifies *pp"]
    #[doc = "  (*pp += length of the DER encoded signature))."]
    #[doc = "  \\param  sig  pointer to the ECDSA_SIG object"]
    #[doc = "  \\param  pp   pointer to a unsigned char pointer for the output or NULL"]
    #[doc = "  \\return the length of the DER encoded ECDSA_SIG object or a negative value"]
    #[doc = "          on error"]
    pub fn i2d_ECDSA_SIG(
        sig: *const ECDSA_SIG,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes a DER encoded ECDSA signature (note: this function changes *pp"]
    #[doc = "  (*pp += len))."]
    #[doc = "  \\param  sig  pointer to ECDSA_SIG pointer (may be NULL)"]
    #[doc = "  \\param  pp   memory buffer with the DER encoded signature"]
    #[doc = "  \\param  len  length of the buffer"]
    #[doc = "  \\return pointer to the decoded ECDSA_SIG structure (or NULL)"]
    pub fn d2i_ECDSA_SIG(
        sig: *mut *mut ECDSA_SIG,
        pp: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    #[doc = " Accessor for r and s fields of ECDSA_SIG"]
    #[doc = "  \\param  sig  pointer to ECDSA_SIG structure"]
    #[doc = "  \\param  pr   pointer to BIGNUM pointer for r (may be NULL)"]
    #[doc = "  \\param  ps   pointer to BIGNUM pointer for s (may be NULL)"]
    pub fn ECDSA_SIG_get0(sig: *const ECDSA_SIG, pr: *mut *const BIGNUM, ps: *mut *const BIGNUM);
}
extern "C" {
    #[doc = " Accessor for r field of ECDSA_SIG"]
    #[doc = "  \\param  sig  pointer to ECDSA_SIG structure"]
    pub fn ECDSA_SIG_get0_r(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    #[doc = " Accessor for s field of ECDSA_SIG"]
    #[doc = "  \\param  sig  pointer to ECDSA_SIG structure"]
    pub fn ECDSA_SIG_get0_s(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    #[doc = " Setter for r and s fields of ECDSA_SIG"]
    #[doc = "  \\param  sig  pointer to ECDSA_SIG structure"]
    #[doc = "  \\param  r    pointer to BIGNUM for r (may be NULL)"]
    #[doc = "  \\param  s    pointer to BIGNUM for s (may be NULL)"]
    pub fn ECDSA_SIG_set0(
        sig: *mut ECDSA_SIG,
        r: *mut BIGNUM,
        s: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes the ECDSA signature of the given hash value using"]
    #[doc = "  the supplied private key and returns the created signature."]
    #[doc = "  \\param  dgst      pointer to the hash value"]
    #[doc = "  \\param  dgst_len  length of the hash value"]
    #[doc = "  \\param  eckey     EC_KEY object containing a private EC key"]
    #[doc = "  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred"]
    pub fn ECDSA_do_sign(
        dgst: *const ::std::os::raw::c_uchar,
        dgst_len: ::std::os::raw::c_int,
        eckey: *mut EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    #[doc = " Computes ECDSA signature of a given hash value using the supplied"]
    #[doc = "  private key (note: sig must point to ECDSA_size(eckey) bytes of memory)."]
    #[doc = "  \\param  dgst     pointer to the hash value to sign"]
    #[doc = "  \\param  dgstlen  length of the hash value"]
    #[doc = "  \\param  kinv     BIGNUM with a pre-computed inverse k (optional)"]
    #[doc = "  \\param  rp       BIGNUM with a pre-computed rp value (optional),"]
    #[doc = "                   see ECDSA_sign_setup"]
    #[doc = "  \\param  eckey    EC_KEY object containing a private EC key"]
    #[doc = "  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred"]
    pub fn ECDSA_do_sign_ex(
        dgst: *const ::std::os::raw::c_uchar,
        dgstlen: ::std::os::raw::c_int,
        kinv: *const BIGNUM,
        rp: *const BIGNUM,
        eckey: *mut EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    #[doc = " Verifies that the supplied signature is a valid ECDSA"]
    #[doc = "  signature of the supplied hash value using the supplied public key."]
    #[doc = "  \\param  dgst      pointer to the hash value"]
    #[doc = "  \\param  dgst_len  length of the hash value"]
    #[doc = "  \\param  sig       ECDSA_SIG structure"]
    #[doc = "  \\param  eckey     EC_KEY object containing a public EC key"]
    #[doc = "  \\return 1 if the signature is valid, 0 if the signature is invalid"]
    #[doc = "          and -1 on error"]
    pub fn ECDSA_do_verify(
        dgst: *const ::std::os::raw::c_uchar,
        dgst_len: ::std::os::raw::c_int,
        sig: *const ECDSA_SIG,
        eckey: *mut EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Precompute parts of the signing operation"]
    #[doc = "  \\param  eckey  EC_KEY object containing a private EC key"]
    #[doc = "  \\param  ctx    BN_CTX object (optional)"]
    #[doc = "  \\param  kinv   BIGNUM pointer for the inverse of k"]
    #[doc = "  \\param  rp     BIGNUM pointer for x coordinate of k * generator"]
    #[doc = "  \\return 1 on success and 0 otherwise"]
    pub fn ECDSA_sign_setup(
        eckey: *mut EC_KEY,
        ctx: *mut BN_CTX,
        kinv: *mut *mut BIGNUM,
        rp: *mut *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes ECDSA signature of a given hash value using the supplied"]
    #[doc = "  private key (note: sig must point to ECDSA_size(eckey) bytes of memory)."]
    #[doc = "  \\param  type     this parameter is ignored"]
    #[doc = "  \\param  dgst     pointer to the hash value to sign"]
    #[doc = "  \\param  dgstlen  length of the hash value"]
    #[doc = "  \\param  sig      memory for the DER encoded created signature"]
    #[doc = "  \\param  siglen   pointer to the length of the returned signature"]
    #[doc = "  \\param  eckey    EC_KEY object containing a private EC key"]
    #[doc = "  \\return 1 on success and 0 otherwise"]
    pub fn ECDSA_sign(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dgstlen: ::std::os::raw::c_int,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        eckey: *mut EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes ECDSA signature of a given hash value using the supplied"]
    #[doc = "  private key (note: sig must point to ECDSA_size(eckey) bytes of memory)."]
    #[doc = "  \\param  type     this parameter is ignored"]
    #[doc = "  \\param  dgst     pointer to the hash value to sign"]
    #[doc = "  \\param  dgstlen  length of the hash value"]
    #[doc = "  \\param  sig      buffer to hold the DER encoded signature"]
    #[doc = "  \\param  siglen   pointer to the length of the returned signature"]
    #[doc = "  \\param  kinv     BIGNUM with a pre-computed inverse k (optional)"]
    #[doc = "  \\param  rp       BIGNUM with a pre-computed rp value (optional),"]
    #[doc = "                   see ECDSA_sign_setup"]
    #[doc = "  \\param  eckey    EC_KEY object containing a private EC key"]
    #[doc = "  \\return 1 on success and 0 otherwise"]
    pub fn ECDSA_sign_ex(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dgstlen: ::std::os::raw::c_int,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        kinv: *const BIGNUM,
        rp: *const BIGNUM,
        eckey: *mut EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verifies that the given signature is valid ECDSA signature"]
    #[doc = "  of the supplied hash value using the specified public key."]
    #[doc = "  \\param  type     this parameter is ignored"]
    #[doc = "  \\param  dgst     pointer to the hash value"]
    #[doc = "  \\param  dgstlen  length of the hash value"]
    #[doc = "  \\param  sig      pointer to the DER encoded signature"]
    #[doc = "  \\param  siglen   length of the DER encoded signature"]
    #[doc = "  \\param  eckey    EC_KEY object containing a public EC key"]
    #[doc = "  \\return 1 if the signature is valid, 0 if the signature is invalid"]
    #[doc = "          and -1 on error"]
    pub fn ECDSA_verify(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dgstlen: ::std::os::raw::c_int,
        sig: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_int,
        eckey: *mut EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the maximum length of the DER encoded signature"]
    #[doc = "  \\param  eckey  EC_KEY object"]
    #[doc = "  \\return numbers of bytes required for the DER encoded signature"]
    pub fn ECDSA_size(eckey: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_METHOD_new(meth: *const EC_KEY_METHOD) -> *mut EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_METHOD_free(meth: *mut EC_KEY_METHOD);
}
extern "C" {
    pub fn EC_KEY_METHOD_set_init(
        meth: *mut EC_KEY_METHOD,
        init: ::std::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY) -> ::std::os::raw::c_int,
        >,
        finish: ::std::option::Option<unsafe extern "C" fn(key: *mut EC_KEY)>,
        copy: ::std::option::Option<
            unsafe extern "C" fn(dest: *mut EC_KEY, src: *const EC_KEY) -> ::std::os::raw::c_int,
        >,
        set_group: ::std::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, grp: *const EC_GROUP) -> ::std::os::raw::c_int,
        >,
        set_private: ::std::option::Option<
            unsafe extern "C" fn(
                key: *mut EC_KEY,
                priv_key: *const BIGNUM,
            ) -> ::std::os::raw::c_int,
        >,
        set_public: ::std::option::Option<
            unsafe extern "C" fn(
                key: *mut EC_KEY,
                pub_key: *const EC_POINT,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_keygen(
        meth: *mut EC_KEY_METHOD,
        keygen: ::std::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_compute_key(
        meth: *mut EC_KEY_METHOD,
        ckey: ::std::option::Option<
            unsafe extern "C" fn(
                psec: *mut *mut ::std::os::raw::c_uchar,
                pseclen: *mut size_t,
                pub_key: *const EC_POINT,
                ecdh: *const EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_sign(
        meth: *mut EC_KEY_METHOD,
        sign: ::std::option::Option<
            unsafe extern "C" fn(
                type_: ::std::os::raw::c_int,
                dgst: *const ::std::os::raw::c_uchar,
                dlen: ::std::os::raw::c_int,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut ::std::os::raw::c_uint,
                kinv: *const BIGNUM,
                r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
        sign_setup: ::std::option::Option<
            unsafe extern "C" fn(
                eckey: *mut EC_KEY,
                ctx_in: *mut BN_CTX,
                kinvp: *mut *mut BIGNUM,
                rp: *mut *mut BIGNUM,
            ) -> ::std::os::raw::c_int,
        >,
        sign_sig: ::std::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::std::os::raw::c_uchar,
                dgst_len: ::std::os::raw::c_int,
                in_kinv: *const BIGNUM,
                in_r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> *mut ECDSA_SIG,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_verify(
        meth: *mut EC_KEY_METHOD,
        verify: ::std::option::Option<
            unsafe extern "C" fn(
                type_: ::std::os::raw::c_int,
                dgst: *const ::std::os::raw::c_uchar,
                dgst_len: ::std::os::raw::c_int,
                sigbuf: *const ::std::os::raw::c_uchar,
                sig_len: ::std::os::raw::c_int,
                eckey: *mut EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
        verify_sig: ::std::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::std::os::raw::c_uchar,
                dgst_len: ::std::os::raw::c_int,
                sig: *const ECDSA_SIG,
                eckey: *mut EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_init(
        meth: *const EC_KEY_METHOD,
        pinit: *mut ::std::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY) -> ::std::os::raw::c_int,
        >,
        pfinish: *mut ::std::option::Option<unsafe extern "C" fn(key: *mut EC_KEY)>,
        pcopy: *mut ::std::option::Option<
            unsafe extern "C" fn(dest: *mut EC_KEY, src: *const EC_KEY) -> ::std::os::raw::c_int,
        >,
        pset_group: *mut ::std::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, grp: *const EC_GROUP) -> ::std::os::raw::c_int,
        >,
        pset_private: *mut ::std::option::Option<
            unsafe extern "C" fn(
                key: *mut EC_KEY,
                priv_key: *const BIGNUM,
            ) -> ::std::os::raw::c_int,
        >,
        pset_public: *mut ::std::option::Option<
            unsafe extern "C" fn(
                key: *mut EC_KEY,
                pub_key: *const EC_POINT,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_keygen(
        meth: *const EC_KEY_METHOD,
        pkeygen: *mut ::std::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_compute_key(
        meth: *const EC_KEY_METHOD,
        pck: *mut ::std::option::Option<
            unsafe extern "C" fn(
                psec: *mut *mut ::std::os::raw::c_uchar,
                pseclen: *mut size_t,
                pub_key: *const EC_POINT,
                ecdh: *const EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_sign(
        meth: *const EC_KEY_METHOD,
        psign: *mut ::std::option::Option<
            unsafe extern "C" fn(
                type_: ::std::os::raw::c_int,
                dgst: *const ::std::os::raw::c_uchar,
                dlen: ::std::os::raw::c_int,
                sig: *mut ::std::os::raw::c_uchar,
                siglen: *mut ::std::os::raw::c_uint,
                kinv: *const BIGNUM,
                r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
        psign_setup: *mut ::std::option::Option<
            unsafe extern "C" fn(
                eckey: *mut EC_KEY,
                ctx_in: *mut BN_CTX,
                kinvp: *mut *mut BIGNUM,
                rp: *mut *mut BIGNUM,
            ) -> ::std::os::raw::c_int,
        >,
        psign_sig: *mut ::std::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::std::os::raw::c_uchar,
                dgst_len: ::std::os::raw::c_int,
                in_kinv: *const BIGNUM,
                in_r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> *mut ECDSA_SIG,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_verify(
        meth: *const EC_KEY_METHOD,
        pverify: *mut ::std::option::Option<
            unsafe extern "C" fn(
                type_: ::std::os::raw::c_int,
                dgst: *const ::std::os::raw::c_uchar,
                dgst_len: ::std::os::raw::c_int,
                sigbuf: *const ::std::os::raw::c_uchar,
                sig_len: ::std::os::raw::c_int,
                eckey: *mut EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
        pverify_sig: *mut ::std::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::std::os::raw::c_uchar,
                dgst_len: ::std::os::raw::c_int,
                sig: *const ECDSA_SIG,
                eckey: *mut EC_KEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn ERR_load_RSA_strings() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_new() -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_method(engine: *mut ENGINE) -> *mut RSA;
}
extern "C" {
    pub fn RSA_bits(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_size(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_security_bits(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set0_key(
        r: *mut RSA,
        n: *mut BIGNUM,
        e: *mut BIGNUM,
        d: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set0_factors(r: *mut RSA, p: *mut BIGNUM, q: *mut BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set0_crt_params(
        r: *mut RSA,
        dmp1: *mut BIGNUM,
        dmq1: *mut BIGNUM,
        iqmp: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set0_multi_prime_params(
        r: *mut RSA,
        primes: *mut *mut BIGNUM,
        exps: *mut *mut BIGNUM,
        coeffs: *mut *mut BIGNUM,
        pnum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get0_key(
        r: *const RSA,
        n: *mut *const BIGNUM,
        e: *mut *const BIGNUM,
        d: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn RSA_get0_factors(r: *const RSA, p: *mut *const BIGNUM, q: *mut *const BIGNUM);
}
extern "C" {
    pub fn RSA_get_multi_prime_extra_count(r: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get0_multi_prime_factors(
        r: *const RSA,
        primes: *mut *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get0_crt_params(
        r: *const RSA,
        dmp1: *mut *const BIGNUM,
        dmq1: *mut *const BIGNUM,
        iqmp: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn RSA_get0_multi_prime_crt_params(
        r: *const RSA,
        exps: *mut *const BIGNUM,
        coeffs: *mut *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get0_n(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_e(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_d(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_p(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_q(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_dmp1(r: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_dmq1(r: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_iqmp(r: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_pss_params(r: *const RSA) -> *const RSA_PSS_PARAMS;
}
extern "C" {
    pub fn RSA_clear_flags(r: *mut RSA, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn RSA_test_flags(r: *const RSA, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set_flags(r: *mut RSA, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn RSA_get_version(r: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get0_engine(r: *const RSA) -> *mut ENGINE;
}
extern "C" {
    pub fn RSA_generate_key(
        bits: ::std::os::raw::c_int,
        e: ::std::os::raw::c_ulong,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn RSA_generate_key_ex(
        rsa: *mut RSA,
        bits: ::std::os::raw::c_int,
        e: *mut BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_generate_multi_prime_key(
        rsa: *mut RSA,
        bits: ::std::os::raw::c_int,
        primes: ::std::os::raw::c_int,
        e: *mut BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_X931_derive_ex(
        rsa: *mut RSA,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        q1: *mut BIGNUM,
        q2: *mut BIGNUM,
        Xp1: *const BIGNUM,
        Xp2: *const BIGNUM,
        Xp: *const BIGNUM,
        Xq1: *const BIGNUM,
        Xq2: *const BIGNUM,
        Xq: *const BIGNUM,
        e: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_X931_generate_key_ex(
        rsa: *mut RSA,
        bits: ::std::os::raw::c_int,
        e: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_check_key(arg1: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_check_key_ex(arg1: *const RSA, cb: *mut BN_GENCB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_encrypt(
        flen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        to: *mut ::std::os::raw::c_uchar,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_encrypt(
        flen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        to: *mut ::std::os::raw::c_uchar,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_decrypt(
        flen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        to: *mut ::std::os::raw::c_uchar,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_decrypt(
        flen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        to: *mut ::std::os::raw::c_uchar,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_free(r: *mut RSA);
}
extern "C" {
    pub fn RSA_up_ref(r: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_flags(r: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set_default_method(meth: *const RSA_METHOD);
}
extern "C" {
    pub fn RSA_get_default_method() -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_null_method() -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_get_method(rsa: *const RSA) -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_set_method(rsa: *mut RSA, meth: *const RSA_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_PKCS1_OpenSSL() -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_pkey_ctx_ctrl(
        ctx: *mut EVP_PKEY_CTX,
        optype: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPublicKey(
        a: *mut *mut RSA,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey(
        a: *const RSA,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static RSAPublicKey_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_RSAPrivateKey(
        a: *mut *mut RSA,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey(
        a: *const RSA,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static RSAPrivateKey_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_pss_params_st {
    pub hashAlgorithm: *mut X509_ALGOR,
    pub maskGenAlgorithm: *mut X509_ALGOR,
    pub saltLength: *mut ASN1_INTEGER,
    pub trailerField: *mut ASN1_INTEGER,
    pub maskHash: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_rsa_pss_params_st() {
    assert_eq!(
        ::std::mem::size_of::<rsa_pss_params_st>(),
        40usize,
        concat!("Size of: ", stringify!(rsa_pss_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_pss_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_pss_params_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).hashAlgorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(hashAlgorithm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rsa_pss_params_st>())).maskGenAlgorithm as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(maskGenAlgorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).saltLength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(saltLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).trailerField as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(trailerField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_pss_params_st>())).maskHash as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(maskHash)
        )
    );
}
extern "C" {
    pub fn RSA_PSS_PARAMS_new() -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn RSA_PSS_PARAMS_free(a: *mut RSA_PSS_PARAMS);
}
extern "C" {
    pub fn d2i_RSA_PSS_PARAMS(
        a: *mut *mut RSA_PSS_PARAMS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn i2d_RSA_PSS_PARAMS(
        a: *mut RSA_PSS_PARAMS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static RSA_PSS_PARAMS_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_oaep_params_st {
    pub hashFunc: *mut X509_ALGOR,
    pub maskGenFunc: *mut X509_ALGOR,
    pub pSourceFunc: *mut X509_ALGOR,
    pub maskHash: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_rsa_oaep_params_st() {
    assert_eq!(
        ::std::mem::size_of::<rsa_oaep_params_st>(),
        32usize,
        concat!("Size of: ", stringify!(rsa_oaep_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_oaep_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_oaep_params_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_oaep_params_st>())).hashFunc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_oaep_params_st),
            "::",
            stringify!(hashFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_oaep_params_st>())).maskGenFunc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_oaep_params_st),
            "::",
            stringify!(maskGenFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_oaep_params_st>())).pSourceFunc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_oaep_params_st),
            "::",
            stringify!(pSourceFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rsa_oaep_params_st>())).maskHash as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_oaep_params_st),
            "::",
            stringify!(maskHash)
        )
    );
}
pub type RSA_OAEP_PARAMS = rsa_oaep_params_st;
extern "C" {
    pub fn RSA_OAEP_PARAMS_new() -> *mut RSA_OAEP_PARAMS;
}
extern "C" {
    pub fn RSA_OAEP_PARAMS_free(a: *mut RSA_OAEP_PARAMS);
}
extern "C" {
    pub fn d2i_RSA_OAEP_PARAMS(
        a: *mut *mut RSA_OAEP_PARAMS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA_OAEP_PARAMS;
}
extern "C" {
    pub fn i2d_RSA_OAEP_PARAMS(
        a: *mut RSA_OAEP_PARAMS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static RSA_OAEP_PARAMS_it: ASN1_ITEM;
}
extern "C" {
    pub fn RSA_print_fp(
        fp: *mut FILE,
        r: *const RSA,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_print(
        bp: *mut BIO,
        r: *const RSA,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigbuf: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign_ASN1_OCTET_STRING(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_ASN1_OCTET_STRING(
        type_: ::std::os::raw::c_int,
        m: *const ::std::os::raw::c_uchar,
        m_length: ::std::os::raw::c_uint,
        sigbuf: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_blinding_on(rsa: *mut RSA, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_blinding_off(rsa: *mut RSA);
}
extern "C" {
    pub fn RSA_setup_blinding(rsa: *mut RSA, ctx: *mut BN_CTX) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_type_1(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_type_1(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_type_2(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_type_2(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS1_MGF1(
        mask: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        seed: *const ::std::os::raw::c_uchar,
        seedlen: ::std::os::raw::c_long,
        dgst: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_uchar,
        pl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_OAEP(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_uchar,
        pl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP_mgf1(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        flen: ::std::os::raw::c_int,
        param: *const ::std::os::raw::c_uchar,
        plen: ::std::os::raw::c_int,
        md: *const EVP_MD,
        mgf1md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_OAEP_mgf1(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_uchar,
        flen: ::std::os::raw::c_int,
        num: ::std::os::raw::c_int,
        param: *const ::std::os::raw::c_uchar,
        plen: ::std::os::raw::c_int,
        md: *const EVP_MD,
        mgf1md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_SSLv23(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_SSLv23(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_none(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_none(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_X931(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_check_X931(
        to: *mut ::std::os::raw::c_uchar,
        tlen: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_uchar,
        fl: ::std::os::raw::c_int,
        rsa_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_X931_hash_id(nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS(
        rsa: *mut RSA,
        mHash: *const ::std::os::raw::c_uchar,
        Hash: *const EVP_MD,
        EM: *const ::std::os::raw::c_uchar,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS(
        rsa: *mut RSA,
        EM: *mut ::std::os::raw::c_uchar,
        mHash: *const ::std::os::raw::c_uchar,
        Hash: *const EVP_MD,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS_mgf1(
        rsa: *mut RSA,
        mHash: *const ::std::os::raw::c_uchar,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        EM: *const ::std::os::raw::c_uchar,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS_mgf1(
        rsa: *mut RSA,
        EM: *mut ::std::os::raw::c_uchar,
        mHash: *const ::std::os::raw::c_uchar,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set_ex_data(
        r: *mut RSA,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get_ex_data(
        r: *const RSA,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn RSAPublicKey_dup(rsa: *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn RSAPrivateKey_dup(rsa: *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn RSA_meth_new(
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut RSA_METHOD;
}
extern "C" {
    pub fn RSA_meth_free(meth: *mut RSA_METHOD);
}
extern "C" {
    pub fn RSA_meth_dup(meth: *const RSA_METHOD) -> *mut RSA_METHOD;
}
extern "C" {
    pub fn RSA_meth_get0_name(meth: *const RSA_METHOD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn RSA_meth_set1_name(
        meth: *mut RSA_METHOD,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_flags(meth: *const RSA_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_set_flags(
        meth: *mut RSA_METHOD,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get0_app_data(meth: *const RSA_METHOD) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn RSA_meth_set0_app_data(
        meth: *mut RSA_METHOD,
        app_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_pub_enc(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: ::std::os::raw::c_int,
            arg1: *const ::std::os::raw::c_uchar,
            arg2: *mut ::std::os::raw::c_uchar,
            arg3: *mut RSA,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_pub_enc(
        rsa: *mut RSA_METHOD,
        pub_enc: ::std::option::Option<
            unsafe extern "C" fn(
                flen: ::std::os::raw::c_int,
                from: *const ::std::os::raw::c_uchar,
                to: *mut ::std::os::raw::c_uchar,
                rsa: *mut RSA,
                padding: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_pub_dec(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: ::std::os::raw::c_int,
            arg1: *const ::std::os::raw::c_uchar,
            arg2: *mut ::std::os::raw::c_uchar,
            arg3: *mut RSA,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_pub_dec(
        rsa: *mut RSA_METHOD,
        pub_dec: ::std::option::Option<
            unsafe extern "C" fn(
                flen: ::std::os::raw::c_int,
                from: *const ::std::os::raw::c_uchar,
                to: *mut ::std::os::raw::c_uchar,
                rsa: *mut RSA,
                padding: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_priv_enc(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: ::std::os::raw::c_int,
            arg1: *const ::std::os::raw::c_uchar,
            arg2: *mut ::std::os::raw::c_uchar,
            arg3: *mut RSA,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_priv_enc(
        rsa: *mut RSA_METHOD,
        priv_enc: ::std::option::Option<
            unsafe extern "C" fn(
                flen: ::std::os::raw::c_int,
                from: *const ::std::os::raw::c_uchar,
                to: *mut ::std::os::raw::c_uchar,
                rsa: *mut RSA,
                padding: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_priv_dec(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: ::std::os::raw::c_int,
            arg1: *const ::std::os::raw::c_uchar,
            arg2: *mut ::std::os::raw::c_uchar,
            arg3: *mut RSA,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_priv_dec(
        rsa: *mut RSA_METHOD,
        priv_dec: ::std::option::Option<
            unsafe extern "C" fn(
                flen: ::std::os::raw::c_int,
                from: *const ::std::os::raw::c_uchar,
                to: *mut ::std::os::raw::c_uchar,
                rsa: *mut RSA,
                padding: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_mod_exp(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: *mut BIGNUM,
            arg1: *const BIGNUM,
            arg2: *mut RSA,
            arg3: *mut BN_CTX,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_mod_exp(
        rsa: *mut RSA_METHOD,
        mod_exp: ::std::option::Option<
            unsafe extern "C" fn(
                r0: *mut BIGNUM,
                i: *const BIGNUM,
                rsa: *mut RSA,
                ctx: *mut BN_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_bn_mod_exp(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: *mut BIGNUM,
            arg1: *const BIGNUM,
            arg2: *const BIGNUM,
            arg3: *const BIGNUM,
            arg4: *mut BN_CTX,
            arg5: *mut BN_MONT_CTX,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_bn_mod_exp(
        rsa: *mut RSA_METHOD,
        bn_mod_exp: ::std::option::Option<
            unsafe extern "C" fn(
                r: *mut BIGNUM,
                a: *const BIGNUM,
                p: *const BIGNUM,
                m: *const BIGNUM,
                ctx: *mut BN_CTX,
                m_ctx: *mut BN_MONT_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_init(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(meth: *mut RSA) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn RSA_meth_set_init(
        rsa: *mut RSA_METHOD,
        init: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_finish(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(meth: *mut RSA) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn RSA_meth_set_finish(
        rsa: *mut RSA_METHOD,
        finish: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_sign(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: ::std::os::raw::c_int,
            arg1: *const ::std::os::raw::c_uchar,
            arg2: ::std::os::raw::c_uint,
            arg3: *mut ::std::os::raw::c_uchar,
            arg4: *mut ::std::os::raw::c_uint,
            arg5: *const RSA,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_sign(
        rsa: *mut RSA_METHOD,
        sign: ::std::option::Option<
            unsafe extern "C" fn(
                type_: ::std::os::raw::c_int,
                m: *const ::std::os::raw::c_uchar,
                m_length: ::std::os::raw::c_uint,
                sigret: *mut ::std::os::raw::c_uchar,
                siglen: *mut ::std::os::raw::c_uint,
                rsa: *const RSA,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_verify(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: ::std::os::raw::c_int,
            arg1: *const ::std::os::raw::c_uchar,
            arg2: ::std::os::raw::c_uint,
            arg3: *const ::std::os::raw::c_uchar,
            arg4: ::std::os::raw::c_uint,
            arg5: *const RSA,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_verify(
        rsa: *mut RSA_METHOD,
        verify: ::std::option::Option<
            unsafe extern "C" fn(
                dtype: ::std::os::raw::c_int,
                m: *const ::std::os::raw::c_uchar,
                m_length: ::std::os::raw::c_uint,
                sigbuf: *const ::std::os::raw::c_uchar,
                siglen: ::std::os::raw::c_uint,
                rsa: *const RSA,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_keygen(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: *mut RSA,
            arg1: ::std::os::raw::c_int,
            arg2: *mut BIGNUM,
            arg3: *mut BN_GENCB,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_keygen(
        rsa: *mut RSA_METHOD,
        keygen: ::std::option::Option<
            unsafe extern "C" fn(
                rsa: *mut RSA,
                bits: ::std::os::raw::c_int,
                e: *mut BIGNUM,
                cb: *mut BN_GENCB,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_meth_get_multi_prime_keygen(
        meth: *const RSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            meth: *mut RSA,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut BIGNUM,
            arg4: *mut BN_GENCB,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_multi_prime_keygen(
        meth: *mut RSA_METHOD,
        keygen: ::std::option::Option<
            unsafe extern "C" fn(
                rsa: *mut RSA,
                bits: ::std::os::raw::c_int,
                primes: ::std::os::raw::c_int,
                e: *mut BIGNUM,
                cb: *mut BN_GENCB,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_DH_strings() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static DHparams_it: ASN1_ITEM;
}
extern "C" {
    pub fn DHparams_dup(arg1: *mut DH) -> *mut DH;
}
extern "C" {
    pub fn DH_OpenSSL() -> *const DH_METHOD;
}
extern "C" {
    pub fn DH_set_default_method(meth: *const DH_METHOD);
}
extern "C" {
    pub fn DH_get_default_method() -> *const DH_METHOD;
}
extern "C" {
    pub fn DH_set_method(dh: *mut DH, meth: *const DH_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_new_method(engine: *mut ENGINE) -> *mut DH;
}
extern "C" {
    pub fn DH_new() -> *mut DH;
}
extern "C" {
    pub fn DH_free(dh: *mut DH);
}
extern "C" {
    pub fn DH_up_ref(dh: *mut DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_bits(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_size(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_security_bits(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_set_ex_data(
        d: *mut DH,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get_ex_data(d: *mut DH, idx: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DH_generate_parameters(
        prime_len: ::std::os::raw::c_int,
        generator: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn DH_generate_parameters_ex(
        dh: *mut DH,
        prime_len: ::std::os::raw::c_int,
        generator: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check_params_ex(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check_ex(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check_pub_key_ex(dh: *const DH, pub_key: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check_params(dh: *const DH, ret: *mut ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check(dh: *const DH, codes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check_pub_key(
        dh: *const DH,
        pub_key: *const BIGNUM,
        codes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_generate_key(dh: *mut DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key(
        key: *mut ::std::os::raw::c_uchar,
        pub_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key_padded(
        key: *mut ::std::os::raw::c_uchar,
        pub_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DHparams(
        a: *mut *mut DH,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DH;
}
extern "C" {
    pub fn i2d_DHparams(
        a: *const DH,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DHxparams(
        a: *mut *mut DH,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DH;
}
extern "C" {
    pub fn i2d_DHxparams(
        a: *const DH,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DHparams_print_fp(fp: *mut FILE, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DHparams_print(bp: *mut BIO, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get_1024_160() -> *mut DH;
}
extern "C" {
    pub fn DH_get_2048_224() -> *mut DH;
}
extern "C" {
    pub fn DH_get_2048_256() -> *mut DH;
}
extern "C" {
    pub fn DH_new_by_nid(nid: ::std::os::raw::c_int) -> *mut DH;
}
extern "C" {
    pub fn DH_get_nid(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_KDF_X9_42(
        out: *mut ::std::os::raw::c_uchar,
        outlen: size_t,
        Z: *const ::std::os::raw::c_uchar,
        Zlen: size_t,
        key_oid: *mut ASN1_OBJECT,
        ukm: *const ::std::os::raw::c_uchar,
        ukmlen: size_t,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get0_pqg(
        dh: *const DH,
        p: *mut *const BIGNUM,
        q: *mut *const BIGNUM,
        g: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DH_set0_pqg(
        dh: *mut DH,
        p: *mut BIGNUM,
        q: *mut BIGNUM,
        g: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get0_key(dh: *const DH, pub_key: *mut *const BIGNUM, priv_key: *mut *const BIGNUM);
}
extern "C" {
    pub fn DH_set0_key(
        dh: *mut DH,
        pub_key: *mut BIGNUM,
        priv_key: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get0_p(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_q(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_g(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_priv_key(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_pub_key(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_clear_flags(dh: *mut DH, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn DH_test_flags(dh: *const DH, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_set_flags(dh: *mut DH, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn DH_get0_engine(d: *mut DH) -> *mut ENGINE;
}
extern "C" {
    pub fn DH_get_length(dh: *const DH) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn DH_set_length(dh: *mut DH, length: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_new(
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut DH_METHOD;
}
extern "C" {
    pub fn DH_meth_free(dhm: *mut DH_METHOD);
}
extern "C" {
    pub fn DH_meth_dup(dhm: *const DH_METHOD) -> *mut DH_METHOD;
}
extern "C" {
    pub fn DH_meth_get0_name(dhm: *const DH_METHOD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DH_meth_set1_name(
        dhm: *mut DH_METHOD,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_get_flags(dhm: *const DH_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_set_flags(
        dhm: *mut DH_METHOD,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_get0_app_data(dhm: *const DH_METHOD) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DH_meth_set0_app_data(
        dhm: *mut DH_METHOD,
        app_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_get_generate_key(
        dhm: *const DH_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(dhm: *mut DH) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn DH_meth_set_generate_key(
        dhm: *mut DH_METHOD,
        generate_key: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut DH) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_get_compute_key(
        dhm: *const DH_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dhm: *mut ::std::os::raw::c_uchar,
            arg1: *const BIGNUM,
            arg2: *mut DH,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn DH_meth_set_compute_key(
        dhm: *mut DH_METHOD,
        compute_key: ::std::option::Option<
            unsafe extern "C" fn(
                key: *mut ::std::os::raw::c_uchar,
                pub_key: *const BIGNUM,
                dh: *mut DH,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_get_bn_mod_exp(
        dhm: *const DH_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dhm: *const DH,
            arg1: *mut BIGNUM,
            arg2: *const BIGNUM,
            arg3: *const BIGNUM,
            arg4: *const BIGNUM,
            arg5: *mut BN_CTX,
            arg6: *mut BN_MONT_CTX,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn DH_meth_set_bn_mod_exp(
        dhm: *mut DH_METHOD,
        bn_mod_exp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const DH,
                arg2: *mut BIGNUM,
                arg3: *const BIGNUM,
                arg4: *const BIGNUM,
                arg5: *const BIGNUM,
                arg6: *mut BN_CTX,
                arg7: *mut BN_MONT_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_get_init(
        dhm: *const DH_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(dhm: *mut DH) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn DH_meth_set_init(
        dhm: *mut DH_METHOD,
        init: ::std::option::Option<unsafe extern "C" fn(arg1: *mut DH) -> ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_get_finish(
        dhm: *const DH_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(dhm: *mut DH) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn DH_meth_set_finish(
        dhm: *mut DH_METHOD,
        finish: ::std::option::Option<unsafe extern "C" fn(arg1: *mut DH) -> ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_meth_get_generate_params(
        dhm: *const DH_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dhm: *mut DH,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut BN_GENCB,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn DH_meth_set_generate_params(
        dhm: *mut DH_METHOD,
        generate_params: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DH,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: *mut BN_GENCB,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_DSA_strings() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DSA_SIG_st {
    _unused: [u8; 0],
}
pub type DSA_SIG = DSA_SIG_st;
extern "C" {
    pub fn DSAparams_dup(x: *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn DSA_SIG_new() -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_SIG_free(a: *mut DSA_SIG);
}
extern "C" {
    pub fn i2d_DSA_SIG(
        a: *const DSA_SIG,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_SIG(
        v: *mut *mut DSA_SIG,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_SIG_get0(sig: *const DSA_SIG, pr: *mut *const BIGNUM, ps: *mut *const BIGNUM);
}
extern "C" {
    pub fn DSA_SIG_set0(sig: *mut DSA_SIG, r: *mut BIGNUM, s: *mut BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_do_sign(
        dgst: *const ::std::os::raw::c_uchar,
        dlen: ::std::os::raw::c_int,
        dsa: *mut DSA,
    ) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_do_verify(
        dgst: *const ::std::os::raw::c_uchar,
        dgst_len: ::std::os::raw::c_int,
        sig: *mut DSA_SIG,
        dsa: *mut DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_OpenSSL() -> *const DSA_METHOD;
}
extern "C" {
    pub fn DSA_set_default_method(arg1: *const DSA_METHOD);
}
extern "C" {
    pub fn DSA_get_default_method() -> *const DSA_METHOD;
}
extern "C" {
    pub fn DSA_set_method(dsa: *mut DSA, arg1: *const DSA_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get_method(d: *mut DSA) -> *const DSA_METHOD;
}
extern "C" {
    pub fn DSA_new() -> *mut DSA;
}
extern "C" {
    pub fn DSA_new_method(engine: *mut ENGINE) -> *mut DSA;
}
extern "C" {
    pub fn DSA_free(r: *mut DSA);
}
extern "C" {
    pub fn DSA_up_ref(r: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_size(arg1: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_bits(d: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_security_bits(d: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_sign_setup(
        dsa: *mut DSA,
        ctx_in: *mut BN_CTX,
        kinvp: *mut *mut BIGNUM,
        rp: *mut *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_sign(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dlen: ::std::os::raw::c_int,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        dsa: *mut DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_verify(
        type_: ::std::os::raw::c_int,
        dgst: *const ::std::os::raw::c_uchar,
        dgst_len: ::std::os::raw::c_int,
        sigbuf: *const ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_int,
        dsa: *mut DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_set_ex_data(
        d: *mut DSA,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get_ex_data(d: *mut DSA, idx: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn d2i_DSAPublicKey(
        a: *mut *mut DSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn d2i_DSAPrivateKey(
        a: *mut *mut DSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn d2i_DSAparams(
        a: *mut *mut DSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn DSA_generate_parameters(
        bits: ::std::os::raw::c_int,
        seed: *mut ::std::os::raw::c_uchar,
        seed_len: ::std::os::raw::c_int,
        counter_ret: *mut ::std::os::raw::c_int,
        h_ret: *mut ::std::os::raw::c_ulong,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn DSA_generate_parameters_ex(
        dsa: *mut DSA,
        bits: ::std::os::raw::c_int,
        seed: *const ::std::os::raw::c_uchar,
        seed_len: ::std::os::raw::c_int,
        counter_ret: *mut ::std::os::raw::c_int,
        h_ret: *mut ::std::os::raw::c_ulong,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_generate_key(a: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSAPublicKey(
        a: *const DSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSAPrivateKey(
        a: *const DSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSAparams(
        a: *const DSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSAparams_print(bp: *mut BIO, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_print(
        bp: *mut BIO,
        x: *const DSA,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSAparams_print_fp(fp: *mut FILE, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_print_fp(
        bp: *mut FILE,
        x: *const DSA,
        off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_dup_DH(r: *const DSA) -> *mut DH;
}
extern "C" {
    pub fn DSA_get0_pqg(
        d: *const DSA,
        p: *mut *const BIGNUM,
        q: *mut *const BIGNUM,
        g: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DSA_set0_pqg(
        d: *mut DSA,
        p: *mut BIGNUM,
        q: *mut BIGNUM,
        g: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get0_key(d: *const DSA, pub_key: *mut *const BIGNUM, priv_key: *mut *const BIGNUM);
}
extern "C" {
    pub fn DSA_set0_key(
        d: *mut DSA,
        pub_key: *mut BIGNUM,
        priv_key: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get0_p(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_q(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_g(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_pub_key(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_priv_key(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_clear_flags(d: *mut DSA, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn DSA_test_flags(d: *const DSA, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_set_flags(d: *mut DSA, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn DSA_get0_engine(d: *mut DSA) -> *mut ENGINE;
}
extern "C" {
    pub fn DSA_meth_new(
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut DSA_METHOD;
}
extern "C" {
    pub fn DSA_meth_free(dsam: *mut DSA_METHOD);
}
extern "C" {
    pub fn DSA_meth_dup(dsam: *const DSA_METHOD) -> *mut DSA_METHOD;
}
extern "C" {
    pub fn DSA_meth_get0_name(dsam: *const DSA_METHOD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn DSA_meth_set1_name(
        dsam: *mut DSA_METHOD,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_flags(dsam: *const DSA_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_set_flags(
        dsam: *mut DSA_METHOD,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get0_app_data(dsam: *const DSA_METHOD) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn DSA_meth_set0_app_data(
        dsam: *mut DSA_METHOD,
        app_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_sign(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dsam: *const ::std::os::raw::c_uchar,
            arg1: ::std::os::raw::c_int,
            arg2: *mut DSA,
        ) -> *mut DSA_SIG,
    >;
}
extern "C" {
    pub fn DSA_meth_set_sign(
        dsam: *mut DSA_METHOD,
        sign: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_uchar,
                arg2: ::std::os::raw::c_int,
                arg3: *mut DSA,
            ) -> *mut DSA_SIG,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_sign_setup(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dsam: *mut DSA,
            arg1: *mut BN_CTX,
            arg2: *mut *mut BIGNUM,
            arg3: *mut *mut BIGNUM,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_sign_setup(
        dsam: *mut DSA_METHOD,
        sign_setup: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DSA,
                arg2: *mut BN_CTX,
                arg3: *mut *mut BIGNUM,
                arg4: *mut *mut BIGNUM,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_verify(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dsam: *const ::std::os::raw::c_uchar,
            arg1: ::std::os::raw::c_int,
            arg2: *mut DSA_SIG,
            arg3: *mut DSA,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_verify(
        dsam: *mut DSA_METHOD,
        verify: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_uchar,
                arg2: ::std::os::raw::c_int,
                arg3: *mut DSA_SIG,
                arg4: *mut DSA,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_mod_exp(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dsam: *mut DSA,
            arg1: *mut BIGNUM,
            arg2: *const BIGNUM,
            arg3: *const BIGNUM,
            arg4: *const BIGNUM,
            arg5: *const BIGNUM,
            arg6: *const BIGNUM,
            arg7: *mut BN_CTX,
            arg8: *mut BN_MONT_CTX,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_mod_exp(
        dsam: *mut DSA_METHOD,
        mod_exp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DSA,
                arg2: *mut BIGNUM,
                arg3: *const BIGNUM,
                arg4: *const BIGNUM,
                arg5: *const BIGNUM,
                arg6: *const BIGNUM,
                arg7: *const BIGNUM,
                arg8: *mut BN_CTX,
                arg9: *mut BN_MONT_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_bn_mod_exp(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dsam: *mut DSA,
            arg1: *mut BIGNUM,
            arg2: *const BIGNUM,
            arg3: *const BIGNUM,
            arg4: *const BIGNUM,
            arg5: *mut BN_CTX,
            arg6: *mut BN_MONT_CTX,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_bn_mod_exp(
        dsam: *mut DSA_METHOD,
        bn_mod_exp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DSA,
                arg2: *mut BIGNUM,
                arg3: *const BIGNUM,
                arg4: *const BIGNUM,
                arg5: *const BIGNUM,
                arg6: *mut BN_CTX,
                arg7: *mut BN_MONT_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_init(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(dsam: *mut DSA) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn DSA_meth_set_init(
        dsam: *mut DSA_METHOD,
        init: ::std::option::Option<unsafe extern "C" fn(arg1: *mut DSA) -> ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_finish(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(dsam: *mut DSA) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn DSA_meth_set_finish(
        dsam: *mut DSA_METHOD,
        finish: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut DSA) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_paramgen(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            dsam: *mut DSA,
            arg1: ::std::os::raw::c_int,
            arg2: *const ::std::os::raw::c_uchar,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_ulong,
            arg6: *mut BN_GENCB,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_paramgen(
        dsam: *mut DSA_METHOD,
        paramgen: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DSA,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_uchar,
                arg4: ::std::os::raw::c_int,
                arg5: *mut ::std::os::raw::c_int,
                arg6: *mut ::std::os::raw::c_ulong,
                arg7: *mut BN_GENCB,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_meth_get_keygen(
        dsam: *const DSA_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(dsam: *mut DSA) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn DSA_meth_set_keygen(
        dsam: *mut DSA_METHOD,
        keygen: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut DSA) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHAstate_st {
    pub h0: ::std::os::raw::c_uint,
    pub h1: ::std::os::raw::c_uint,
    pub h2: ::std::os::raw::c_uint,
    pub h3: ::std::os::raw::c_uint,
    pub h4: ::std::os::raw::c_uint,
    pub Nl: ::std::os::raw::c_uint,
    pub Nh: ::std::os::raw::c_uint,
    pub data: [::std::os::raw::c_uint; 16usize],
    pub num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SHAstate_st() {
    assert_eq!(
        ::std::mem::size_of::<SHAstate_st>(),
        96usize,
        concat!("Size of: ", stringify!(SHAstate_st))
    );
    assert_eq!(
        ::std::mem::align_of::<SHAstate_st>(),
        4usize,
        concat!("Alignment of ", stringify!(SHAstate_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).h4 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(h4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).Nl as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).Nh as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).data as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHAstate_st>())).num as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(SHAstate_st),
            "::",
            stringify!(num)
        )
    );
}
pub type SHA_CTX = SHAstate_st;
extern "C" {
    pub fn SHA1_Init(c: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Update(
        c: *mut SHA_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Final(md: *mut ::std::os::raw::c_uchar, c: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1(
        d: *const ::std::os::raw::c_uchar,
        n: size_t,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA1_Transform(c: *mut SHA_CTX, data: *const ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHA256state_st {
    pub h: [::std::os::raw::c_uint; 8usize],
    pub Nl: ::std::os::raw::c_uint,
    pub Nh: ::std::os::raw::c_uint,
    pub data: [::std::os::raw::c_uint; 16usize],
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SHA256state_st() {
    assert_eq!(
        ::std::mem::size_of::<SHA256state_st>(),
        112usize,
        concat!("Size of: ", stringify!(SHA256state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<SHA256state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(SHA256state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).Nl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).Nh as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).num as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA256state_st>())).md_len as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA256state_st),
            "::",
            stringify!(md_len)
        )
    );
}
pub type SHA256_CTX = SHA256state_st;
extern "C" {
    pub fn SHA224_Init(c: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224_Update(
        c: *mut SHA256_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224_Final(
        md: *mut ::std::os::raw::c_uchar,
        c: *mut SHA256_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224(
        d: *const ::std::os::raw::c_uchar,
        n: size_t,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA256_Init(c: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Update(
        c: *mut SHA256_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Final(
        md: *mut ::std::os::raw::c_uchar,
        c: *mut SHA256_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256(
        d: *const ::std::os::raw::c_uchar,
        n: size_t,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA256_Transform(c: *mut SHA256_CTX, data: *const ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHA512state_st {
    pub h: [::std::os::raw::c_ulonglong; 8usize],
    pub Nl: ::std::os::raw::c_ulonglong,
    pub Nh: ::std::os::raw::c_ulonglong,
    pub u: SHA512state_st__bindgen_ty_1,
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SHA512state_st__bindgen_ty_1 {
    pub d: [::std::os::raw::c_ulonglong; 16usize],
    pub p: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_SHA512state_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SHA512state_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(SHA512state_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SHA512state_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SHA512state_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st__bindgen_ty_1>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_SHA512state_st() {
    assert_eq!(
        ::std::mem::size_of::<SHA512state_st>(),
        216usize,
        concat!("Size of: ", stringify!(SHA512state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<SHA512state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(SHA512state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).Nl as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).Nh as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).u as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).num as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHA512state_st>())).md_len as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(SHA512state_st),
            "::",
            stringify!(md_len)
        )
    );
}
pub type SHA512_CTX = SHA512state_st;
extern "C" {
    pub fn SHA384_Init(c: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384_Update(
        c: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384_Final(
        md: *mut ::std::os::raw::c_uchar,
        c: *mut SHA512_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384(
        d: *const ::std::os::raw::c_uchar,
        n: size_t,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA512_Init(c: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Update(
        c: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Final(
        md: *mut ::std::os::raw::c_uchar,
        c: *mut SHA512_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512(
        d: *const ::std::os::raw::c_uchar,
        n: size_t,
        md: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SHA512_Transform(c: *mut SHA512_CTX, data: *const ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn ERR_load_X509_strings() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_algor_st {
    pub algorithm: *mut ASN1_OBJECT,
    pub parameter: *mut ASN1_TYPE,
}
#[test]
fn bindgen_test_layout_X509_algor_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_algor_st>(),
        16usize,
        concat!("Size of: ", stringify!(X509_algor_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_algor_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_algor_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_algor_st>())).algorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_algor_st),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_algor_st>())).parameter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_algor_st),
            "::",
            stringify!(parameter)
        )
    );
}
pub type X509_ALGORS = stack_st_X509_ALGOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_val_st {
    pub notBefore: *mut ASN1_TIME,
    pub notAfter: *mut ASN1_TIME,
}
#[test]
fn bindgen_test_layout_X509_val_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_val_st>(),
        16usize,
        concat!("Size of: ", stringify!(X509_val_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_val_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_val_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_val_st>())).notBefore as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_val_st),
            "::",
            stringify!(notBefore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_val_st>())).notAfter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_val_st),
            "::",
            stringify!(notAfter)
        )
    );
}
pub type X509_VAL = X509_val_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_sig_st {
    _unused: [u8; 0],
}
pub type X509_SIG = X509_sig_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_entry_st {
    _unused: [u8; 0],
}
pub type X509_NAME_ENTRY = X509_name_entry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_NAME_ENTRY {
    _unused: [u8; 0],
}
pub type sk_X509_NAME_ENTRY_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_NAME_ENTRY,
        b: *const *const X509_NAME_ENTRY,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_NAME_ENTRY_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut X509_NAME_ENTRY)>;
pub type sk_X509_NAME_ENTRY_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_NAME_ENTRY) -> *mut X509_NAME_ENTRY>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_NAME {
    _unused: [u8; 0],
}
pub type sk_X509_NAME_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_NAME,
        b: *const *const X509_NAME,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_NAME_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut X509_NAME)>;
pub type sk_X509_NAME_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_NAME) -> *mut X509_NAME>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_extension_st {
    _unused: [u8; 0],
}
pub type X509_EXTENSION = X509_extension_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_EXTENSION {
    _unused: [u8; 0],
}
pub type X509_EXTENSIONS = stack_st_X509_EXTENSION;
pub type sk_X509_EXTENSION_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_EXTENSION,
        b: *const *const X509_EXTENSION,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_EXTENSION_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut X509_EXTENSION)>;
pub type sk_X509_EXTENSION_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_EXTENSION) -> *mut X509_EXTENSION>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_attributes_st {
    _unused: [u8; 0],
}
pub type X509_ATTRIBUTE = x509_attributes_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ATTRIBUTE {
    _unused: [u8; 0],
}
pub type sk_X509_ATTRIBUTE_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_ATTRIBUTE,
        b: *const *const X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_ATTRIBUTE_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut X509_ATTRIBUTE)>;
pub type sk_X509_ATTRIBUTE_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_ATTRIBUTE) -> *mut X509_ATTRIBUTE>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_req_info_st {
    _unused: [u8; 0],
}
pub type X509_REQ_INFO = X509_req_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_req_st {
    _unused: [u8; 0],
}
pub type X509_REQ = X509_req_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_cert_aux_st {
    _unused: [u8; 0],
}
pub type X509_CERT_AUX = x509_cert_aux_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_cinf_st {
    _unused: [u8; 0],
}
pub type X509_CINF = x509_cinf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509 {
    _unused: [u8; 0],
}
pub type sk_X509_compfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const *const X509, b: *const *const X509) -> ::std::os::raw::c_int,
>;
pub type sk_X509_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut X509)>;
pub type sk_X509_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509) -> *mut X509>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_trust_st {
    pub trust: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub check_trust: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut x509_trust_st,
            arg2: *mut X509,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: ::std::os::raw::c_int,
    pub arg2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_x509_trust_st() {
    assert_eq!(
        ::std::mem::size_of::<x509_trust_st>(),
        40usize,
        concat!("Size of: ", stringify!(x509_trust_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_trust_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_trust_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).trust as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).check_trust as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(check_trust)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).arg1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x509_trust_st>())).arg2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(arg2)
        )
    );
}
pub type X509_TRUST = x509_trust_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_TRUST {
    _unused: [u8; 0],
}
pub type sk_X509_TRUST_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_TRUST,
        b: *const *const X509_TRUST,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_TRUST_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut X509_TRUST)>;
pub type sk_X509_TRUST_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_TRUST) -> *mut X509_TRUST>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_REVOKED {
    _unused: [u8; 0],
}
pub type sk_X509_REVOKED_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_REVOKED,
        b: *const *const X509_REVOKED,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_REVOKED_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut X509_REVOKED)>;
pub type sk_X509_REVOKED_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_REVOKED) -> *mut X509_REVOKED>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_crl_info_st {
    _unused: [u8; 0],
}
pub type X509_CRL_INFO = X509_crl_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_CRL {
    _unused: [u8; 0],
}
pub type sk_X509_CRL_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_CRL,
        b: *const *const X509_CRL,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_CRL_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut X509_CRL)>;
pub type sk_X509_CRL_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_CRL) -> *mut X509_CRL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct private_key_st {
    pub version: ::std::os::raw::c_int,
    pub enc_algor: *mut X509_ALGOR,
    pub enc_pkey: *mut ASN1_OCTET_STRING,
    pub dec_pkey: *mut EVP_PKEY,
    pub key_length: ::std::os::raw::c_int,
    pub key_data: *mut ::std::os::raw::c_char,
    pub key_free: ::std::os::raw::c_int,
    pub cipher: EVP_CIPHER_INFO,
}
#[test]
fn bindgen_test_layout_private_key_st() {
    assert_eq!(
        ::std::mem::size_of::<private_key_st>(),
        80usize,
        concat!("Size of: ", stringify!(private_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<private_key_st>(),
        8usize,
        concat!("Alignment of ", stringify!(private_key_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).enc_algor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(enc_algor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).enc_pkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(enc_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).dec_pkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(dec_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).key_length as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(key_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).key_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(key_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).key_free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(key_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<private_key_st>())).cipher as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(cipher)
        )
    );
}
pub type X509_PKEY = private_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_info_st {
    pub x509: *mut X509,
    pub crl: *mut X509_CRL,
    pub x_pkey: *mut X509_PKEY,
    pub enc_cipher: EVP_CIPHER_INFO,
    pub enc_len: ::std::os::raw::c_int,
    pub enc_data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_X509_info_st() {
    assert_eq!(
        ::std::mem::size_of::<X509_info_st>(),
        64usize,
        concat!("Size of: ", stringify!(X509_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).x509 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).crl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).x_pkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(x_pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).enc_cipher as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).enc_len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<X509_info_st>())).enc_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_data)
        )
    );
}
pub type X509_INFO = X509_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_INFO {
    _unused: [u8; 0],
}
pub type sk_X509_INFO_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_INFO,
        b: *const *const X509_INFO,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_INFO_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut X509_INFO)>;
pub type sk_X509_INFO_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_INFO) -> *mut X509_INFO>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_spkac_st {
    pub pubkey: *mut X509_PUBKEY,
    pub challenge: *mut ASN1_IA5STRING,
}
#[test]
fn bindgen_test_layout_Netscape_spkac_st() {
    assert_eq!(
        ::std::mem::size_of::<Netscape_spkac_st>(),
        16usize,
        concat!("Size of: ", stringify!(Netscape_spkac_st))
    );
    assert_eq!(
        ::std::mem::align_of::<Netscape_spkac_st>(),
        8usize,
        concat!("Alignment of ", stringify!(Netscape_spkac_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spkac_st>())).pubkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spkac_st),
            "::",
            stringify!(pubkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spkac_st>())).challenge as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spkac_st),
            "::",
            stringify!(challenge)
        )
    );
}
pub type NETSCAPE_SPKAC = Netscape_spkac_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_spki_st {
    pub spkac: *mut NETSCAPE_SPKAC,
    pub sig_algor: X509_ALGOR,
    pub signature: *mut ASN1_BIT_STRING,
}
#[test]
fn bindgen_test_layout_Netscape_spki_st() {
    assert_eq!(
        ::std::mem::size_of::<Netscape_spki_st>(),
        32usize,
        concat!("Size of: ", stringify!(Netscape_spki_st))
    );
    assert_eq!(
        ::std::mem::align_of::<Netscape_spki_st>(),
        8usize,
        concat!("Alignment of ", stringify!(Netscape_spki_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spki_st>())).spkac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(spkac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spki_st>())).sig_algor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(sig_algor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Netscape_spki_st>())).signature as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(signature)
        )
    );
}
pub type NETSCAPE_SPKI = Netscape_spki_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_certificate_sequence {
    pub type_: *mut ASN1_OBJECT,
    pub certs: *mut stack_st_X509,
}
#[test]
fn bindgen_test_layout_Netscape_certificate_sequence() {
    assert_eq!(
        ::std::mem::size_of::<Netscape_certificate_sequence>(),
        16usize,
        concat!("Size of: ", stringify!(Netscape_certificate_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<Netscape_certificate_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(Netscape_certificate_sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Netscape_certificate_sequence>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_certificate_sequence),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Netscape_certificate_sequence>())).certs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_certificate_sequence),
            "::",
            stringify!(certs)
        )
    );
}
pub type NETSCAPE_CERT_SEQUENCE = Netscape_certificate_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBEPARAM_st {
    pub salt: *mut ASN1_OCTET_STRING,
    pub iter: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_PBEPARAM_st() {
    assert_eq!(
        ::std::mem::size_of::<PBEPARAM_st>(),
        16usize,
        concat!("Size of: ", stringify!(PBEPARAM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<PBEPARAM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(PBEPARAM_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBEPARAM_st>())).salt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PBEPARAM_st),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBEPARAM_st>())).iter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PBEPARAM_st),
            "::",
            stringify!(iter)
        )
    );
}
pub type PBEPARAM = PBEPARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBE2PARAM_st {
    pub keyfunc: *mut X509_ALGOR,
    pub encryption: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_PBE2PARAM_st() {
    assert_eq!(
        ::std::mem::size_of::<PBE2PARAM_st>(),
        16usize,
        concat!("Size of: ", stringify!(PBE2PARAM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<PBE2PARAM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(PBE2PARAM_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBE2PARAM_st>())).keyfunc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PBE2PARAM_st),
            "::",
            stringify!(keyfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBE2PARAM_st>())).encryption as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PBE2PARAM_st),
            "::",
            stringify!(encryption)
        )
    );
}
pub type PBE2PARAM = PBE2PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBKDF2PARAM_st {
    pub salt: *mut ASN1_TYPE,
    pub iter: *mut ASN1_INTEGER,
    pub keylength: *mut ASN1_INTEGER,
    pub prf: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_PBKDF2PARAM_st() {
    assert_eq!(
        ::std::mem::size_of::<PBKDF2PARAM_st>(),
        32usize,
        concat!("Size of: ", stringify!(PBKDF2PARAM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<PBKDF2PARAM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(PBKDF2PARAM_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBKDF2PARAM_st>())).salt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PBKDF2PARAM_st),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBKDF2PARAM_st>())).iter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PBKDF2PARAM_st),
            "::",
            stringify!(iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBKDF2PARAM_st>())).keylength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PBKDF2PARAM_st),
            "::",
            stringify!(keylength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PBKDF2PARAM_st>())).prf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PBKDF2PARAM_st),
            "::",
            stringify!(prf)
        )
    );
}
pub type PBKDF2PARAM = PBKDF2PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCRYPT_PARAMS_st {
    pub salt: *mut ASN1_OCTET_STRING,
    pub costParameter: *mut ASN1_INTEGER,
    pub blockSize: *mut ASN1_INTEGER,
    pub parallelizationParameter: *mut ASN1_INTEGER,
    pub keyLength: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_SCRYPT_PARAMS_st() {
    assert_eq!(
        ::std::mem::size_of::<SCRYPT_PARAMS_st>(),
        40usize,
        concat!("Size of: ", stringify!(SCRYPT_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<SCRYPT_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(SCRYPT_PARAMS_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCRYPT_PARAMS_st>())).salt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCRYPT_PARAMS_st),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCRYPT_PARAMS_st>())).costParameter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCRYPT_PARAMS_st),
            "::",
            stringify!(costParameter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCRYPT_PARAMS_st>())).blockSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCRYPT_PARAMS_st),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SCRYPT_PARAMS_st>())).parallelizationParameter as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCRYPT_PARAMS_st),
            "::",
            stringify!(parallelizationParameter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCRYPT_PARAMS_st>())).keyLength as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SCRYPT_PARAMS_st),
            "::",
            stringify!(keyLength)
        )
    );
}
pub type SCRYPT_PARAMS = SCRYPT_PARAMS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_node_st {
    _unused: [u8; 0],
}
pub type OPENSSL_LH_NODE = lhash_node_st;
pub type OPENSSL_LH_COMPFUNC = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type OPENSSL_LH_HASHFUNC = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_ulong,
>;
pub type OPENSSL_LH_DOALL_FUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type OPENSSL_LH_DOALL_FUNCARG = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st {
    _unused: [u8; 0],
}
pub type OPENSSL_LHASH = lhash_st;
extern "C" {
    pub fn OPENSSL_LH_error(lh: *mut OPENSSL_LHASH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_LH_new(h: OPENSSL_LH_HASHFUNC, c: OPENSSL_LH_COMPFUNC) -> *mut OPENSSL_LHASH;
}
extern "C" {
    pub fn OPENSSL_LH_free(lh: *mut OPENSSL_LHASH);
}
extern "C" {
    pub fn OPENSSL_LH_insert(
        lh: *mut OPENSSL_LHASH,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_LH_delete(
        lh: *mut OPENSSL_LHASH,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_LH_retrieve(
        lh: *mut OPENSSL_LHASH,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_LH_doall(lh: *mut OPENSSL_LHASH, func: OPENSSL_LH_DOALL_FUNC);
}
extern "C" {
    pub fn OPENSSL_LH_doall_arg(
        lh: *mut OPENSSL_LHASH,
        func: OPENSSL_LH_DOALL_FUNCARG,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn OPENSSL_LH_strhash(c: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn OPENSSL_LH_num_items(lh: *const OPENSSL_LHASH) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn OPENSSL_LH_get_down_load(lh: *const OPENSSL_LHASH) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn OPENSSL_LH_set_down_load(lh: *mut OPENSSL_LHASH, down_load: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn OPENSSL_LH_stats(lh: *const OPENSSL_LHASH, fp: *mut FILE);
}
extern "C" {
    pub fn OPENSSL_LH_node_stats(lh: *const OPENSSL_LHASH, fp: *mut FILE);
}
extern "C" {
    pub fn OPENSSL_LH_node_usage_stats(lh: *const OPENSSL_LHASH, fp: *mut FILE);
}
extern "C" {
    pub fn OPENSSL_LH_stats_bio(lh: *const OPENSSL_LHASH, out: *mut BIO);
}
extern "C" {
    pub fn OPENSSL_LH_node_stats_bio(lh: *const OPENSSL_LHASH, out: *mut BIO);
}
extern "C" {
    pub fn OPENSSL_LH_node_usage_stats_bio(lh: *const OPENSSL_LHASH, out: *mut BIO);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lhash_st_OPENSSL_STRING {
    pub dummy: lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy {
    pub d1: *mut ::std::os::raw::c_void,
    pub d2: ::std::os::raw::c_ulong,
    pub d3: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy>())).d1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy),
            "::",
            stringify!(d1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy>())).d2
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy),
            "::",
            stringify!(d2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy>())).d3
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy),
            "::",
            stringify!(d3)
        )
    );
}
#[test]
fn bindgen_test_layout_lhash_st_OPENSSL_STRING() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_OPENSSL_STRING>(),
        8usize,
        concat!("Size of: ", stringify!(lhash_st_OPENSSL_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_OPENSSL_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(lhash_st_OPENSSL_STRING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st_OPENSSL_STRING>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_STRING),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lhash_st_OPENSSL_CSTRING {
    pub dummy: lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy {
    pub d1: *mut ::std::os::raw::c_void,
    pub d2: ::std::os::raw::c_ulong,
    pub d3: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy>())).d1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy),
            "::",
            stringify!(d1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy>())).d2
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy),
            "::",
            stringify!(d2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy>())).d3
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy),
            "::",
            stringify!(d3)
        )
    );
}
#[test]
fn bindgen_test_layout_lhash_st_OPENSSL_CSTRING() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_OPENSSL_CSTRING>(),
        8usize,
        concat!("Size of: ", stringify!(lhash_st_OPENSSL_CSTRING))
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_OPENSSL_CSTRING>(),
        8usize,
        concat!("Alignment of ", stringify!(lhash_st_OPENSSL_CSTRING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st_OPENSSL_CSTRING>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_OPENSSL_CSTRING),
            "::",
            stringify!(dummy)
        )
    );
}
pub const X509_LOOKUP_TYPE_X509_LU_NONE: X509_LOOKUP_TYPE = 0;
pub const X509_LOOKUP_TYPE_X509_LU_X509: X509_LOOKUP_TYPE = 1;
pub const X509_LOOKUP_TYPE_X509_LU_CRL: X509_LOOKUP_TYPE = 2;
pub type X509_LOOKUP_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_LOOKUP {
    _unused: [u8; 0],
}
pub type sk_X509_LOOKUP_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_LOOKUP,
        b: *const *const X509_LOOKUP,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_LOOKUP_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut X509_LOOKUP)>;
pub type sk_X509_LOOKUP_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_LOOKUP) -> *mut X509_LOOKUP>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_OBJECT {
    _unused: [u8; 0],
}
pub type sk_X509_OBJECT_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_OBJECT,
        b: *const *const X509_OBJECT,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_OBJECT_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut X509_OBJECT)>;
pub type sk_X509_OBJECT_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const X509_OBJECT) -> *mut X509_OBJECT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_VERIFY_PARAM {
    _unused: [u8; 0],
}
pub type sk_X509_VERIFY_PARAM_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_VERIFY_PARAM,
        b: *const *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_VERIFY_PARAM_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut X509_VERIFY_PARAM)>;
pub type sk_X509_VERIFY_PARAM_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const X509_VERIFY_PARAM) -> *mut X509_VERIFY_PARAM,
>;
extern "C" {
    pub fn X509_STORE_set_depth(
        store: *mut X509_STORE,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type X509_STORE_CTX_verify_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut X509_STORE_CTX,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_STORE_CTX_verify_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_STORE_CTX) -> ::std::os::raw::c_int>;
pub type X509_STORE_CTX_get_issuer_fn = ::std::option::Option<
    unsafe extern "C" fn(
        issuer: *mut *mut X509,
        ctx: *mut X509_STORE_CTX,
        x: *mut X509,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_STORE_CTX_check_issued_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_STORE_CTX,
        x: *mut X509,
        issuer: *mut X509,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_STORE_CTX_check_revocation_fn =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int>;
pub type X509_STORE_CTX_get_crl_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_STORE_CTX,
        crl: *mut *mut X509_CRL,
        x: *mut X509,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_STORE_CTX_check_crl_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, crl: *mut X509_CRL) -> ::std::os::raw::c_int,
>;
pub type X509_STORE_CTX_cert_crl_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_STORE_CTX,
        crl: *mut X509_CRL,
        x: *mut X509,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_STORE_CTX_check_policy_fn =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int>;
pub type X509_STORE_CTX_lookup_certs_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, nm: *mut X509_NAME) -> *mut stack_st_X509,
>;
pub type X509_STORE_CTX_lookup_crls_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, nm: *mut X509_NAME) -> *mut stack_st_X509_CRL,
>;
pub type X509_STORE_CTX_cleanup_fn =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn X509_STORE_CTX_set_depth(ctx: *mut X509_STORE_CTX, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_OBJECT_idx_by_subject(
        h: *mut stack_st_X509_OBJECT,
        type_: X509_LOOKUP_TYPE,
        name: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_OBJECT_retrieve_by_subject(
        h: *mut stack_st_X509_OBJECT,
        type_: X509_LOOKUP_TYPE,
        name: *mut X509_NAME,
    ) -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_retrieve_match(
        h: *mut stack_st_X509_OBJECT,
        x: *mut X509_OBJECT,
    ) -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_up_ref_count(a: *mut X509_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_OBJECT_new() -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_free(a: *mut X509_OBJECT);
}
extern "C" {
    pub fn X509_OBJECT_get_type(a: *const X509_OBJECT) -> X509_LOOKUP_TYPE;
}
extern "C" {
    pub fn X509_OBJECT_get0_X509(a: *const X509_OBJECT) -> *mut X509;
}
extern "C" {
    pub fn X509_OBJECT_set1_X509(a: *mut X509_OBJECT, obj: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_OBJECT_get0_X509_CRL(a: *mut X509_OBJECT) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_OBJECT_set1_X509_CRL(
        a: *mut X509_OBJECT,
        obj: *mut X509_CRL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_new() -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_STORE_free(v: *mut X509_STORE);
}
extern "C" {
    pub fn X509_STORE_lock(ctx: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_unlock(ctx: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_up_ref(v: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_get0_objects(v: *mut X509_STORE) -> *mut stack_st_X509_OBJECT;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_certs(
        st: *mut X509_STORE_CTX,
        nm: *mut X509_NAME,
    ) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_crls(
        st: *mut X509_STORE_CTX,
        nm: *mut X509_NAME,
    ) -> *mut stack_st_X509_CRL;
}
extern "C" {
    pub fn X509_STORE_set_flags(
        ctx: *mut X509_STORE,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_purpose(
        ctx: *mut X509_STORE,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_trust(
        ctx: *mut X509_STORE,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set1_param(
        ctx: *mut X509_STORE,
        pm: *mut X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_get0_param(ctx: *mut X509_STORE) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_STORE_set_verify(ctx: *mut X509_STORE, verify: X509_STORE_CTX_verify_fn);
}
extern "C" {
    pub fn X509_STORE_CTX_set_verify(ctx: *mut X509_STORE_CTX, verify: X509_STORE_CTX_verify_fn);
}
extern "C" {
    pub fn X509_STORE_get_verify(ctx: *mut X509_STORE) -> X509_STORE_CTX_verify_fn;
}
extern "C" {
    pub fn X509_STORE_set_verify_cb(ctx: *mut X509_STORE, verify_cb: X509_STORE_CTX_verify_cb);
}
extern "C" {
    pub fn X509_STORE_get_verify_cb(ctx: *mut X509_STORE) -> X509_STORE_CTX_verify_cb;
}
extern "C" {
    pub fn X509_STORE_set_get_issuer(
        ctx: *mut X509_STORE,
        get_issuer: X509_STORE_CTX_get_issuer_fn,
    );
}
extern "C" {
    pub fn X509_STORE_get_get_issuer(ctx: *mut X509_STORE) -> X509_STORE_CTX_get_issuer_fn;
}
extern "C" {
    pub fn X509_STORE_set_check_issued(
        ctx: *mut X509_STORE,
        check_issued: X509_STORE_CTX_check_issued_fn,
    );
}
extern "C" {
    pub fn X509_STORE_get_check_issued(ctx: *mut X509_STORE) -> X509_STORE_CTX_check_issued_fn;
}
extern "C" {
    pub fn X509_STORE_set_check_revocation(
        ctx: *mut X509_STORE,
        check_revocation: X509_STORE_CTX_check_revocation_fn,
    );
}
extern "C" {
    pub fn X509_STORE_get_check_revocation(
        ctx: *mut X509_STORE,
    ) -> X509_STORE_CTX_check_revocation_fn;
}
extern "C" {
    pub fn X509_STORE_set_get_crl(ctx: *mut X509_STORE, get_crl: X509_STORE_CTX_get_crl_fn);
}
extern "C" {
    pub fn X509_STORE_get_get_crl(ctx: *mut X509_STORE) -> X509_STORE_CTX_get_crl_fn;
}
extern "C" {
    pub fn X509_STORE_set_check_crl(ctx: *mut X509_STORE, check_crl: X509_STORE_CTX_check_crl_fn);
}
extern "C" {
    pub fn X509_STORE_get_check_crl(ctx: *mut X509_STORE) -> X509_STORE_CTX_check_crl_fn;
}
extern "C" {
    pub fn X509_STORE_set_cert_crl(ctx: *mut X509_STORE, cert_crl: X509_STORE_CTX_cert_crl_fn);
}
extern "C" {
    pub fn X509_STORE_get_cert_crl(ctx: *mut X509_STORE) -> X509_STORE_CTX_cert_crl_fn;
}
extern "C" {
    pub fn X509_STORE_set_check_policy(
        ctx: *mut X509_STORE,
        check_policy: X509_STORE_CTX_check_policy_fn,
    );
}
extern "C" {
    pub fn X509_STORE_get_check_policy(ctx: *mut X509_STORE) -> X509_STORE_CTX_check_policy_fn;
}
extern "C" {
    pub fn X509_STORE_set_lookup_certs(
        ctx: *mut X509_STORE,
        lookup_certs: X509_STORE_CTX_lookup_certs_fn,
    );
}
extern "C" {
    pub fn X509_STORE_get_lookup_certs(ctx: *mut X509_STORE) -> X509_STORE_CTX_lookup_certs_fn;
}
extern "C" {
    pub fn X509_STORE_set_lookup_crls(
        ctx: *mut X509_STORE,
        lookup_crls: X509_STORE_CTX_lookup_crls_fn,
    );
}
extern "C" {
    pub fn X509_STORE_get_lookup_crls(ctx: *mut X509_STORE) -> X509_STORE_CTX_lookup_crls_fn;
}
extern "C" {
    pub fn X509_STORE_set_cleanup(ctx: *mut X509_STORE, cleanup: X509_STORE_CTX_cleanup_fn);
}
extern "C" {
    pub fn X509_STORE_get_cleanup(ctx: *mut X509_STORE) -> X509_STORE_CTX_cleanup_fn;
}
extern "C" {
    pub fn X509_STORE_set_ex_data(
        ctx: *mut X509_STORE,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_get_ex_data(
        ctx: *mut X509_STORE,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_STORE_CTX_new() -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_issuer(
        issuer: *mut *mut X509,
        ctx: *mut X509_STORE_CTX,
        x: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_free(ctx: *mut X509_STORE_CTX);
}
extern "C" {
    pub fn X509_STORE_CTX_init(
        ctx: *mut X509_STORE_CTX,
        store: *mut X509_STORE,
        x509: *mut X509,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_trusted_stack(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_cleanup(ctx: *mut X509_STORE_CTX);
}
extern "C" {
    pub fn X509_STORE_CTX_get0_store(ctx: *mut X509_STORE_CTX) -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_cert(ctx: *mut X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_untrusted(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_untrusted(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_set_verify_cb(ctx: *mut X509_STORE_CTX, verify: X509_STORE_CTX_verify_cb);
}
extern "C" {
    pub fn X509_STORE_CTX_get_verify_cb(ctx: *mut X509_STORE_CTX) -> X509_STORE_CTX_verify_cb;
}
extern "C" {
    pub fn X509_STORE_CTX_get_verify(ctx: *mut X509_STORE_CTX) -> X509_STORE_CTX_verify_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_get_issuer(ctx: *mut X509_STORE_CTX) -> X509_STORE_CTX_get_issuer_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_check_issued(
        ctx: *mut X509_STORE_CTX,
    ) -> X509_STORE_CTX_check_issued_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_check_revocation(
        ctx: *mut X509_STORE_CTX,
    ) -> X509_STORE_CTX_check_revocation_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_get_crl(ctx: *mut X509_STORE_CTX) -> X509_STORE_CTX_get_crl_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_check_crl(ctx: *mut X509_STORE_CTX) -> X509_STORE_CTX_check_crl_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_cert_crl(ctx: *mut X509_STORE_CTX) -> X509_STORE_CTX_cert_crl_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_check_policy(
        ctx: *mut X509_STORE_CTX,
    ) -> X509_STORE_CTX_check_policy_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_lookup_certs(
        ctx: *mut X509_STORE_CTX,
    ) -> X509_STORE_CTX_lookup_certs_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_lookup_crls(
        ctx: *mut X509_STORE_CTX,
    ) -> X509_STORE_CTX_lookup_crls_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_cleanup(ctx: *mut X509_STORE_CTX) -> X509_STORE_CTX_cleanup_fn;
}
extern "C" {
    pub fn X509_STORE_add_lookup(
        v: *mut X509_STORE,
        m: *mut X509_LOOKUP_METHOD,
    ) -> *mut X509_LOOKUP;
}
extern "C" {
    pub fn X509_LOOKUP_hash_dir() -> *mut X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_LOOKUP_file() -> *mut X509_LOOKUP_METHOD;
}
pub type X509_LOOKUP_ctrl_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        cmd: ::std::os::raw::c_int,
        argc: *const ::std::os::raw::c_char,
        argl: ::std::os::raw::c_long,
        ret: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_LOOKUP_get_by_subject_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *mut X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_LOOKUP_get_by_issuer_serial_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *mut X509_NAME,
        serial: *mut ASN1_INTEGER,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_LOOKUP_get_by_fingerprint_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_LOOKUP_get_by_alias_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn X509_LOOKUP_meth_new(name: *const ::std::os::raw::c_char) -> *mut X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_LOOKUP_meth_free(method: *mut X509_LOOKUP_METHOD);
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_new_item(
        method: *mut X509_LOOKUP_METHOD,
        new_item: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_new_item(
        method: *const X509_LOOKUP_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(method: *mut X509_LOOKUP) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_free(
        method: *mut X509_LOOKUP_METHOD,
        free_fn: ::std::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_free(
        method: *const X509_LOOKUP_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(method: *mut X509_LOOKUP)>;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_init(
        method: *mut X509_LOOKUP_METHOD,
        init: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_init(
        method: *const X509_LOOKUP_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(method: *mut X509_LOOKUP) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_shutdown(
        method: *mut X509_LOOKUP_METHOD,
        shutdown: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_shutdown(
        method: *const X509_LOOKUP_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(method: *mut X509_LOOKUP) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_ctrl(
        method: *mut X509_LOOKUP_METHOD,
        ctrl_fn: X509_LOOKUP_ctrl_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_ctrl(method: *const X509_LOOKUP_METHOD) -> X509_LOOKUP_ctrl_fn;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_get_by_subject(
        method: *mut X509_LOOKUP_METHOD,
        fn_: X509_LOOKUP_get_by_subject_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_get_by_subject(
        method: *const X509_LOOKUP_METHOD,
    ) -> X509_LOOKUP_get_by_subject_fn;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_get_by_issuer_serial(
        method: *mut X509_LOOKUP_METHOD,
        fn_: X509_LOOKUP_get_by_issuer_serial_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_get_by_issuer_serial(
        method: *const X509_LOOKUP_METHOD,
    ) -> X509_LOOKUP_get_by_issuer_serial_fn;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_get_by_fingerprint(
        method: *mut X509_LOOKUP_METHOD,
        fn_: X509_LOOKUP_get_by_fingerprint_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_get_by_fingerprint(
        method: *const X509_LOOKUP_METHOD,
    ) -> X509_LOOKUP_get_by_fingerprint_fn;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_get_by_alias(
        method: *mut X509_LOOKUP_METHOD,
        fn_: X509_LOOKUP_get_by_alias_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_get_by_alias(
        method: *const X509_LOOKUP_METHOD,
    ) -> X509_LOOKUP_get_by_alias_fn;
}
extern "C" {
    pub fn X509_STORE_add_cert(ctx: *mut X509_STORE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_add_crl(ctx: *mut X509_STORE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_by_subject(
        vs: *mut X509_STORE_CTX,
        type_: X509_LOOKUP_TYPE,
        name: *mut X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_obj_by_subject(
        vs: *mut X509_STORE_CTX,
        type_: X509_LOOKUP_TYPE,
        name: *mut X509_NAME,
    ) -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_LOOKUP_ctrl(
        ctx: *mut X509_LOOKUP,
        cmd: ::std::os::raw::c_int,
        argc: *const ::std::os::raw::c_char,
        argl: ::std::os::raw::c_long,
        ret: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_cert_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_crl_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_cert_crl_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_new(method: *mut X509_LOOKUP_METHOD) -> *mut X509_LOOKUP;
}
extern "C" {
    pub fn X509_LOOKUP_free(ctx: *mut X509_LOOKUP);
}
extern "C" {
    pub fn X509_LOOKUP_init(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_subject(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *mut X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_issuer_serial(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *mut X509_NAME,
        serial: *mut ASN1_INTEGER,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_fingerprint(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_alias(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_set_method_data(
        ctx: *mut X509_LOOKUP,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_get_method_data(ctx: *const X509_LOOKUP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_LOOKUP_get_store(ctx: *const X509_LOOKUP) -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_LOOKUP_shutdown(ctx: *mut X509_LOOKUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_load_locations(
        ctx: *mut X509_STORE,
        file: *const ::std::os::raw::c_char,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_default_paths(ctx: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_ex_data(
        ctx: *mut X509_STORE_CTX,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_ex_data(
        ctx: *mut X509_STORE_CTX,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_STORE_CTX_get_error(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_error(ctx: *mut X509_STORE_CTX, s: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_STORE_CTX_get_error_depth(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_error_depth(ctx: *mut X509_STORE_CTX, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_STORE_CTX_get_current_cert(ctx: *mut X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set_current_cert(ctx: *mut X509_STORE_CTX, x: *mut X509);
}
extern "C" {
    pub fn X509_STORE_CTX_get0_current_issuer(ctx: *mut X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_current_crl(ctx: *mut X509_STORE_CTX) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_parent_ctx(ctx: *mut X509_STORE_CTX) -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_chain(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_chain(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set_cert(c: *mut X509_STORE_CTX, x: *mut X509);
}
extern "C" {
    pub fn X509_STORE_CTX_set0_verified_chain(c: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_set0_crls(c: *mut X509_STORE_CTX, sk: *mut stack_st_X509_CRL);
}
extern "C" {
    pub fn X509_STORE_CTX_set_purpose(
        ctx: *mut X509_STORE_CTX,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_trust(
        ctx: *mut X509_STORE_CTX,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_purpose_inherit(
        ctx: *mut X509_STORE_CTX,
        def_purpose: ::std::os::raw::c_int,
        purpose: ::std::os::raw::c_int,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_flags(ctx: *mut X509_STORE_CTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn X509_STORE_CTX_set_time(
        ctx: *mut X509_STORE_CTX,
        flags: ::std::os::raw::c_ulong,
        t: time_t,
    );
}
extern "C" {
    pub fn X509_STORE_CTX_get0_policy_tree(ctx: *mut X509_STORE_CTX) -> *mut X509_POLICY_TREE;
}
extern "C" {
    pub fn X509_STORE_CTX_get_explicit_policy(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_num_untrusted(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_param(ctx: *mut X509_STORE_CTX) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_param(ctx: *mut X509_STORE_CTX, param: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_STORE_CTX_set_default(
        ctx: *mut X509_STORE_CTX,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_dane(ctx: *mut X509_STORE_CTX, dane: *mut SSL_DANE);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_new() -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_free(param: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_inherit(
        to: *mut X509_VERIFY_PARAM,
        from: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1(
        to: *mut X509_VERIFY_PARAM,
        from: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_name(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_clear_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_flags(param: *mut X509_VERIFY_PARAM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_purpose(
        param: *mut X509_VERIFY_PARAM,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_trust(
        param: *mut X509_VERIFY_PARAM,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_depth(param: *mut X509_VERIFY_PARAM, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_auth_level(
        param: *mut X509_VERIFY_PARAM,
        auth_level: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_time(param: *const X509_VERIFY_PARAM) -> time_t;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_time(param: *mut X509_VERIFY_PARAM, t: time_t);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add0_policy(
        param: *mut X509_VERIFY_PARAM,
        policy: *mut ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_policies(
        param: *mut X509_VERIFY_PARAM,
        policies: *mut stack_st_ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_inh_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_inh_flags(param: *const X509_VERIFY_PARAM) -> u32;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_host(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::std::os::raw::c_char,
        namelen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add1_host(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::std::os::raw::c_char,
        namelen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_hostflags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_hostflags(
        param: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0_peername(
        arg1: *mut X509_VERIFY_PARAM,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_move_peername(
        arg1: *mut X509_VERIFY_PARAM,
        arg2: *mut X509_VERIFY_PARAM,
    );
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_email(
        param: *mut X509_VERIFY_PARAM,
        email: *const ::std::os::raw::c_char,
        emaillen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_ip(
        param: *mut X509_VERIFY_PARAM,
        ip: *const ::std::os::raw::c_uchar,
        iplen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_ip_asc(
        param: *mut X509_VERIFY_PARAM,
        ipasc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_depth(param: *const X509_VERIFY_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_auth_level(
        param: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0_name(
        param: *const X509_VERIFY_PARAM,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add0_table(param: *mut X509_VERIFY_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0(id: ::std::os::raw::c_int) -> *const X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_lookup(
        name: *const ::std::os::raw::c_char,
    ) -> *const X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_table_cleanup();
}
extern "C" {
    pub fn X509_policy_check(
        ptree: *mut *mut X509_POLICY_TREE,
        pexplicit_policy: *mut ::std::os::raw::c_int,
        certs: *mut stack_st_X509,
        policy_oids: *mut stack_st_ASN1_OBJECT,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_policy_tree_free(tree: *mut X509_POLICY_TREE);
}
extern "C" {
    pub fn X509_policy_tree_level_count(tree: *const X509_POLICY_TREE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_policy_tree_get0_level(
        tree: *const X509_POLICY_TREE,
        i: ::std::os::raw::c_int,
    ) -> *mut X509_POLICY_LEVEL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_POLICY_NODE {
    _unused: [u8; 0],
}
extern "C" {
    pub fn X509_policy_tree_get0_policies(
        tree: *const X509_POLICY_TREE,
    ) -> *mut stack_st_X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_tree_get0_user_policies(
        tree: *const X509_POLICY_TREE,
    ) -> *mut stack_st_X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_level_node_count(level: *mut X509_POLICY_LEVEL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_policy_level_get0_node(
        level: *mut X509_POLICY_LEVEL,
        i: ::std::os::raw::c_int,
    ) -> *mut X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_node_get0_policy(node: *const X509_POLICY_NODE) -> *const ASN1_OBJECT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_POLICYQUALINFO {
    _unused: [u8; 0],
}
extern "C" {
    pub fn X509_policy_node_get0_qualifiers(
        node: *const X509_POLICY_NODE,
    ) -> *mut stack_st_POLICYQUALINFO;
}
extern "C" {
    pub fn X509_policy_node_get0_parent(node: *const X509_POLICY_NODE) -> *const X509_POLICY_NODE;
}
extern "C" {
    pub fn ERR_load_PKCS7_strings() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_issuer_and_serial_st {
    pub issuer: *mut X509_NAME,
    pub serial: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_pkcs7_issuer_and_serial_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_issuer_and_serial_st>(),
        16usize,
        concat!("Size of: ", stringify!(pkcs7_issuer_and_serial_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_issuer_and_serial_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_issuer_and_serial_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_issuer_and_serial_st>())).issuer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_issuer_and_serial_st),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_issuer_and_serial_st>())).serial as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_issuer_and_serial_st),
            "::",
            stringify!(serial)
        )
    );
}
pub type PKCS7_ISSUER_AND_SERIAL = pkcs7_issuer_and_serial_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signer_info_st {
    pub version: *mut ASN1_INTEGER,
    pub issuer_and_serial: *mut PKCS7_ISSUER_AND_SERIAL,
    pub digest_alg: *mut X509_ALGOR,
    pub auth_attr: *mut stack_st_X509_ATTRIBUTE,
    pub digest_enc_alg: *mut X509_ALGOR,
    pub enc_digest: *mut ASN1_OCTET_STRING,
    pub unauth_attr: *mut stack_st_X509_ATTRIBUTE,
    pub pkey: *mut EVP_PKEY,
}
#[test]
fn bindgen_test_layout_pkcs7_signer_info_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_signer_info_st>(),
        64usize,
        concat!("Size of: ", stringify!(pkcs7_signer_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_signer_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_signer_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signer_info_st>())).issuer_and_serial as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(issuer_and_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).digest_alg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(digest_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).auth_attr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(auth_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signer_info_st>())).digest_enc_alg as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(digest_enc_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).enc_digest as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(enc_digest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signer_info_st>())).unauth_attr as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(unauth_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signer_info_st>())).pkey as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signer_info_st),
            "::",
            stringify!(pkey)
        )
    );
}
pub type PKCS7_SIGNER_INFO = pkcs7_signer_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7_SIGNER_INFO {
    _unused: [u8; 0],
}
pub type sk_PKCS7_SIGNER_INFO_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const PKCS7_SIGNER_INFO,
        b: *const *const PKCS7_SIGNER_INFO,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_PKCS7_SIGNER_INFO_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut PKCS7_SIGNER_INFO)>;
pub type sk_PKCS7_SIGNER_INFO_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const PKCS7_SIGNER_INFO) -> *mut PKCS7_SIGNER_INFO,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_recip_info_st {
    pub version: *mut ASN1_INTEGER,
    pub issuer_and_serial: *mut PKCS7_ISSUER_AND_SERIAL,
    pub key_enc_algor: *mut X509_ALGOR,
    pub enc_key: *mut ASN1_OCTET_STRING,
    pub cert: *mut X509,
}
#[test]
fn bindgen_test_layout_pkcs7_recip_info_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_recip_info_st>(),
        40usize,
        concat!("Size of: ", stringify!(pkcs7_recip_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_recip_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_recip_info_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_recip_info_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_recip_info_st>())).issuer_and_serial as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(issuer_and_serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_recip_info_st>())).key_enc_algor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(key_enc_algor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_recip_info_st>())).enc_key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(enc_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_recip_info_st>())).cert as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_recip_info_st),
            "::",
            stringify!(cert)
        )
    );
}
pub type PKCS7_RECIP_INFO = pkcs7_recip_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7_RECIP_INFO {
    _unused: [u8; 0],
}
pub type sk_PKCS7_RECIP_INFO_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const PKCS7_RECIP_INFO,
        b: *const *const PKCS7_RECIP_INFO,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_PKCS7_RECIP_INFO_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut PKCS7_RECIP_INFO)>;
pub type sk_PKCS7_RECIP_INFO_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const PKCS7_RECIP_INFO) -> *mut PKCS7_RECIP_INFO,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signed_st {
    pub version: *mut ASN1_INTEGER,
    pub md_algs: *mut stack_st_X509_ALGOR,
    pub cert: *mut stack_st_X509,
    pub crl: *mut stack_st_X509_CRL,
    pub signer_info: *mut stack_st_PKCS7_SIGNER_INFO,
    pub contents: *mut pkcs7_st,
}
#[test]
fn bindgen_test_layout_pkcs7_signed_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_signed_st>(),
        48usize,
        concat!("Size of: ", stringify!(pkcs7_signed_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_signed_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_signed_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).md_algs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(md_algs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).cert as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).crl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).signer_info as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(signer_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signed_st>())).contents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signed_st),
            "::",
            stringify!(contents)
        )
    );
}
pub type PKCS7_SIGNED = pkcs7_signed_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_enc_content_st {
    pub content_type: *mut ASN1_OBJECT,
    pub algorithm: *mut X509_ALGOR,
    pub enc_data: *mut ASN1_OCTET_STRING,
    pub cipher: *const EVP_CIPHER,
}
#[test]
fn bindgen_test_layout_pkcs7_enc_content_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_enc_content_st>(),
        32usize,
        concat!("Size of: ", stringify!(pkcs7_enc_content_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_enc_content_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_enc_content_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_enc_content_st>())).content_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enc_content_st),
            "::",
            stringify!(content_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enc_content_st>())).algorithm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enc_content_st),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enc_content_st>())).enc_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enc_content_st),
            "::",
            stringify!(enc_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enc_content_st>())).cipher as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enc_content_st),
            "::",
            stringify!(cipher)
        )
    );
}
pub type PKCS7_ENC_CONTENT = pkcs7_enc_content_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_enveloped_st {
    pub version: *mut ASN1_INTEGER,
    pub recipientinfo: *mut stack_st_PKCS7_RECIP_INFO,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
}
#[test]
fn bindgen_test_layout_pkcs7_enveloped_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_enveloped_st>(),
        24usize,
        concat!("Size of: ", stringify!(pkcs7_enveloped_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_enveloped_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_enveloped_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enveloped_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enveloped_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_enveloped_st>())).recipientinfo as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enveloped_st),
            "::",
            stringify!(recipientinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_enveloped_st>())).enc_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_enveloped_st),
            "::",
            stringify!(enc_data)
        )
    );
}
pub type PKCS7_ENVELOPE = pkcs7_enveloped_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signedandenveloped_st {
    pub version: *mut ASN1_INTEGER,
    pub md_algs: *mut stack_st_X509_ALGOR,
    pub cert: *mut stack_st_X509,
    pub crl: *mut stack_st_X509_CRL,
    pub signer_info: *mut stack_st_PKCS7_SIGNER_INFO,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
    pub recipientinfo: *mut stack_st_PKCS7_RECIP_INFO,
}
#[test]
fn bindgen_test_layout_pkcs7_signedandenveloped_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_signedandenveloped_st>(),
        56usize,
        concat!("Size of: ", stringify!(pkcs7_signedandenveloped_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_signedandenveloped_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_signedandenveloped_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).md_algs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(md_algs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).cert as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).crl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).signer_info as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(signer_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).enc_data as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(enc_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_signedandenveloped_st>())).recipientinfo as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_signedandenveloped_st),
            "::",
            stringify!(recipientinfo)
        )
    );
}
pub type PKCS7_SIGN_ENVELOPE = pkcs7_signedandenveloped_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_digest_st {
    pub version: *mut ASN1_INTEGER,
    pub md: *mut X509_ALGOR,
    pub contents: *mut pkcs7_st,
    pub digest: *mut ASN1_OCTET_STRING,
}
#[test]
fn bindgen_test_layout_pkcs7_digest_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_digest_st>(),
        32usize,
        concat!("Size of: ", stringify!(pkcs7_digest_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_digest_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_digest_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_digest_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_digest_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_digest_st>())).md as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_digest_st),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_digest_st>())).contents as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_digest_st),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_digest_st>())).digest as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_digest_st),
            "::",
            stringify!(digest)
        )
    );
}
pub type PKCS7_DIGEST = pkcs7_digest_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_encrypted_st {
    pub version: *mut ASN1_INTEGER,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
}
#[test]
fn bindgen_test_layout_pkcs7_encrypted_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_encrypted_st>(),
        16usize,
        concat!("Size of: ", stringify!(pkcs7_encrypted_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_encrypted_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_encrypted_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_encrypted_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_encrypted_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_encrypted_st>())).enc_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_encrypted_st),
            "::",
            stringify!(enc_data)
        )
    );
}
pub type PKCS7_ENCRYPT = pkcs7_encrypted_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pkcs7_st {
    pub asn1: *mut ::std::os::raw::c_uchar,
    pub length: ::std::os::raw::c_long,
    pub state: ::std::os::raw::c_int,
    pub detached: ::std::os::raw::c_int,
    pub type_: *mut ASN1_OBJECT,
    pub d: pkcs7_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pkcs7_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub data: *mut ASN1_OCTET_STRING,
    pub sign: *mut PKCS7_SIGNED,
    pub enveloped: *mut PKCS7_ENVELOPE,
    pub signed_and_enveloped: *mut PKCS7_SIGN_ENVELOPE,
    pub digest: *mut PKCS7_DIGEST,
    pub encrypted: *mut PKCS7_ENCRYPT,
    pub other: *mut ASN1_TYPE,
}
#[test]
fn bindgen_test_layout_pkcs7_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pkcs7_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).sign as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).enveloped as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(enveloped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).signed_and_enveloped as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(signed_and_enveloped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).encrypted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(encrypted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st__bindgen_ty_1>())).other as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st__bindgen_ty_1),
            "::",
            stringify!(other)
        )
    );
}
#[test]
fn bindgen_test_layout_pkcs7_st() {
    assert_eq!(
        ::std::mem::size_of::<pkcs7_st>(),
        40usize,
        concat!("Size of: ", stringify!(pkcs7_st))
    );
    assert_eq!(
        ::std::mem::align_of::<pkcs7_st>(),
        8usize,
        concat!("Alignment of ", stringify!(pkcs7_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).asn1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(asn1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).detached as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(detached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkcs7_st>())).d as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pkcs7_st),
            "::",
            stringify!(d)
        )
    );
}
pub type PKCS7 = pkcs7_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7 {
    _unused: [u8; 0],
}
pub type sk_PKCS7_compfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const *const PKCS7, b: *const *const PKCS7) -> ::std::os::raw::c_int,
>;
pub type sk_PKCS7_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut PKCS7)>;
pub type sk_PKCS7_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const PKCS7) -> *mut PKCS7>;
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_new() -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_free(a: *mut PKCS7_ISSUER_AND_SERIAL);
}
extern "C" {
    pub fn d2i_PKCS7_ISSUER_AND_SERIAL(
        a: *mut *mut PKCS7_ISSUER_AND_SERIAL,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn i2d_PKCS7_ISSUER_AND_SERIAL(
        a: *mut PKCS7_ISSUER_AND_SERIAL,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_ISSUER_AND_SERIAL_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_digest(
        data: *mut PKCS7_ISSUER_AND_SERIAL,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS7_fp(fp: *mut FILE, p7: *mut *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7_fp(fp: *mut FILE, p7: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_dup(p7: *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn d2i_PKCS7_bio(bp: *mut BIO, p7: *mut *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7_bio(bp: *mut BIO, p7: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS7_bio_stream(
        out: *mut BIO,
        p7: *mut PKCS7,
        in_: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS7_stream(
        out: *mut BIO,
        p7: *mut PKCS7,
        in_: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_new() -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_free(a: *mut PKCS7_SIGNER_INFO);
}
extern "C" {
    pub fn d2i_PKCS7_SIGNER_INFO(
        a: *mut *mut PKCS7_SIGNER_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn i2d_PKCS7_SIGNER_INFO(
        a: *mut PKCS7_SIGNER_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_SIGNER_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_new() -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_free(a: *mut PKCS7_RECIP_INFO);
}
extern "C" {
    pub fn d2i_PKCS7_RECIP_INFO(
        a: *mut *mut PKCS7_RECIP_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn i2d_PKCS7_RECIP_INFO(
        a: *mut PKCS7_RECIP_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_RECIP_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_SIGNED_new() -> *mut PKCS7_SIGNED;
}
extern "C" {
    pub fn PKCS7_SIGNED_free(a: *mut PKCS7_SIGNED);
}
extern "C" {
    pub fn d2i_PKCS7_SIGNED(
        a: *mut *mut PKCS7_SIGNED,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_SIGNED;
}
extern "C" {
    pub fn i2d_PKCS7_SIGNED(
        a: *mut PKCS7_SIGNED,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_SIGNED_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENC_CONTENT_new() -> *mut PKCS7_ENC_CONTENT;
}
extern "C" {
    pub fn PKCS7_ENC_CONTENT_free(a: *mut PKCS7_ENC_CONTENT);
}
extern "C" {
    pub fn d2i_PKCS7_ENC_CONTENT(
        a: *mut *mut PKCS7_ENC_CONTENT,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_ENC_CONTENT;
}
extern "C" {
    pub fn i2d_PKCS7_ENC_CONTENT(
        a: *mut PKCS7_ENC_CONTENT,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_ENC_CONTENT_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENVELOPE_new() -> *mut PKCS7_ENVELOPE;
}
extern "C" {
    pub fn PKCS7_ENVELOPE_free(a: *mut PKCS7_ENVELOPE);
}
extern "C" {
    pub fn d2i_PKCS7_ENVELOPE(
        a: *mut *mut PKCS7_ENVELOPE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_ENVELOPE;
}
extern "C" {
    pub fn i2d_PKCS7_ENVELOPE(
        a: *mut PKCS7_ENVELOPE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_ENVELOPE_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_SIGN_ENVELOPE_new() -> *mut PKCS7_SIGN_ENVELOPE;
}
extern "C" {
    pub fn PKCS7_SIGN_ENVELOPE_free(a: *mut PKCS7_SIGN_ENVELOPE);
}
extern "C" {
    pub fn d2i_PKCS7_SIGN_ENVELOPE(
        a: *mut *mut PKCS7_SIGN_ENVELOPE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_SIGN_ENVELOPE;
}
extern "C" {
    pub fn i2d_PKCS7_SIGN_ENVELOPE(
        a: *mut PKCS7_SIGN_ENVELOPE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_SIGN_ENVELOPE_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_DIGEST_new() -> *mut PKCS7_DIGEST;
}
extern "C" {
    pub fn PKCS7_DIGEST_free(a: *mut PKCS7_DIGEST);
}
extern "C" {
    pub fn d2i_PKCS7_DIGEST(
        a: *mut *mut PKCS7_DIGEST,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_DIGEST;
}
extern "C" {
    pub fn i2d_PKCS7_DIGEST(
        a: *mut PKCS7_DIGEST,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_DIGEST_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENCRYPT_new() -> *mut PKCS7_ENCRYPT;
}
extern "C" {
    pub fn PKCS7_ENCRYPT_free(a: *mut PKCS7_ENCRYPT);
}
extern "C" {
    pub fn d2i_PKCS7_ENCRYPT(
        a: *mut *mut PKCS7_ENCRYPT,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7_ENCRYPT;
}
extern "C" {
    pub fn i2d_PKCS7_ENCRYPT(
        a: *mut PKCS7_ENCRYPT,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_ENCRYPT_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_new() -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_free(a: *mut PKCS7);
}
extern "C" {
    pub fn d2i_PKCS7(
        a: *mut *mut PKCS7,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7(
        a: *mut PKCS7,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS7_it: ASN1_ITEM;
}
extern "C" {
    pub static PKCS7_ATTR_SIGN_it: ASN1_ITEM;
}
extern "C" {
    pub static PKCS7_ATTR_VERIFY_it: ASN1_ITEM;
}
extern "C" {
    pub fn i2d_PKCS7_NDEF(
        a: *mut PKCS7,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_print_ctx(
        out: *mut BIO,
        x: *mut PKCS7,
        indent: ::std::os::raw::c_int,
        pctx: *const ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_ctrl(
        p7: *mut PKCS7,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn PKCS7_set_type(p7: *mut PKCS7, type_: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_set0_type_other(
        p7: *mut PKCS7,
        type_: ::std::os::raw::c_int,
        other: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_set_content(p7: *mut PKCS7, p7_data: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_set(
        p7i: *mut PKCS7_SIGNER_INFO,
        x509: *mut X509,
        pkey: *mut EVP_PKEY,
        dgst: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_sign(si: *mut PKCS7_SIGNER_INFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_signer(p7: *mut PKCS7, p7i: *mut PKCS7_SIGNER_INFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_certificate(p7: *mut PKCS7, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_crl(p7: *mut PKCS7, x509: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_content_new(p7: *mut PKCS7, nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_dataVerify(
        cert_store: *mut X509_STORE,
        ctx: *mut X509_STORE_CTX,
        bio: *mut BIO,
        p7: *mut PKCS7,
        si: *mut PKCS7_SIGNER_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_signatureVerify(
        bio: *mut BIO,
        p7: *mut PKCS7,
        si: *mut PKCS7_SIGNER_INFO,
        x509: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_dataInit(p7: *mut PKCS7, bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn PKCS7_dataFinal(p7: *mut PKCS7, bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_dataDecode(
        p7: *mut PKCS7,
        pkey: *mut EVP_PKEY,
        in_bio: *mut BIO,
        pcert: *mut X509,
    ) -> *mut BIO;
}
extern "C" {
    pub fn PKCS7_add_signature(
        p7: *mut PKCS7,
        x509: *mut X509,
        pkey: *mut EVP_PKEY,
        dgst: *const EVP_MD,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_cert_from_signer_info(p7: *mut PKCS7, si: *mut PKCS7_SIGNER_INFO) -> *mut X509;
}
extern "C" {
    pub fn PKCS7_set_digest(p7: *mut PKCS7, md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_signer_info(p7: *mut PKCS7) -> *mut stack_st_PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_add_recipient(p7: *mut PKCS7, x509: *mut X509) -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_get0_algs(
        si: *mut PKCS7_SIGNER_INFO,
        pk: *mut *mut EVP_PKEY,
        pdig: *mut *mut X509_ALGOR,
        psig: *mut *mut X509_ALGOR,
    );
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_get0_alg(ri: *mut PKCS7_RECIP_INFO, penc: *mut *mut X509_ALGOR);
}
extern "C" {
    pub fn PKCS7_add_recipient_info(
        p7: *mut PKCS7,
        ri: *mut PKCS7_RECIP_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_set(
        p7i: *mut PKCS7_RECIP_INFO,
        x509: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_set_cipher(p7: *mut PKCS7, cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_stream(
        boundary: *mut *mut *mut ::std::os::raw::c_uchar,
        p7: *mut PKCS7,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_issuer_and_serial(
        p7: *mut PKCS7,
        idx: ::std::os::raw::c_int,
    ) -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn PKCS7_digest_from_attributes(sk: *mut stack_st_X509_ATTRIBUTE)
        -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn PKCS7_add_signed_attribute(
        p7si: *mut PKCS7_SIGNER_INFO,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_attribute(
        p7si: *mut PKCS7_SIGNER_INFO,
        nid: ::std::os::raw::c_int,
        atrtype: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_attribute(
        si: *mut PKCS7_SIGNER_INFO,
        nid: ::std::os::raw::c_int,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn PKCS7_get_signed_attribute(
        si: *mut PKCS7_SIGNER_INFO,
        nid: ::std::os::raw::c_int,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn PKCS7_set_signed_attributes(
        p7si: *mut PKCS7_SIGNER_INFO,
        sk: *mut stack_st_X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_set_attributes(
        p7si: *mut PKCS7_SIGNER_INFO,
        sk: *mut stack_st_X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_sign(
        signcert: *mut X509,
        pkey: *mut EVP_PKEY,
        certs: *mut stack_st_X509,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_sign_add_signer(
        p7: *mut PKCS7,
        signcert: *mut X509,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
        flags: ::std::os::raw::c_int,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_final(
        p7: *mut PKCS7,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_verify(
        p7: *mut PKCS7,
        certs: *mut stack_st_X509,
        store: *mut X509_STORE,
        indata: *mut BIO,
        out: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get0_signers(
        p7: *mut PKCS7,
        certs: *mut stack_st_X509,
        flags: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509;
}
extern "C" {
    pub fn PKCS7_encrypt(
        certs: *mut stack_st_X509,
        in_: *mut BIO,
        cipher: *const EVP_CIPHER,
        flags: ::std::os::raw::c_int,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_decrypt(
        p7: *mut PKCS7,
        pkey: *mut EVP_PKEY,
        cert: *mut X509,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_attrib_smimecap(
        si: *mut PKCS7_SIGNER_INFO,
        cap: *mut stack_st_X509_ALGOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_smimecap(si: *mut PKCS7_SIGNER_INFO) -> *mut stack_st_X509_ALGOR;
}
extern "C" {
    pub fn PKCS7_simple_smimecap(
        sk: *mut stack_st_X509_ALGOR,
        nid: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add_attrib_content_type(
        si: *mut PKCS7_SIGNER_INFO,
        coid: *mut ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add0_attrib_signing_time(
        si: *mut PKCS7_SIGNER_INFO,
        t: *mut ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_add1_attrib_digest(
        si: *mut PKCS7_SIGNER_INFO,
        md: *const ::std::os::raw::c_uchar,
        mdlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_write_PKCS7(
        bio: *mut BIO,
        p7: *mut PKCS7,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SMIME_read_PKCS7(bio: *mut BIO, bcont: *mut *mut BIO) -> *mut PKCS7;
}
extern "C" {
    pub fn BIO_new_PKCS7(out: *mut BIO, p7: *mut PKCS7) -> *mut BIO;
}
extern "C" {
    pub fn X509_CRL_set_default_method(meth: *const X509_CRL_METHOD);
}
extern "C" {
    pub fn X509_CRL_METHOD_new(
        crl_init: ::std::option::Option<
            unsafe extern "C" fn(crl: *mut X509_CRL) -> ::std::os::raw::c_int,
        >,
        crl_free: ::std::option::Option<
            unsafe extern "C" fn(crl: *mut X509_CRL) -> ::std::os::raw::c_int,
        >,
        crl_lookup: ::std::option::Option<
            unsafe extern "C" fn(
                crl: *mut X509_CRL,
                ret: *mut *mut X509_REVOKED,
                ser: *mut ASN1_INTEGER,
                issuer: *mut X509_NAME,
            ) -> ::std::os::raw::c_int,
        >,
        crl_verify: ::std::option::Option<
            unsafe extern "C" fn(crl: *mut X509_CRL, pk: *mut EVP_PKEY) -> ::std::os::raw::c_int,
        >,
    ) -> *mut X509_CRL_METHOD;
}
extern "C" {
    pub fn X509_CRL_METHOD_free(m: *mut X509_CRL_METHOD);
}
extern "C" {
    pub fn X509_CRL_set_meth_data(crl: *mut X509_CRL, dat: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn X509_CRL_get_meth_data(crl: *mut X509_CRL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_verify_cert_error_string(
        n: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_verify(a: *mut X509, r: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_verify(a: *mut X509_REQ, r: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_verify(a: *mut X509_CRL, r: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_verify(a: *mut NETSCAPE_SPKI, r: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_b64_decode(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn NETSCAPE_SPKI_b64_encode(x: *mut NETSCAPE_SPKI) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn NETSCAPE_SPKI_get_pubkey(x: *mut NETSCAPE_SPKI) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn NETSCAPE_SPKI_set_pubkey(
        x: *mut NETSCAPE_SPKI,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_print(out: *mut BIO, spki: *mut NETSCAPE_SPKI) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_signature_dump(
        bp: *mut BIO,
        sig: *const ASN1_STRING,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_signature_print(
        bp: *mut BIO,
        alg: *const X509_ALGOR,
        sig: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_sign(x: *mut X509, pkey: *mut EVP_PKEY, md: *const EVP_MD)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_sign_ctx(x: *mut X509, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_http_nbio(rctx: *mut OCSP_REQ_CTX, pcert: *mut *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_sign(
        x: *mut X509_REQ,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_sign_ctx(x: *mut X509_REQ, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sign(
        x: *mut X509_CRL,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sign_ctx(x: *mut X509_CRL, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_http_nbio(
        rctx: *mut OCSP_REQ_CTX,
        pcrl: *mut *mut X509_CRL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_sign(
        x: *mut NETSCAPE_SPKI,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_pubkey_digest(
        data: *const X509,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_digest(
        data: *const X509,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_digest(
        data: *const X509_CRL,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_digest(
        data: *const X509_REQ,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_digest(
        data: *const X509_NAME,
        type_: *const EVP_MD,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_fp(fp: *mut FILE, x509: *mut *mut X509) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509_fp(fp: *mut FILE, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_CRL_fp(fp: *mut FILE, crl: *mut *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL_fp(fp: *mut FILE, crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_REQ_fp(fp: *mut FILE, req: *mut *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ_fp(fp: *mut FILE, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPrivateKey_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPublicKey_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY_fp(fp: *mut FILE, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY_fp(fp: *mut FILE, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSAPrivateKey_fp(fp: *mut FILE, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPrivateKey_fp(fp: *mut FILE, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY_fp(fp: *mut FILE, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_EC_PUBKEY_fp(fp: *mut FILE, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ECPrivateKey_fp(fp: *mut FILE, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey_fp(fp: *mut FILE, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_fp(fp: *mut FILE, p8: *mut *mut X509_SIG) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_PKCS8_fp(fp: *mut FILE, p8: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO_fp(
        fp: *mut FILE,
        p8inf: *mut *mut PKCS8_PRIV_KEY_INFO,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO_fp(
        fp: *mut FILE,
        p8inf: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKeyInfo_fp(fp: *mut FILE, key: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PrivateKey_fp(fp: *mut FILE, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey_fp(fp: *mut FILE, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PUBKEY_fp(fp: *mut FILE, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY_fp(fp: *mut FILE, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_X509_bio(bp: *mut BIO, x509: *mut *mut X509) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509_bio(bp: *mut BIO, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_CRL_bio(bp: *mut BIO, crl: *mut *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL_bio(bp: *mut BIO, crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_REQ_bio(bp: *mut BIO, req: *mut *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ_bio(bp: *mut BIO, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPrivateKey_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPublicKey_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY_bio(bp: *mut BIO, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY_bio(bp: *mut BIO, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSAPrivateKey_bio(bp: *mut BIO, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPrivateKey_bio(bp: *mut BIO, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY_bio(bp: *mut BIO, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_EC_PUBKEY_bio(bp: *mut BIO, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ECPrivateKey_bio(bp: *mut BIO, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey_bio(bp: *mut BIO, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_bio(bp: *mut BIO, p8: *mut *mut X509_SIG) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_PKCS8_bio(bp: *mut BIO, p8: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO_bio(
        bp: *mut BIO,
        p8inf: *mut *mut PKCS8_PRIV_KEY_INFO,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO_bio(
        bp: *mut BIO,
        p8inf: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKeyInfo_bio(bp: *mut BIO, key: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PrivateKey_bio(bp: *mut BIO, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey_bio(bp: *mut BIO, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PUBKEY_bio(bp: *mut BIO, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY_bio(bp: *mut BIO, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_dup(x509: *mut X509) -> *mut X509;
}
extern "C" {
    pub fn X509_ATTRIBUTE_dup(xa: *mut X509_ATTRIBUTE) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_EXTENSION_dup(ex: *mut X509_EXTENSION) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_dup(crl: *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_REVOKED_dup(rev: *mut X509_REVOKED) -> *mut X509_REVOKED;
}
extern "C" {
    pub fn X509_REQ_dup(req: *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_ALGOR_dup(xn: *mut X509_ALGOR) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn X509_ALGOR_set0(
        alg: *mut X509_ALGOR,
        aobj: *mut ASN1_OBJECT,
        ptype: ::std::os::raw::c_int,
        pval: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ALGOR_get0(
        paobj: *mut *const ASN1_OBJECT,
        pptype: *mut ::std::os::raw::c_int,
        ppval: *mut *const ::std::os::raw::c_void,
        algor: *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_ALGOR_set_md(alg: *mut X509_ALGOR, md: *const EVP_MD);
}
extern "C" {
    pub fn X509_ALGOR_cmp(a: *const X509_ALGOR, b: *const X509_ALGOR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ALGOR_copy(dest: *mut X509_ALGOR, src: *const X509_ALGOR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_dup(xn: *mut X509_NAME) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_NAME_ENTRY_dup(ne: *mut X509_NAME_ENTRY) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_cmp_time(s: *const ASN1_TIME, t: *mut time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_cmp_current_time(s: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_time_adj(
        s: *mut ASN1_TIME,
        adj: ::std::os::raw::c_long,
        t: *mut time_t,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_time_adj_ex(
        s: *mut ASN1_TIME,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
        t: *mut time_t,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_gmtime_adj(s: *mut ASN1_TIME, adj: ::std::os::raw::c_long) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_get_default_cert_area() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_file() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_dir_env() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_file_env() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_private_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_to_X509_REQ(x: *mut X509, pkey: *mut EVP_PKEY, md: *const EVP_MD) -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REQ_to_X509(
        r: *mut X509_REQ,
        days: ::std::os::raw::c_int,
        pkey: *mut EVP_PKEY,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_ALGOR_new() -> *mut X509_ALGOR;
}
extern "C" {
    pub fn X509_ALGOR_free(a: *mut X509_ALGOR);
}
extern "C" {
    pub fn d2i_X509_ALGOR(
        a: *mut *mut X509_ALGOR,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn i2d_X509_ALGOR(
        a: *mut X509_ALGOR,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_ALGOR_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_X509_ALGORS(
        a: *mut *mut X509_ALGORS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_ALGORS;
}
extern "C" {
    pub fn i2d_X509_ALGORS(
        a: *mut X509_ALGORS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_ALGORS_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_VAL_new() -> *mut X509_VAL;
}
extern "C" {
    pub fn X509_VAL_free(a: *mut X509_VAL);
}
extern "C" {
    pub fn d2i_X509_VAL(
        a: *mut *mut X509_VAL,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_VAL;
}
extern "C" {
    pub fn i2d_X509_VAL(
        a: *mut X509_VAL,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_VAL_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_PUBKEY_new() -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_PUBKEY_free(a: *mut X509_PUBKEY);
}
extern "C" {
    pub fn d2i_X509_PUBKEY(
        a: *mut *mut X509_PUBKEY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn i2d_X509_PUBKEY(
        a: *mut X509_PUBKEY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_PUBKEY_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_PUBKEY_set(x: *mut *mut X509_PUBKEY, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get0(key: *mut X509_PUBKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_PUBKEY_get(key: *mut X509_PUBKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get_pubkey_parameters(
        pkey: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_pathlen(x: *mut X509) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn i2d_PUBKEY(
        a: *mut EVP_PKEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY(
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY(
        a: *mut RSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY(
        a: *mut *mut RSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY(
        a: *mut DSA,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY(
        a: *mut *mut DSA,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_EC_PUBKEY(
        a: *mut EC_KEY,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY(
        a: *mut *mut EC_KEY,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn X509_SIG_new() -> *mut X509_SIG;
}
extern "C" {
    pub fn X509_SIG_free(a: *mut X509_SIG);
}
extern "C" {
    pub fn d2i_X509_SIG(
        a: *mut *mut X509_SIG,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_X509_SIG(
        a: *mut X509_SIG,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_SIG_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_SIG_get0(
        sig: *const X509_SIG,
        palg: *mut *const X509_ALGOR,
        pdigest: *mut *const ASN1_OCTET_STRING,
    );
}
extern "C" {
    pub fn X509_SIG_getm(
        sig: *mut X509_SIG,
        palg: *mut *mut X509_ALGOR,
        pdigest: *mut *mut ASN1_OCTET_STRING,
    );
}
extern "C" {
    pub fn X509_REQ_INFO_new() -> *mut X509_REQ_INFO;
}
extern "C" {
    pub fn X509_REQ_INFO_free(a: *mut X509_REQ_INFO);
}
extern "C" {
    pub fn d2i_X509_REQ_INFO(
        a: *mut *mut X509_REQ_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_REQ_INFO;
}
extern "C" {
    pub fn i2d_X509_REQ_INFO(
        a: *mut X509_REQ_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_REQ_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_REQ_new() -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REQ_free(a: *mut X509_REQ);
}
extern "C" {
    pub fn d2i_X509_REQ(
        a: *mut *mut X509_REQ,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ(
        a: *mut X509_REQ,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_REQ_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_ATTRIBUTE_new() -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_free(a: *mut X509_ATTRIBUTE);
}
extern "C" {
    pub fn d2i_X509_ATTRIBUTE(
        a: *mut *mut X509_ATTRIBUTE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn i2d_X509_ATTRIBUTE(
        a: *mut X509_ATTRIBUTE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_ATTRIBUTE_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create(
        nid: ::std::os::raw::c_int,
        atrtype: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_EXTENSION_new() -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_free(a: *mut X509_EXTENSION);
}
extern "C" {
    pub fn d2i_X509_EXTENSION(
        a: *mut *mut X509_EXTENSION,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn i2d_X509_EXTENSION(
        a: *mut X509_EXTENSION,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_EXTENSION_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_X509_EXTENSIONS(
        a: *mut *mut X509_EXTENSIONS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_EXTENSIONS;
}
extern "C" {
    pub fn i2d_X509_EXTENSIONS(
        a: *mut X509_EXTENSIONS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_EXTENSIONS_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_ENTRY_new() -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_free(a: *mut X509_NAME_ENTRY);
}
extern "C" {
    pub fn d2i_X509_NAME_ENTRY(
        a: *mut *mut X509_NAME_ENTRY,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn i2d_X509_NAME_ENTRY(
        a: *mut X509_NAME_ENTRY,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_NAME_ENTRY_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_new() -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_NAME_free(a: *mut X509_NAME);
}
extern "C" {
    pub fn d2i_X509_NAME(
        a: *mut *mut X509_NAME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_NAME;
}
extern "C" {
    pub fn i2d_X509_NAME(
        a: *mut X509_NAME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_NAME_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_set(xn: *mut *mut X509_NAME, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CINF_new() -> *mut X509_CINF;
}
extern "C" {
    pub fn X509_CINF_free(a: *mut X509_CINF);
}
extern "C" {
    pub fn d2i_X509_CINF(
        a: *mut *mut X509_CINF,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CINF;
}
extern "C" {
    pub fn i2d_X509_CINF(
        a: *mut X509_CINF,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_CINF_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_new() -> *mut X509;
}
extern "C" {
    pub fn X509_free(a: *mut X509);
}
extern "C" {
    pub fn d2i_X509(
        a: *mut *mut X509,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509(a: *mut X509, out: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CERT_AUX_new() -> *mut X509_CERT_AUX;
}
extern "C" {
    pub fn X509_CERT_AUX_free(a: *mut X509_CERT_AUX);
}
extern "C" {
    pub fn d2i_X509_CERT_AUX(
        a: *mut *mut X509_CERT_AUX,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CERT_AUX;
}
extern "C" {
    pub fn i2d_X509_CERT_AUX(
        a: *mut X509_CERT_AUX,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_CERT_AUX_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_set_ex_data(
        r: *mut X509,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ex_data(
        r: *mut X509,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn i2d_X509_AUX(
        a: *mut X509,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_AUX(
        a: *mut *mut X509,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut X509;
}
extern "C" {
    pub fn i2d_re_X509_tbs(
        x: *mut X509,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_SIG_INFO_get(
        siginf: *const X509_SIG_INFO,
        mdnid: *mut ::std::os::raw::c_int,
        pknid: *mut ::std::os::raw::c_int,
        secbits: *mut ::std::os::raw::c_int,
        flags: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_SIG_INFO_set(
        siginf: *mut X509_SIG_INFO,
        mdnid: ::std::os::raw::c_int,
        pknid: ::std::os::raw::c_int,
        secbits: ::std::os::raw::c_int,
        flags: u32,
    );
}
extern "C" {
    pub fn X509_get_signature_info(
        x: *mut X509,
        mdnid: *mut ::std::os::raw::c_int,
        pknid: *mut ::std::os::raw::c_int,
        secbits: *mut ::std::os::raw::c_int,
        flags: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get0_signature(
        psig: *mut *const ASN1_BIT_STRING,
        palg: *mut *const X509_ALGOR,
        x: *const X509,
    );
}
extern "C" {
    pub fn X509_get_signature_nid(x: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_trusted(x: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_alias_set1(
        x: *mut X509,
        name: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_keyid_set1(
        x: *mut X509,
        id: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_alias_get0(
        x: *mut X509,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn X509_keyid_get0(
        x: *mut X509,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn X509_TRUST_set_default(
        trust: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *mut X509,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            trust: ::std::os::raw::c_int,
            arg1: *mut X509,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn X509_TRUST_set(
        t: *mut ::std::os::raw::c_int,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_add1_trust_object(x: *mut X509, obj: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_add1_reject_object(x: *mut X509, obj: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_trust_clear(x: *mut X509);
}
extern "C" {
    pub fn X509_reject_clear(x: *mut X509);
}
extern "C" {
    pub fn X509_get0_trust_objects(x: *mut X509) -> *mut stack_st_ASN1_OBJECT;
}
extern "C" {
    pub fn X509_get0_reject_objects(x: *mut X509) -> *mut stack_st_ASN1_OBJECT;
}
extern "C" {
    pub fn X509_REVOKED_new() -> *mut X509_REVOKED;
}
extern "C" {
    pub fn X509_REVOKED_free(a: *mut X509_REVOKED);
}
extern "C" {
    pub fn d2i_X509_REVOKED(
        a: *mut *mut X509_REVOKED,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_REVOKED;
}
extern "C" {
    pub fn i2d_X509_REVOKED(
        a: *mut X509_REVOKED,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_REVOKED_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_INFO_new() -> *mut X509_CRL_INFO;
}
extern "C" {
    pub fn X509_CRL_INFO_free(a: *mut X509_CRL_INFO);
}
extern "C" {
    pub fn d2i_X509_CRL_INFO(
        a: *mut *mut X509_CRL_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CRL_INFO;
}
extern "C" {
    pub fn i2d_X509_CRL_INFO(
        a: *mut X509_CRL_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_CRL_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_new() -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_CRL_free(a: *mut X509_CRL);
}
extern "C" {
    pub fn d2i_X509_CRL(
        a: *mut *mut X509_CRL,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL(
        a: *mut X509_CRL,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_CRL_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_add0_revoked(
        crl: *mut X509_CRL,
        rev: *mut X509_REVOKED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get0_by_serial(
        crl: *mut X509_CRL,
        ret: *mut *mut X509_REVOKED,
        serial: *mut ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get0_by_cert(
        crl: *mut X509_CRL,
        ret: *mut *mut X509_REVOKED,
        x: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PKEY_new() -> *mut X509_PKEY;
}
extern "C" {
    pub fn X509_PKEY_free(a: *mut X509_PKEY);
}
extern "C" {
    pub fn NETSCAPE_SPKI_new() -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn NETSCAPE_SPKI_free(a: *mut NETSCAPE_SPKI);
}
extern "C" {
    pub fn d2i_NETSCAPE_SPKI(
        a: *mut *mut NETSCAPE_SPKI,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn i2d_NETSCAPE_SPKI(
        a: *mut NETSCAPE_SPKI,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static NETSCAPE_SPKI_it: ASN1_ITEM;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_new() -> *mut NETSCAPE_SPKAC;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_free(a: *mut NETSCAPE_SPKAC);
}
extern "C" {
    pub fn d2i_NETSCAPE_SPKAC(
        a: *mut *mut NETSCAPE_SPKAC,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_SPKAC;
}
extern "C" {
    pub fn i2d_NETSCAPE_SPKAC(
        a: *mut NETSCAPE_SPKAC,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static NETSCAPE_SPKAC_it: ASN1_ITEM;
}
extern "C" {
    pub fn NETSCAPE_CERT_SEQUENCE_new() -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn NETSCAPE_CERT_SEQUENCE_free(a: *mut NETSCAPE_CERT_SEQUENCE);
}
extern "C" {
    pub fn d2i_NETSCAPE_CERT_SEQUENCE(
        a: *mut *mut NETSCAPE_CERT_SEQUENCE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn i2d_NETSCAPE_CERT_SEQUENCE(
        a: *mut NETSCAPE_CERT_SEQUENCE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static NETSCAPE_CERT_SEQUENCE_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_INFO_new() -> *mut X509_INFO;
}
extern "C" {
    pub fn X509_INFO_free(a: *mut X509_INFO);
}
extern "C" {
    pub fn X509_NAME_oneline(
        a: *const X509_NAME,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ASN1_verify(
        i2d: i2d_of_void,
        algor1: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_char,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_digest(
        i2d: i2d_of_void,
        type_: *const EVP_MD,
        data: *mut ::std::os::raw::c_char,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_sign(
        i2d: i2d_of_void,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_char,
        pkey: *mut EVP_PKEY,
        type_: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_digest(
        it: *const ASN1_ITEM,
        type_: *const EVP_MD,
        data: *mut ::std::os::raw::c_void,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_verify(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_void,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_sign(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_void,
        pkey: *mut EVP_PKEY,
        type_: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_sign_ctx(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        asn: *mut ::std::os::raw::c_void,
        ctx: *mut EVP_MD_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_version(x: *const X509) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn X509_set_version(x: *mut X509, version: ::std::os::raw::c_long)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_serialNumber(x: *mut X509, serial: *mut ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_serialNumber(x: *mut X509) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn X509_get0_serialNumber(x: *const X509) -> *const ASN1_INTEGER;
}
extern "C" {
    pub fn X509_set_issuer_name(x: *mut X509, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_issuer_name(a: *const X509) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_set_subject_name(x: *mut X509, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_subject_name(a: *const X509) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_get0_notBefore(x: *const X509) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_getm_notBefore(x: *const X509) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_set1_notBefore(x: *mut X509, tm: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get0_notAfter(x: *const X509) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_getm_notAfter(x: *const X509) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_set1_notAfter(x: *mut X509, tm: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_pubkey(x: *mut X509, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_up_ref(x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_signature_type(x: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_X509_PUBKEY(x: *const X509) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_get0_extensions(x: *const X509) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_get0_uids(
        x: *const X509,
        piuid: *mut *const ASN1_BIT_STRING,
        psuid: *mut *const ASN1_BIT_STRING,
    );
}
extern "C" {
    pub fn X509_get0_tbs_sigalg(x: *const X509) -> *const X509_ALGOR;
}
extern "C" {
    pub fn X509_get0_pubkey(x: *const X509) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get_pubkey(x: *mut X509) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get0_pubkey_bitstr(x: *const X509) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn X509_certificate_type(x: *const X509, pubkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_version(req: *const X509_REQ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn X509_REQ_set_version(
        x: *mut X509_REQ,
        version: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_subject_name(req: *const X509_REQ) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_REQ_set_subject_name(
        req: *mut X509_REQ,
        name: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get0_signature(
        req: *const X509_REQ,
        psig: *mut *const ASN1_BIT_STRING,
        palg: *mut *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_REQ_set0_signature(req: *mut X509_REQ, psig: *mut ASN1_BIT_STRING);
}
extern "C" {
    pub fn X509_REQ_set1_signature_algo(
        req: *mut X509_REQ,
        palg: *mut X509_ALGOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_signature_nid(req: *const X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_re_X509_REQ_tbs(
        req: *mut X509_REQ,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set_pubkey(x: *mut X509_REQ, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_pubkey(req: *mut X509_REQ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_REQ_get0_pubkey(req: *mut X509_REQ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_REQ_get_X509_PUBKEY(req: *mut X509_REQ) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_REQ_extension_nid(nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_extension_nids() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set_extension_nids(nids: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_REQ_get_extensions(req: *mut X509_REQ) -> *mut stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_REQ_add_extensions_nid(
        req: *mut X509_REQ,
        exts: *mut stack_st_X509_EXTENSION,
        nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add_extensions(
        req: *mut X509_REQ,
        exts: *mut stack_st_X509_EXTENSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_count(req: *const X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_by_NID(
        req: *const X509_REQ,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_by_OBJ(
        req: *const X509_REQ,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr(
        req: *const X509_REQ,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_REQ_delete_attr(
        req: *mut X509_REQ,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_REQ_add1_attr(
        req: *mut X509_REQ,
        attr: *mut X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_OBJ(
        req: *mut X509_REQ,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_NID(
        req: *mut X509_REQ,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_txt(
        req: *mut X509_REQ,
        attrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set_version(
        x: *mut X509_CRL,
        version: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set_issuer_name(
        x: *mut X509_CRL,
        name: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set1_lastUpdate(
        x: *mut X509_CRL,
        tm: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set1_nextUpdate(
        x: *mut X509_CRL,
        tm: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sort(crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_up_ref(crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_version(crl: *const X509_CRL) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn X509_CRL_get0_lastUpdate(crl: *const X509_CRL) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get0_nextUpdate(crl: *const X509_CRL) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get_lastUpdate(crl: *mut X509_CRL) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get_nextUpdate(crl: *mut X509_CRL) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get_issuer(crl: *const X509_CRL) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_CRL_get0_extensions(crl: *const X509_CRL) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_get_REVOKED(crl: *mut X509_CRL) -> *mut stack_st_X509_REVOKED;
}
extern "C" {
    pub fn X509_CRL_get0_signature(
        crl: *const X509_CRL,
        psig: *mut *const ASN1_BIT_STRING,
        palg: *mut *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_CRL_get_signature_nid(crl: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_re_X509_CRL_tbs(
        req: *mut X509_CRL,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get0_serialNumber(x: *const X509_REVOKED) -> *const ASN1_INTEGER;
}
extern "C" {
    pub fn X509_REVOKED_set_serialNumber(
        x: *mut X509_REVOKED,
        serial: *mut ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get0_revocationDate(x: *const X509_REVOKED) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_REVOKED_set_revocationDate(
        r: *mut X509_REVOKED,
        tm: *mut ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get0_extensions(r: *const X509_REVOKED) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_diff(
        base: *mut X509_CRL,
        newer: *mut X509_CRL,
        skey: *mut EVP_PKEY,
        md: *const EVP_MD,
        flags: ::std::os::raw::c_uint,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_REQ_check_private_key(
        x509: *mut X509_REQ,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_private_key(
        x509: *const X509,
        pkey: *const EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_chain_check_suiteb(
        perror_depth: *mut ::std::os::raw::c_int,
        x: *mut X509,
        chain: *mut stack_st_X509,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_check_suiteb(
        crl: *mut X509_CRL,
        pk: *mut EVP_PKEY,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_chain_up_ref(chain: *mut stack_st_X509) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_issuer_and_serial_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_issuer_and_serial_hash(a: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_issuer_name_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_issuer_name_hash(a: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_subject_name_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_subject_name_hash(x: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_issuer_name_hash_old(a: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_subject_name_hash_old(x: *mut X509) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_cmp(a: *const X509_NAME, b: *const X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_hash(x: *mut X509_NAME) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_NAME_hash_old(x: *mut X509_NAME) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_CRL_cmp(a: *const X509_CRL, b: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_match(a: *const X509_CRL, b: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_aux_print(
        out: *mut BIO,
        x: *mut X509,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print_ex_fp(
        bp: *mut FILE,
        x: *mut X509,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print_fp(bp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_print_fp(bp: *mut FILE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print_fp(bp: *mut FILE, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_print_ex_fp(
        fp: *mut FILE,
        nm: *const X509_NAME,
        indent: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_print(
        bp: *mut BIO,
        name: *const X509_NAME,
        obase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_print_ex(
        out: *mut BIO,
        nm: *const X509_NAME,
        indent: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print_ex(
        bp: *mut BIO,
        x: *mut X509,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ocspid_print(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_print_ex(
        out: *mut BIO,
        x: *mut X509_CRL,
        nmflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_print(bp: *mut BIO, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print_ex(
        bp: *mut BIO,
        x: *mut X509_REQ,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print(bp: *mut BIO, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_entry_count(name: *const X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_text_by_NID(
        name: *mut X509_NAME,
        nid: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_text_by_OBJ(
        name: *mut X509_NAME,
        obj: *const ASN1_OBJECT,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_index_by_NID(
        name: *mut X509_NAME,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_index_by_OBJ(
        name: *mut X509_NAME,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_entry(
        name: *const X509_NAME,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_delete_entry(
        name: *mut X509_NAME,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_add_entry(
        name: *mut X509_NAME,
        ne: *const X509_NAME_ENTRY,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_OBJ(
        name: *mut X509_NAME,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_NID(
        name: *mut X509_NAME,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_txt(
        ne: *mut *mut X509_NAME_ENTRY,
        field: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_NID(
        ne: *mut *mut X509_NAME_ENTRY,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_txt(
        name: *mut X509_NAME,
        field: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_OBJ(
        ne: *mut *mut X509_NAME_ENTRY,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set_object(
        ne: *mut X509_NAME_ENTRY,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set_data(
        ne: *mut X509_NAME_ENTRY,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_get_object(ne: *const X509_NAME_ENTRY) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_NAME_ENTRY_get_data(ne: *const X509_NAME_ENTRY) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set(ne: *const X509_NAME_ENTRY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get0_der(
        nm: *mut X509_NAME,
        pder: *mut *const ::std::os::raw::c_uchar,
        pderlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_count(x: *const stack_st_X509_EXTENSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_NID(
        x: *const stack_st_X509_EXTENSION,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_OBJ(
        x: *const stack_st_X509_EXTENSION,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_critical(
        x: *const stack_st_X509_EXTENSION,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext(
        x: *const stack_st_X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509v3_delete_ext(
        x: *mut stack_st_X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509v3_add_ext(
        x: *mut *mut stack_st_X509_EXTENSION,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_get_ext_count(x: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_NID(
        x: *const X509,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_OBJ(
        x: *const X509,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_critical(
        x: *const X509,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext(x: *const X509, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_delete_ext(x: *mut X509, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_add_ext(
        x: *mut X509,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_d2i(
        x: *const X509,
        nid: ::std::os::raw::c_int,
        crit: *mut ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_add1_ext_i2d(
        x: *mut X509,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_count(x: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_NID(
        x: *const X509_CRL,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_OBJ(
        x: *const X509_CRL,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_critical(
        x: *const X509_CRL,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext(x: *const X509_CRL, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_delete_ext(x: *mut X509_CRL, loc: ::std::os::raw::c_int)
        -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_add_ext(
        x: *mut X509_CRL,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_d2i(
        x: *const X509_CRL,
        nid: ::std::os::raw::c_int,
        crit: *mut ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_CRL_add1_ext_i2d(
        x: *mut X509_CRL,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_count(x: *const X509_REVOKED) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_NID(
        x: *const X509_REVOKED,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_OBJ(
        x: *const X509_REVOKED,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_critical(
        x: *const X509_REVOKED,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext(
        x: *const X509_REVOKED,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_delete_ext(
        x: *mut X509_REVOKED,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_add_ext(
        x: *mut X509_REVOKED,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_d2i(
        x: *const X509_REVOKED,
        nid: ::std::os::raw::c_int,
        crit: *mut ::std::os::raw::c_int,
        idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_REVOKED_add1_ext_i2d(
        x: *mut X509_REVOKED,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_create_by_NID(
        ex: *mut *mut X509_EXTENSION,
        nid: ::std::os::raw::c_int,
        crit: ::std::os::raw::c_int,
        data: *mut ASN1_OCTET_STRING,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_create_by_OBJ(
        ex: *mut *mut X509_EXTENSION,
        obj: *const ASN1_OBJECT,
        crit: ::std::os::raw::c_int,
        data: *mut ASN1_OCTET_STRING,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_set_object(
        ex: *mut X509_EXTENSION,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_critical(
        ex: *mut X509_EXTENSION,
        crit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_data(
        ex: *mut X509_EXTENSION,
        data: *mut ASN1_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_get_object(ex: *mut X509_EXTENSION) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_EXTENSION_get_data(ne: *mut X509_EXTENSION) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_EXTENSION_get_critical(ex: *const X509_EXTENSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509at_get_attr_count(x: *const stack_st_X509_ATTRIBUTE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509at_get_attr_by_NID(
        x: *const stack_st_X509_ATTRIBUTE,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509at_get_attr_by_OBJ(
        sk: *const stack_st_X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509at_get_attr(
        x: *const stack_st_X509_ATTRIBUTE,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_delete_attr(
        x: *mut stack_st_X509_ATTRIBUTE,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        attr: *mut X509_ATTRIBUTE,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_OBJ(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_NID(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_txt(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        attrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_get0_data_by_OBJ(
        x: *const stack_st_X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_NID(
        attr: *mut *mut X509_ATTRIBUTE,
        nid: ::std::os::raw::c_int,
        atrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_OBJ(
        attr: *mut *mut X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        atrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_txt(
        attr: *mut *mut X509_ATTRIBUTE,
        atrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_set1_object(
        attr: *mut X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_set1_data(
        attr: *mut X509_ATTRIBUTE,
        attrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_data(
        attr: *mut X509_ATTRIBUTE,
        idx: ::std::os::raw::c_int,
        atrtype: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_ATTRIBUTE_count(attr: *const X509_ATTRIBUTE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_object(attr: *mut X509_ATTRIBUTE) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_type(
        attr: *mut X509_ATTRIBUTE,
        idx: ::std::os::raw::c_int,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_count(key: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_by_NID(
        key: *const EVP_PKEY,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_by_OBJ(
        key: *const EVP_PKEY,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr(
        key: *const EVP_PKEY,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn EVP_PKEY_delete_attr(
        key: *mut EVP_PKEY,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr(
        key: *mut EVP_PKEY,
        attr: *mut X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_OBJ(
        key: *mut EVP_PKEY,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_NID(
        key: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_txt(
        key: *mut EVP_PKEY,
        attrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_verify_cert(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_find_by_issuer_and_serial(
        sk: *mut stack_st_X509,
        name: *mut X509_NAME,
        serial: *mut ASN1_INTEGER,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_find_by_subject(sk: *mut stack_st_X509, name: *mut X509_NAME) -> *mut X509;
}
extern "C" {
    pub fn PBEPARAM_new() -> *mut PBEPARAM;
}
extern "C" {
    pub fn PBEPARAM_free(a: *mut PBEPARAM);
}
extern "C" {
    pub fn d2i_PBEPARAM(
        a: *mut *mut PBEPARAM,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PBEPARAM;
}
extern "C" {
    pub fn i2d_PBEPARAM(
        a: *mut PBEPARAM,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PBEPARAM_it: ASN1_ITEM;
}
extern "C" {
    pub fn PBE2PARAM_new() -> *mut PBE2PARAM;
}
extern "C" {
    pub fn PBE2PARAM_free(a: *mut PBE2PARAM);
}
extern "C" {
    pub fn d2i_PBE2PARAM(
        a: *mut *mut PBE2PARAM,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PBE2PARAM;
}
extern "C" {
    pub fn i2d_PBE2PARAM(
        a: *mut PBE2PARAM,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PBE2PARAM_it: ASN1_ITEM;
}
extern "C" {
    pub fn PBKDF2PARAM_new() -> *mut PBKDF2PARAM;
}
extern "C" {
    pub fn PBKDF2PARAM_free(a: *mut PBKDF2PARAM);
}
extern "C" {
    pub fn d2i_PBKDF2PARAM(
        a: *mut *mut PBKDF2PARAM,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PBKDF2PARAM;
}
extern "C" {
    pub fn i2d_PBKDF2PARAM(
        a: *mut PBKDF2PARAM,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PBKDF2PARAM_it: ASN1_ITEM;
}
extern "C" {
    pub fn SCRYPT_PARAMS_new() -> *mut SCRYPT_PARAMS;
}
extern "C" {
    pub fn SCRYPT_PARAMS_free(a: *mut SCRYPT_PARAMS);
}
extern "C" {
    pub fn d2i_SCRYPT_PARAMS(
        a: *mut *mut SCRYPT_PARAMS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut SCRYPT_PARAMS;
}
extern "C" {
    pub fn i2d_SCRYPT_PARAMS(
        a: *mut SCRYPT_PARAMS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static SCRYPT_PARAMS_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS5_pbe_set0_algor(
        algor: *mut X509_ALGOR,
        alg: ::std::os::raw::c_int,
        iter: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_pbe_set(
        alg: ::std::os::raw::c_int,
        iter: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set(
        cipher: *const EVP_CIPHER,
        iter: ::std::os::raw::c_int,
        salt: *mut ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set_iv(
        cipher: *const EVP_CIPHER,
        iter: ::std::os::raw::c_int,
        salt: *mut ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        aiv: *mut ::std::os::raw::c_uchar,
        prf_nid: ::std::os::raw::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set_scrypt(
        cipher: *const EVP_CIPHER,
        salt: *const ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        aiv: *mut ::std::os::raw::c_uchar,
        N: u64,
        r: u64,
        p: u64,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbkdf2_set(
        iter: ::std::os::raw::c_int,
        salt: *mut ::std::os::raw::c_uchar,
        saltlen: ::std::os::raw::c_int,
        prf_nid: ::std::os::raw::c_int,
        keylen: ::std::os::raw::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_new() -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_free(a: *mut PKCS8_PRIV_KEY_INFO);
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO(
        a: *mut *mut PKCS8_PRIV_KEY_INFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO(
        a: *mut PKCS8_PRIV_KEY_INFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS8_PRIV_KEY_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn EVP_PKCS82PKEY(p8: *const PKCS8_PRIV_KEY_INFO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY2PKCS8(pkey: *mut EVP_PKEY) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_pkey_set0(
        priv_: *mut PKCS8_PRIV_KEY_INFO,
        aobj: *mut ASN1_OBJECT,
        version: ::std::os::raw::c_int,
        ptype: ::std::os::raw::c_int,
        pval: *mut ::std::os::raw::c_void,
        penc: *mut ::std::os::raw::c_uchar,
        penclen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS8_pkey_get0(
        ppkalg: *mut *const ASN1_OBJECT,
        pk: *mut *const ::std::os::raw::c_uchar,
        ppklen: *mut ::std::os::raw::c_int,
        pa: *mut *const X509_ALGOR,
        p8: *const PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS8_pkey_get0_attrs(p8: *const PKCS8_PRIV_KEY_INFO) -> *const stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn PKCS8_pkey_add1_attr_by_NID(
        p8: *mut PKCS8_PRIV_KEY_INFO,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_set0_param(
        pub_: *mut X509_PUBKEY,
        aobj: *mut ASN1_OBJECT,
        ptype: ::std::os::raw::c_int,
        pval: *mut ::std::os::raw::c_void,
        penc: *mut ::std::os::raw::c_uchar,
        penclen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get0_param(
        ppkalg: *mut *mut ASN1_OBJECT,
        pk: *mut *const ::std::os::raw::c_uchar,
        ppklen: *mut ::std::os::raw::c_int,
        pa: *mut *mut X509_ALGOR,
        pub_: *mut X509_PUBKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_trust(
        x: *mut X509,
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get0(idx: ::std::os::raw::c_int) -> *mut X509_TRUST;
}
extern "C" {
    pub fn X509_TRUST_get_by_id(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_add(
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        ck: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut X509_TRUST,
                arg2: *mut X509,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        name: *const ::std::os::raw::c_char,
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_cleanup();
}
extern "C" {
    pub fn X509_TRUST_get_flags(xp: *const X509_TRUST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get0_name(xp: *const X509_TRUST) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_TRUST_get_trust(xp: *const X509_TRUST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_PEM_strings() -> ::std::os::raw::c_int;
}
pub type pem_password_cb = ::std::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        rwflag: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn PEM_get_EVP_CIPHER_INFO(
        header: *mut ::std::os::raw::c_char,
        cipher: *mut EVP_CIPHER_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_do_header(
        cipher: *mut EVP_CIPHER_INFO,
        data: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
        callback: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio(
        bp: *mut BIO,
        name: *mut *mut ::std::os::raw::c_char,
        header: *mut *mut ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ex(
        bp: *mut BIO,
        name: *mut *mut ::std::os::raw::c_char,
        header: *mut *mut ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_bytes_read_bio_secmem(
        pdata: *mut *mut ::std::os::raw::c_uchar,
        plen: *mut ::std::os::raw::c_long,
        pnm: *mut *mut ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio(
        bp: *mut BIO,
        name: *const ::std::os::raw::c_char,
        hdr: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_bytes_read_bio(
        pdata: *mut *mut ::std::os::raw::c_uchar,
        plen: *mut ::std::os::raw::c_long,
        pnm: *mut *mut ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_ASN1_read_bio(
        d2i: d2i_of_void,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        x: *mut *mut ::std::os::raw::c_void,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PEM_ASN1_write_bio(
        i2d: i2d_of_void,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        x: *mut ::std::os::raw::c_void,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_X509_INFO_read_bio(
        bp: *mut BIO,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_X509_INFO_write_bio(
        bp: *mut BIO,
        xi: *mut X509_INFO,
        enc: *mut EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cd: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read(
        fp: *mut FILE,
        name: *mut *mut ::std::os::raw::c_char,
        header: *mut *mut ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write(
        fp: *mut FILE,
        name: *const ::std::os::raw::c_char,
        hdr: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_ASN1_read(
        d2i: d2i_of_void,
        name: *const ::std::os::raw::c_char,
        fp: *mut FILE,
        x: *mut *mut ::std::os::raw::c_void,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PEM_ASN1_write(
        i2d: i2d_of_void,
        name: *const ::std::os::raw::c_char,
        fp: *mut FILE,
        x: *mut ::std::os::raw::c_void,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        callback: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_X509_INFO_read(
        fp: *mut FILE,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_SignInit(ctx: *mut EVP_MD_CTX, type_: *mut EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_SignUpdate(
        ctx: *mut EVP_MD_CTX,
        d: *mut ::std::os::raw::c_uchar,
        cnt: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_SignFinal(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut ::std::os::raw::c_uchar,
        siglen: *mut ::std::os::raw::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_def_callback(
        buf: *mut ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
        rwflag: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_proc_type(buf: *mut ::std::os::raw::c_char, type_: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PEM_dek_info(
        buf: *mut ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        str_: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn PEM_read_bio_X509(
        bp: *mut BIO,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_read_X509(
        fp: *mut FILE,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_write_bio_X509(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509(fp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_AUX(
        bp: *mut BIO,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_read_X509_AUX(
        fp: *mut FILE,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_write_bio_X509_AUX(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_AUX(fp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_REQ(
        bp: *mut BIO,
        x: *mut *mut X509_REQ,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn PEM_read_X509_REQ(
        fp: *mut FILE,
        x: *mut *mut X509_REQ,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn PEM_write_bio_X509_REQ(bp: *mut BIO, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_REQ(fp: *mut FILE, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_X509_REQ_NEW(bp: *mut BIO, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_REQ_NEW(fp: *mut FILE, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_CRL(
        bp: *mut BIO,
        x: *mut *mut X509_CRL,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn PEM_read_X509_CRL(
        fp: *mut FILE,
        x: *mut *mut X509_CRL,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn PEM_write_bio_X509_CRL(bp: *mut BIO, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_CRL(fp: *mut FILE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS7(
        bp: *mut BIO,
        x: *mut *mut PKCS7,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PEM_read_PKCS7(
        fp: *mut FILE,
        x: *mut *mut PKCS7,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PEM_write_bio_PKCS7(bp: *mut BIO, x: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS7(fp: *mut FILE, x: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_NETSCAPE_CERT_SEQUENCE(
        bp: *mut BIO,
        x: *mut *mut NETSCAPE_CERT_SEQUENCE,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn PEM_read_NETSCAPE_CERT_SEQUENCE(
        fp: *mut FILE,
        x: *mut *mut NETSCAPE_CERT_SEQUENCE,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn PEM_write_bio_NETSCAPE_CERT_SEQUENCE(
        bp: *mut BIO,
        x: *mut NETSCAPE_CERT_SEQUENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_NETSCAPE_CERT_SEQUENCE(
        fp: *mut FILE,
        x: *mut NETSCAPE_CERT_SEQUENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS8(
        bp: *mut BIO,
        x: *mut *mut X509_SIG,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PEM_read_PKCS8(
        fp: *mut FILE,
        x: *mut *mut X509_SIG,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8(bp: *mut BIO, x: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8(fp: *mut FILE, x: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS8_PRIV_KEY_INFO(
        bp: *mut BIO,
        x: *mut *mut PKCS8_PRIV_KEY_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PEM_read_PKCS8_PRIV_KEY_INFO(
        fp: *mut FILE,
        x: *mut *mut PKCS8_PRIV_KEY_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8_PRIV_KEY_INFO(
        bp: *mut BIO,
        x: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8_PRIV_KEY_INFO(
        fp: *mut FILE,
        x: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSAPrivateKey(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSAPrivateKey(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSAPrivateKey(
        bp: *mut BIO,
        x: *mut RSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSAPrivateKey(
        fp: *mut FILE,
        x: *mut RSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSAPublicKey(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSAPublicKey(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSAPublicKey(bp: *mut BIO, x: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSAPublicKey(fp: *mut FILE, x: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSA_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSA_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSA_PUBKEY(bp: *mut BIO, x: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSA_PUBKEY(fp: *mut FILE, x: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSAPrivateKey(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSAPrivateKey(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSAPrivateKey(
        bp: *mut BIO,
        x: *mut DSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSAPrivateKey(
        fp: *mut FILE,
        x: *mut DSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSA_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSA_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSA_PUBKEY(bp: *mut BIO, x: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSA_PUBKEY(fp: *mut FILE, x: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSAparams(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSAparams(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSAparams(bp: *mut BIO, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSAparams(fp: *mut FILE, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ECPKParameters(
        bp: *mut BIO,
        x: *mut *mut EC_GROUP,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn PEM_read_ECPKParameters(
        fp: *mut FILE,
        x: *mut *mut EC_GROUP,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn PEM_write_bio_ECPKParameters(bp: *mut BIO, x: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_ECPKParameters(fp: *mut FILE, x: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ECPrivateKey(
        bp: *mut BIO,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_read_ECPrivateKey(
        fp: *mut FILE,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_write_bio_ECPrivateKey(
        bp: *mut BIO,
        x: *mut EC_KEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_ECPrivateKey(
        fp: *mut FILE,
        x: *mut EC_KEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_EC_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_read_EC_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_write_bio_EC_PUBKEY(bp: *mut BIO, x: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_EC_PUBKEY(fp: *mut FILE, x: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DHparams(
        bp: *mut BIO,
        x: *mut *mut DH,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn PEM_read_DHparams(
        fp: *mut FILE,
        x: *mut *mut DH,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn PEM_write_bio_DHparams(bp: *mut BIO, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DHparams(fp: *mut FILE, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_DHxparams(bp: *mut BIO, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DHxparams(fp: *mut FILE, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PrivateKey(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PrivateKey(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_PrivateKey(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PrivateKey(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_PUBKEY(bp: *mut BIO, x: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PUBKEY(fp: *mut FILE, x: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PrivateKey_traditional(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8PrivateKey_nid(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8PrivateKey(
        arg1: *mut BIO,
        arg2: *mut EVP_PKEY,
        arg3: *const EVP_CIPHER,
        arg4: *mut ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
        arg6: pem_password_cb,
        arg7: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_bio(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_nid_bio(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8PrivateKey_bio(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_fp(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_nid_fp(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8PrivateKey_nid(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8PrivateKey_fp(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_PKCS8PrivateKey(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cd: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_Parameters(bp: *mut BIO, x: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_Parameters(bp: *mut BIO, x: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b2i_PrivateKey(
        in_: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PublicKey(
        in_: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PrivateKey_bio(in_: *mut BIO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PublicKey_bio(in_: *mut BIO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2b_PrivateKey_bio(out: *mut BIO, pk: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2b_PublicKey_bio(out: *mut BIO, pk: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn b2i_PVK_bio(
        in_: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2b_PVK_bio(
        out: *mut BIO,
        pk: *mut EVP_PKEY,
        enclevel: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_size(e: *const HMAC_CTX) -> size_t;
}
extern "C" {
    pub fn HMAC_CTX_new() -> *mut HMAC_CTX;
}
extern "C" {
    pub fn HMAC_CTX_reset(ctx: *mut HMAC_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_CTX_free(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_Init(
        ctx: *mut HMAC_CTX,
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Init_ex(
        ctx: *mut HMAC_CTX,
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        md: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Update(
        ctx: *mut HMAC_CTX,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Final(
        ctx: *mut HMAC_CTX,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC(
        evp_md: *const EVP_MD,
        key: *const ::std::os::raw::c_void,
        key_len: ::std::os::raw::c_int,
        d: *const ::std::os::raw::c_uchar,
        n: size_t,
        md: *mut ::std::os::raw::c_uchar,
        md_len: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn HMAC_CTX_copy(dctx: *mut HMAC_CTX, sctx: *mut HMAC_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_CTX_set_flags(ctx: *mut HMAC_CTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn HMAC_CTX_get_md(ctx: *const HMAC_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn ERR_load_ASYNC_strings() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_job_st {
    _unused: [u8; 0],
}
pub type ASYNC_JOB = async_job_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_wait_ctx_st {
    _unused: [u8; 0],
}
pub type ASYNC_WAIT_CTX = async_wait_ctx_st;
extern "C" {
    pub fn ASYNC_init_thread(max_size: size_t, init_size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_cleanup_thread();
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_new() -> *mut ASYNC_WAIT_CTX;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_free(ctx: *mut ASYNC_WAIT_CTX);
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_set_wait_fd(
        ctx: *mut ASYNC_WAIT_CTX,
        key: *const ::std::os::raw::c_void,
        fd: ::std::os::raw::c_int,
        custom_data: *mut ::std::os::raw::c_void,
        cleanup: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ASYNC_WAIT_CTX,
                arg2: *const ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_get_fd(
        ctx: *mut ASYNC_WAIT_CTX,
        key: *const ::std::os::raw::c_void,
        fd: *mut ::std::os::raw::c_int,
        custom_data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_get_all_fds(
        ctx: *mut ASYNC_WAIT_CTX,
        fd: *mut ::std::os::raw::c_int,
        numfds: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_get_changed_fds(
        ctx: *mut ASYNC_WAIT_CTX,
        addfd: *mut ::std::os::raw::c_int,
        numaddfds: *mut size_t,
        delfd: *mut ::std::os::raw::c_int,
        numdelfds: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_clear_fd(
        ctx: *mut ASYNC_WAIT_CTX,
        key: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_is_capable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_start_job(
        job: *mut *mut ASYNC_JOB,
        ctx: *mut ASYNC_WAIT_CTX,
        ret: *mut ::std::os::raw::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        args: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_pause_job() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASYNC_get_current_job() -> *mut ASYNC_JOB;
}
extern "C" {
    pub fn ASYNC_get_wait_ctx(job: *mut ASYNC_JOB) -> *mut ASYNC_WAIT_CTX;
}
extern "C" {
    pub fn ASYNC_block_pause();
}
extern "C" {
    pub fn ASYNC_unblock_pause();
}
extern "C" {
    pub fn ERR_load_CT_strings() -> ::std::os::raw::c_int;
}
pub const ct_log_entry_type_t_CT_LOG_ENTRY_TYPE_NOT_SET: ct_log_entry_type_t = -1;
pub const ct_log_entry_type_t_CT_LOG_ENTRY_TYPE_X509: ct_log_entry_type_t = 0;
pub const ct_log_entry_type_t_CT_LOG_ENTRY_TYPE_PRECERT: ct_log_entry_type_t = 1;
pub type ct_log_entry_type_t = ::std::os::raw::c_int;
pub const sct_version_t_SCT_VERSION_NOT_SET: sct_version_t = -1;
pub const sct_version_t_SCT_VERSION_V1: sct_version_t = 0;
pub type sct_version_t = ::std::os::raw::c_int;
pub const sct_source_t_SCT_SOURCE_UNKNOWN: sct_source_t = 0;
pub const sct_source_t_SCT_SOURCE_TLS_EXTENSION: sct_source_t = 1;
pub const sct_source_t_SCT_SOURCE_X509V3_EXTENSION: sct_source_t = 2;
pub const sct_source_t_SCT_SOURCE_OCSP_STAPLED_RESPONSE: sct_source_t = 3;
pub type sct_source_t = ::std::os::raw::c_uint;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_NOT_SET: sct_validation_status_t = 0;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_UNKNOWN_LOG: sct_validation_status_t = 1;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_VALID: sct_validation_status_t = 2;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_INVALID: sct_validation_status_t = 3;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_UNVERIFIED: sct_validation_status_t = 4;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_UNKNOWN_VERSION: sct_validation_status_t =
    5;
pub type sct_validation_status_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SCT {
    _unused: [u8; 0],
}
pub type sk_SCT_compfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const *const SCT, b: *const *const SCT) -> ::std::os::raw::c_int,
>;
pub type sk_SCT_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut SCT)>;
pub type sk_SCT_copyfunc = ::std::option::Option<unsafe extern "C" fn(a: *const SCT) -> *mut SCT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_CTLOG {
    _unused: [u8; 0],
}
pub type sk_CTLOG_compfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const *const CTLOG, b: *const *const CTLOG) -> ::std::os::raw::c_int,
>;
pub type sk_CTLOG_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut CTLOG)>;
pub type sk_CTLOG_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const CTLOG) -> *mut CTLOG>;
extern "C" {
    #[doc = " CT policy evaluation context functions *"]
    pub fn CT_POLICY_EVAL_CTX_new() -> *mut CT_POLICY_EVAL_CTX;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_free(ctx: *mut CT_POLICY_EVAL_CTX);
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_get0_cert(ctx: *const CT_POLICY_EVAL_CTX) -> *mut X509;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_set1_cert(
        ctx: *mut CT_POLICY_EVAL_CTX,
        cert: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_get0_issuer(ctx: *const CT_POLICY_EVAL_CTX) -> *mut X509;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_set1_issuer(
        ctx: *mut CT_POLICY_EVAL_CTX,
        issuer: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_get0_log_store(ctx: *const CT_POLICY_EVAL_CTX) -> *const CTLOG_STORE;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(
        ctx: *mut CT_POLICY_EVAL_CTX,
        log_store: *mut CTLOG_STORE,
    );
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_get_time(ctx: *const CT_POLICY_EVAL_CTX) -> u64;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_set_time(ctx: *mut CT_POLICY_EVAL_CTX, time_in_ms: u64);
}
extern "C" {
    #[doc = " SCT functions *"]
    pub fn SCT_new() -> *mut SCT;
}
extern "C" {
    pub fn SCT_new_from_base64(
        version: ::std::os::raw::c_uchar,
        logid_base64: *const ::std::os::raw::c_char,
        entry_type: ct_log_entry_type_t,
        timestamp: u64,
        extensions_base64: *const ::std::os::raw::c_char,
        signature_base64: *const ::std::os::raw::c_char,
    ) -> *mut SCT;
}
extern "C" {
    pub fn SCT_free(sct: *mut SCT);
}
extern "C" {
    pub fn SCT_LIST_free(a: *mut stack_st_SCT);
}
extern "C" {
    pub fn SCT_get_version(sct: *const SCT) -> sct_version_t;
}
extern "C" {
    pub fn SCT_set_version(sct: *mut SCT, version: sct_version_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_get_log_entry_type(sct: *const SCT) -> ct_log_entry_type_t;
}
extern "C" {
    pub fn SCT_set_log_entry_type(
        sct: *mut SCT,
        entry_type: ct_log_entry_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_get0_log_id(sct: *const SCT, log_id: *mut *mut ::std::os::raw::c_uchar) -> size_t;
}
extern "C" {
    pub fn SCT_set0_log_id(
        sct: *mut SCT,
        log_id: *mut ::std::os::raw::c_uchar,
        log_id_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_set1_log_id(
        sct: *mut SCT,
        log_id: *const ::std::os::raw::c_uchar,
        log_id_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_get_timestamp(sct: *const SCT) -> u64;
}
extern "C" {
    pub fn SCT_set_timestamp(sct: *mut SCT, timestamp: u64);
}
extern "C" {
    pub fn SCT_get_signature_nid(sct: *const SCT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_set_signature_nid(
        sct: *mut SCT,
        nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_get0_extensions(sct: *const SCT, ext: *mut *mut ::std::os::raw::c_uchar) -> size_t;
}
extern "C" {
    pub fn SCT_set0_extensions(sct: *mut SCT, ext: *mut ::std::os::raw::c_uchar, ext_len: size_t);
}
extern "C" {
    pub fn SCT_set1_extensions(
        sct: *mut SCT,
        ext: *const ::std::os::raw::c_uchar,
        ext_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_get0_signature(sct: *const SCT, sig: *mut *mut ::std::os::raw::c_uchar) -> size_t;
}
extern "C" {
    pub fn SCT_set0_signature(sct: *mut SCT, sig: *mut ::std::os::raw::c_uchar, sig_len: size_t);
}
extern "C" {
    pub fn SCT_set1_signature(
        sct: *mut SCT,
        sig: *const ::std::os::raw::c_uchar,
        sig_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_get_source(sct: *const SCT) -> sct_source_t;
}
extern "C" {
    pub fn SCT_set_source(sct: *mut SCT, source: sct_source_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_validation_status_string(sct: *const SCT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCT_print(
        sct: *const SCT,
        out: *mut BIO,
        indent: ::std::os::raw::c_int,
        logs: *const CTLOG_STORE,
    );
}
extern "C" {
    pub fn SCT_LIST_print(
        sct_list: *const stack_st_SCT,
        out: *mut BIO,
        indent: ::std::os::raw::c_int,
        separator: *const ::std::os::raw::c_char,
        logs: *const CTLOG_STORE,
    );
}
extern "C" {
    pub fn SCT_get_validation_status(sct: *const SCT) -> sct_validation_status_t;
}
extern "C" {
    pub fn SCT_validate(sct: *mut SCT, ctx: *const CT_POLICY_EVAL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCT_LIST_validate(
        scts: *const stack_st_SCT,
        ctx: *mut CT_POLICY_EVAL_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " SCT parsing and serialisation *"]
    pub fn i2o_SCT_LIST(
        a: *const stack_st_SCT,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn o2i_SCT_LIST(
        a: *mut *mut stack_st_SCT,
        pp: *mut *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> *mut stack_st_SCT;
}
extern "C" {
    pub fn i2d_SCT_LIST(
        a: *const stack_st_SCT,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_SCT_LIST(
        a: *mut *mut stack_st_SCT,
        pp: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut stack_st_SCT;
}
extern "C" {
    pub fn i2o_SCT(
        sct: *const SCT,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn o2i_SCT(
        psct: *mut *mut SCT,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> *mut SCT;
}
extern "C" {
    #[doc = " CT log functions *"]
    pub fn CTLOG_new(public_key: *mut EVP_PKEY, name: *const ::std::os::raw::c_char) -> *mut CTLOG;
}
extern "C" {
    pub fn CTLOG_new_from_base64(
        ct_log: *mut *mut CTLOG,
        pkey_base64: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CTLOG_free(log: *mut CTLOG);
}
extern "C" {
    pub fn CTLOG_get0_name(log: *const CTLOG) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn CTLOG_get0_log_id(log: *const CTLOG, log_id: *mut *const u8, log_id_len: *mut size_t);
}
extern "C" {
    pub fn CTLOG_get0_public_key(log: *const CTLOG) -> *mut EVP_PKEY;
}
extern "C" {
    #[doc = " CT log store functions *"]
    pub fn CTLOG_STORE_new() -> *mut CTLOG_STORE;
}
extern "C" {
    pub fn CTLOG_STORE_free(store: *mut CTLOG_STORE);
}
extern "C" {
    pub fn CTLOG_STORE_get0_log_by_id(
        store: *const CTLOG_STORE,
        log_id: *const u8,
        log_id_len: size_t,
    ) -> *const CTLOG;
}
extern "C" {
    pub fn CTLOG_STORE_load_file(
        store: *mut CTLOG_STORE,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CTLOG_STORE_load_default_file(store: *mut CTLOG_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_SSL_strings() -> ::std::os::raw::c_int;
}
pub type ssl_crock_st = *mut ssl_st;
pub type TLS_SESSION_TICKET_EXT = tls_session_ticket_ext_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_method_st {
    _unused: [u8; 0],
}
pub type SSL_METHOD = ssl_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_cipher_st {
    _unused: [u8; 0],
}
pub type SSL_CIPHER = ssl_cipher_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_session_st {
    _unused: [u8; 0],
}
pub type SSL_SESSION = ssl_session_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_sigalgs_st {
    _unused: [u8; 0],
}
pub type TLS_SIGALGS = tls_sigalgs_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_conf_ctx_st {
    _unused: [u8; 0],
}
pub type SSL_CONF_CTX = ssl_conf_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_comp_st {
    _unused: [u8; 0],
}
pub type SSL_COMP = ssl_comp_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SSL_CIPHER {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SSL_COMP {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_protection_profile_st {
    pub name: *const ::std::os::raw::c_char,
    pub id: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_srtp_protection_profile_st() {
    assert_eq!(
        ::std::mem::size_of::<srtp_protection_profile_st>(),
        16usize,
        concat!("Size of: ", stringify!(srtp_protection_profile_st))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_protection_profile_st>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_protection_profile_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_protection_profile_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_protection_profile_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srtp_protection_profile_st>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_protection_profile_st),
            "::",
            stringify!(id)
        )
    );
}
pub type SRTP_PROTECTION_PROFILE = srtp_protection_profile_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SRTP_PROTECTION_PROFILE {
    _unused: [u8; 0],
}
pub type sk_SRTP_PROTECTION_PROFILE_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const SRTP_PROTECTION_PROFILE,
        b: *const *const SRTP_PROTECTION_PROFILE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_SRTP_PROTECTION_PROFILE_freefunc =
    ::std::option::Option<unsafe extern "C" fn(a: *mut SRTP_PROTECTION_PROFILE)>;
pub type sk_SRTP_PROTECTION_PROFILE_copyfunc = ::std::option::Option<
    unsafe extern "C" fn(a: *const SRTP_PROTECTION_PROFILE) -> *mut SRTP_PROTECTION_PROFILE,
>;
pub type tls_session_ticket_ext_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type tls_session_secret_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        secret: *mut ::std::os::raw::c_void,
        secret_len: *mut ::std::os::raw::c_int,
        peer_ciphers: *mut stack_st_SSL_CIPHER,
        cipher: *mut *const SSL_CIPHER,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type custom_ext_add_cb = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        out: *mut *const ::std::os::raw::c_uchar,
        outlen: *mut size_t,
        al: *mut ::std::os::raw::c_int,
        add_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type custom_ext_free_cb = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        out: *const ::std::os::raw::c_uchar,
        add_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type custom_ext_parse_cb = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        in_: *const ::std::os::raw::c_uchar,
        inlen: size_t,
        al: *mut ::std::os::raw::c_int,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type SSL_custom_ext_add_cb_ex = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        context: ::std::os::raw::c_uint,
        out: *mut *const ::std::os::raw::c_uchar,
        outlen: *mut size_t,
        x: *mut X509,
        chainidx: size_t,
        al: *mut ::std::os::raw::c_int,
        add_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type SSL_custom_ext_free_cb_ex = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        context: ::std::os::raw::c_uint,
        out: *const ::std::os::raw::c_uchar,
        add_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type SSL_custom_ext_parse_cb_ex = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::std::os::raw::c_uint,
        context: ::std::os::raw::c_uint,
        in_: *const ::std::os::raw::c_uchar,
        inlen: size_t,
        x: *mut X509,
        chainidx: size_t,
        al: *mut ::std::os::raw::c_int,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type SSL_verify_cb = ::std::option::Option<
    unsafe extern "C" fn(
        preverify_ok: ::std::os::raw::c_int,
        x509_ctx: *mut X509_STORE_CTX,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_CTX_get_options(ctx: *const SSL_CTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_get_options(s: *const SSL) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_clear_options(
        ctx: *mut SSL_CTX,
        op: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_clear_options(s: *mut SSL, op: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_set_options(
        ctx: *mut SSL_CTX,
        op: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_set_options(s: *mut SSL, op: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_set_msg_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                write_p: ::std::os::raw::c_int,
                version: ::std::os::raw::c_int,
                content_type: ::std::os::raw::c_int,
                buf: *const ::std::os::raw::c_void,
                len: size_t,
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_set_msg_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                write_p: ::std::os::raw::c_int,
                version: ::std::os::raw::c_int,
                content_type: ::std::os::raw::c_int,
                buf: *const ::std::os::raw::c_void,
                len: size_t,
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_SRP_CTX_init(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_SRP_CTX_init(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SRP_CTX_free(ctx: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_SRP_CTX_free(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_srp_server_param_with_username(
        s: *mut SSL,
        ad: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SRP_Calc_A_param(s: *mut SSL) -> ::std::os::raw::c_int;
}
pub type GEN_SESSION_CB = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        id: *mut ::std::os::raw::c_uchar,
        id_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st_SSL_SESSION {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SSL_CTX_sessions(ctx: *mut SSL_CTX) -> *mut lhash_st_SSL_SESSION;
}
extern "C" {
    pub fn SSL_CTX_sess_set_new_cb(
        ctx: *mut SSL_CTX,
        new_session_cb: ::std::option::Option<
            unsafe extern "C" fn(ssl: *mut ssl_st, sess: *mut SSL_SESSION) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_new_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ssl_st, arg1: *mut SSL_SESSION) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn SSL_CTX_sess_set_remove_cb(
        ctx: *mut SSL_CTX,
        remove_session_cb: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut ssl_ctx_st, sess: *mut SSL_SESSION),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_remove_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<unsafe extern "C" fn(ctx: *mut ssl_ctx_st, arg1: *mut SSL_SESSION)>;
}
extern "C" {
    pub fn SSL_CTX_sess_set_get_cb(
        ctx: *mut SSL_CTX,
        get_session_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut ssl_st,
                data: *const ::std::os::raw::c_uchar,
                len: ::std::os::raw::c_int,
                copy: *mut ::std::os::raw::c_int,
            ) -> *mut SSL_SESSION,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_get_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ssl_st,
            arg1: *const ::std::os::raw::c_uchar,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_int,
        ) -> *mut SSL_SESSION,
    >;
}
extern "C" {
    pub fn SSL_CTX_set_info_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *const SSL,
                type_: ::std::os::raw::c_int,
                val: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_info_callback(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *const SSL,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn SSL_CTX_set_client_cert_cb(
        ctx: *mut SSL_CTX,
        client_cert_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                x509: *mut *mut X509,
                pkey: *mut *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_client_cert_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut SSL,
            arg1: *mut *mut X509,
            arg2: *mut *mut EVP_PKEY,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn SSL_CTX_set_client_cert_engine(
        ctx: *mut SSL_CTX,
        e: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_cookie_generate_cb(
        ctx: *mut SSL_CTX,
        app_gen_cookie_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *mut ::std::os::raw::c_uchar,
                cookie_len: *mut ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_cookie_verify_cb(
        ctx: *mut SSL_CTX,
        app_verify_cookie_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *const ::std::os::raw::c_uchar,
                cookie_len: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_stateless_cookie_generate_cb(
        ctx: *mut SSL_CTX,
        gen_stateless_cookie_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *mut ::std::os::raw::c_uchar,
                cookie_len: *mut size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_stateless_cookie_verify_cb(
        ctx: *mut SSL_CTX,
        verify_stateless_cookie_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *const ::std::os::raw::c_uchar,
                cookie_len: size_t,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
pub type SSL_CTX_npn_advertised_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        out: *mut *const ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_next_protos_advertised_cb(
        s: *mut SSL_CTX,
        cb: SSL_CTX_npn_advertised_cb_func,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub type SSL_CTX_npn_select_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        out: *mut *mut ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_next_proto_select_cb(
        s: *mut SSL_CTX,
        cb: SSL_CTX_npn_select_cb_func,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_next_proto_negotiated(
        s: *const SSL,
        data: *mut *const ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SSL_select_next_proto(
        out: *mut *mut ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_uint,
        client: *const ::std::os::raw::c_uchar,
        client_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_alpn_protos(
        ctx: *mut SSL_CTX,
        protos: *const ::std::os::raw::c_uchar,
        protos_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_alpn_protos(
        ssl: *mut SSL,
        protos: *const ::std::os::raw::c_uchar,
        protos_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type SSL_CTX_alpn_select_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        out: *mut *const ::std::os::raw::c_uchar,
        outlen: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_alpn_select_cb(
        ctx: *mut SSL_CTX,
        cb: SSL_CTX_alpn_select_cb_func,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_alpn_selected(
        ssl: *const SSL,
        data: *mut *const ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    );
}
pub type SSL_psk_client_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        hint: *const ::std::os::raw::c_char,
        identity: *mut ::std::os::raw::c_char,
        max_identity_len: ::std::os::raw::c_uint,
        psk: *mut ::std::os::raw::c_uchar,
        max_psk_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    pub fn SSL_CTX_set_psk_client_callback(ctx: *mut SSL_CTX, cb: SSL_psk_client_cb_func);
}
extern "C" {
    pub fn SSL_set_psk_client_callback(ssl: *mut SSL, cb: SSL_psk_client_cb_func);
}
pub type SSL_psk_server_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        identity: *const ::std::os::raw::c_char,
        psk: *mut ::std::os::raw::c_uchar,
        max_psk_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    pub fn SSL_CTX_set_psk_server_callback(ctx: *mut SSL_CTX, cb: SSL_psk_server_cb_func);
}
extern "C" {
    pub fn SSL_set_psk_server_callback(ssl: *mut SSL, cb: SSL_psk_server_cb_func);
}
extern "C" {
    pub fn SSL_CTX_use_psk_identity_hint(
        ctx: *mut SSL_CTX,
        identity_hint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_psk_identity_hint(
        s: *mut SSL,
        identity_hint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_psk_identity_hint(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_psk_identity(s: *const SSL) -> *const ::std::os::raw::c_char;
}
pub type SSL_psk_find_session_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        identity: *const ::std::os::raw::c_uchar,
        identity_len: size_t,
        sess: *mut *mut SSL_SESSION,
    ) -> ::std::os::raw::c_int,
>;
pub type SSL_psk_use_session_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        md: *const EVP_MD,
        id: *mut *const ::std::os::raw::c_uchar,
        idlen: *mut size_t,
        sess: *mut *mut SSL_SESSION,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_set_psk_find_session_callback(s: *mut SSL, cb: SSL_psk_find_session_cb_func);
}
extern "C" {
    pub fn SSL_CTX_set_psk_find_session_callback(
        ctx: *mut SSL_CTX,
        cb: SSL_psk_find_session_cb_func,
    );
}
extern "C" {
    pub fn SSL_set_psk_use_session_callback(s: *mut SSL, cb: SSL_psk_use_session_cb_func);
}
extern "C" {
    pub fn SSL_CTX_set_psk_use_session_callback(ctx: *mut SSL_CTX, cb: SSL_psk_use_session_cb_func);
}
extern "C" {
    pub fn SSL_CTX_has_client_custom_ext(
        ctx: *const SSL_CTX,
        ext_type: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_client_custom_ext(
        ctx: *mut SSL_CTX,
        ext_type: ::std::os::raw::c_uint,
        add_cb: custom_ext_add_cb,
        free_cb: custom_ext_free_cb,
        add_arg: *mut ::std::os::raw::c_void,
        parse_cb: custom_ext_parse_cb,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_server_custom_ext(
        ctx: *mut SSL_CTX,
        ext_type: ::std::os::raw::c_uint,
        add_cb: custom_ext_add_cb,
        free_cb: custom_ext_free_cb,
        add_arg: *mut ::std::os::raw::c_void,
        parse_cb: custom_ext_parse_cb,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_custom_ext(
        ctx: *mut SSL_CTX,
        ext_type: ::std::os::raw::c_uint,
        context: ::std::os::raw::c_uint,
        add_cb: SSL_custom_ext_add_cb_ex,
        free_cb: SSL_custom_ext_free_cb_ex,
        add_arg: *mut ::std::os::raw::c_void,
        parse_cb: SSL_custom_ext_parse_cb_ex,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_extension_supported(ext_type: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
pub type SSL_CTX_keylog_cb_func = ::std::option::Option<
    unsafe extern "C" fn(ssl: *const SSL, line: *const ::std::os::raw::c_char),
>;
extern "C" {
    pub fn SSL_CTX_set_keylog_callback(ctx: *mut SSL_CTX, cb: SSL_CTX_keylog_cb_func);
}
extern "C" {
    pub fn SSL_CTX_get_keylog_callback(ctx: *const SSL_CTX) -> SSL_CTX_keylog_cb_func;
}
extern "C" {
    pub fn SSL_CTX_set_max_early_data(
        ctx: *mut SSL_CTX,
        max_early_data: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_max_early_data(ctx: *const SSL_CTX) -> u32;
}
extern "C" {
    pub fn SSL_set_max_early_data(s: *mut SSL, max_early_data: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_max_early_data(s: *const SSL) -> u32;
}
extern "C" {
    pub fn SSL_CTX_set_recv_max_early_data(
        ctx: *mut SSL_CTX,
        recv_max_early_data: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_recv_max_early_data(ctx: *const SSL_CTX) -> u32;
}
extern "C" {
    pub fn SSL_set_recv_max_early_data(
        s: *mut SSL,
        recv_max_early_data: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_recv_max_early_data(s: *const SSL) -> u32;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_max_fragment_length(
        ctx: *mut SSL_CTX,
        mode: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_max_fragment_length(ssl: *mut SSL, mode: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_servername(
        s: *const SSL,
        type_: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_servername_type(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_export_keying_material(
        s: *mut SSL,
        out: *mut ::std::os::raw::c_uchar,
        olen: size_t,
        label: *const ::std::os::raw::c_char,
        llen: size_t,
        context: *const ::std::os::raw::c_uchar,
        contextlen: size_t,
        use_context: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_export_keying_material_early(
        s: *mut SSL,
        out: *mut ::std::os::raw::c_uchar,
        olen: size_t,
        label: *const ::std::os::raw::c_char,
        llen: size_t,
        context: *const ::std::os::raw::c_uchar,
        contextlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_peer_signature_type_nid(
        s: *const SSL,
        pnid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_signature_type_nid(
        s: *const SSL,
        pnid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_sigalgs(
        s: *mut SSL,
        idx: ::std::os::raw::c_int,
        psign: *mut ::std::os::raw::c_int,
        phash: *mut ::std::os::raw::c_int,
        psignandhash: *mut ::std::os::raw::c_int,
        rsig: *mut ::std::os::raw::c_uchar,
        rhash: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_shared_sigalgs(
        s: *mut SSL,
        idx: ::std::os::raw::c_int,
        psign: *mut ::std::os::raw::c_int,
        phash: *mut ::std::os::raw::c_int,
        psignandhash: *mut ::std::os::raw::c_int,
        rsig: *mut ::std::os::raw::c_uchar,
        rhash: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_check_chain(
        s: *mut SSL,
        x: *mut X509,
        pk: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_session_ticket_ext_st {
    pub length: ::std::os::raw::c_ushort,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_tls_session_ticket_ext_st() {
    assert_eq!(
        ::std::mem::size_of::<tls_session_ticket_ext_st>(),
        16usize,
        concat!("Size of: ", stringify!(tls_session_ticket_ext_st))
    );
    assert_eq!(
        ::std::mem::align_of::<tls_session_ticket_ext_st>(),
        8usize,
        concat!("Alignment of ", stringify!(tls_session_ticket_ext_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tls_session_ticket_ext_st>())).length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tls_session_ticket_ext_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tls_session_ticket_ext_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tls_session_ticket_ext_st),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_use_srtp(
        ctx: *mut SSL_CTX,
        profiles: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_use_srtp(
        ssl: *mut SSL,
        profiles: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_srtp_profiles(ssl: *mut SSL) -> *mut stack_st_SRTP_PROTECTION_PROFILE;
}
extern "C" {
    pub fn SSL_get_selected_srtp_profile(s: *mut SSL) -> *mut SRTP_PROTECTION_PROFILE;
}
pub type sk_SSL_CIPHER_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const SSL_CIPHER,
        b: *const *const SSL_CIPHER,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_SSL_CIPHER_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut SSL_CIPHER)>;
pub type sk_SSL_CIPHER_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const SSL_CIPHER) -> *mut SSL_CIPHER>;
pub type sk_SSL_COMP_compfunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const SSL_COMP,
        b: *const *const SSL_COMP,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_SSL_COMP_freefunc = ::std::option::Option<unsafe extern "C" fn(a: *mut SSL_COMP)>;
pub type sk_SSL_COMP_copyfunc =
    ::std::option::Option<unsafe extern "C" fn(a: *const SSL_COMP) -> *mut SSL_COMP>;
extern "C" {
    pub fn SSL_set_debug(s: *mut SSL, debug: ::std::os::raw::c_int);
}
pub const OSSL_HANDSHAKE_STATE_TLS_ST_BEFORE: OSSL_HANDSHAKE_STATE = 0;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_OK: OSSL_HANDSHAKE_STATE = 1;
pub const OSSL_HANDSHAKE_STATE_DTLS_ST_CR_HELLO_VERIFY_REQUEST: OSSL_HANDSHAKE_STATE = 2;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_SRVR_HELLO: OSSL_HANDSHAKE_STATE = 3;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CERT: OSSL_HANDSHAKE_STATE = 4;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CERT_STATUS: OSSL_HANDSHAKE_STATE = 5;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_KEY_EXCH: OSSL_HANDSHAKE_STATE = 6;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CERT_REQ: OSSL_HANDSHAKE_STATE = 7;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_SRVR_DONE: OSSL_HANDSHAKE_STATE = 8;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_SESSION_TICKET: OSSL_HANDSHAKE_STATE = 9;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CHANGE: OSSL_HANDSHAKE_STATE = 10;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_FINISHED: OSSL_HANDSHAKE_STATE = 11;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_CLNT_HELLO: OSSL_HANDSHAKE_STATE = 12;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_CERT: OSSL_HANDSHAKE_STATE = 13;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_KEY_EXCH: OSSL_HANDSHAKE_STATE = 14;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_CERT_VRFY: OSSL_HANDSHAKE_STATE = 15;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_CHANGE: OSSL_HANDSHAKE_STATE = 16;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_NEXT_PROTO: OSSL_HANDSHAKE_STATE = 17;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_FINISHED: OSSL_HANDSHAKE_STATE = 18;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_HELLO_REQ: OSSL_HANDSHAKE_STATE = 19;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_CLNT_HELLO: OSSL_HANDSHAKE_STATE = 20;
pub const OSSL_HANDSHAKE_STATE_DTLS_ST_SW_HELLO_VERIFY_REQUEST: OSSL_HANDSHAKE_STATE = 21;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_SRVR_HELLO: OSSL_HANDSHAKE_STATE = 22;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CERT: OSSL_HANDSHAKE_STATE = 23;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_KEY_EXCH: OSSL_HANDSHAKE_STATE = 24;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CERT_REQ: OSSL_HANDSHAKE_STATE = 25;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_SRVR_DONE: OSSL_HANDSHAKE_STATE = 26;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_CERT: OSSL_HANDSHAKE_STATE = 27;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_KEY_EXCH: OSSL_HANDSHAKE_STATE = 28;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_CERT_VRFY: OSSL_HANDSHAKE_STATE = 29;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_NEXT_PROTO: OSSL_HANDSHAKE_STATE = 30;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_CHANGE: OSSL_HANDSHAKE_STATE = 31;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_FINISHED: OSSL_HANDSHAKE_STATE = 32;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_SESSION_TICKET: OSSL_HANDSHAKE_STATE = 33;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CERT_STATUS: OSSL_HANDSHAKE_STATE = 34;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CHANGE: OSSL_HANDSHAKE_STATE = 35;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_FINISHED: OSSL_HANDSHAKE_STATE = 36;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_ENCRYPTED_EXTENSIONS: OSSL_HANDSHAKE_STATE = 37;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_ENCRYPTED_EXTENSIONS: OSSL_HANDSHAKE_STATE = 38;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CERT_VRFY: OSSL_HANDSHAKE_STATE = 39;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CERT_VRFY: OSSL_HANDSHAKE_STATE = 40;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_HELLO_REQ: OSSL_HANDSHAKE_STATE = 41;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_KEY_UPDATE: OSSL_HANDSHAKE_STATE = 42;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_KEY_UPDATE: OSSL_HANDSHAKE_STATE = 43;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_KEY_UPDATE: OSSL_HANDSHAKE_STATE = 44;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_KEY_UPDATE: OSSL_HANDSHAKE_STATE = 45;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_EARLY_DATA: OSSL_HANDSHAKE_STATE = 46;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_PENDING_EARLY_DATA_END: OSSL_HANDSHAKE_STATE = 47;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_END_OF_EARLY_DATA: OSSL_HANDSHAKE_STATE = 48;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_END_OF_EARLY_DATA: OSSL_HANDSHAKE_STATE = 49;
pub type OSSL_HANDSHAKE_STATE = ::std::os::raw::c_uint;
extern "C" {
    pub fn SSL_in_init(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_in_before(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_is_init_finished(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_finished(
        s: *const SSL,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SSL_get_peer_finished(
        s: *const SSL,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn PEM_read_bio_SSL_SESSION(
        bp: *mut BIO,
        x: *mut *mut SSL_SESSION,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn PEM_read_SSL_SESSION(
        fp: *mut FILE,
        x: *mut *mut SSL_SESSION,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn PEM_write_bio_SSL_SESSION(bp: *mut BIO, x: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_SSL_SESSION(fp: *mut FILE, x: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_f_ssl() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_ssl(ctx: *mut SSL_CTX, client: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_ssl_connect(ctx: *mut SSL_CTX) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_buffer_ssl_connect(ctx: *mut SSL_CTX) -> *mut BIO;
}
extern "C" {
    pub fn BIO_ssl_copy_session_id(to: *mut BIO, from: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ssl_shutdown(ssl_bio: *mut BIO);
}
extern "C" {
    pub fn SSL_CTX_set_cipher_list(
        arg1: *mut SSL_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_new(meth: *const SSL_METHOD) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_CTX_up_ref(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_free(arg1: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_CTX_set_timeout(
        ctx: *mut SSL_CTX,
        t: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_get_timeout(ctx: *const SSL_CTX) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_get_cert_store(arg1: *const SSL_CTX) -> *mut X509_STORE;
}
extern "C" {
    pub fn SSL_CTX_set_cert_store(arg1: *mut SSL_CTX, arg2: *mut X509_STORE);
}
extern "C" {
    pub fn SSL_CTX_set1_cert_store(arg1: *mut SSL_CTX, arg2: *mut X509_STORE);
}
extern "C" {
    pub fn SSL_want(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_clear(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_flush_sessions(ctx: *mut SSL_CTX, tm: ::std::os::raw::c_long);
}
extern "C" {
    pub fn SSL_get_current_cipher(s: *const SSL) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_get_pending_cipher(s: *const SSL) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CIPHER_get_bits(
        c: *const SSL_CIPHER,
        alg_bits: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_version(c: *const SSL_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_name(c: *const SSL_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_standard_name(c: *const SSL_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OPENSSL_cipher_name(
        rfc_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_id(c: *const SSL_CIPHER) -> u32;
}
extern "C" {
    pub fn SSL_CIPHER_get_protocol_id(c: *const SSL_CIPHER) -> u16;
}
extern "C" {
    pub fn SSL_CIPHER_get_kx_nid(c: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_auth_nid(c: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_handshake_digest(c: *const SSL_CIPHER) -> *const EVP_MD;
}
extern "C" {
    pub fn SSL_CIPHER_is_aead(c: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_fd(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_rfd(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_wfd(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_cipher_list(
        s: *const SSL,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_shared_ciphers(
        s: *const SSL,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_read_ahead(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_pending(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_has_pending(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_fd(s: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_rfd(s: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_wfd(s: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set0_rbio(s: *mut SSL, rbio: *mut BIO);
}
extern "C" {
    pub fn SSL_set0_wbio(s: *mut SSL, wbio: *mut BIO);
}
extern "C" {
    pub fn SSL_set_bio(s: *mut SSL, rbio: *mut BIO, wbio: *mut BIO);
}
extern "C" {
    pub fn SSL_get_rbio(s: *const SSL) -> *mut BIO;
}
extern "C" {
    pub fn SSL_get_wbio(s: *const SSL) -> *mut BIO;
}
extern "C" {
    pub fn SSL_set_cipher_list(
        s: *mut SSL,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ciphersuites(
        ctx: *mut SSL_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_ciphersuites(
        s: *mut SSL,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_read_ahead(s: *mut SSL, yes: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_verify_mode(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_verify_depth(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_verify_callback(s: *const SSL) -> SSL_verify_cb;
}
extern "C" {
    pub fn SSL_set_verify(s: *mut SSL, mode: ::std::os::raw::c_int, callback: SSL_verify_cb);
}
extern "C" {
    pub fn SSL_set_verify_depth(s: *mut SSL, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_cert_cb(
        s: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey(ssl: *mut SSL, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey_ASN1(
        ssl: *mut SSL,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey(ssl: *mut SSL, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey_ASN1(
        pk: ::std::os::raw::c_int,
        ssl: *mut SSL,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate(ssl: *mut SSL, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_ASN1(
        ssl: *mut SSL,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_cert_and_key(
        ssl: *mut SSL,
        x509: *mut X509,
        privatekey: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
        override_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_serverinfo(
        ctx: *mut SSL_CTX,
        serverinfo: *const ::std::os::raw::c_uchar,
        serverinfo_length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_serverinfo_ex(
        ctx: *mut SSL_CTX,
        version: ::std::os::raw::c_uint,
        serverinfo: *const ::std::os::raw::c_uchar,
        serverinfo_length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_serverinfo_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_chain_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_chain_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_load_client_CA_file(file: *const ::std::os::raw::c_char) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add_file_cert_subjects_to_stack(
        stackCAs: *mut stack_st_X509_NAME,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_add_dir_cert_subjects_to_stack(
        stackCAs: *mut stack_st_X509_NAME,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_state_string(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_rstate_string(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_state_string_long(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_rstate_string_long(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_SESSION_get_time(s: *const SSL_SESSION) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_SESSION_set_time(
        s: *mut SSL_SESSION,
        t: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_SESSION_get_timeout(s: *const SSL_SESSION) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_SESSION_set_timeout(
        s: *mut SSL_SESSION,
        t: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_SESSION_get_protocol_version(s: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_set_protocol_version(
        s: *mut SSL_SESSION,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_hostname(s: *const SSL_SESSION) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_SESSION_set1_hostname(
        s: *mut SSL_SESSION,
        hostname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_alpn_selected(
        s: *const SSL_SESSION,
        alpn: *mut *const ::std::os::raw::c_uchar,
        len: *mut size_t,
    );
}
extern "C" {
    pub fn SSL_SESSION_set1_alpn_selected(
        s: *mut SSL_SESSION,
        alpn: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_cipher(s: *const SSL_SESSION) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_SESSION_set_cipher(
        s: *mut SSL_SESSION,
        cipher: *const SSL_CIPHER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_has_ticket(s: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_ticket_lifetime_hint(s: *const SSL_SESSION) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_SESSION_get0_ticket(
        s: *const SSL_SESSION,
        tick: *mut *const ::std::os::raw::c_uchar,
        len: *mut size_t,
    );
}
extern "C" {
    pub fn SSL_SESSION_get_max_early_data(s: *const SSL_SESSION) -> u32;
}
extern "C" {
    pub fn SSL_SESSION_set_max_early_data(
        s: *mut SSL_SESSION,
        max_early_data: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_copy_session_id(to: *mut SSL, from: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_peer(s: *mut SSL_SESSION) -> *mut X509;
}
extern "C" {
    pub fn SSL_SESSION_set1_id_context(
        s: *mut SSL_SESSION,
        sid_ctx: *const ::std::os::raw::c_uchar,
        sid_ctx_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_set1_id(
        s: *mut SSL_SESSION,
        sid: *const ::std::os::raw::c_uchar,
        sid_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_is_resumable(s: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_new() -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_SESSION_dup(src: *mut SSL_SESSION) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_SESSION_get_id(
        s: *const SSL_SESSION,
        len: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SSL_SESSION_get0_id_context(
        s: *const SSL_SESSION,
        len: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn SSL_SESSION_get_compress_id(s: *const SSL_SESSION) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SSL_SESSION_print_fp(fp: *mut FILE, ses: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_print(fp: *mut BIO, ses: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_print_keylog(bp: *mut BIO, x: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_up_ref(ses: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_free(ses: *mut SSL_SESSION);
}
extern "C" {
    pub fn i2d_SSL_SESSION(
        in_: *mut SSL_SESSION,
        pp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session(to: *mut SSL, session: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_session(
        ctx: *mut SSL_CTX,
        session: *mut SSL_SESSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_remove_session(
        ctx: *mut SSL_CTX,
        session: *mut SSL_SESSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_generate_session_id(
        ctx: *mut SSL_CTX,
        cb: GEN_SESSION_CB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_generate_session_id(s: *mut SSL, cb: GEN_SESSION_CB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_has_matching_session_id(
        s: *const SSL,
        id: *const ::std::os::raw::c_uchar,
        id_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_SSL_SESSION(
        a: *mut *mut SSL_SESSION,
        pp: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get_peer_certificate(s: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_get_peer_cert_chain(s: *const SSL) -> *mut stack_st_X509;
}
extern "C" {
    pub fn SSL_CTX_get_verify_mode(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_verify_depth(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_verify_callback(ctx: *const SSL_CTX) -> SSL_verify_cb;
}
extern "C" {
    pub fn SSL_CTX_set_verify(
        ctx: *mut SSL_CTX,
        mode: ::std::os::raw::c_int,
        callback: SSL_verify_cb,
    );
}
extern "C" {
    pub fn SSL_CTX_set_verify_depth(ctx: *mut SSL_CTX, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_set_cert_verify_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut X509_STORE_CTX,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_set_cert_cb(
        c: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey(ctx: *mut SSL_CTX, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey_ASN1(
        ctx: *mut SSL_CTX,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey(ctx: *mut SSL_CTX, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey_ASN1(
        pk: ::std::os::raw::c_int,
        ctx: *mut SSL_CTX,
        d: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate(ctx: *mut SSL_CTX, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_ASN1(
        ctx: *mut SSL_CTX,
        len: ::std::os::raw::c_int,
        d: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_cert_and_key(
        ctx: *mut SSL_CTX,
        x509: *mut X509,
        privatekey: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
        override_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_passwd_cb(ctx: *mut SSL_CTX, cb: pem_password_cb);
}
extern "C" {
    pub fn SSL_CTX_set_default_passwd_cb_userdata(
        ctx: *mut SSL_CTX,
        u: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_get_default_passwd_cb(ctx: *mut SSL_CTX) -> pem_password_cb;
}
extern "C" {
    pub fn SSL_CTX_get_default_passwd_cb_userdata(ctx: *mut SSL_CTX)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_set_default_passwd_cb(s: *mut SSL, cb: pem_password_cb);
}
extern "C" {
    pub fn SSL_set_default_passwd_cb_userdata(s: *mut SSL, u: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SSL_get_default_passwd_cb(s: *mut SSL) -> pem_password_cb;
}
extern "C" {
    pub fn SSL_get_default_passwd_cb_userdata(s: *mut SSL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_CTX_check_private_key(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_check_private_key(ctx: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_session_id_context(
        ctx: *mut SSL_CTX,
        sid_ctx: *const ::std::os::raw::c_uchar,
        sid_ctx_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_new(ctx: *mut SSL_CTX) -> *mut SSL;
}
extern "C" {
    pub fn SSL_up_ref(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_is_dtls(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session_id_context(
        ssl: *mut SSL,
        sid_ctx: *const ::std::os::raw::c_uchar,
        sid_ctx_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_purpose(
        ctx: *mut SSL_CTX,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_purpose(ssl: *mut SSL, purpose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_trust(
        ctx: *mut SSL_CTX,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_trust(ssl: *mut SSL, trust: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_host(
        s: *mut SSL,
        hostname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_add1_host(
        s: *mut SSL,
        hostname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_peername(s: *mut SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_set_hostflags(s: *mut SSL, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn SSL_CTX_dane_enable(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_dane_mtype_set(
        ctx: *mut SSL_CTX,
        md: *const EVP_MD,
        mtype: u8,
        ord: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_dane_enable(
        s: *mut SSL,
        basedomain: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_dane_tlsa_add(
        s: *mut SSL,
        usage: u8,
        selector: u8,
        mtype: u8,
        data: *const ::std::os::raw::c_uchar,
        dlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_dane_authority(
        s: *mut SSL,
        mcert: *mut *mut X509,
        mspki: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_dane_tlsa(
        s: *mut SSL,
        usage: *mut u8,
        selector: *mut u8,
        mtype: *mut u8,
        data: *mut *const ::std::os::raw::c_uchar,
        dlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_dane(ssl: *mut SSL) -> *mut SSL_DANE;
}
extern "C" {
    pub fn SSL_CTX_dane_set_flags(
        ctx: *mut SSL_CTX,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_dane_clear_flags(
        ctx: *mut SSL_CTX,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_dane_set_flags(
        ssl: *mut SSL,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_dane_clear_flags(
        ssl: *mut SSL,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_set1_param(
        ctx: *mut SSL_CTX,
        vpm: *mut X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_param(ssl: *mut SSL, vpm: *mut X509_VERIFY_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get0_param(ctx: *mut SSL_CTX) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn SSL_get0_param(ssl: *mut SSL) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn SSL_CTX_set_srp_username(
        ctx: *mut SSL_CTX,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_password(
        ctx: *mut SSL_CTX,
        password: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_strength(
        ctx: *mut SSL_CTX,
        strength: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_client_pwd_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_char,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_verify_param_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_username_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_cb_arg(
        ctx: *mut SSL_CTX,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_srp_server_param(
        s: *mut SSL,
        N: *const BIGNUM,
        g: *const BIGNUM,
        sa: *mut BIGNUM,
        v: *mut BIGNUM,
        info: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_srp_server_param_pw(
        s: *mut SSL,
        user: *const ::std::os::raw::c_char,
        pass: *const ::std::os::raw::c_char,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_srp_g(s: *mut SSL) -> *mut BIGNUM;
}
extern "C" {
    pub fn SSL_get_srp_N(s: *mut SSL) -> *mut BIGNUM;
}
extern "C" {
    pub fn SSL_get_srp_username(s: *mut SSL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_srp_userinfo(s: *mut SSL) -> *mut ::std::os::raw::c_char;
}
pub type SSL_client_hello_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        al: *mut ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_client_hello_cb(
        c: *mut SSL_CTX,
        cb: SSL_client_hello_cb_fn,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_client_hello_isv2(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_client_hello_get0_legacy_version(s: *mut SSL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SSL_client_hello_get0_random(
        s: *mut SSL,
        out: *mut *const ::std::os::raw::c_uchar,
    ) -> size_t;
}
extern "C" {
    pub fn SSL_client_hello_get0_session_id(
        s: *mut SSL,
        out: *mut *const ::std::os::raw::c_uchar,
    ) -> size_t;
}
extern "C" {
    pub fn SSL_client_hello_get0_ciphers(
        s: *mut SSL,
        out: *mut *const ::std::os::raw::c_uchar,
    ) -> size_t;
}
extern "C" {
    pub fn SSL_client_hello_get0_compression_methods(
        s: *mut SSL,
        out: *mut *const ::std::os::raw::c_uchar,
    ) -> size_t;
}
extern "C" {
    pub fn SSL_client_hello_get1_extensions_present(
        s: *mut SSL,
        out: *mut *mut ::std::os::raw::c_int,
        outlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_client_hello_get0_ext(
        s: *mut SSL,
        type_: ::std::os::raw::c_uint,
        out: *mut *const ::std::os::raw::c_uchar,
        outlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_certs_clear(s: *mut SSL);
}
extern "C" {
    pub fn SSL_free(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_waiting_for_async(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_all_async_fds(
        s: *mut SSL,
        fds: *mut ::std::os::raw::c_int,
        numfds: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_changed_async_fds(
        s: *mut SSL,
        addfd: *mut ::std::os::raw::c_int,
        numaddfds: *mut size_t,
        delfd: *mut ::std::os::raw::c_int,
        numdelfds: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_accept(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_stateless(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_connect(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_read(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_read_ex(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: size_t,
        readbytes: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_read_early_data(
        s: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: size_t,
        readbytes: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_peek(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_peek_ex(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: size_t,
        readbytes: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_write(
        ssl: *mut SSL,
        buf: *const ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_write_ex(
        s: *mut SSL,
        buf: *const ::std::os::raw::c_void,
        num: size_t,
        written: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_write_early_data(
        s: *mut SSL,
        buf: *const ::std::os::raw::c_void,
        num: size_t,
        written: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_ctrl(
        ssl: *mut SSL,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_callback_ctrl(
        arg1: *mut SSL,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_ctrl(
        ctx: *mut SSL_CTX,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_callback_ctrl(
        arg1: *mut SSL_CTX,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_get_early_data_status(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_error(s: *const SSL, ret_code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_version(s: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CTX_set_ssl_version(
        ctx: *mut SSL_CTX,
        meth: *const SSL_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TLS_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLS_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLS_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_get_data_mtu(s: *const SSL) -> size_t;
}
extern "C" {
    pub fn SSL_get_ciphers(s: *const SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CTX_get_ciphers(ctx: *const SSL_CTX) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_get_client_ciphers(s: *const SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_get1_supported_ciphers(s: *mut SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_do_handshake(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_key_update(s: *mut SSL, updatetype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_key_update_type(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_renegotiate(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_renegotiate_abbreviated(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_renegotiate_pending(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_shutdown(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_verify_client_post_handshake(s: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_post_handshake_auth(ctx: *mut SSL_CTX, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_post_handshake_auth(s: *mut SSL, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_ssl_method(ctx: *const SSL_CTX) -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_get_ssl_method(s: *const SSL) -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_set_ssl_method(s: *mut SSL, method: *const SSL_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_alert_type_string_long(
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_alert_type_string(value: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_alert_desc_string_long(
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_alert_desc_string(value: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_set0_CA_list(s: *mut SSL, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_CTX_set0_CA_list(ctx: *mut SSL_CTX, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_get0_CA_list(s: *const SSL) -> *const stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_CTX_get0_CA_list(ctx: *const SSL_CTX) -> *const stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add1_to_CA_list(ssl: *mut SSL, x: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add1_to_CA_list(ctx: *mut SSL_CTX, x: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_peer_CA_list(s: *const SSL) -> *const stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_set_client_CA_list(s: *mut SSL, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_CTX_set_client_CA_list(ctx: *mut SSL_CTX, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_get_client_CA_list(s: *const SSL) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_CTX_get_client_CA_list(s: *const SSL_CTX) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add_client_CA(ssl: *mut SSL, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_client_CA(ctx: *mut SSL_CTX, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_connect_state(s: *mut SSL);
}
extern "C" {
    pub fn SSL_set_accept_state(s: *mut SSL);
}
extern "C" {
    pub fn SSL_get_default_timeout(s: *const SSL) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CIPHER_description(
        arg1: *const SSL_CIPHER,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_dup_CA_list(sk: *const stack_st_X509_NAME) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_dup(ssl: *mut SSL) -> *mut SSL;
}
extern "C" {
    pub fn SSL_get_certificate(ssl: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_get_privatekey(ssl: *const SSL) -> *mut evp_pkey_st;
}
extern "C" {
    pub fn SSL_CTX_get0_certificate(ctx: *const SSL_CTX) -> *mut X509;
}
extern "C" {
    pub fn SSL_CTX_get0_privatekey(ctx: *const SSL_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn SSL_CTX_set_quiet_shutdown(ctx: *mut SSL_CTX, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_quiet_shutdown(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_quiet_shutdown(ssl: *mut SSL, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_quiet_shutdown(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_shutdown(ssl: *mut SSL, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_shutdown(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_version(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_client_version(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_paths(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_dir(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_file(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_load_verify_locations(
        ctx: *mut SSL_CTX,
        CAfile: *const ::std::os::raw::c_char,
        CApath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_session(ssl: *const SSL) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get1_session(ssl: *mut SSL) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get_SSL_CTX(ssl: *const SSL) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_set_SSL_CTX(ssl: *mut SSL, ctx: *mut SSL_CTX) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_set_info_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *const SSL,
                type_: ::std::os::raw::c_int,
                val: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_get_info_callback(
        ssl: *const SSL,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *const SSL,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn SSL_get_state(ssl: *const SSL) -> OSSL_HANDSHAKE_STATE;
}
extern "C" {
    pub fn SSL_set_verify_result(ssl: *mut SSL, v: ::std::os::raw::c_long);
}
extern "C" {
    pub fn SSL_get_verify_result(ssl: *const SSL) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_get0_verified_chain(s: *const SSL) -> *mut stack_st_X509;
}
extern "C" {
    pub fn SSL_get_client_random(
        ssl: *const SSL,
        out: *mut ::std::os::raw::c_uchar,
        outlen: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SSL_get_server_random(
        ssl: *const SSL,
        out: *mut ::std::os::raw::c_uchar,
        outlen: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SSL_SESSION_get_master_key(
        sess: *const SSL_SESSION,
        out: *mut ::std::os::raw::c_uchar,
        outlen: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SSL_SESSION_set1_master_key(
        sess: *mut SSL_SESSION,
        in_: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_max_fragment_length(sess: *const SSL_SESSION) -> u8;
}
extern "C" {
    pub fn SSL_set_ex_data(
        ssl: *mut SSL,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_ex_data(
        ssl: *const SSL,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_SESSION_set_ex_data(
        ss: *mut SSL_SESSION,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_ex_data(
        ss: *const SSL_SESSION,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_CTX_set_ex_data(
        ssl: *mut SSL_CTX,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_ex_data(
        ssl: *const SSL_CTX,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_get_ex_data_X509_STORE_CTX_idx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_read_buffer_len(ctx: *mut SSL_CTX, len: size_t);
}
extern "C" {
    pub fn SSL_set_default_read_buffer_len(s: *mut SSL, len: size_t);
}
extern "C" {
    pub fn SSL_CTX_set_tmp_dh_callback(
        ctx: *mut SSL_CTX,
        dh: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut DH,
        >,
    );
}
extern "C" {
    pub fn SSL_set_tmp_dh_callback(
        ssl: *mut SSL,
        dh: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut DH,
        >,
    );
}
extern "C" {
    pub fn SSL_get_current_compression(s: *const SSL) -> *const COMP_METHOD;
}
extern "C" {
    pub fn SSL_get_current_expansion(s: *const SSL) -> *const COMP_METHOD;
}
extern "C" {
    pub fn SSL_COMP_get_name(comp: *const COMP_METHOD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_COMP_get0_name(comp: *const SSL_COMP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_COMP_get_id(comp: *const SSL_COMP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_COMP_get_compression_methods() -> *mut stack_st_SSL_COMP;
}
extern "C" {
    pub fn SSL_COMP_set0_compression_methods(
        meths: *mut stack_st_SSL_COMP,
    ) -> *mut stack_st_SSL_COMP;
}
extern "C" {
    pub fn SSL_COMP_add_compression_method(
        id: ::std::os::raw::c_int,
        cm: *mut COMP_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_find(ssl: *mut SSL, ptr: *const ::std::os::raw::c_uchar)
        -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CIPHER_get_cipher_nid(c: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_digest_nid(c: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_bytes_to_cipher_list(
        s: *mut SSL,
        bytes: *const ::std::os::raw::c_uchar,
        len: size_t,
        isv2format: ::std::os::raw::c_int,
        sk: *mut *mut stack_st_SSL_CIPHER,
        scsvs: *mut *mut stack_st_SSL_CIPHER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session_ticket_ext(
        s: *mut SSL,
        ext_data: *mut ::std::os::raw::c_void,
        ext_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session_ticket_ext_cb(
        s: *mut SSL,
        cb: tls_session_ticket_ext_cb_fn,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session_secret_cb(
        s: *mut SSL,
        session_secret_cb: tls_session_secret_cb_fn,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_not_resumable_session_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_forward_secure: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_set_not_resumable_session_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_forward_secure: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_record_padding_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                type_: ::std::os::raw::c_int,
                len: size_t,
                arg: *mut ::std::os::raw::c_void,
            ) -> size_t,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_record_padding_callback_arg(
        ctx: *mut SSL_CTX,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_get_record_padding_callback_arg(
        ctx: *const SSL_CTX,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_CTX_set_block_padding(
        ctx: *mut SSL_CTX,
        block_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_record_padding_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                type_: ::std::os::raw::c_int,
                len: size_t,
                arg: *mut ::std::os::raw::c_void,
            ) -> size_t,
        >,
    );
}
extern "C" {
    pub fn SSL_set_record_padding_callback_arg(ssl: *mut SSL, arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SSL_get_record_padding_callback_arg(ssl: *const SSL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_set_block_padding(ssl: *mut SSL, block_size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_num_tickets(s: *mut SSL, num_tickets: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_num_tickets(s: *const SSL) -> size_t;
}
extern "C" {
    pub fn SSL_CTX_set_num_tickets(ctx: *mut SSL_CTX, num_tickets: size_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_num_tickets(ctx: *const SSL_CTX) -> size_t;
}
extern "C" {
    pub fn SSL_session_reused(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_is_server(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_new() -> *mut SSL_CONF_CTX;
}
extern "C" {
    pub fn SSL_CONF_CTX_finish(cctx: *mut SSL_CONF_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_free(cctx: *mut SSL_CONF_CTX);
}
extern "C" {
    pub fn SSL_CONF_CTX_set_flags(
        cctx: *mut SSL_CONF_CTX,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SSL_CONF_CTX_clear_flags(
        cctx: *mut SSL_CONF_CTX,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SSL_CONF_CTX_set1_prefix(
        cctx: *mut SSL_CONF_CTX,
        pre: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_set_ssl(cctx: *mut SSL_CONF_CTX, ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_CONF_CTX_set_ssl_ctx(cctx: *mut SSL_CONF_CTX, ctx: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_CONF_cmd(
        cctx: *mut SSL_CONF_CTX,
        cmd: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_cmd_argv(
        cctx: *mut SSL_CONF_CTX,
        pargc: *mut ::std::os::raw::c_int,
        pargv: *mut *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CONF_cmd_value_type(
        cctx: *mut SSL_CONF_CTX,
        cmd: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_add_ssl_module();
}
extern "C" {
    pub fn SSL_config(s: *mut SSL, name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_config(
        ctx: *mut SSL_CTX,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DTLSv1_listen(s: *mut SSL, client: *mut BIO_ADDR) -> ::std::os::raw::c_int;
}
pub type ssl_ct_validation_cb = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const CT_POLICY_EVAL_CTX,
        scts: *const stack_st_SCT,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_set_ct_validation_callback(
        s: *mut SSL,
        callback: ssl_ct_validation_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ct_validation_callback(
        ctx: *mut SSL_CTX,
        callback: ssl_ct_validation_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const SSL_CT_VALIDATION_PERMISSIVE: ::std::os::raw::c_uint = 0;
pub const SSL_CT_VALIDATION_STRICT: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
extern "C" {
    pub fn SSL_enable_ct(
        s: *mut SSL,
        validation_mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_enable_ct(
        ctx: *mut SSL_CTX,
        validation_mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_ct_is_enabled(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_ct_is_enabled(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_peer_scts(s: *mut SSL) -> *const stack_st_SCT;
}
extern "C" {
    pub fn SSL_CTX_set_default_ctlog_list_file(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ctlog_list_file(
        ctx: *mut SSL_CTX,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set0_ctlog_store(ctx: *mut SSL_CTX, logs: *mut CTLOG_STORE);
}
extern "C" {
    pub fn SSL_CTX_get0_ctlog_store(ctx: *const SSL_CTX) -> *const CTLOG_STORE;
}
extern "C" {
    pub fn SSL_set_security_level(s: *mut SSL, level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_security_level(s: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_security_callback(
        s: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                s: *const SSL,
                ctx: *const SSL_CTX,
                op: ::std::os::raw::c_int,
                bits: ::std::os::raw::c_int,
                nid: ::std::os::raw::c_int,
                other: *mut ::std::os::raw::c_void,
                ex: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_get_security_callback(
        s: *const SSL,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            s: *const SSL,
            arg1: *const SSL_CTX,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_void,
            arg6: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn SSL_set0_security_ex_data(s: *mut SSL, ex: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SSL_get0_security_ex_data(s: *const SSL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_CTX_set_security_level(ctx: *mut SSL_CTX, level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_security_level(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_security_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                s: *const SSL,
                ctx: *const SSL_CTX,
                op: ::std::os::raw::c_int,
                bits: ::std::os::raw::c_int,
                nid: ::std::os::raw::c_int,
                other: *mut ::std::os::raw::c_void,
                ex: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_security_callback(
        ctx: *const SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *const SSL,
            arg1: *const SSL_CTX,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: ::std::os::raw::c_int,
            arg5: *mut ::std::os::raw::c_void,
            arg6: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn SSL_CTX_set0_security_ex_data(ctx: *mut SSL_CTX, ex: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SSL_CTX_get0_security_ex_data(ctx: *const SSL_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_init_ssl(
        opts: u64,
        settings: *const OPENSSL_INIT_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_free_buffers(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_alloc_buffers(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
pub type SSL_TICKET_STATUS = ::std::os::raw::c_int;
pub type SSL_TICKET_RETURN = ::std::os::raw::c_int;
pub type SSL_CTX_generate_session_ticket_fn = ::std::option::Option<
    unsafe extern "C" fn(s: *mut SSL, arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type SSL_CTX_decrypt_session_ticket_fn = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ss: *mut SSL_SESSION,
        keyname: *const ::std::os::raw::c_uchar,
        keyname_length: size_t,
        status: SSL_TICKET_STATUS,
        arg: *mut ::std::os::raw::c_void,
    ) -> SSL_TICKET_RETURN,
>;
extern "C" {
    pub fn SSL_CTX_set_session_ticket_cb(
        ctx: *mut SSL_CTX,
        gen_cb: SSL_CTX_generate_session_ticket_fn,
        dec_cb: SSL_CTX_decrypt_session_ticket_fn,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_set1_ticket_appdata(
        ss: *mut SSL_SESSION,
        data: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_ticket_appdata(
        ss: *mut SSL_SESSION,
        data: *mut *mut ::std::os::raw::c_void,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut SSL_version_str: [::std::os::raw::c_char; 0usize];
}
pub type DTLS_timer_cb = ::std::option::Option<
    unsafe extern "C" fn(s: *mut SSL, timer_us: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint,
>;
extern "C" {
    pub fn DTLS_set_timer_cb(s: *mut SSL, cb: DTLS_timer_cb);
}
pub type SSL_allow_early_data_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(s: *mut SSL, arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_allow_early_data_cb(
        ctx: *mut SSL_CTX,
        cb: SSL_allow_early_data_cb_fn,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_set_allow_early_data_cb(
        s: *mut SSL,
        cb: SSL_allow_early_data_cb_fn,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct err_state_st {
    pub err_flags: [::std::os::raw::c_int; 16usize],
    pub err_buffer: [::std::os::raw::c_ulong; 16usize],
    pub err_data: [*mut ::std::os::raw::c_char; 16usize],
    pub err_data_flags: [::std::os::raw::c_int; 16usize],
    pub err_file: [*const ::std::os::raw::c_char; 16usize],
    pub err_line: [::std::os::raw::c_int; 16usize],
    pub top: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_err_state_st() {
    assert_eq!(
        ::std::mem::size_of::<err_state_st>(),
        584usize,
        concat!("Size of: ", stringify!(err_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<err_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(err_state_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<err_state_st>())).err_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(err_state_st),
            "::",
            stringify!(err_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<err_state_st>())).err_buffer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(err_state_st),
            "::",
            stringify!(err_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<err_state_st>())).err_data as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(err_state_st),
            "::",
            stringify!(err_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<err_state_st>())).err_data_flags as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(err_state_st),
            "::",
            stringify!(err_data_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<err_state_st>())).err_file as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(err_state_st),
            "::",
            stringify!(err_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<err_state_st>())).err_line as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(err_state_st),
            "::",
            stringify!(err_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<err_state_st>())).top as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(err_state_st),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<err_state_st>())).bottom as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(err_state_st),
            "::",
            stringify!(bottom)
        )
    );
}
pub type ERR_STATE = err_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERR_string_data_st {
    pub error: ::std::os::raw::c_ulong,
    pub string: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ERR_string_data_st() {
    assert_eq!(
        ::std::mem::size_of::<ERR_string_data_st>(),
        16usize,
        concat!("Size of: ", stringify!(ERR_string_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ERR_string_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ERR_string_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ERR_string_data_st>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ERR_string_data_st),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ERR_string_data_st>())).string as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ERR_string_data_st),
            "::",
            stringify!(string)
        )
    );
}
pub type ERR_STRING_DATA = ERR_string_data_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lhash_st_ERR_STRING_DATA {
    pub dummy: lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy {
    pub d1: *mut ::std::os::raw::c_void,
    pub d2: ::std::os::raw::c_ulong,
    pub d3: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy>())).d1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy),
            "::",
            stringify!(d1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy>())).d2
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy),
            "::",
            stringify!(d2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy>())).d3
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy),
            "::",
            stringify!(d3)
        )
    );
}
#[test]
fn bindgen_test_layout_lhash_st_ERR_STRING_DATA() {
    assert_eq!(
        ::std::mem::size_of::<lhash_st_ERR_STRING_DATA>(),
        8usize,
        concat!("Size of: ", stringify!(lhash_st_ERR_STRING_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<lhash_st_ERR_STRING_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(lhash_st_ERR_STRING_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lhash_st_ERR_STRING_DATA>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lhash_st_ERR_STRING_DATA),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    pub fn ERR_put_error(
        lib: ::std::os::raw::c_int,
        func: ::std::os::raw::c_int,
        reason: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ERR_set_error_data(data: *mut ::std::os::raw::c_char, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ERR_get_error() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_get_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_get_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ERR_clear_error();
}
extern "C" {
    pub fn ERR_error_string(
        e: ::std::os::raw::c_ulong,
        buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_error_string_n(
        e: ::std::os::raw::c_ulong,
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
    );
}
extern "C" {
    pub fn ERR_lib_error_string(e: ::std::os::raw::c_ulong) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_func_error_string(e: ::std::os::raw::c_ulong) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_reason_error_string(e: ::std::os::raw::c_ulong) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_print_errors_cb(
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                str_: *const ::std::os::raw::c_char,
                len: size_t,
                u: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        u: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ERR_print_errors_fp(fp: *mut FILE);
}
extern "C" {
    pub fn ERR_print_errors(bp: *mut BIO);
}
extern "C" {
    pub fn ERR_add_error_data(num: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn ERR_add_error_vdata(num: ::std::os::raw::c_int, args: *mut __va_list_tag);
}
extern "C" {
    pub fn ERR_load_strings(
        lib: ::std::os::raw::c_int,
        str_: *mut ERR_STRING_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_strings_const(str_: *const ERR_STRING_DATA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_unload_strings(
        lib: ::std::os::raw::c_int,
        str_: *mut ERR_STRING_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_ERR_strings() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_remove_thread_state(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ERR_remove_state(pid: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ERR_get_state() -> *mut ERR_STATE;
}
extern "C" {
    pub fn ERR_get_next_error_library() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_set_mark() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_pop_to_mark() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_clear_last_mark() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstat(
        __ver: ::std::os::raw::c_int,
        __fildes: ::std::os::raw::c_int,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xstat(
        __ver: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lxstat(
        __ver: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstatat(
        __ver: ::std::os::raw::c_int,
        __fildes: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknod(
        __ver: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknodat(
        __ver: ::std::os::raw::c_int,
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> ::std::os::raw::c_int;
}
pub const cl_error_t_CL_CLEAN: cl_error_t = 0;
pub const cl_error_t_CL_SUCCESS: cl_error_t = 0;
pub const cl_error_t_CL_VIRUS: cl_error_t = 1;
pub const cl_error_t_CL_ENULLARG: cl_error_t = 2;
pub const cl_error_t_CL_EARG: cl_error_t = 3;
pub const cl_error_t_CL_EMALFDB: cl_error_t = 4;
pub const cl_error_t_CL_ECVD: cl_error_t = 5;
pub const cl_error_t_CL_EVERIFY: cl_error_t = 6;
pub const cl_error_t_CL_EUNPACK: cl_error_t = 7;
pub const cl_error_t_CL_EOPEN: cl_error_t = 8;
pub const cl_error_t_CL_ECREAT: cl_error_t = 9;
pub const cl_error_t_CL_EUNLINK: cl_error_t = 10;
pub const cl_error_t_CL_ESTAT: cl_error_t = 11;
pub const cl_error_t_CL_EREAD: cl_error_t = 12;
pub const cl_error_t_CL_ESEEK: cl_error_t = 13;
pub const cl_error_t_CL_EWRITE: cl_error_t = 14;
pub const cl_error_t_CL_EDUP: cl_error_t = 15;
pub const cl_error_t_CL_EACCES: cl_error_t = 16;
pub const cl_error_t_CL_ETMPFILE: cl_error_t = 17;
pub const cl_error_t_CL_ETMPDIR: cl_error_t = 18;
pub const cl_error_t_CL_EMAP: cl_error_t = 19;
pub const cl_error_t_CL_EMEM: cl_error_t = 20;
pub const cl_error_t_CL_ETIMEOUT: cl_error_t = 21;
pub const cl_error_t_CL_BREAK: cl_error_t = 22;
pub const cl_error_t_CL_EMAXREC: cl_error_t = 23;
pub const cl_error_t_CL_EMAXSIZE: cl_error_t = 24;
pub const cl_error_t_CL_EMAXFILES: cl_error_t = 25;
pub const cl_error_t_CL_EFORMAT: cl_error_t = 26;
pub const cl_error_t_CL_EPARSE: cl_error_t = 27;
pub const cl_error_t_CL_EBYTECODE: cl_error_t = 28;
pub const cl_error_t_CL_EBYTECODE_TESTFAIL: cl_error_t = 29;
pub const cl_error_t_CL_ELOCK: cl_error_t = 30;
pub const cl_error_t_CL_EBUSY: cl_error_t = 31;
pub const cl_error_t_CL_ESTATE: cl_error_t = 32;
pub const cl_error_t_CL_VERIFIED: cl_error_t = 33;
pub const cl_error_t_CL_ERROR: cl_error_t = 34;
pub const cl_error_t_CL_ELAST_ERROR: cl_error_t = 35;
pub type cl_error_t = ::std::os::raw::c_uint;
#[doc = " scan options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_scan_options {
    pub general: u32,
    pub parse: u32,
    pub heuristic: u32,
    pub mail: u32,
    pub dev: u32,
}
#[test]
fn bindgen_test_layout_cl_scan_options() {
    assert_eq!(
        ::std::mem::size_of::<cl_scan_options>(),
        20usize,
        concat!("Size of: ", stringify!(cl_scan_options))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_scan_options>(),
        4usize,
        concat!("Alignment of ", stringify!(cl_scan_options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).general as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(general)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).parse as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).heuristic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(heuristic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).mail as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(mail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).dev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(dev)
        )
    );
}
extern "C" {
    #[doc = " @brief Enable debug messages"]
    pub fn cl_debug();
}
extern "C" {
    #[doc = " @brief Set libclamav to always create section hashes for PE files."]
    #[doc = ""]
    #[doc = " Section hashes are used in .mdb signature."]
    pub fn cl_always_gen_section_hash();
}
extern "C" {
    #[doc = " @brief This function initializes the openssl crypto system."]
    #[doc = ""]
    #[doc = " Called by cl_init() and does not need to be cleaned up as de-init"]
    #[doc = " is handled automatically by openssl 1.0.2.h and 1.1.0"]
    #[doc = ""]
    #[doc = " @return Always returns 0"]
    pub fn cl_initialize_crypto() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief This is a deprecated function that used to clean up ssl crypto inits."]
    #[doc = ""]
    #[doc = " Call to EVP_cleanup() has been removed since cleanup is now handled by"]
    #[doc = " auto-deinit as of openssl 1.0.2h and 1.1.0"]
    pub fn cl_cleanup_crypto();
}
extern "C" {
    #[doc = " @brief Initialize the ClamAV library."]
    #[doc = ""]
    #[doc = " @param initoptions   Unused."]
    #[doc = " @return cl_error_t   CL_SUCCESS if everything initalized correctly."]
    pub fn cl_init(initoptions: ::std::os::raw::c_uint) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Allocate a new scanning engine and initialize default settings."]
    #[doc = ""]
    #[doc = " The engine should be freed with `cl_engine_free()`."]
    #[doc = ""]
    #[doc = " @return struct cl_engine* Pointer to the scanning engine."]
    pub fn cl_engine_new() -> *mut cl_engine;
}
pub const cl_engine_field_CL_ENGINE_MAX_SCANSIZE: cl_engine_field = 0;
pub const cl_engine_field_CL_ENGINE_MAX_FILESIZE: cl_engine_field = 1;
pub const cl_engine_field_CL_ENGINE_MAX_RECURSION: cl_engine_field = 2;
pub const cl_engine_field_CL_ENGINE_MAX_FILES: cl_engine_field = 3;
pub const cl_engine_field_CL_ENGINE_MIN_CC_COUNT: cl_engine_field = 4;
pub const cl_engine_field_CL_ENGINE_MIN_SSN_COUNT: cl_engine_field = 5;
pub const cl_engine_field_CL_ENGINE_PUA_CATEGORIES: cl_engine_field = 6;
pub const cl_engine_field_CL_ENGINE_DB_OPTIONS: cl_engine_field = 7;
pub const cl_engine_field_CL_ENGINE_DB_VERSION: cl_engine_field = 8;
pub const cl_engine_field_CL_ENGINE_DB_TIME: cl_engine_field = 9;
pub const cl_engine_field_CL_ENGINE_AC_ONLY: cl_engine_field = 10;
pub const cl_engine_field_CL_ENGINE_AC_MINDEPTH: cl_engine_field = 11;
pub const cl_engine_field_CL_ENGINE_AC_MAXDEPTH: cl_engine_field = 12;
pub const cl_engine_field_CL_ENGINE_TMPDIR: cl_engine_field = 13;
pub const cl_engine_field_CL_ENGINE_KEEPTMP: cl_engine_field = 14;
pub const cl_engine_field_CL_ENGINE_BYTECODE_SECURITY: cl_engine_field = 15;
pub const cl_engine_field_CL_ENGINE_BYTECODE_TIMEOUT: cl_engine_field = 16;
pub const cl_engine_field_CL_ENGINE_BYTECODE_MODE: cl_engine_field = 17;
pub const cl_engine_field_CL_ENGINE_MAX_EMBEDDEDPE: cl_engine_field = 18;
pub const cl_engine_field_CL_ENGINE_MAX_HTMLNORMALIZE: cl_engine_field = 19;
pub const cl_engine_field_CL_ENGINE_MAX_HTMLNOTAGS: cl_engine_field = 20;
pub const cl_engine_field_CL_ENGINE_MAX_SCRIPTNORMALIZE: cl_engine_field = 21;
pub const cl_engine_field_CL_ENGINE_MAX_ZIPTYPERCG: cl_engine_field = 22;
pub const cl_engine_field_CL_ENGINE_FORCETODISK: cl_engine_field = 23;
pub const cl_engine_field_CL_ENGINE_DISABLE_CACHE: cl_engine_field = 24;
pub const cl_engine_field_CL_ENGINE_DISABLE_PE_STATS: cl_engine_field = 25;
pub const cl_engine_field_CL_ENGINE_STATS_TIMEOUT: cl_engine_field = 26;
pub const cl_engine_field_CL_ENGINE_MAX_PARTITIONS: cl_engine_field = 27;
pub const cl_engine_field_CL_ENGINE_MAX_ICONSPE: cl_engine_field = 28;
pub const cl_engine_field_CL_ENGINE_MAX_RECHWP3: cl_engine_field = 29;
pub const cl_engine_field_CL_ENGINE_MAX_SCANTIME: cl_engine_field = 30;
pub const cl_engine_field_CL_ENGINE_PCRE_MATCH_LIMIT: cl_engine_field = 31;
pub const cl_engine_field_CL_ENGINE_PCRE_RECMATCH_LIMIT: cl_engine_field = 32;
pub const cl_engine_field_CL_ENGINE_PCRE_MAX_FILESIZE: cl_engine_field = 33;
pub const cl_engine_field_CL_ENGINE_DISABLE_PE_CERTS: cl_engine_field = 34;
pub const cl_engine_field_CL_ENGINE_PE_DUMPCERTS: cl_engine_field = 35;
pub type cl_engine_field = ::std::os::raw::c_uint;
pub const bytecode_security_CL_BYTECODE_TRUST_ALL: bytecode_security = 0;
pub const bytecode_security_CL_BYTECODE_TRUST_SIGNED: bytecode_security = 1;
pub const bytecode_security_CL_BYTECODE_TRUST_NOTHING: bytecode_security = 2;
pub type bytecode_security = ::std::os::raw::c_uint;
pub const bytecode_mode_CL_BYTECODE_MODE_AUTO: bytecode_mode = 0;
pub const bytecode_mode_CL_BYTECODE_MODE_JIT: bytecode_mode = 1;
pub const bytecode_mode_CL_BYTECODE_MODE_INTERPRETER: bytecode_mode = 2;
pub const bytecode_mode_CL_BYTECODE_MODE_TEST: bytecode_mode = 3;
pub const bytecode_mode_CL_BYTECODE_MODE_OFF: bytecode_mode = 4;
pub type bytecode_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_section_hash {
    pub md5: [::std::os::raw::c_uchar; 16usize],
    pub len: size_t,
}
#[test]
fn bindgen_test_layout_cli_section_hash() {
    assert_eq!(
        ::std::mem::size_of::<cli_section_hash>(),
        24usize,
        concat!("Size of: ", stringify!(cli_section_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_section_hash>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_section_hash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_section_hash>())).md5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_section_hash),
            "::",
            stringify!(md5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_section_hash>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_section_hash),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_stats_sections {
    pub nsections: size_t,
    pub sections: *mut cli_section_hash,
}
#[test]
fn bindgen_test_layout_cli_stats_sections() {
    assert_eq!(
        ::std::mem::size_of::<cli_stats_sections>(),
        16usize,
        concat!("Size of: ", stringify!(cli_stats_sections))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_stats_sections>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_stats_sections))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_stats_sections>())).nsections as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_stats_sections),
            "::",
            stringify!(nsections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_stats_sections>())).sections as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_stats_sections),
            "::",
            stringify!(sections)
        )
    );
}
pub type stats_section_t = cli_stats_sections;
extern "C" {
    #[doc = " @brief Set a numerical engine option."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine            An initialized scan engine."]
    #[doc = " @param cl_engine_field   A CL_ENGINE option."]
    #[doc = " @param num               The new engine option value."]
    #[doc = " @return cl_error_t       CL_SUCCESS if successfully set."]
    #[doc = " @return cl_error_t       CL_EARG if the field number was incorrect."]
    #[doc = " @return cl_error_t       CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_set_num(
        engine: *mut cl_engine,
        field: cl_engine_field,
        num: ::std::os::raw::c_longlong,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Get a numerical engine option."]
    #[doc = ""]
    #[doc = " @param engine            An initialized scan engine."]
    #[doc = " @param cl_engine_field   A CL_ENGINE option."]
    #[doc = " @param err               (optional) A cl_error_t status code."]
    #[doc = " @return long long        The numerical option value."]
    pub fn cl_engine_get_num(
        engine: *const cl_engine,
        field: cl_engine_field,
        err: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief Set a string engine option."]
    #[doc = ""]
    #[doc = " If the string option has already been set, the existing string will be free'd"]
    #[doc = " and the new string will replace it."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine            An initialized scan engine."]
    #[doc = " @param cl_engine_field   A CL_ENGINE option."]
    #[doc = " @param str               The new engine option value."]
    #[doc = " @return cl_error_t       CL_SUCCESS if successfully set."]
    #[doc = " @return cl_error_t       CL_EARG if the field number was incorrect."]
    #[doc = " @return cl_error_t       CL_EMEM if a memory allocation error occurred."]
    #[doc = " @return cl_error_t       CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_set_str(
        engine: *mut cl_engine,
        field: cl_engine_field,
        str_: *const ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Get a string engine option."]
    #[doc = ""]
    #[doc = " @param engine            An initialized scan engine."]
    #[doc = " @param cl_engine_field   A CL_ENGINE option."]
    #[doc = " @param err               (optional) A cl_error_t status code."]
    #[doc = " @return const char *     The string option value."]
    pub fn cl_engine_get_str(
        engine: *const cl_engine,
        field: cl_engine_field,
        err: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Copy the settings from an existing scan engine."]
    #[doc = ""]
    #[doc = " The cl_settings pointer is allocated and must be freed with cl_engine_settings_free()."]
    #[doc = ""]
    #[doc = " @param engine                An configured scan engine."]
    #[doc = " @return struct cl_settings*  The settings."]
    pub fn cl_engine_settings_copy(engine: *const cl_engine) -> *mut cl_settings;
}
extern "C" {
    #[doc = " @brief Apply settings from a settings structure to a scan engine."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine        A scan engine."]
    #[doc = " @param settings      The settings."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_EMEM if a memory allocation error occurred."]
    pub fn cl_engine_settings_apply(
        engine: *mut cl_engine,
        settings: *const cl_settings,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Free a settings struct pointer."]
    #[doc = ""]
    #[doc = " @param settings      The settings struct pointer."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_settings_free(settings: *mut cl_settings) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Prepare the scanning engine."]
    #[doc = ""]
    #[doc = " Called this after all required databases have been loaded and settings have"]
    #[doc = " been applied."]
    #[doc = ""]
    #[doc = " @param engine        A scan engine."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_compile(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Add a reference count to the engine."]
    #[doc = ""]
    #[doc = " Thread safety mechanism so that the engine is not free'd by another thread."]
    #[doc = ""]
    #[doc = " The engine is initialized with refcount = 1, so this only needs to be called"]
    #[doc = " for additional scanning threads."]
    #[doc = ""]
    #[doc = " @param engine        A scan engine."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_addref(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Free an engine."]
    #[doc = ""]
    #[doc = " Will lower the reference count on an engine. If the reference count hits"]
    #[doc = " zero, the engine will be freed."]
    #[doc = ""]
    #[doc = " @param engine        A scan engine."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_free(engine: *mut cl_engine) -> cl_error_t;
}
#[doc = " @brief Pre-cache callback."]
#[doc = ""]
#[doc = " Called for each processed file (both the entry level - AKA 'outer' - file and"]
#[doc = " inner files - those generated when processing archive and container files), before"]
#[doc = " the actual scanning takes place."]
#[doc = ""]
#[doc = " @param fd        File descriptor which is about to be scanned."]
#[doc = " @param type      File type detected via magic - i.e. NOT on the fly - (e.g. \"CL_TYPE_MSEXE\")."]
#[doc = " @param context   Opaque application provided data."]
#[doc = " @return          CL_CLEAN = File is scanned."]
#[doc = " @return          CL_BREAK = Allowed by callback - file is skipped and marked as clean."]
#[doc = " @return          CL_VIRUS = Blocked by callback - file is skipped and marked as infected."]
pub type clcb_pre_cache = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom pre-cache callback function."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_pre_cache(engine: *mut cl_engine, callback: clcb_pre_cache);
}
#[doc = " @brief Pre-scan callback."]
#[doc = ""]
#[doc = " Called for each NEW file (inner and outer) before the scanning takes place. This is"]
#[doc = " roughly the the same as clcb_before_cache, but it is affected by clean file caching."]
#[doc = " This means that it won't be called if a clean cached file (inner or outer) is"]
#[doc = " scanned a second time."]
#[doc = ""]
#[doc = " @param fd        File descriptor which is about to be scanned."]
#[doc = " @param type      File type detected via magic - i.e. NOT on the fly - (e.g. \"CL_TYPE_MSEXE\")."]
#[doc = " @param context   Opaque application provided data."]
#[doc = " @return          CL_CLEAN = File is scanned."]
#[doc = " @return          CL_BREAK = Allowed by callback - file is skipped and marked as clean."]
#[doc = " @return          CL_VIRUS = Blocked by callback - file is skipped and marked as infected."]
pub type clcb_pre_scan = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom pre-scan callback function."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_pre_scan(engine: *mut cl_engine, callback: clcb_pre_scan);
}
#[doc = " @brief Post-scan callback."]
#[doc = ""]
#[doc = " Called for each processed file (inner and outer), after the scanning is complete."]
#[doc = " In all-match mode, the virname will be one of the matches, but there is no"]
#[doc = " guarantee in which order the matches will occur, thus the final virname may"]
#[doc = " be any one of the matches."]
#[doc = ""]
#[doc = " @param fd        File descriptor which was scanned."]
#[doc = " @param result    The scan result for the file."]
#[doc = " @param virname   A signature name if there was one or more matches."]
#[doc = " @param context   Opaque application provided data."]
#[doc = " @return          Scan result is not overridden."]
#[doc = " @return          CL_BREAK = Allowed by callback - scan result is set to CL_CLEAN."]
#[doc = " @return          Blocked by callback - scan result is set to CL_VIRUS."]
pub type clcb_post_scan = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        result: ::std::os::raw::c_int,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom post-scan callback function."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_post_scan(engine: *mut cl_engine, callback: clcb_post_scan);
}
#[doc = " @brief Virus-found callback."]
#[doc = ""]
#[doc = " Called for each signature match."]
#[doc = " If all-match is enabled, clcb_virus_found() may be called multiple times per"]
#[doc = " scan."]
#[doc = ""]
#[doc = " In addition, clcb_virus_found() does not have a return value and thus."]
#[doc = " can not be used to ignore the match."]
#[doc = ""]
#[doc = " @param fd        File descriptor which was scanned."]
#[doc = " @param virname   Virus name."]
#[doc = " @param context   Opaque application provided data."]
pub type clcb_virus_found = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom virus-found callback function."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_virus_found(engine: *mut cl_engine, callback: clcb_virus_found);
}
#[doc = " @brief Signature-load callback."]
#[doc = ""]
#[doc = " May be used to ignore signatures at database load time."]
#[doc = ""]
#[doc = " WARNING: Some signatures (notably ldb, cbc) can be dependent upon other signatures."]
#[doc = "          Failure to preserve dependency chains will result in database loading failure."]
#[doc = "          It is the implementor's responsibility to guarantee consistency."]
#[doc = ""]
#[doc = " @param type      The signature type (e.g. \"db\", \"ndb\", \"mdb\", etc.)"]
#[doc = " @param name      Signature name."]
#[doc = " @param custom    The signature is official (custom == 0) or custom (custom != 0)"]
#[doc = " @param context   Opaque application provided data"]
#[doc = " @return          0 to load the current signature."]
#[doc = " @return          Non-0 to skip the current signature."]
pub type clcb_sigload = ::std::option::Option<
    unsafe extern "C" fn(
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        custom: ::std::os::raw::c_uint,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Set a custom signature-load callback function."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    #[doc = " @param context   Opaque application provided data."]
    pub fn cl_engine_set_clcb_sigload(
        engine: *mut cl_engine,
        callback: clcb_sigload,
        context: *mut ::std::os::raw::c_void,
    );
}
pub const cl_msg_CL_MSG_INFO_VERBOSE: cl_msg = 32;
pub const cl_msg_CL_MSG_WARN: cl_msg = 64;
pub const cl_msg_CL_MSG_ERROR: cl_msg = 128;
pub type cl_msg = ::std::os::raw::c_uint;
#[doc = " @brief Progress callback for sig-load, engine-compile, and engine-free."]
#[doc = ""]
#[doc = " Progress is complete when total_items == now_completed."]
#[doc = ""]
#[doc = " Note: The callback should return CL_SUCCESS. We reserve the right to have it"]
#[doc = "       cancel the operation in the future if you return something else..."]
#[doc = "       ... but for now, the return value will be ignored."]
#[doc = ""]
#[doc = " @param total_items   Total number of items"]
#[doc = " @param now_completed Number of items completed"]
#[doc = " @param context       Opaque application provided data"]
#[doc = " @return cl_error_t   reserved for future use"]
pub type clcb_progress = ::std::option::Option<
    unsafe extern "C" fn(
        total_items: size_t,
        now_completed: size_t,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a progress callback function to be called incrementally during a"]
    #[doc = " database load."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine"]
    #[doc = " @param callback  The callback function pointer"]
    #[doc = " @param context   Opaque application provided data"]
    pub fn cl_engine_set_clcb_sigload_progress(
        engine: *mut cl_engine,
        callback: clcb_progress,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Set a progress callback function to be called incrementally during an"]
    #[doc = " engine compile."]
    #[doc = ""]
    #[doc = " Disclaimer: the number of items for this is a rough estimate of the items that"]
    #[doc = " tend to take longest to compile and doesn't represent an accurate number of"]
    #[doc = " things compiled."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine"]
    #[doc = " @param callback  The callback function pointer"]
    #[doc = " @param context   Opaque application provided data"]
    pub fn cl_engine_set_clcb_engine_compile_progress(
        engine: *mut cl_engine,
        callback: clcb_progress,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Set a progress callback function to be called incrementally during an"]
    #[doc = " engine free (if the engine is in fact freed)."]
    #[doc = ""]
    #[doc = " Disclaimer: the number of items for this is a rough estimate of the items that"]
    #[doc = " tend to take longest to free and doesn't represent an accurate number of"]
    #[doc = " things freed."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine"]
    #[doc = " @param callback  The callback function pointer"]
    #[doc = " @param context   Opaque application provided data"]
    pub fn cl_engine_set_clcb_engine_free_progress(
        engine: *mut cl_engine,
        callback: clcb_progress,
        context: *mut ::std::os::raw::c_void,
    );
}
#[doc = " @brief Logging message callback for info, warning, and error messages."]
#[doc = ""]
#[doc = " The specified callback will be called instead of logging to stderr."]
#[doc = " Messages of lower severity than specified are logged as usual."]
#[doc = ""]
#[doc = " Callback may be used to silence logging by assigning a do-nothing function."]
#[doc = " Does not affect debug log messages."]
#[doc = ""]
#[doc = " Just like with cl_debug() this must be called before going multithreaded."]
#[doc = " Callable before cl_init, if you want to log messages from cl_init() itself."]
#[doc = ""]
#[doc = " You can use context of cl_scandesc_callback to convey more information to"]
#[doc = " the callback (such as the filename!)."]
#[doc = ""]
#[doc = " Note: setting a 2nd callbacks overwrites previous, multiple callbacks are not"]
#[doc = " supported."]
#[doc = ""]
#[doc = " @param severity  Message severity (CL_MSG_INFO_VERBOSE, CL_MSG_WARN, or CL_MSG_ERROR)."]
#[doc = " @param fullmsg   The log message including the \"LibClamAV <severity>: \" prefix."]
#[doc = " @param msg       The log message."]
#[doc = " @param context   Opaque application provided data."]
pub type clcb_msg = ::std::option::Option<
    unsafe extern "C" fn(
        severity: cl_msg,
        fullmsg: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom logging message callback function for all of libclamav."]
    #[doc = ""]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_set_clcb_msg(callback: clcb_msg);
}
#[doc = " @brief LibClamAV hash stats callback."]
#[doc = ""]
#[doc = " Callback that provides the hash of a scanned sample if a signature alerted."]
#[doc = " Provides a mechanism to record detection statistics."]
#[doc = ""]
#[doc = " @param fd        File descriptor if available, else -1."]
#[doc = " @param size      Sample size"]
#[doc = " @param md5       Sample md5 hash"]
#[doc = " @param virname   Signature name that the sample matched against"]
#[doc = " @param context   Opaque application provided data"]
pub type clcb_hash = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        size: ::std::os::raw::c_ulonglong,
        md5: *const ::std::os::raw::c_uchar,
        virname: *const ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom hash stats callback function."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_hash(engine: *mut cl_engine, callback: clcb_hash);
}
#[doc = " @brief Archive meta matching callback function."]
#[doc = ""]
#[doc = " May be used to block archive/container samples based on archive metadata."]
#[doc = " Function is invoked multiple times per archive. Typically once per contained file."]
#[doc = ""]
#[doc = " Note: Used by the --archive-verbose clamscan option. Overriding this will alter"]
#[doc = " the output from --archive-verbose."]
#[doc = ""]
#[doc = " @param container_type    String name of type (CL_TYPE)."]
#[doc = " @param fsize_container   Sample size"]
#[doc = " @param filename          Filename associated with the data in archive."]
#[doc = " @param fsize_real        Size of file after decompression (according to the archive)."]
#[doc = " @param is_encrypted      Boolean non-zero if the contained file is encrypted."]
#[doc = " @param filepos_container File index in container."]
#[doc = " @param context           Opaque application provided data."]
#[doc = " @return                  CL_VIRUS to block (alert on)"]
#[doc = " @return                  CL_CLEAN to continue scanning"]
pub type clcb_meta = ::std::option::Option<
    unsafe extern "C" fn(
        container_type: *const ::std::os::raw::c_char,
        fsize_container: ::std::os::raw::c_ulong,
        filename: *const ::std::os::raw::c_char,
        fsize_real: ::std::os::raw::c_ulong,
        is_encrypted: ::std::os::raw::c_int,
        filepos_container: ::std::os::raw::c_uint,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t,
>;
extern "C" {
    #[doc = " @brief Set a custom archive metadata matching callback function."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_meta(engine: *mut cl_engine, callback: clcb_meta);
}
#[doc = " @brief File properties callback function."]
#[doc = ""]
#[doc = " Invoked after a scan the CL_SCAN_GENERAL_COLLECT_METADATA general scan option"]
#[doc = " is enabled and libclamav was built with json support."]
#[doc = ""]
#[doc = " @param j_propstr File properties/metadata in a JSON encoded string."]
#[doc = " @param rc        The cl_error_t return code from the scan."]
#[doc = " @param cbdata    Opaque application provided data."]
pub type clcb_file_props = ::std::option::Option<
    unsafe extern "C" fn(
        j_propstr: *const ::std::os::raw::c_char,
        rc: ::std::os::raw::c_int,
        cbdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Set a custom file properties callback function."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_file_props(engine: *mut cl_engine, callback: clcb_file_props);
}
extern "C" {
    #[doc = " @brief Set a pointer the caller-defined cbdata structure."]
    #[doc = ""]
    #[doc = " The data must persist at least until `clcb_stats_submit()` is called, or"]
    #[doc = " `clcb_stats_flush()` is called (optional)."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine The scanning engine."]
    #[doc = " @param cbdata The statistics data. Probably a pointer to a malloc'd struct."]
    pub fn cl_engine_set_stats_set_cbdata(
        engine: *mut cl_engine,
        cbdata: *mut ::std::os::raw::c_void,
    );
}
#[doc = " @brief Add sample metadata to the statistics for a sample that matched on a signature."]
#[doc = ""]
#[doc = " @param virname   Name of the signature that matched."]
#[doc = " @param md5       Sample hash."]
#[doc = " @param size      Sample size."]
#[doc = " @param sections  PE section data, if applicable."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_add_sample = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: size_t,
        sections: *mut stats_section_t,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to add sample metadata to a statistics report."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_add_sample(
        engine: *mut cl_engine,
        callback: clcb_stats_add_sample,
    );
}
#[doc = " @brief Remove a specific sample from the statistics report."]
#[doc = ""]
#[doc = " @param virname   Name of the signature that matched."]
#[doc = " @param md5       Sample hash."]
#[doc = " @param size      Sample size."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_remove_sample = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: size_t,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to remove sample metadata from a statistics report."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_remove_sample(
        engine: *mut cl_engine,
        callback: clcb_stats_remove_sample,
    );
}
#[doc = " @brief Decrement the hit count listed in the statistics report for a specific sample."]
#[doc = ""]
#[doc = " @param virname   Name of the signature that matched."]
#[doc = " @param md5       Sample hash."]
#[doc = " @param size      Sample size."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_decrement_count = ::std::option::Option<
    unsafe extern "C" fn(
        virname: *const ::std::os::raw::c_char,
        md5: *const ::std::os::raw::c_uchar,
        size: size_t,
        cbdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to decrement the hit count listed in the statistics report for a specific sample."]
    #[doc = ""]
    #[doc = " This function may remove the sample from the report if the hit count is decremented to 0."]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_decrement_count(
        engine: *mut cl_engine,
        callback: clcb_stats_decrement_count,
    );
}
#[doc = " @brief Function to submit a statistics report."]
#[doc = ""]
#[doc = " @param engine    The initialized scanning engine."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_submit = ::std::option::Option<
    unsafe extern "C" fn(engine: *mut cl_engine, cbdata: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to submit the statistics report."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_submit(engine: *mut cl_engine, callback: clcb_stats_submit);
}
#[doc = " @brief Function to flush/free the statistics report data."]
#[doc = ""]
#[doc = " @param engine    The initialized scanning engine."]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_flush = ::std::option::Option<
    unsafe extern "C" fn(engine: *mut cl_engine, cbdata: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to flush/free the statistics report data."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_flush(engine: *mut cl_engine, callback: clcb_stats_flush);
}
#[doc = " @brief Function to get the number of samples listed in the statistics report."]
#[doc = ""]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_num =
    ::std::option::Option<unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> size_t>;
extern "C" {
    #[doc = " @brief Set a custom callback function to get the number of samples listed in the statistics report."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_get_num(engine: *mut cl_engine, callback: clcb_stats_get_num);
}
#[doc = " @brief Function to get the size of memory used to store the statistics report."]
#[doc = ""]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_size =
    ::std::option::Option<unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> size_t>;
extern "C" {
    #[doc = " @brief Set a custom callback function to get the size of memory used to store the statistics report."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_get_size(engine: *mut cl_engine, callback: clcb_stats_get_size);
}
#[doc = " @brief Function to get the machine's unique host ID."]
#[doc = ""]
#[doc = " @param cbdata    The statistics data. Probably a pointer to a malloc'd struct."]
pub type clcb_stats_get_hostid = ::std::option::Option<
    unsafe extern "C" fn(cbdata: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    #[doc = " @brief Set a custom callback function to get the machine's unique host ID."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    #[doc = " @param callback  The callback function pointer."]
    pub fn cl_engine_set_clcb_stats_get_hostid(
        engine: *mut cl_engine,
        callback: clcb_stats_get_hostid,
    );
}
extern "C" {
    #[doc = " @brief Function enables the built-in statistics reporting feature."]
    #[doc = ""]
    #[doc = " @param engine    The initialized scanning engine."]
    pub fn cl_engine_stats_enable(engine: *mut cl_engine);
}
extern "C" {
    #[doc = " @brief Scan a file, given a file descriptor."]
    #[doc = ""]
    #[doc = " @param desc              File descriptor of an open file. The caller must provide this or the map."]
    #[doc = " @param filename          (optional) Filepath of the open file descriptor or file map."]
    #[doc = " @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature."]
    #[doc = " @param[out] scanned      The number of bytes scanned."]
    #[doc = " @param engine            The scanning engine."]
    #[doc = " @param scanoptions       Scanning options."]
    #[doc = " @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occured during the scan."]
    pub fn cl_scandesc(
        desc: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a file descriptor."]
    #[doc = ""]
    #[doc = " This callback variant allows the caller to provide a context structure that caller provided callback functions can interpret."]
    #[doc = ""]
    #[doc = " @param desc              File descriptor of an open file. The caller must provide this or the map."]
    #[doc = " @param filename          (optional) Filepath of the open file descriptor or file map."]
    #[doc = " @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature."]
    #[doc = " @param[out] scanned      The number of bytes scanned."]
    #[doc = " @param engine            The scanning engine."]
    #[doc = " @param scanoptions       Scanning options."]
    #[doc = " @param[in,out] context   An opaque context structure allowing the caller to record details about the sample being scanned."]
    #[doc = " @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occured during the scan."]
    pub fn cl_scandesc_callback(
        desc: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a filename."]
    #[doc = ""]
    #[doc = " @param filename          Filepath of the file to be scanned."]
    #[doc = " @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature."]
    #[doc = " @param[out] scanned      The number of bytes scanned."]
    #[doc = " @param engine            The scanning engine."]
    #[doc = " @param scanoptions       Scanning options."]
    #[doc = " @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occured during the scan."]
    pub fn cl_scanfile(
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a filename."]
    #[doc = ""]
    #[doc = " This callback variant allows the caller to provide a context structure that caller provided callback functions can interpret."]
    #[doc = ""]
    #[doc = " @param filename          Filepath of the file to be scanned."]
    #[doc = " @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature."]
    #[doc = " @param[out] scanned      The number of bytes scanned."]
    #[doc = " @param engine            The scanning engine."]
    #[doc = " @param scanoptions       Scanning options."]
    #[doc = " @param[in,out] context   An opaque context structure allowing the caller to record details about the sample being scanned."]
    #[doc = " @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occured during the scan."]
    pub fn cl_scanfile_callback(
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Load the signature databases found at the path."]
    #[doc = ""]
    #[doc = " @param path          May be a file or directory."]
    #[doc = " @param engine        The engine to load the signatures into"]
    #[doc = " @param[out] signo    The number of signatures loaded"]
    #[doc = " @param dboptions     Database load bitflag field. See the CL_DB_* defines, above."]
    #[doc = " @return cl_error_t"]
    pub fn cl_load(
        path: *const ::std::os::raw::c_char,
        engine: *mut cl_engine,
        signo: *mut ::std::os::raw::c_uint,
        dboptions: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Get the default database directory path."]
    #[doc = ""]
    #[doc = " @return const char*"]
    pub fn cl_retdbdir() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_cvd {
    pub time: *mut ::std::os::raw::c_char,
    pub version: ::std::os::raw::c_uint,
    pub sigs: ::std::os::raw::c_uint,
    pub fl: ::std::os::raw::c_uint,
    pub md5: *mut ::std::os::raw::c_char,
    pub dsig: *mut ::std::os::raw::c_char,
    pub builder: *mut ::std::os::raw::c_char,
    pub stime: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cl_cvd() {
    assert_eq!(
        ::std::mem::size_of::<cl_cvd>(),
        56usize,
        concat!("Size of: ", stringify!(cl_cvd))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_cvd>(),
        8usize,
        concat!("Alignment of ", stringify!(cl_cvd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_cvd>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_cvd>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_cvd>())).sigs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(sigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_cvd>())).fl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_cvd>())).md5 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(md5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_cvd>())).dsig as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(dsig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_cvd>())).builder as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(builder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_cvd>())).stime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_cvd),
            "::",
            stringify!(stime)
        )
    );
}
extern "C" {
    #[doc = " @brief Read the CVD header data from a file."]
    #[doc = ""]
    #[doc = " The returned pointer must be free'd with cl_cvdfree()."]
    #[doc = ""]
    #[doc = " @param file              Filepath of CVD file."]
    #[doc = " @return struct cl_cvd*   Pointer to an allocated CVD header data structure."]
    pub fn cl_cvdhead(file: *const ::std::os::raw::c_char) -> *mut cl_cvd;
}
extern "C" {
    #[doc = " @brief Parse the CVD header."]
    #[doc = ""]
    #[doc = " Buffer length is not an argument, and the check must be done"]
    #[doc = " by the caller cl_cvdhead()."]
    #[doc = ""]
    #[doc = " The returned pointer must be free'd with cl_cvdfree()."]
    #[doc = ""]
    #[doc = " @param head              Pointer to the header data buffer."]
    #[doc = " @return struct cl_cvd*   Pointer to an allocated CVD header data structure."]
    pub fn cl_cvdparse(head: *const ::std::os::raw::c_char) -> *mut cl_cvd;
}
extern "C" {
    #[doc = " @brief Verify a CVD file by loading and unloading it."]
    #[doc = ""]
    #[doc = " @param file          Filepath of CVD file."]
    #[doc = " @return cl_error_t   CL_SUCCESS if success, else a CL_E* error code."]
    pub fn cl_cvdverify(file: *const ::std::os::raw::c_char) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Free a CVD header struct."]
    #[doc = ""]
    #[doc = " @param cvd   Pointer to a CVD header struct."]
    pub fn cl_cvdfree(cvd: *mut cl_cvd);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_stat {
    pub dir: *mut ::std::os::raw::c_char,
    pub stattab: *mut stat,
    pub statdname: *mut *mut ::std::os::raw::c_char,
    pub entries: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cl_stat() {
    assert_eq!(
        ::std::mem::size_of::<cl_stat>(),
        32usize,
        concat!("Size of: ", stringify!(cl_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(cl_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_stat>())).dir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_stat),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_stat>())).stattab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_stat),
            "::",
            stringify!(stattab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_stat>())).statdname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_stat),
            "::",
            stringify!(statdname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_stat>())).entries as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_stat),
            "::",
            stringify!(entries)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a directory to be watched for database changes."]
    #[doc = ""]
    #[doc = " The dbstat out variable is allocated and must be freed using cl_statfree()."]
    #[doc = ""]
    #[doc = " @param dirname       Pathname of the database directory."]
    #[doc = " @param[out] dbstat   dbstat handle."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successfully initialized."]
    pub fn cl_statinidir(
        dirname: *const ::std::os::raw::c_char,
        dbstat: *mut cl_stat,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Check the database directory for changes."]
    #[doc = ""]
    #[doc = " @param dbstat dbstat handle."]
    #[doc = " @return int   0 No change."]
    #[doc = " @return int   1 Some change occured."]
    pub fn cl_statchkdir(dbstat: *const cl_stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Free the dbstat handle."]
    #[doc = ""]
    #[doc = " @param dbstat        dbstat handle."]
    #[doc = " @return cl_error_t   CL_SUCCESS"]
    #[doc = " @return cl_error_t   CL_ENULLARG"]
    pub fn cl_statfree(dbstat: *mut cl_stat) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Count the number of signatures in a database file or directory."]
    #[doc = ""]
    #[doc = " @param path          Path of the database file or directory."]
    #[doc = " @param countoptions  A bitflag field. May be CL_COUNTSIGS_OFFICIAL, CL_COUNTSIGS_UNOFFICIAL, or CL_COUNTSIGS_ALL."]
    #[doc = " @param[out] sigs     The number of sigs."]
    #[doc = " @return cl_error_t   CL_SUCCESS if success, else a CL_E* error type."]
    pub fn cl_countsigs(
        path: *const ::std::os::raw::c_char,
        countoptions: ::std::os::raw::c_uint,
        sigs: *mut ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Get the Functionality Level (FLEVEL)."]
    #[doc = ""]
    #[doc = " @return unsigned int The FLEVEL."]
    pub fn cl_retflevel() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Get the ClamAV version string."]
    #[doc = ""]
    #[doc = " E.g. clamav-0.100.0-beta"]
    #[doc = ""]
    #[doc = " @return const char* The version string."]
    pub fn cl_retver() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cl_strerror(clerror: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub type cl_fmap_t = cl_fmap;
#[doc = " @brief Read callback function type."]
#[doc = ""]
#[doc = " A callback function pointer type for reading data from a cl_fmap_t that uses"]
#[doc = " reads data from a handle interface."]
#[doc = ""]
#[doc = " Read 'count' bytes starting at 'offset' into the buffer 'buf'"]
#[doc = ""]
#[doc = " Thread safety: It is guaranteed that only one callback is executing for a"]
#[doc = " specific handle at any time, but there might be multiple callbacks executing"]
#[doc = " for different handle at the same time."]
#[doc = ""]
#[doc = " @param handle    The handle passed to cl_fmap_open_handle, its meaning is up"]
#[doc = "                  to the callback's implementation"]
#[doc = " @param buf       A buffer to read data into, must be at least offset + count"]
#[doc = "                  bytes in size."]
#[doc = " @param count     The number of bytes to read."]
#[doc = " @param offset    The the offset into buf to read the data to. If successful,"]
#[doc = "                  the number of bytes actually read is returned. Upon reading"]
#[doc = "                  end-of-file, zero is returned. Otherwise, a -1 is returned"]
#[doc = "                  and the global variable errno is set to indicate the error."]
pub type clcb_pread = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
        offset: off_t,
    ) -> off_t,
>;
extern "C" {
    #[doc = " @brief Open a map given a handle."]
    #[doc = ""]
    #[doc = " Open a map for scanning custom data accessed by a handle and pread (lseek +"]
    #[doc = " read)-like interface. For example a file descriptor or a WIN32 HANDLE."]
    #[doc = " By default fmap will use aging to discard old data, unless you tell it not"]
    #[doc = " to."]
    #[doc = ""]
    #[doc = " The handle will be passed to the callback each time."]
    #[doc = ""]
    #[doc = " @param handle        A handle that may be accessed using lseek + read."]
    #[doc = " @param offset        Initial offset to start scanning."]
    #[doc = " @param len           Length of the data from the start (not the offset)."]
    #[doc = " @param pread_cb      A callback function to read data from the handle."]
    #[doc = " @param use_aging     Set to a non-zero value to enable aging."]
    #[doc = " @return cl_fmap_t*   A map representing the handle interface."]
    pub fn cl_fmap_open_handle(
        handle: *mut ::std::os::raw::c_void,
        offset: size_t,
        len: size_t,
        pread_cb: clcb_pread,
        use_aging: ::std::os::raw::c_int,
    ) -> *mut cl_fmap_t;
}
extern "C" {
    #[doc = " @brief Open a map given a buffer."]
    #[doc = ""]
    #[doc = " Open a map for scanning custom data, where the data is already in memory,"]
    #[doc = " either in the form of a buffer, a memory mapped file, etc."]
    #[doc = " Note that the memory [start, start+len) must be the _entire_ file,"]
    #[doc = " you can't give it parts of a file and expect detection to work."]
    #[doc = ""]
    #[doc = " @param start         Pointer to a buffer of data."]
    #[doc = " @param len           Length in bytes of the data."]
    #[doc = " @return cl_fmap_t*   A map representing the buffer."]
    pub fn cl_fmap_open_memory(start: *const ::std::os::raw::c_void, len: size_t)
        -> *mut cl_fmap_t;
}
extern "C" {
    #[doc = " @brief Releases resources associated with the map."]
    #[doc = ""]
    #[doc = " You should release any resources you hold only after (handles, maps) calling"]
    #[doc = " this function."]
    #[doc = ""]
    #[doc = " @param map           Map to be closed."]
    pub fn cl_fmap_close(arg1: *mut cl_fmap_t);
}
extern "C" {
    #[doc = " @brief Scan custom data."]
    #[doc = ""]
    #[doc = " @param map           Buffer to be scanned, in form of a cl_fmap_t."]
    #[doc = " @param filename      Name of data origin. Does not need to be an actual"]
    #[doc = "                      file on disk. May be NULL if a name is not available."]
    #[doc = " @param[out] virname  Pointer to receive the signature match name name if a"]
    #[doc = "                      signature matched."]
    #[doc = " @param[out] scanned  Number of bytes scanned."]
    #[doc = " @param engine        The scanning engine."]
    #[doc = " @param scanoptions   The scanning options struct."]
    #[doc = " @param context       An application-defined context struct, opaque to"]
    #[doc = "                      libclamav. May be used within your callback functions."]
    #[doc = " @return cl_error_t   CL_CLEAN if no signature matched. CL_VIRUS if a"]
    #[doc = "                      signature matched. Another CL_E* error code if an"]
    #[doc = "                      error occured."]
    pub fn cl_scanmap_callback(
        map: *mut cl_fmap_t,
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Generate a hash of data."]
    #[doc = ""]
    #[doc = " @param alg       The hashing algorithm to use."]
    #[doc = " @param buf       The data to be hashed."]
    #[doc = " @param len       The length of the to-be-hashed data."]
    #[doc = " @param[out] obuf (optional) A buffer to store the generated hash. Use NULL to dynamically allocate buffer."]
    #[doc = " @param[out] olen (optional) A pointer that stores how long the generated hash is."]
    #[doc = " @return          A pointer to the generated hash or obuf if obuf is not NULL."]
    pub fn cl_hash_data(
        alg: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        obuf: *mut ::std::os::raw::c_uchar,
        olen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Generate a hash of a file."]
    #[doc = ""]
    #[doc = " @param ctx       A pointer to the OpenSSL EVP_MD_CTX object."]
    #[doc = " @param fd        The file descriptor."]
    #[doc = " @param[out] olen (optional) The length of the generated hash."]
    #[doc = " @return          A pointer to a malloc'd buffer that holds the generated hash."]
    pub fn cl_hash_file_fd_ctx(
        ctx: *mut EVP_MD_CTX,
        fd: ::std::os::raw::c_int,
        olen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Generate a hash of a file."]
    #[doc = ""]
    #[doc = " @param fd        The file descriptor."]
    #[doc = " @param alg       The hashing algorithm to use."]
    #[doc = " @param[out] olen (optional) The length of the generated hash."]
    #[doc = " @return          A pointer to a malloc'd buffer that holds the generated hash."]
    pub fn cl_hash_file_fd(
        fd: ::std::os::raw::c_int,
        alg: *const ::std::os::raw::c_char,
        olen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Generate a hash of a file."]
    #[doc = ""]
    #[doc = " @param fp        A pointer to a FILE object."]
    #[doc = " @param alg       The hashing algorithm to use."]
    #[doc = " @param[out] olen (optional) The length of the generated hash."]
    #[doc = " @return          A pointer to a malloc'd buffer that holds the generated hash."]
    pub fn cl_hash_file_fp(
        fp: *mut FILE,
        alg: *const ::std::os::raw::c_char,
        olen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Generate a sha256 hash of data."]
    #[doc = ""]
    #[doc = " @param buf       The data to hash."]
    #[doc = " @param len       The length of the to-be-hashed data."]
    #[doc = " @param[out] obuf (optional) A pointer to store the generated hash. Use NULL to dynamically allocate buffer."]
    #[doc = " @param[out] olen (optional) The length of the generated hash."]
    #[doc = " @return          A pointer to a malloc'd buffer that holds the generated hash."]
    pub fn cl_sha256(
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        obuf: *mut ::std::os::raw::c_uchar,
        olen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Generate a sha384 hash of data."]
    #[doc = ""]
    #[doc = " @param buf       The data to hash."]
    #[doc = " @param len       The length of the to-be-hashed data."]
    #[doc = " @param[out] obuf (optional) A pointer to store the generated hash. Use NULL to dynamically allocate buffer."]
    #[doc = " @param[out] olen (optional) The length of the generated hash."]
    #[doc = " @return          A pointer to a malloc'd buffer that holds the generated hash."]
    pub fn cl_sha384(
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        obuf: *mut ::std::os::raw::c_uchar,
        olen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Generate a sha512 hash of data."]
    #[doc = ""]
    #[doc = " @param buf       The data to hash."]
    #[doc = " @param len       The length of the to-be-hashed data."]
    #[doc = " @param[out] obuf (optional) A pointer to store the generated hash. Use NULL to dynamically allocate buffer."]
    #[doc = " @param[out] olen (optional) The length of the generated hash."]
    #[doc = " @return          A pointer to a malloc'd buffer that holds the generated hash."]
    pub fn cl_sha512(
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        obuf: *mut ::std::os::raw::c_uchar,
        olen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Generate a sha1 hash of data."]
    #[doc = ""]
    #[doc = " @param buf       The data to hash."]
    #[doc = " @param len       The length of the to-be-hashed data."]
    #[doc = " @param[out] obuf (optional) A pointer to store the generated hash. Use NULL to dynamically allocate buffer."]
    #[doc = " @param[out] olen (optional) The length of the generated hash."]
    #[doc = " @return          A pointer to a malloc'd buffer that holds the generated hash."]
    pub fn cl_sha1(
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        obuf: *mut ::std::os::raw::c_uchar,
        olen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data."]
    #[doc = ""]
    #[doc = " @param pkey      The public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param data      The data that was signed."]
    #[doc = " @param datalen   The length of the data."]
    #[doc = " @param decode    Whether or not to base64-decode the signature prior to verification. 1 for yes, 0 for no."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature(
        pkey: *mut EVP_PKEY,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_uchar,
        datalen: size_t,
        decode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data."]
    #[doc = ""]
    #[doc = " @param pkey      The public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param digest    The hash of the signed data."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature_hash(
        pkey: *mut EVP_PKEY,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        digest: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data."]
    #[doc = ""]
    #[doc = " @param pkey      The public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param fd        The file descriptor."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature_fd(
        pkey: *mut EVP_PKEY,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data."]
    #[doc = ""]
    #[doc = " @param x509path  The path to the public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param digest    The hash of the signed data."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature_hash_x509_keyfile(
        x509path: *mut ::std::os::raw::c_char,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        digest: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data."]
    #[doc = ""]
    #[doc = " @param x509path  The path to the public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param fd        The file descriptor."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature_fd_x509_keyfile(
        x509path: *mut ::std::os::raw::c_char,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data."]
    #[doc = ""]
    #[doc = " @param x509path  The path to the public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param data      The data that was signed."]
    #[doc = " @param datalen   The length of the data."]
    #[doc = " @param decode    Whether or not to base64-decode the signature prior to verification. 1 for yes, 0 for no."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature_x509_keyfile(
        x509path: *mut ::std::os::raw::c_char,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_uchar,
        datalen: size_t,
        decode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data"]
    #[doc = ""]
    #[doc = " @param x509      The X509 object of the public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param digest    The hash of the signed data."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature_hash_x509(
        x509: *mut X509,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        digest: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data."]
    #[doc = ""]
    #[doc = " @param x509      The X509 object of the public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param fd        The file descriptor."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature_fd_x509(
        x509: *mut X509,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify validity of signed data."]
    #[doc = ""]
    #[doc = " @param x509      The X509 object of the public key of the keypair that signed the data."]
    #[doc = " @param alg       The algorithm used to hash the data."]
    #[doc = " @param sig       The signature block."]
    #[doc = " @param siglen    The length of the signature."]
    #[doc = " @param data      The data that was signed."]
    #[doc = " @param datalen   The length of the data."]
    #[doc = " @param decode    Whether or not to base64-decode the signature prior to verification. 1 for yes, 0 for no."]
    #[doc = " @return          0 for success, -1 for error or invalid signature."]
    pub fn cl_verify_signature_x509(
        x509: *mut X509,
        alg: *const ::std::os::raw::c_char,
        sig: *mut ::std::os::raw::c_uchar,
        siglen: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_uchar,
        datalen: size_t,
        decode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get an X509 object from memory."]
    #[doc = ""]
    #[doc = " @param data      A pointer to a spot in memory that contains the PEM X509 cert."]
    #[doc = " @param len       The length of the data."]
    #[doc = " @return          A pointer to the X509 object on success, NULL on error."]
    pub fn cl_get_x509_from_mem(
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> *mut X509;
}
extern "C" {
    #[doc = " @brief Validate an X509 certificate chain, with the chain being located in a directory."]
    #[doc = ""]
    #[doc = " @param tsdir     The path to the trust store directory."]
    #[doc = " @param certpath  The path to the X509 certificate to be validated."]
    #[doc = " @return          0 for success, -1 for error or invalid certificate."]
    pub fn cl_validate_certificate_chain_ts_dir(
        tsdir: *mut ::std::os::raw::c_char,
        certpath: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Validate an X509 certificate chain with support for a CRL."]
    #[doc = ""]
    #[doc = " @param authorities   A NULL-terminated array of strings that hold the path of the CA's X509 certificate."]
    #[doc = " @param crlpath       (optional) A path to the CRL file. NULL if no CRL."]
    #[doc = " @param certpath      The path to the X509 certificate to be validated."]
    #[doc = " @return              0 for success, -1 for error or invalid certificate."]
    pub fn cl_validate_certificate_chain(
        authorities: *mut *mut ::std::os::raw::c_char,
        crlpath: *mut ::std::os::raw::c_char,
        certpath: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Load an X509 certificate from a file."]
    #[doc = ""]
    #[doc = " @param certpath  The path to the X509 certificate."]
    pub fn cl_load_cert(certpath: *const ::std::os::raw::c_char) -> *mut X509;
}
extern "C" {
    #[doc = " @brief Parse an ASN1_TIME object."]
    #[doc = ""]
    #[doc = " @param timeobj   The ASN1_TIME object."]
    #[doc = " @return          A pointer to a (struct tm). Adjusted for time zone and daylight savings time."]
    pub fn cl_ASN1_GetTimeT(timeobj: *mut ASN1_TIME) -> *mut tm;
}
extern "C" {
    #[doc = " @brief Load a CRL file into an X509_CRL object."]
    #[doc = ""]
    #[doc = " @param file  The path to the CRL."]
    #[doc = " @return      A pointer to an X509_CRL object or NULL on error."]
    pub fn cl_load_crl(timeobj: *const ::std::os::raw::c_char) -> *mut X509_CRL;
}
extern "C" {
    #[doc = " @brief Sign data with a key stored on disk."]
    #[doc = ""]
    #[doc = " @param keypath   The path to the RSA private key."]
    #[doc = " @param alg       The hash/signature algorithm to use."]
    #[doc = " @param hash      The hash to sign."]
    #[doc = " @param[out] olen A pointer that stores the size of the signature."]
    #[doc = " @param           Whether or not to base64-encode the signature. 1 for yes, 0 for no."]
    #[doc = " @return          The generated signature."]
    pub fn cl_sign_data_keyfile(
        keypath: *mut ::std::os::raw::c_char,
        alg: *const ::std::os::raw::c_char,
        hash: *mut ::std::os::raw::c_uchar,
        olen: *mut ::std::os::raw::c_uint,
        encode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Sign data with an RSA private key object."]
    #[doc = ""]
    #[doc = " @param pkey      The RSA private key object."]
    #[doc = " @param alg       The hash/signature algorithm to use."]
    #[doc = " @param hash      The hash to sign."]
    #[doc = " @param[out] olen A pointer that stores the size of the signature."]
    #[doc = " @param           Whether or not to base64-encode the signature. 1 for yes, 0 for no."]
    #[doc = " @return          The generated signature."]
    pub fn cl_sign_data(
        pkey: *mut EVP_PKEY,
        alg: *const ::std::os::raw::c_char,
        hash: *mut ::std::os::raw::c_uchar,
        olen: *mut ::std::os::raw::c_uint,
        encode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Sign a file with an RSA private key object."]
    #[doc = ""]
    #[doc = " @param fd        The file descriptor."]
    #[doc = " @param pkey      The RSA private key object."]
    #[doc = " @param alg       The hash/signature algorithm to use."]
    #[doc = " @param[out] olen A pointer that stores the size of the signature."]
    #[doc = " @param encode    Whether or not to base64-encode the signature. 1 for yes, 0 for no."]
    #[doc = " @return          The generated signature."]
    pub fn cl_sign_file_fd(
        fd: ::std::os::raw::c_int,
        pkey: *mut EVP_PKEY,
        alg: *const ::std::os::raw::c_char,
        olen: *mut ::std::os::raw::c_uint,
        encode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Sign a file with an RSA private key object."]
    #[doc = ""]
    #[doc = " @param fp        A pointer to a FILE object."]
    #[doc = " @param pkey      The RSA private key object."]
    #[doc = " @param alg       The hash/signature algorithm to use."]
    #[doc = " @param[out] olen A pointer that stores the size of the signature."]
    #[doc = " @param encode    Whether or not to base64-encode the signature. 1 for yes, 0 for no."]
    #[doc = " @return          The generated signature."]
    pub fn cl_sign_file_fp(
        fp: *mut FILE,
        pkey: *mut EVP_PKEY,
        alg: *const ::std::os::raw::c_char,
        olen: *mut ::std::os::raw::c_uint,
        encode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Get the Private Key stored on disk."]
    #[doc = ""]
    #[doc = " @param keypath   The path on disk where the private key is stored."]
    #[doc = " @return          A pointer to the EVP_PKEY object that contains the private key in memory."]
    pub fn cl_get_pkey_file(keypath: *mut ::std::os::raw::c_char) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn cl_hash_init(alg: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cl_update_hash(
        ctx: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_void,
        sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cl_finish_hash(
        ctx: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cl_hash_destroy(ctx: *mut ::std::os::raw::c_void);
}
pub type in_port_t = ::std::os::raw::c_ushort;
pub type in_addr_t = ::std::os::raw::c_uint;
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(
        __buf: *mut ::std::os::raw::c_char,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: ::std::os::raw::c_uint = 0;
pub const _PC_MAX_CANON: ::std::os::raw::c_uint = 1;
pub const _PC_MAX_INPUT: ::std::os::raw::c_uint = 2;
pub const _PC_NAME_MAX: ::std::os::raw::c_uint = 3;
pub const _PC_PATH_MAX: ::std::os::raw::c_uint = 4;
pub const _PC_PIPE_BUF: ::std::os::raw::c_uint = 5;
pub const _PC_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 6;
pub const _PC_NO_TRUNC: ::std::os::raw::c_uint = 7;
pub const _PC_VDISABLE: ::std::os::raw::c_uint = 8;
pub const _PC_SYNC_IO: ::std::os::raw::c_uint = 9;
pub const _PC_ASYNC_IO: ::std::os::raw::c_uint = 10;
pub const _PC_PRIO_IO: ::std::os::raw::c_uint = 11;
pub const _PC_SOCK_MAXBUF: ::std::os::raw::c_uint = 12;
pub const _PC_FILESIZEBITS: ::std::os::raw::c_uint = 13;
pub const _PC_REC_INCR_XFER_SIZE: ::std::os::raw::c_uint = 14;
pub const _PC_REC_MAX_XFER_SIZE: ::std::os::raw::c_uint = 15;
pub const _PC_REC_MIN_XFER_SIZE: ::std::os::raw::c_uint = 16;
pub const _PC_REC_XFER_ALIGN: ::std::os::raw::c_uint = 17;
pub const _PC_ALLOC_SIZE_MIN: ::std::os::raw::c_uint = 18;
pub const _PC_SYMLINK_MAX: ::std::os::raw::c_uint = 19;
pub const _PC_2_SYMLINKS: ::std::os::raw::c_uint = 20;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: ::std::os::raw::c_uint = 0;
pub const _SC_CHILD_MAX: ::std::os::raw::c_uint = 1;
pub const _SC_CLK_TCK: ::std::os::raw::c_uint = 2;
pub const _SC_NGROUPS_MAX: ::std::os::raw::c_uint = 3;
pub const _SC_OPEN_MAX: ::std::os::raw::c_uint = 4;
pub const _SC_STREAM_MAX: ::std::os::raw::c_uint = 5;
pub const _SC_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _SC_JOB_CONTROL: ::std::os::raw::c_uint = 7;
pub const _SC_SAVED_IDS: ::std::os::raw::c_uint = 8;
pub const _SC_REALTIME_SIGNALS: ::std::os::raw::c_uint = 9;
pub const _SC_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 10;
pub const _SC_TIMERS: ::std::os::raw::c_uint = 11;
pub const _SC_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 12;
pub const _SC_PRIORITIZED_IO: ::std::os::raw::c_uint = 13;
pub const _SC_SYNCHRONIZED_IO: ::std::os::raw::c_uint = 14;
pub const _SC_FSYNC: ::std::os::raw::c_uint = 15;
pub const _SC_MAPPED_FILES: ::std::os::raw::c_uint = 16;
pub const _SC_MEMLOCK: ::std::os::raw::c_uint = 17;
pub const _SC_MEMLOCK_RANGE: ::std::os::raw::c_uint = 18;
pub const _SC_MEMORY_PROTECTION: ::std::os::raw::c_uint = 19;
pub const _SC_MESSAGE_PASSING: ::std::os::raw::c_uint = 20;
pub const _SC_SEMAPHORES: ::std::os::raw::c_uint = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 22;
pub const _SC_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 23;
pub const _SC_AIO_MAX: ::std::os::raw::c_uint = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 25;
pub const _SC_DELAYTIMER_MAX: ::std::os::raw::c_uint = 26;
pub const _SC_MQ_OPEN_MAX: ::std::os::raw::c_uint = 27;
pub const _SC_MQ_PRIO_MAX: ::std::os::raw::c_uint = 28;
pub const _SC_VERSION: ::std::os::raw::c_uint = 29;
pub const _SC_PAGESIZE: ::std::os::raw::c_uint = 30;
pub const _SC_RTSIG_MAX: ::std::os::raw::c_uint = 31;
pub const _SC_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 32;
pub const _SC_SEM_VALUE_MAX: ::std::os::raw::c_uint = 33;
pub const _SC_SIGQUEUE_MAX: ::std::os::raw::c_uint = 34;
pub const _SC_TIMER_MAX: ::std::os::raw::c_uint = 35;
pub const _SC_BC_BASE_MAX: ::std::os::raw::c_uint = 36;
pub const _SC_BC_DIM_MAX: ::std::os::raw::c_uint = 37;
pub const _SC_BC_SCALE_MAX: ::std::os::raw::c_uint = 38;
pub const _SC_BC_STRING_MAX: ::std::os::raw::c_uint = 39;
pub const _SC_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 40;
pub const _SC_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 41;
pub const _SC_EXPR_NEST_MAX: ::std::os::raw::c_uint = 42;
pub const _SC_LINE_MAX: ::std::os::raw::c_uint = 43;
pub const _SC_RE_DUP_MAX: ::std::os::raw::c_uint = 44;
pub const _SC_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 45;
pub const _SC_2_VERSION: ::std::os::raw::c_uint = 46;
pub const _SC_2_C_BIND: ::std::os::raw::c_uint = 47;
pub const _SC_2_C_DEV: ::std::os::raw::c_uint = 48;
pub const _SC_2_FORT_DEV: ::std::os::raw::c_uint = 49;
pub const _SC_2_FORT_RUN: ::std::os::raw::c_uint = 50;
pub const _SC_2_SW_DEV: ::std::os::raw::c_uint = 51;
pub const _SC_2_LOCALEDEF: ::std::os::raw::c_uint = 52;
pub const _SC_PII: ::std::os::raw::c_uint = 53;
pub const _SC_PII_XTI: ::std::os::raw::c_uint = 54;
pub const _SC_PII_SOCKET: ::std::os::raw::c_uint = 55;
pub const _SC_PII_INTERNET: ::std::os::raw::c_uint = 56;
pub const _SC_PII_OSI: ::std::os::raw::c_uint = 57;
pub const _SC_POLL: ::std::os::raw::c_uint = 58;
pub const _SC_SELECT: ::std::os::raw::c_uint = 59;
pub const _SC_UIO_MAXIOV: ::std::os::raw::c_uint = 60;
pub const _SC_IOV_MAX: ::std::os::raw::c_uint = 60;
pub const _SC_PII_INTERNET_STREAM: ::std::os::raw::c_uint = 61;
pub const _SC_PII_INTERNET_DGRAM: ::std::os::raw::c_uint = 62;
pub const _SC_PII_OSI_COTS: ::std::os::raw::c_uint = 63;
pub const _SC_PII_OSI_CLTS: ::std::os::raw::c_uint = 64;
pub const _SC_PII_OSI_M: ::std::os::raw::c_uint = 65;
pub const _SC_T_IOV_MAX: ::std::os::raw::c_uint = 66;
pub const _SC_THREADS: ::std::os::raw::c_uint = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 68;
pub const _SC_GETGR_R_SIZE_MAX: ::std::os::raw::c_uint = 69;
pub const _SC_GETPW_R_SIZE_MAX: ::std::os::raw::c_uint = 70;
pub const _SC_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 71;
pub const _SC_TTY_NAME_MAX: ::std::os::raw::c_uint = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 73;
pub const _SC_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 74;
pub const _SC_THREAD_STACK_MIN: ::std::os::raw::c_uint = 75;
pub const _SC_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 76;
pub const _SC_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 79;
pub const _SC_THREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 80;
pub const _SC_THREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 81;
pub const _SC_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 82;
pub const _SC_NPROCESSORS_CONF: ::std::os::raw::c_uint = 83;
pub const _SC_NPROCESSORS_ONLN: ::std::os::raw::c_uint = 84;
pub const _SC_PHYS_PAGES: ::std::os::raw::c_uint = 85;
pub const _SC_AVPHYS_PAGES: ::std::os::raw::c_uint = 86;
pub const _SC_ATEXIT_MAX: ::std::os::raw::c_uint = 87;
pub const _SC_PASS_MAX: ::std::os::raw::c_uint = 88;
pub const _SC_XOPEN_VERSION: ::std::os::raw::c_uint = 89;
pub const _SC_XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 90;
pub const _SC_XOPEN_UNIX: ::std::os::raw::c_uint = 91;
pub const _SC_XOPEN_CRYPT: ::std::os::raw::c_uint = 92;
pub const _SC_XOPEN_ENH_I18N: ::std::os::raw::c_uint = 93;
pub const _SC_XOPEN_SHM: ::std::os::raw::c_uint = 94;
pub const _SC_2_CHAR_TERM: ::std::os::raw::c_uint = 95;
pub const _SC_2_C_VERSION: ::std::os::raw::c_uint = 96;
pub const _SC_2_UPE: ::std::os::raw::c_uint = 97;
pub const _SC_XOPEN_XPG2: ::std::os::raw::c_uint = 98;
pub const _SC_XOPEN_XPG3: ::std::os::raw::c_uint = 99;
pub const _SC_XOPEN_XPG4: ::std::os::raw::c_uint = 100;
pub const _SC_CHAR_BIT: ::std::os::raw::c_uint = 101;
pub const _SC_CHAR_MAX: ::std::os::raw::c_uint = 102;
pub const _SC_CHAR_MIN: ::std::os::raw::c_uint = 103;
pub const _SC_INT_MAX: ::std::os::raw::c_uint = 104;
pub const _SC_INT_MIN: ::std::os::raw::c_uint = 105;
pub const _SC_LONG_BIT: ::std::os::raw::c_uint = 106;
pub const _SC_WORD_BIT: ::std::os::raw::c_uint = 107;
pub const _SC_MB_LEN_MAX: ::std::os::raw::c_uint = 108;
pub const _SC_NZERO: ::std::os::raw::c_uint = 109;
pub const _SC_SSIZE_MAX: ::std::os::raw::c_uint = 110;
pub const _SC_SCHAR_MAX: ::std::os::raw::c_uint = 111;
pub const _SC_SCHAR_MIN: ::std::os::raw::c_uint = 112;
pub const _SC_SHRT_MAX: ::std::os::raw::c_uint = 113;
pub const _SC_SHRT_MIN: ::std::os::raw::c_uint = 114;
pub const _SC_UCHAR_MAX: ::std::os::raw::c_uint = 115;
pub const _SC_UINT_MAX: ::std::os::raw::c_uint = 116;
pub const _SC_ULONG_MAX: ::std::os::raw::c_uint = 117;
pub const _SC_USHRT_MAX: ::std::os::raw::c_uint = 118;
pub const _SC_NL_ARGMAX: ::std::os::raw::c_uint = 119;
pub const _SC_NL_LANGMAX: ::std::os::raw::c_uint = 120;
pub const _SC_NL_MSGMAX: ::std::os::raw::c_uint = 121;
pub const _SC_NL_NMAX: ::std::os::raw::c_uint = 122;
pub const _SC_NL_SETMAX: ::std::os::raw::c_uint = 123;
pub const _SC_NL_TEXTMAX: ::std::os::raw::c_uint = 124;
pub const _SC_XBS5_ILP32_OFF32: ::std::os::raw::c_uint = 125;
pub const _SC_XBS5_ILP32_OFFBIG: ::std::os::raw::c_uint = 126;
pub const _SC_XBS5_LP64_OFF64: ::std::os::raw::c_uint = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: ::std::os::raw::c_uint = 128;
pub const _SC_XOPEN_LEGACY: ::std::os::raw::c_uint = 129;
pub const _SC_XOPEN_REALTIME: ::std::os::raw::c_uint = 130;
pub const _SC_XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 131;
pub const _SC_ADVISORY_INFO: ::std::os::raw::c_uint = 132;
pub const _SC_BARRIERS: ::std::os::raw::c_uint = 133;
pub const _SC_BASE: ::std::os::raw::c_uint = 134;
pub const _SC_C_LANG_SUPPORT: ::std::os::raw::c_uint = 135;
pub const _SC_C_LANG_SUPPORT_R: ::std::os::raw::c_uint = 136;
pub const _SC_CLOCK_SELECTION: ::std::os::raw::c_uint = 137;
pub const _SC_CPUTIME: ::std::os::raw::c_uint = 138;
pub const _SC_THREAD_CPUTIME: ::std::os::raw::c_uint = 139;
pub const _SC_DEVICE_IO: ::std::os::raw::c_uint = 140;
pub const _SC_DEVICE_SPECIFIC: ::std::os::raw::c_uint = 141;
pub const _SC_DEVICE_SPECIFIC_R: ::std::os::raw::c_uint = 142;
pub const _SC_FD_MGMT: ::std::os::raw::c_uint = 143;
pub const _SC_FIFO: ::std::os::raw::c_uint = 144;
pub const _SC_PIPE: ::std::os::raw::c_uint = 145;
pub const _SC_FILE_ATTRIBUTES: ::std::os::raw::c_uint = 146;
pub const _SC_FILE_LOCKING: ::std::os::raw::c_uint = 147;
pub const _SC_FILE_SYSTEM: ::std::os::raw::c_uint = 148;
pub const _SC_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 149;
pub const _SC_MULTI_PROCESS: ::std::os::raw::c_uint = 150;
pub const _SC_SINGLE_PROCESS: ::std::os::raw::c_uint = 151;
pub const _SC_NETWORKING: ::std::os::raw::c_uint = 152;
pub const _SC_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 153;
pub const _SC_SPIN_LOCKS: ::std::os::raw::c_uint = 154;
pub const _SC_REGEXP: ::std::os::raw::c_uint = 155;
pub const _SC_REGEX_VERSION: ::std::os::raw::c_uint = 156;
pub const _SC_SHELL: ::std::os::raw::c_uint = 157;
pub const _SC_SIGNALS: ::std::os::raw::c_uint = 158;
pub const _SC_SPAWN: ::std::os::raw::c_uint = 159;
pub const _SC_SPORADIC_SERVER: ::std::os::raw::c_uint = 160;
pub const _SC_THREAD_SPORADIC_SERVER: ::std::os::raw::c_uint = 161;
pub const _SC_SYSTEM_DATABASE: ::std::os::raw::c_uint = 162;
pub const _SC_SYSTEM_DATABASE_R: ::std::os::raw::c_uint = 163;
pub const _SC_TIMEOUTS: ::std::os::raw::c_uint = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 165;
pub const _SC_USER_GROUPS: ::std::os::raw::c_uint = 166;
pub const _SC_USER_GROUPS_R: ::std::os::raw::c_uint = 167;
pub const _SC_2_PBS: ::std::os::raw::c_uint = 168;
pub const _SC_2_PBS_ACCOUNTING: ::std::os::raw::c_uint = 169;
pub const _SC_2_PBS_LOCATE: ::std::os::raw::c_uint = 170;
pub const _SC_2_PBS_MESSAGE: ::std::os::raw::c_uint = 171;
pub const _SC_2_PBS_TRACK: ::std::os::raw::c_uint = 172;
pub const _SC_SYMLOOP_MAX: ::std::os::raw::c_uint = 173;
pub const _SC_STREAMS: ::std::os::raw::c_uint = 174;
pub const _SC_2_PBS_CHECKPOINT: ::std::os::raw::c_uint = 175;
pub const _SC_V6_ILP32_OFF32: ::std::os::raw::c_uint = 176;
pub const _SC_V6_ILP32_OFFBIG: ::std::os::raw::c_uint = 177;
pub const _SC_V6_LP64_OFF64: ::std::os::raw::c_uint = 178;
pub const _SC_V6_LPBIG_OFFBIG: ::std::os::raw::c_uint = 179;
pub const _SC_HOST_NAME_MAX: ::std::os::raw::c_uint = 180;
pub const _SC_TRACE: ::std::os::raw::c_uint = 181;
pub const _SC_TRACE_EVENT_FILTER: ::std::os::raw::c_uint = 182;
pub const _SC_TRACE_INHERIT: ::std::os::raw::c_uint = 183;
pub const _SC_TRACE_LOG: ::std::os::raw::c_uint = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: ::std::os::raw::c_uint = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: ::std::os::raw::c_uint = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: ::std::os::raw::c_uint = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: ::std::os::raw::c_uint = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: ::std::os::raw::c_uint = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: ::std::os::raw::c_uint = 190;
pub const _SC_LEVEL2_CACHE_SIZE: ::std::os::raw::c_uint = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: ::std::os::raw::c_uint = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: ::std::os::raw::c_uint = 193;
pub const _SC_LEVEL3_CACHE_SIZE: ::std::os::raw::c_uint = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: ::std::os::raw::c_uint = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: ::std::os::raw::c_uint = 196;
pub const _SC_LEVEL4_CACHE_SIZE: ::std::os::raw::c_uint = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: ::std::os::raw::c_uint = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: ::std::os::raw::c_uint = 199;
pub const _SC_IPV6: ::std::os::raw::c_uint = 235;
pub const _SC_RAW_SOCKETS: ::std::os::raw::c_uint = 236;
pub const _SC_V7_ILP32_OFF32: ::std::os::raw::c_uint = 237;
pub const _SC_V7_ILP32_OFFBIG: ::std::os::raw::c_uint = 238;
pub const _SC_V7_LP64_OFF64: ::std::os::raw::c_uint = 239;
pub const _SC_V7_LPBIG_OFFBIG: ::std::os::raw::c_uint = 240;
pub const _SC_SS_REPL_MAX: ::std::os::raw::c_uint = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 242;
pub const _SC_TRACE_NAME_MAX: ::std::os::raw::c_uint = 243;
pub const _SC_TRACE_SYS_MAX: ::std::os::raw::c_uint = 244;
pub const _SC_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 245;
pub const _SC_XOPEN_STREAMS: ::std::os::raw::c_uint = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::std::os::raw::c_uint = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::std::os::raw::c_uint = 248;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const _CS_PATH: ::std::os::raw::c_uint = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 1;
pub const _CS_GNU_LIBC_VERSION: ::std::os::raw::c_uint = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: ::std::os::raw::c_uint = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 5;
pub const _CS_LFS_CFLAGS: ::std::os::raw::c_uint = 1000;
pub const _CS_LFS_LDFLAGS: ::std::os::raw::c_uint = 1001;
pub const _CS_LFS_LIBS: ::std::os::raw::c_uint = 1002;
pub const _CS_LFS_LINTFLAGS: ::std::os::raw::c_uint = 1003;
pub const _CS_LFS64_CFLAGS: ::std::os::raw::c_uint = 1004;
pub const _CS_LFS64_LDFLAGS: ::std::os::raw::c_uint = 1005;
pub const _CS_LFS64_LIBS: ::std::os::raw::c_uint = 1006;
pub const _CS_LFS64_LINTFLAGS: ::std::os::raw::c_uint = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1147;
pub const _CS_V6_ENV: ::std::os::raw::c_uint = 1148;
pub const _CS_V7_ENV: ::std::os::raw::c_uint = 1149;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: size_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: size_t,
        __offset: size_t,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: __locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: __locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: __locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type fmap_t = cl_fmap_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_fmap {
    pub handle: *mut ::std::os::raw::c_void,
    pub pread_cb: clcb_pread,
    pub data: *const ::std::os::raw::c_void,
    pub mtime: time_t,
    pub pages: u64,
    pub pgsz: u64,
    pub paged: u64,
    pub aging: u16,
    pub dont_cache_flag: u16,
    #[doc = " indicates if we should not cache scan results for this fmap. Used if limits exceeded"]
    pub handle_is_fd: u16,
    #[doc = " non-zero if map->handle is an fd."]
    pub offset: size_t,
    #[doc = " file offset representing start of original fmap, if the fmap created reading from a file starting at offset other than 0"]
    pub nested_offset: size_t,
    #[doc = " offset from start of original fmap (data) for nested scan. 0 for orig fmap."]
    pub real_len: size_t,
    #[doc = " len from start of original fmap (data) to end of current (possibly nested) map."]
    pub len: size_t,
    #[doc = " length of data from nested_offset, accessible via current fmap"]
    pub unmap: ::std::option::Option<unsafe extern "C" fn(arg1: *mut fmap_t)>,
    pub need: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fmap_t,
            at: size_t,
            len: size_t,
            lock: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub need_offstr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fmap_t,
            at: size_t,
            len_hint: size_t,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub gets: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fmap_t,
            dst: *mut ::std::os::raw::c_char,
            at: *mut size_t,
            max_len: size_t,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub unneed_off:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut fmap_t, at: size_t, len: size_t)>,
    pub have_maphash: bool,
    pub maphash: [::std::os::raw::c_uchar; 16usize],
    pub bitmap: *mut u64,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cl_fmap() {
    assert_eq!(
        ::std::mem::size_of::<cl_fmap>(),
        176usize,
        concat!("Size of: ", stringify!(cl_fmap))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_fmap>(),
        8usize,
        concat!("Alignment of ", stringify!(cl_fmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).pread_cb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(pread_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).mtime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).pages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).pgsz as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(pgsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).paged as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(paged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).aging as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(aging)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).dont_cache_flag as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(dont_cache_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).handle_is_fd as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(handle_is_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).offset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).nested_offset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(nested_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).real_len as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(real_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).len as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).unmap as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(unmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).need as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(need)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).need_offstr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(need_offstr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).gets as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(gets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).unneed_off as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(unneed_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).have_maphash as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(have_maphash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).maphash as *const _ as usize },
        137usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(maphash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).bitmap as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_fmap>())).name as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_fmap),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[doc = " @brief Create a new fmap given a file descriptor."]
    #[doc = ""]
    #[doc = " @param fd        File descriptor of file to be mapped."]
    #[doc = " @param offset    Offset into file for start of map."]
    #[doc = " @param len       Length from offset for size of map."]
    #[doc = " @param name      (optional) Original name of the file (to set fmap name metadata)"]
    #[doc = " @return fmap_t*  The newly created fmap.  Free it with `funmap()`"]
    pub fn fmap(
        fd: ::std::os::raw::c_int,
        offset: off_t,
        len: size_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut fmap_t;
}
extern "C" {
    #[doc = " @brief Create  new fmap given a file descriptor."]
    #[doc = ""]
    #[doc = " This variant of fmap() provides a boolean output variable to indicate on"]
    #[doc = " failure if the failure was because the file is empty (not really a failure)."]
    #[doc = ""]
    #[doc = " @param fd            File descriptor of file to be mapped."]
    #[doc = " @param offset        Offset into file for start of map."]
    #[doc = " @param len           Length from offset for size of map."]
    #[doc = " @param[out] empty    Boolean will be non-zero if the file couldn't be mapped because it is empty."]
    #[doc = " @param name          (optional) Original name of the file (to set fmap name metadata)"]
    #[doc = " @return fmap_t*      The newly created fmap.  Free it with `funmap()`"]
    pub fn fmap_check_empty(
        fd: ::std::os::raw::c_int,
        offset: off_t,
        len: size_t,
        empty: *mut ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> *mut fmap_t;
}
extern "C" {
    #[doc = " @brief Create a new fmap given a buffer."]
    #[doc = ""]
    #[doc = " @param start     Start of a buffer that the fmap will reference."]
    #[doc = " @param len       Length of the buffer."]
    #[doc = " @param name      (optional) Original name of the file (to set fmap name metadata)"]
    #[doc = " @return fmap_t*"]
    pub fn fmap_open_memory(
        start: *const ::std::os::raw::c_void,
        len: size_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut fmap_t;
}
extern "C" {
    #[doc = " @brief Create a new fmap view into another fmap."]
    #[doc = ""]
    #[doc = " @param map       The parent fmap."]
    #[doc = " @param offset    Offset for the start of the new fmap into the parent fmap."]
    #[doc = " @param length    Length of the data from the offset for the new fmap."]
    #[doc = " @param name      (optional) Original name of the file (to set fmap name metadata)"]
    #[doc = " @return fmap_t*  NULL if failure or a special fmap that the caller must free with free_duplicate_fmap()"]
    pub fn fmap_duplicate(
        map: *mut cl_fmap_t,
        offset: size_t,
        length: size_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut fmap_t;
}
extern "C" {
    #[doc = " @brief Deallocate a _duplicated_ fmap.  Does not unmap the mapped region."]
    #[doc = ""]
    #[doc = " This function should be used instead of `free()` to cleanup the optional fmap name."]
    #[doc = ""]
    #[doc = " @param m The map to be free'd."]
    pub fn free_duplicate_fmap(map: *mut cl_fmap_t);
}
extern "C" {
    #[doc = " @brief \tDump a specified range of data from an fmap to a new temp file."]
    #[doc = ""]
    #[doc = " @param map           The file map in question"]
    #[doc = " @param filepath      (Optional) The full filepath of the file being dumped."]
    #[doc = " @param tmpdir        The directory to drop the file to."]
    #[doc = " @param outname       The filename chosen for the temp file."]
    #[doc = " @param outfd         The file descriptor of the new file, open and seeked to the start of the file."]
    #[doc = " @param start_offset  The start offset of the data that you wish to write to the temp file. Must be less than the length of the fmap and must be less than end_offset."]
    #[doc = " @param end_offset    The end offset of the data you wish to write to the temp file.  May be larger than the size of the fmap.  Use SIZE_MAX to write the entire fmap."]
    #[doc = " @return cl_error_t   CL_SUCCESS on success, else CL_EARG, CL_EWRITE, CL_ECREAT, or CL_EMEM for self-explanatory reasons."]
    pub fn fmap_dump_to_file(
        map: *mut fmap_t,
        filepath: *const ::std::os::raw::c_char,
        tmpdir: *const ::std::os::raw::c_char,
        outname: *mut *mut ::std::os::raw::c_char,
        outfd: *mut ::std::os::raw::c_int,
        start_offset: size_t,
        end_offset: size_t,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief   Return the open file desciptor for the fmap (if available)."]
    #[doc = ""]
    #[doc = " This function will only provide the file descriptor if the fmap handle is set,"]
    #[doc = " and if the handle is in fact a file descriptor (handle_is_fd != 0)."]
    #[doc = ""]
    #[doc = " @param m     The fmap."]
    #[doc = " @return int  The file descriptor, or -1 if not available."]
    pub fn fmap_fd(m: *mut fmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief   Get a pointer to the fmap hash."]
    #[doc = ""]
    #[doc = " Will calculate the hash if not already previously calculated."]
    #[doc = ""]
    #[doc = " @param map       The map in question."]
    #[doc = " @param[out] hash A pointer to the hash."]
    #[doc = " @return cl_error_t CL_SUCCESS if was able to get the hash, else some error."]
    pub fn fmap_get_MD5(map: *mut fmap_t, hash: *mut *mut ::std::os::raw::c_uchar) -> cl_error_t;
}
pub const cli_file_CL_TYPE_ANY: cli_file = 0;
pub const cli_file_CL_TYPE_TEXT_ASCII: cli_file = 500;
pub const cli_file_CL_TYPE_TEXT_UTF8: cli_file = 501;
pub const cli_file_CL_TYPE_TEXT_UTF16LE: cli_file = 502;
pub const cli_file_CL_TYPE_TEXT_UTF16BE: cli_file = 503;
pub const cli_file_CL_TYPE_BINARY_DATA: cli_file = 504;
pub const cli_file_CL_TYPE_ERROR: cli_file = 505;
pub const cli_file_CL_TYPE_MSEXE: cli_file = 506;
pub const cli_file_CL_TYPE_ELF: cli_file = 507;
pub const cli_file_CL_TYPE_MACHO: cli_file = 508;
pub const cli_file_CL_TYPE_MACHO_UNIBIN: cli_file = 509;
pub const cli_file_CL_TYPE_POSIX_TAR: cli_file = 510;
pub const cli_file_CL_TYPE_OLD_TAR: cli_file = 511;
pub const cli_file_CL_TYPE_CPIO_OLD: cli_file = 512;
pub const cli_file_CL_TYPE_CPIO_ODC: cli_file = 513;
pub const cli_file_CL_TYPE_CPIO_NEWC: cli_file = 514;
pub const cli_file_CL_TYPE_CPIO_CRC: cli_file = 515;
pub const cli_file_CL_TYPE_GZ: cli_file = 516;
pub const cli_file_CL_TYPE_ZIP: cli_file = 517;
pub const cli_file_CL_TYPE_BZ: cli_file = 518;
pub const cli_file_CL_TYPE_RAR: cli_file = 519;
pub const cli_file_CL_TYPE_ARJ: cli_file = 520;
pub const cli_file_CL_TYPE_MSSZDD: cli_file = 521;
pub const cli_file_CL_TYPE_MSOLE2: cli_file = 522;
pub const cli_file_CL_TYPE_MSCAB: cli_file = 523;
pub const cli_file_CL_TYPE_MSCHM: cli_file = 524;
pub const cli_file_CL_TYPE_SIS: cli_file = 525;
pub const cli_file_CL_TYPE_SCRENC: cli_file = 526;
pub const cli_file_CL_TYPE_GRAPHICS: cli_file = 527;
pub const cli_file_CL_TYPE_GIF: cli_file = 528;
pub const cli_file_CL_TYPE_PNG: cli_file = 529;
pub const cli_file_CL_TYPE_JPEG: cli_file = 530;
pub const cli_file_CL_TYPE_TIFF: cli_file = 531;
pub const cli_file_CL_TYPE_RIFF: cli_file = 532;
pub const cli_file_CL_TYPE_BINHEX: cli_file = 533;
pub const cli_file_CL_TYPE_TNEF: cli_file = 534;
pub const cli_file_CL_TYPE_CRYPTFF: cli_file = 535;
pub const cli_file_CL_TYPE_PDF: cli_file = 536;
pub const cli_file_CL_TYPE_UUENCODED: cli_file = 537;
pub const cli_file_CL_TYPE_SCRIPT: cli_file = 538;
pub const cli_file_CL_TYPE_HTML_UTF16: cli_file = 539;
pub const cli_file_CL_TYPE_RTF: cli_file = 540;
pub const cli_file_CL_TYPE_7Z: cli_file = 541;
pub const cli_file_CL_TYPE_SWF: cli_file = 542;
pub const cli_file_CL_TYPE_JAVA: cli_file = 543;
pub const cli_file_CL_TYPE_XAR: cli_file = 544;
pub const cli_file_CL_TYPE_XZ: cli_file = 545;
pub const cli_file_CL_TYPE_OOXML_WORD: cli_file = 546;
pub const cli_file_CL_TYPE_OOXML_PPT: cli_file = 547;
pub const cli_file_CL_TYPE_OOXML_XL: cli_file = 548;
pub const cli_file_CL_TYPE_INTERNAL: cli_file = 549;
pub const cli_file_CL_TYPE_HWP3: cli_file = 550;
pub const cli_file_CL_TYPE_OOXML_HWP: cli_file = 551;
pub const cli_file_CL_TYPE_PS: cli_file = 552;
pub const cli_file_CL_TYPE_EGG: cli_file = 553;
pub const cli_file_CL_TYPE_PART_ANY: cli_file = 554;
pub const cli_file_CL_TYPE_PART_HFSPLUS: cli_file = 555;
pub const cli_file_CL_TYPE_MBR: cli_file = 556;
pub const cli_file_CL_TYPE_HTML: cli_file = 557;
pub const cli_file_CL_TYPE_MAIL: cli_file = 558;
pub const cli_file_CL_TYPE_SFX: cli_file = 559;
pub const cli_file_CL_TYPE_ZIPSFX: cli_file = 560;
pub const cli_file_CL_TYPE_RARSFX: cli_file = 561;
pub const cli_file_CL_TYPE_7ZSFX: cli_file = 562;
pub const cli_file_CL_TYPE_CABSFX: cli_file = 563;
pub const cli_file_CL_TYPE_ARJSFX: cli_file = 564;
pub const cli_file_CL_TYPE_EGGSFX: cli_file = 565;
pub const cli_file_CL_TYPE_NULSFT: cli_file = 566;
pub const cli_file_CL_TYPE_AUTOIT: cli_file = 567;
pub const cli_file_CL_TYPE_ISHIELD_MSI: cli_file = 568;
pub const cli_file_CL_TYPE_ISO9660: cli_file = 569;
pub const cli_file_CL_TYPE_DMG: cli_file = 570;
pub const cli_file_CL_TYPE_GPT: cli_file = 571;
pub const cli_file_CL_TYPE_APM: cli_file = 572;
pub const cli_file_CL_TYPE_XDP: cli_file = 573;
pub const cli_file_CL_TYPE_XML_WORD: cli_file = 574;
pub const cli_file_CL_TYPE_XML_XL: cli_file = 575;
pub const cli_file_CL_TYPE_XML_HWP: cli_file = 576;
pub const cli_file_CL_TYPE_HWPOLE2: cli_file = 577;
pub const cli_file_CL_TYPE_MHTML: cli_file = 578;
pub const cli_file_CL_TYPE_LNK: cli_file = 579;
pub const cli_file_CL_TYPE_OTHER: cli_file = 580;
pub const cli_file_CL_TYPE_IGNORED: cli_file = 581;
pub type cli_file = ::std::os::raw::c_uint;
pub use self::cli_file as cli_file_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ftype {
    pub type_: cli_file_t,
    pub offset: u32,
    pub magic: *mut ::std::os::raw::c_uchar,
    pub tname: *mut ::std::os::raw::c_char,
    pub next: *mut cli_ftype,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_cli_ftype() {
    assert_eq!(
        ::std::mem::size_of::<cli_ftype>(),
        40usize,
        concat!("Size of: ", stringify!(cli_ftype))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ftype>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ftype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ftype>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ftype),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ftype>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ftype),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ftype>())).magic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ftype),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ftype>())).tname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ftype),
            "::",
            stringify!(tname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ftype>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ftype),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ftype>())).length as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ftype),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_matched_type {
    pub next: *mut cli_matched_type,
    pub offset: off_t,
    pub type_: cli_file_t,
    pub cnt: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_cli_matched_type() {
    assert_eq!(
        ::std::mem::size_of::<cli_matched_type>(),
        24usize,
        concat!("Size of: ", stringify!(cli_matched_type))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_matched_type>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_matched_type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matched_type>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matched_type),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matched_type>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matched_type),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matched_type>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matched_type),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matched_type>())).cnt as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matched_type),
            "::",
            stringify!(cnt)
        )
    );
}
extern "C" {
    pub fn cli_ftcode(name: *const ::std::os::raw::c_char) -> cli_file_t;
}
extern "C" {
    pub fn cli_ftname(code: cli_file_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_ftfree(engine: *const cl_engine);
}
extern "C" {
    pub fn cli_compare_ftm_file(
        buf: *const ::std::os::raw::c_uchar,
        buflen: size_t,
        engine: *const cl_engine,
    ) -> cli_file_t;
}
extern "C" {
    pub fn cli_compare_ftm_partition(
        buf: *const ::std::os::raw::c_uchar,
        buflen: size_t,
        engine: *const cl_engine,
    ) -> cli_file_t;
}
extern "C" {
    pub fn cli_determine_fmap_type(
        map: *mut fmap_t,
        engine: *const cl_engine,
        basetype: cli_file_t,
    ) -> cli_file_t;
}
extern "C" {
    pub fn cli_addtypesigs(engine: *mut cl_engine) -> ::std::os::raw::c_int;
}
pub type array_list_free_fn =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct array_list {
    pub array: *mut *mut ::std::os::raw::c_void,
    pub length: size_t,
    pub size: size_t,
    pub free_fn: array_list_free_fn,
}
#[test]
fn bindgen_test_layout_array_list() {
    assert_eq!(
        ::std::mem::size_of::<array_list>(),
        32usize,
        concat!("Size of: ", stringify!(array_list))
    );
    assert_eq!(
        ::std::mem::align_of::<array_list>(),
        8usize,
        concat!("Alignment of ", stringify!(array_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<array_list>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(array_list),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<array_list>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(array_list),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<array_list>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(array_list),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<array_list>())).free_fn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(array_list),
            "::",
            stringify!(free_fn)
        )
    );
}
extern "C" {
    #[doc = " Allocate an array_list of the default size (32)."]
    #[doc = " @deprecated Use array_list_new2() instead."]
    pub fn array_list_new(free_fn: array_list_free_fn) -> *mut array_list;
}
extern "C" {
    #[doc = " Allocate an array_list of the desired size."]
    #[doc = ""]
    #[doc = " If possible, the size should be chosen to closely match"]
    #[doc = " the actual number of elements expected to be used."]
    #[doc = " If the exact size is unknown, there are tradeoffs to be made:"]
    #[doc = " - too small - the array_list code will need to call realloc() more"]
    #[doc = "   often (which might incur an additional memory copy)."]
    #[doc = " - too large - will waste memory, but that can be mitigated"]
    #[doc = "   by calling array_list_shrink() once the final size is known."]
    #[doc = ""]
    #[doc = " @see array_list_shrink"]
    pub fn array_list_new2(
        free_fn: array_list_free_fn,
        initial_size: ::std::os::raw::c_int,
    ) -> *mut array_list;
}
extern "C" {
    pub fn array_list_free(al: *mut array_list);
}
extern "C" {
    pub fn array_list_get_idx(al: *mut array_list, i: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn array_list_put_idx(
        al: *mut array_list,
        i: size_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn array_list_add(
        al: *mut array_list,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn array_list_length(al: *mut array_list) -> size_t;
}
extern "C" {
    pub fn array_list_sort(
        arr: *mut array_list,
        compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn array_list_bsearch(
        key: *mut *const ::std::os::raw::c_void,
        arr: *mut array_list,
        compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn array_list_del_idx(
        arr: *mut array_list,
        idx: size_t,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shrink the array list to just enough to fit the number of elements in it,"]
    #[doc = " plus empty_slots."]
    pub fn array_list_shrink(arr: *mut array_list, empty_slots: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mc_set_debug(debug: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mc_get_debug() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mc_set_syslog(syslog: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mc_debug(msg: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn mc_error(msg: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn mc_info(msg: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " @see JSON_C_VERSION"]
    #[doc = " @return the version of the json-c library as a string"]
    pub fn json_c_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " The json-c version encoded into an int, with the low order 8 bits"]
    #[doc = " being the micro version, the next higher 8 bits being the minor version"]
    #[doc = " and the next higher 8 bits being the major version."]
    #[doc = " For example, 7.12.99 would be 0x00070B63."]
    #[doc = ""]
    #[doc = " @see JSON_C_VERSION_NUM"]
    #[doc = " @return the version of the json-c library as an int"]
    pub fn json_c_version_num() -> ::std::os::raw::c_int;
}
#[doc = " A structure to use with json_object_object_foreachC() loops."]
#[doc = " Contains key, val and entry members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct json_object_iter {
    pub key: *mut ::std::os::raw::c_char,
    pub val: *mut json_object,
    pub entry: *mut lh_entry,
}
#[test]
fn bindgen_test_layout_json_object_iter() {
    assert_eq!(
        ::std::mem::size_of::<json_object_iter>(),
        24usize,
        concat!("Size of: ", stringify!(json_object_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<json_object_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(json_object_iter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_object_iter>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(json_object_iter),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_object_iter>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(json_object_iter),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_object_iter>())).entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(json_object_iter),
            "::",
            stringify!(entry)
        )
    );
}
pub type json_bool = ::std::os::raw::c_int;
#[doc = " Type of custom user delete functions.  See json_object_set_serializer."]
pub type json_object_delete_fn = ::std::option::Option<
    unsafe extern "C" fn(jso: *mut json_object, userdata: *mut ::std::os::raw::c_void),
>;
#[doc = " Type of a custom serialization function.  See json_object_set_serializer."]
pub type json_object_to_json_string_fn = ::std::option::Option<
    unsafe extern "C" fn(
        jso: *mut json_object,
        pb: *mut printbuf,
        level: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub const json_type_json_type_null: json_type = 0;
pub const json_type_json_type_boolean: json_type = 1;
pub const json_type_json_type_double: json_type = 2;
pub const json_type_json_type_int: json_type = 3;
pub const json_type_json_type_object: json_type = 4;
pub const json_type_json_type_array: json_type = 5;
pub const json_type_json_type_string: json_type = 6;
pub type json_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct printbuf {
    pub buf: *mut ::std::os::raw::c_char,
    pub bpos: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_printbuf() {
    assert_eq!(
        ::std::mem::size_of::<printbuf>(),
        16usize,
        concat!("Size of: ", stringify!(printbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<printbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(printbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<printbuf>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(printbuf),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<printbuf>())).bpos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(printbuf),
            "::",
            stringify!(bpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<printbuf>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(printbuf),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn printbuf_new() -> *mut printbuf;
}
extern "C" {
    pub fn printbuf_memappend(
        p: *mut printbuf,
        buf: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set len bytes of the buffer to charvalue, starting at offset offset."]
    #[doc = " Similar to calling memset(x, charvalue, len);"]
    #[doc = ""]
    #[doc = " The memory allocated for the buffer is extended as necessary."]
    #[doc = ""]
    #[doc = " If offset is -1, this starts at the end of the current data in the buffer."]
    pub fn printbuf_memset(
        pb: *mut printbuf,
        offset: ::std::os::raw::c_int,
        charvalue: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Formatted print to printbuf."]
    #[doc = ""]
    #[doc = " This function is the most expensive of the available functions for appending"]
    #[doc = " string data to a printbuf and should be used only where convenience is more"]
    #[doc = " important than speed. Avoid using this function in high performance code or"]
    #[doc = " tight loops; in these scenarios, consider using snprintf() with a static"]
    #[doc = " buffer in conjunction with one of the printbuf_*append() functions."]
    #[doc = ""]
    #[doc = " See also:"]
    #[doc = "   printbuf_memappend_fast()"]
    #[doc = "   printbuf_memappend()"]
    #[doc = "   printbuf_strappend()"]
    pub fn sprintbuf(
        p: *mut printbuf,
        msg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printbuf_reset(p: *mut printbuf);
}
extern "C" {
    pub fn printbuf_free(p: *mut printbuf);
}
extern "C" {
    #[doc = " Increment the reference count of json_object, thereby taking ownership of it."]
    #[doc = ""]
    #[doc = " Cases where you might need to increase the refcount include:"]
    #[doc = " - Using an object field or array index (retrieved through"]
    #[doc = "    `json_object_object_get()` or `json_object_array_get_idx()`)"]
    #[doc = "    beyond the lifetime of the parent object."]
    #[doc = " - Detaching an object field or array index from its parent object"]
    #[doc = "    (using `json_object_object_del()` or `json_object_array_del_idx()`)"]
    #[doc = " - Sharing a json_object with multiple (not necessarily parallel) threads"]
    #[doc = "    of execution that all expect to free it (with `json_object_put()`) when"]
    #[doc = "    they're done."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @see json_object_put()"]
    #[doc = " @see json_object_object_get()"]
    #[doc = " @see json_object_array_get_idx()"]
    pub fn json_object_get(obj: *mut json_object) -> *mut json_object;
}
extern "C" {
    #[doc = " Decrement the reference count of json_object and free if it reaches zero."]
    #[doc = ""]
    #[doc = " You must have ownership of obj prior to doing this or you will cause an"]
    #[doc = " imbalance in the reference count, leading to a classic use-after-free bug."]
    #[doc = " In particular, you normally do not need to call `json_object_put()` on the"]
    #[doc = " json_object returned by `json_object_object_get()` or `json_object_array_get_idx()`."]
    #[doc = ""]
    #[doc = " Just like after calling `free()` on a block of memory, you must not use"]
    #[doc = " `obj` after calling `json_object_put()` on it or any object that it"]
    #[doc = " is a member of (unless you know you've called `json_object_get(obj)` to"]
    #[doc = " explicitly increment the refcount)."]
    #[doc = ""]
    #[doc = " NULL may be passed, which which case this is a no-op."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns 1 if the object was freed."]
    #[doc = " @see json_object_get()"]
    pub fn json_object_put(obj: *mut json_object) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the json_object is of a given type"]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param type one of:"]
    #[doc = "json_type_null (i.e. obj == NULL),"]
    #[doc = "json_type_boolean,"]
    #[doc = "json_type_double,"]
    #[doc = "json_type_int,"]
    #[doc = "json_type_object,"]
    #[doc = "json_type_array,"]
    #[doc = "json_type_string"]
    pub fn json_object_is_type(obj: *const json_object, type_: json_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the type of the json_object.  See also json_type_to_name() to turn this"]
    #[doc = " into a string suitable, for instance, for logging."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns type being one of:"]
    #[doc = "json_type_null (i.e. obj == NULL),"]
    #[doc = "json_type_boolean,"]
    #[doc = "json_type_double,"]
    #[doc = "json_type_int,"]
    #[doc = "json_type_object,"]
    #[doc = "json_type_array,"]
    #[doc = "json_type_string"]
    pub fn json_object_get_type(obj: *const json_object) -> json_type;
}
extern "C" {
    #[doc = " Stringify object to json format."]
    #[doc = " Equivalent to json_object_to_json_string_ext(obj, JSON_C_TO_STRING_SPACED)"]
    #[doc = " The pointer you get is an internal of your json object. You don't"]
    #[doc = " have to free it, later use of json_object_put() should be sufficient."]
    #[doc = " If you can not ensure there's no concurrent access to *obj use"]
    #[doc = " strdup()."]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns a string in JSON format"]
    pub fn json_object_to_json_string(obj: *mut json_object) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Stringify object to json format"]
    #[doc = " @see json_object_to_json_string() for details on how to free string."]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param flags formatting options, see JSON_C_TO_STRING_PRETTY and other constants"]
    #[doc = " @returns a string in JSON format"]
    pub fn json_object_to_json_string_ext(
        obj: *mut json_object,
        flags: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Stringify object to json format"]
    #[doc = " @see json_object_to_json_string() for details on how to free string."]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param flags formatting options, see JSON_C_TO_STRING_PRETTY and other constants"]
    #[doc = " @param length a pointer where, if not NULL, the length (without null) is stored"]
    #[doc = " @returns a string in JSON format and the length if not NULL"]
    pub fn json_object_to_json_string_length(
        obj: *mut json_object,
        flags: ::std::os::raw::c_int,
        length: *mut size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the userdata set by json_object_set_userdata() or"]
    #[doc = " json_object_set_serializer()"]
    #[doc = ""]
    #[doc = " @param jso the object to return the userdata for"]
    pub fn json_object_get_userdata(jso: *mut json_object) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Set an opaque userdata value for an object"]
    #[doc = ""]
    #[doc = " The userdata can be retrieved using json_object_get_userdata()."]
    #[doc = ""]
    #[doc = " If custom userdata is already set on this object, any existing user_delete"]
    #[doc = " function is called before the new one is set."]
    #[doc = ""]
    #[doc = " The user_delete parameter is optional and may be passed as NULL, even if"]
    #[doc = " the userdata parameter is non-NULL.  It will be called just before the"]
    #[doc = " json_object is deleted, after it's reference count goes to zero"]
    #[doc = " (see json_object_put())."]
    #[doc = " If this is not provided, it is up to the caller to free the userdata at"]
    #[doc = " an appropriate time. (i.e. after the json_object is deleted)"]
    #[doc = ""]
    #[doc = " Note: Objects created by parsing strings may have custom serializers set"]
    #[doc = " which expect the userdata to contain specific data (due to use of"]
    #[doc = " json_object_new_double_s()). In this case, json_object_set_serialiser() with"]
    #[doc = " NULL as to_string_func should be used instead to set the userdata and reset"]
    #[doc = " the serializer to its default value."]
    #[doc = ""]
    #[doc = " @param jso the object to set the userdata for"]
    #[doc = " @param userdata an optional opaque cookie"]
    #[doc = " @param user_delete an optional function from freeing userdata"]
    pub fn json_object_set_userdata(
        jso: *mut json_object,
        userdata: *mut ::std::os::raw::c_void,
        user_delete: json_object_delete_fn,
    );
}
extern "C" {
    #[doc = " Set a custom serialization function to be used when this particular object"]
    #[doc = " is converted to a string by json_object_to_json_string."]
    #[doc = ""]
    #[doc = " If custom userdata is already set on this object, any existing user_delete"]
    #[doc = " function is called before the new one is set."]
    #[doc = ""]
    #[doc = " If to_string_func is NULL the default behaviour is reset (but the userdata"]
    #[doc = " and user_delete fields are still set)."]
    #[doc = ""]
    #[doc = " The userdata parameter is optional and may be passed as NULL. It can be used"]
    #[doc = " to provide additional data for to_string_func to use. This parameter may"]
    #[doc = " be NULL even if user_delete is non-NULL."]
    #[doc = ""]
    #[doc = " The user_delete parameter is optional and may be passed as NULL, even if"]
    #[doc = " the userdata parameter is non-NULL.  It will be called just before the"]
    #[doc = " json_object is deleted, after it's reference count goes to zero"]
    #[doc = " (see json_object_put())."]
    #[doc = " If this is not provided, it is up to the caller to free the userdata at"]
    #[doc = " an appropriate time. (i.e. after the json_object is deleted)"]
    #[doc = ""]
    #[doc = " Note that the userdata is the same as set by json_object_set_userdata(), so"]
    #[doc = " care must be taken not to overwrite the value when both a custom serializer"]
    #[doc = " and json_object_set_userdata() are used."]
    #[doc = ""]
    #[doc = " @param jso the object to customize"]
    #[doc = " @param to_string_func the custom serialization function"]
    #[doc = " @param userdata an optional opaque cookie"]
    #[doc = " @param user_delete an optional function from freeing userdata"]
    pub fn json_object_set_serializer(
        jso: *mut json_object,
        to_string_func: json_object_to_json_string_fn,
        userdata: *mut ::std::os::raw::c_void,
        user_delete: json_object_delete_fn,
    );
}
extern "C" {
    #[doc = " Simply call free on the userdata pointer."]
    #[doc = " Can be used with json_object_set_serializer()."]
    #[doc = ""]
    #[doc = " @param jso unused"]
    #[doc = " @param userdata the pointer that is passed to free()."]
    pub fn json_object_free_userdata(jso: *mut json_object, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Copy the jso->_userdata string over to pb as-is."]
    #[doc = " Can be used with json_object_set_serializer()."]
    #[doc = ""]
    #[doc = " @param jso The object whose _userdata is used."]
    #[doc = " @param pb The destination buffer."]
    #[doc = " @param level Ignored."]
    #[doc = " @param flags Ignored."]
    pub fn json_object_userdata_to_json_string(
        jso: *mut json_object,
        pb: *mut printbuf,
        level: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new empty object with a reference count of 1.  The caller of"]
    #[doc = " this object initially has sole ownership.  Remember, when using"]
    #[doc = " json_object_object_add or json_object_array_put_idx, ownership will"]
    #[doc = " transfer to the object/array.  Call json_object_get if you want to maintain"]
    #[doc = " shared ownership or also add this object as a child of multiple objects or"]
    #[doc = " arrays.  Any ownerships you acquired but did not transfer must be released"]
    #[doc = " through json_object_put."]
    #[doc = ""]
    #[doc = " @returns a json_object of type json_type_object"]
    pub fn json_object_new_object() -> *mut json_object;
}
extern "C" {
    #[doc = " Get the hashtable of a json_object of type json_type_object"]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns a linkhash"]
    pub fn json_object_get_object(obj: *const json_object) -> *mut lh_table;
}
extern "C" {
    #[doc = " Get the size of an object in terms of the number of fields it has."]
    #[doc = " @param obj the json_object whose length to return"]
    pub fn json_object_object_length(obj: *const json_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn json_c_object_sizeof() -> size_t;
}
extern "C" {
    #[doc = " Add an object field to a json_object of type json_type_object"]
    #[doc = ""]
    #[doc = " The reference count of `val` will *not* be incremented, in effect"]
    #[doc = " transferring ownership that object to `obj`, and thus `val` will be"]
    #[doc = " freed when `obj` is.  (i.e. through `json_object_put(obj)`)"]
    #[doc = ""]
    #[doc = " If you want to retain a reference to the added object, independent"]
    #[doc = " of the lifetime of obj, you must increment the refcount with"]
    #[doc = " `json_object_get(val)` (and later release it with json_object_put())."]
    #[doc = ""]
    #[doc = " Since ownership transfers to `obj`, you must make sure"]
    #[doc = " that you do in fact have ownership over `val`.  For instance,"]
    #[doc = " json_object_new_object() will give you ownership until you transfer it,"]
    #[doc = " whereas json_object_object_get() does not."]
    #[doc = ""]
    #[doc = " Any previous object stored under `key` in `obj` will have its refcount"]
    #[doc = " decremented, and be freed normally if that drops to zero."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param key the object field name (a private copy will be duplicated)"]
    #[doc = " @param val a json_object or NULL member to associate with the given field"]
    #[doc = ""]
    #[doc = " @return On success, <code>0</code> is returned."]
    #[doc = " \tOn error, a negative value is returned."]
    pub fn json_object_object_add(
        obj: *mut json_object,
        key: *const ::std::os::raw::c_char,
        val: *mut json_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an object field to a json_object of type json_type_object"]
    #[doc = ""]
    #[doc = " The semantics are identical to json_object_object_add, except that an"]
    #[doc = " additional flag fields gives you more control over some detail aspects"]
    #[doc = " of processing. See the description of JSON_C_OBJECT_ADD_* flags for more"]
    #[doc = " details."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param key the object field name (a private copy will be duplicated)"]
    #[doc = " @param val a json_object or NULL member to associate with the given field"]
    #[doc = " @param opts process-modifying options. To specify multiple options, use"]
    #[doc = "             (OPT1|OPT2)"]
    pub fn json_object_object_add_ex(
        obj: *mut json_object,
        key: *const ::std::os::raw::c_char,
        val: *mut json_object,
        opts: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the json_object associate with a given object field."]
    #[doc = " Deprecated/discouraged: used json_object_object_get_ex instead."]
    #[doc = ""]
    #[doc = " This returns NULL if the field is found but its value is null, or if"]
    #[doc = "  the field is not found, or if obj is not a json_type_object.  If you"]
    #[doc = "  need to distinguish between these cases, use json_object_object_get_ex()."]
    #[doc = ""]
    #[doc = " *No* reference counts will be changed.  There is no need to manually adjust"]
    #[doc = " reference counts through the json_object_put/json_object_get methods unless"]
    #[doc = " you need to have the child (value) reference maintain a different lifetime"]
    #[doc = " than the owning parent (obj). Ownership of the returned value is retained"]
    #[doc = " by obj (do not do json_object_put unless you have done a json_object_get)."]
    #[doc = " If you delete the value from obj (json_object_object_del) and wish to access"]
    #[doc = " the returned reference afterwards, make sure you have first gotten shared"]
    #[doc = " ownership through json_object_get (& don't forget to do a json_object_put"]
    #[doc = " or transfer ownership to prevent a memory leak)."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param key the object field name"]
    #[doc = " @returns the json_object associated with the given field name"]
    pub fn json_object_object_get(
        obj: *const json_object,
        key: *const ::std::os::raw::c_char,
    ) -> *mut json_object;
}
extern "C" {
    #[doc = " Get the json_object associated with a given object field."]
    #[doc = ""]
    #[doc = " This returns true if the key is found, false in all other cases (including"]
    #[doc = " if obj isn't a json_type_object)."]
    #[doc = ""]
    #[doc = " *No* reference counts will be changed.  There is no need to manually adjust"]
    #[doc = " reference counts through the json_object_put/json_object_get methods unless"]
    #[doc = " you need to have the child (value) reference maintain a different lifetime"]
    #[doc = " than the owning parent (obj).  Ownership of value is retained by obj."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param key the object field name"]
    #[doc = " @param value a pointer where to store a reference to the json_object"]
    #[doc = "              associated with the given field name."]
    #[doc = ""]
    #[doc = "              It is safe to pass a NULL value."]
    #[doc = " @returns whether or not the key exists"]
    pub fn json_object_object_get_ex(
        obj: *const json_object,
        key: *const ::std::os::raw::c_char,
        value: *mut *mut json_object,
    ) -> json_bool;
}
extern "C" {
    #[doc = " Delete the given json_object field"]
    #[doc = ""]
    #[doc = " The reference count will be decremented for the deleted object.  If there"]
    #[doc = " are no more owners of the value represented by this key, then the value is"]
    #[doc = " freed.  Otherwise, the reference to the value will remain in memory."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param key the object field name"]
    pub fn json_object_object_del(obj: *mut json_object, key: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_array"]
    #[doc = " with 32 slots allocated."]
    #[doc = " If you know the array size you'll need ahead of time, use"]
    #[doc = " json_object_new_array_ext() instead."]
    #[doc = " @see json_object_new_array_ext()"]
    #[doc = " @see json_object_array_shrink()"]
    #[doc = " @returns a json_object of type json_type_array"]
    pub fn json_object_new_array() -> *mut json_object;
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_array"]
    #[doc = " with the desired number of slots allocated."]
    #[doc = " @see json_object_array_shrink()"]
    #[doc = " @param initial_size the number of slots to allocate"]
    #[doc = " @returns a json_object of type json_type_array"]
    pub fn json_object_new_array_ext(initial_size: ::std::os::raw::c_int) -> *mut json_object;
}
extern "C" {
    #[doc = " Get the arraylist of a json_object of type json_type_array"]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns an arraylist"]
    pub fn json_object_get_array(obj: *const json_object) -> *mut array_list;
}
extern "C" {
    #[doc = " Get the length of a json_object of type json_type_array"]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns an int"]
    pub fn json_object_array_length(obj: *const json_object) -> size_t;
}
extern "C" {
    #[doc = " Sorts the elements of jso of type json_type_array"]
    #[doc = ""]
    #[doc = " Pointers to the json_object pointers will be passed as the two arguments"]
    #[doc = " to sort_fn"]
    #[doc = ""]
    #[doc = " @param jso the json_object instance"]
    #[doc = " @param sort_fn a sorting function"]
    pub fn json_object_array_sort(
        jso: *mut json_object,
        sort_fn: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[doc = " Binary search a sorted array for a specified key object."]
    #[doc = ""]
    #[doc = " It depends on your compare function what's sufficient as a key."]
    #[doc = " Usually you create some dummy object with the parameter compared in"]
    #[doc = " it, to identify the right item you're actually looking for."]
    #[doc = ""]
    #[doc = " @see json_object_array_sort() for hints on the compare function."]
    #[doc = ""]
    #[doc = " @param key a dummy json_object with the right key"]
    #[doc = " @param jso the array object we're searching"]
    #[doc = " @param sort_fn the sort/compare function"]
    #[doc = ""]
    #[doc = " @return the wanted json_object instance"]
    pub fn json_object_array_bsearch(
        key: *const json_object,
        jso: *const json_object,
        sort_fn: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut json_object;
}
extern "C" {
    #[doc = " Add an element to the end of a json_object of type json_type_array"]
    #[doc = ""]
    #[doc = " The reference count will *not* be incremented. This is to make adding"]
    #[doc = " fields to objects in code more compact. If you want to retain a reference"]
    #[doc = " to an added object you must wrap the passed object with json_object_get"]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param val the json_object to be added"]
    pub fn json_object_array_add(
        obj: *mut json_object,
        val: *mut json_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Insert or replace an element at a specified index in an array (a json_object of type json_type_array)"]
    #[doc = ""]
    #[doc = " The reference count will *not* be incremented. This is to make adding"]
    #[doc = " fields to objects in code more compact. If you want to retain a reference"]
    #[doc = " to an added object you must wrap the passed object with json_object_get"]
    #[doc = ""]
    #[doc = " The reference count of a replaced object will be decremented."]
    #[doc = ""]
    #[doc = " The array size will be automatically be expanded to the size of the"]
    #[doc = " index if the index is larger than the current size."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param idx the index to insert the element at"]
    #[doc = " @param val the json_object to be added"]
    pub fn json_object_array_put_idx(
        obj: *mut json_object,
        idx: size_t,
        val: *mut json_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the element at specified index of array `obj` (which must be a json_object of type json_type_array)"]
    #[doc = ""]
    #[doc = " *No* reference counts will be changed, and ownership of the returned"]
    #[doc = " object remains with `obj`.  See json_object_object_get() for additional"]
    #[doc = " implications of this behavior."]
    #[doc = ""]
    #[doc = " Calling this with anything other than a json_type_array will trigger"]
    #[doc = " an assert."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param idx the index to get the element at"]
    #[doc = " @returns the json_object at the specified index (or NULL)"]
    pub fn json_object_array_get_idx(obj: *const json_object, idx: size_t) -> *mut json_object;
}
extern "C" {
    #[doc = " Delete an elements from a specified index in an array (a json_object of type json_type_array)"]
    #[doc = ""]
    #[doc = " The reference count will be decremented for each of the deleted objects.  If there"]
    #[doc = " are no more owners of an element that is being deleted, then the value is"]
    #[doc = " freed.  Otherwise, the reference to the value will remain in memory."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param idx the index to start deleting elements at"]
    #[doc = " @param count the number of elements to delete"]
    #[doc = " @returns 0 if the elements were successfully deleted"]
    pub fn json_object_array_del_idx(
        obj: *mut json_object,
        idx: size_t,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shrink the internal memory allocation of the array to just"]
    #[doc = " enough to fit the number of elements in it, plus empty_slots."]
    #[doc = ""]
    #[doc = " @param jso the json_object instance, must be json_type_array"]
    #[doc = " @param empty_slots the number of empty slots to leave allocated"]
    pub fn json_object_array_shrink(
        jso: *mut json_object,
        empty_slots: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_boolean"]
    #[doc = " @param b a json_bool 1 or 0"]
    #[doc = " @returns a json_object of type json_type_boolean"]
    pub fn json_object_new_boolean(b: json_bool) -> *mut json_object;
}
extern "C" {
    #[doc = " Get the json_bool value of a json_object"]
    #[doc = ""]
    #[doc = " The type is coerced to a json_bool if the passed object is not a json_bool."]
    #[doc = " integer and double objects will return 0 if there value is zero"]
    #[doc = " or 1 otherwise. If the passed object is a string it will return"]
    #[doc = " 1 if it has a non zero length."]
    #[doc = " If any other object type is passed 0 will be returned, even non-empty"]
    #[doc = "  json_type_array and json_type_object objects."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns a json_bool"]
    pub fn json_object_get_boolean(obj: *const json_object) -> json_bool;
}
extern "C" {
    #[doc = " Set the json_bool value of a json_object"]
    #[doc = ""]
    #[doc = " The type of obj is checked to be a json_type_boolean and 0 is returned"]
    #[doc = " if it is not without any further actions. If type of obj is json_type_boolean"]
    #[doc = " the object value is changed to new_value"]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param new_value the value to be set"]
    #[doc = " @returns 1 if value is set correctly, 0 otherwise"]
    pub fn json_object_set_boolean(
        obj: *mut json_object,
        new_value: json_bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_int"]
    #[doc = " Note that values are stored as 64-bit values internally."]
    #[doc = " To ensure the full range is maintained, use json_object_new_int64 instead."]
    #[doc = " @param i the integer"]
    #[doc = " @returns a json_object of type json_type_int"]
    pub fn json_object_new_int(i: i32) -> *mut json_object;
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_int"]
    #[doc = " @param i the integer"]
    #[doc = " @returns a json_object of type json_type_int"]
    pub fn json_object_new_int64(i: i64) -> *mut json_object;
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_uint"]
    #[doc = " @param i the integer"]
    #[doc = " @returns a json_object of type json_type_uint"]
    pub fn json_object_new_uint64(i: u64) -> *mut json_object;
}
extern "C" {
    #[doc = " Get the int value of a json_object"]
    #[doc = ""]
    #[doc = " The type is coerced to a int if the passed object is not a int."]
    #[doc = " double objects will return their integer conversion. Strings will be"]
    #[doc = " parsed as an integer. If no conversion exists then 0 is returned"]
    #[doc = " and errno is set to EINVAL. null is equivalent to 0 (no error values set)"]
    #[doc = ""]
    #[doc = " Note that integers are stored internally as 64-bit values."]
    #[doc = " If the value of too big or too small to fit into 32-bit, INT32_MAX or"]
    #[doc = " INT32_MIN are returned, respectively."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns an int"]
    pub fn json_object_get_int(obj: *const json_object) -> i32;
}
extern "C" {
    #[doc = " Set the int value of a json_object"]
    #[doc = ""]
    #[doc = " The type of obj is checked to be a json_type_int and 0 is returned"]
    #[doc = " if it is not without any further actions. If type of obj is json_type_int"]
    #[doc = " the object value is changed to new_value"]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param new_value the value to be set"]
    #[doc = " @returns 1 if value is set correctly, 0 otherwise"]
    pub fn json_object_set_int(
        obj: *mut json_object,
        new_value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Increment a json_type_int object by the given amount, which may be negative."]
    #[doc = ""]
    #[doc = " If the type of obj is not json_type_int then 0 is returned with no further"]
    #[doc = " action taken."]
    #[doc = " If the addition would result in a overflow, the object value"]
    #[doc = " is set to INT64_MAX."]
    #[doc = " If the addition would result in a underflow, the object value"]
    #[doc = " is set to INT64_MIN."]
    #[doc = " Neither overflow nor underflow affect the return value."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param val the value to add"]
    #[doc = " @returns 1 if the increment succeeded, 0 otherwise"]
    pub fn json_object_int_inc(obj: *mut json_object, val: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the int value of a json_object"]
    #[doc = ""]
    #[doc = " The type is coerced to a int64 if the passed object is not a int64."]
    #[doc = " double objects will return their int64 conversion. Strings will be"]
    #[doc = " parsed as an int64. If no conversion exists then 0 is returned."]
    #[doc = ""]
    #[doc = " NOTE: Set errno to 0 directly before a call to this function to determine"]
    #[doc = " whether or not conversion was successful (it does not clear the value for"]
    #[doc = " you)."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns an int64"]
    pub fn json_object_get_int64(obj: *const json_object) -> i64;
}
extern "C" {
    #[doc = " Get the uint value of a json_object"]
    #[doc = ""]
    #[doc = " The type is coerced to a uint64 if the passed object is not a uint64."]
    #[doc = " double objects will return their uint64 conversion. Strings will be"]
    #[doc = " parsed as an uint64. If no conversion exists then 0 is returned."]
    #[doc = ""]
    #[doc = " NOTE: Set errno to 0 directly before a call to this function to determine"]
    #[doc = " whether or not conversion was successful (it does not clear the value for"]
    #[doc = " you)."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns an uint64"]
    pub fn json_object_get_uint64(obj: *const json_object) -> u64;
}
extern "C" {
    #[doc = " Set the int64_t value of a json_object"]
    #[doc = ""]
    #[doc = " The type of obj is checked to be a json_type_int and 0 is returned"]
    #[doc = " if it is not without any further actions. If type of obj is json_type_int"]
    #[doc = " the object value is changed to new_value"]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param new_value the value to be set"]
    #[doc = " @returns 1 if value is set correctly, 0 otherwise"]
    pub fn json_object_set_int64(obj: *mut json_object, new_value: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the uint64_t value of a json_object"]
    #[doc = ""]
    #[doc = " The type of obj is checked to be a json_type_uint and 0 is returned"]
    #[doc = " if it is not without any further actions. If type of obj is json_type_uint"]
    #[doc = " the object value is changed to new_value"]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param new_value the value to be set"]
    #[doc = " @returns 1 if value is set correctly, 0 otherwise"]
    pub fn json_object_set_uint64(obj: *mut json_object, new_value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_double"]
    #[doc = ""]
    #[doc = " @see json_object_double_to_json_string() for how to set a custom format string."]
    #[doc = ""]
    #[doc = " @param d the double"]
    #[doc = " @returns a json_object of type json_type_double"]
    pub fn json_object_new_double(d: f64) -> *mut json_object;
}
extern "C" {
    #[doc = " Create a new json_object of type json_type_double, using"]
    #[doc = " the exact serialized representation of the value."]
    #[doc = ""]
    #[doc = " This allows for numbers that would otherwise get displayed"]
    #[doc = " inefficiently (e.g. 12.3 => \"12.300000000000001\") to be"]
    #[doc = " serialized with the more convenient form."]
    #[doc = ""]
    #[doc = " Notes:"]
    #[doc = ""]
    #[doc = " This is used by json_tokener_parse_ex() to allow for"]
    #[doc = " an exact re-serialization of a parsed object."]
    #[doc = ""]
    #[doc = " The userdata field is used to store the string representation, so it"]
    #[doc = " can't be used for other data if this function is used."]
    #[doc = ""]
    #[doc = " A roughly equivalent sequence of calls, with the difference being that"]
    #[doc = "  the serialization function won't be reset by json_object_set_double(), is:"]
    #[doc = " @code"]
    #[doc = "   jso = json_object_new_double(d);"]
    #[doc = "   json_object_set_serializer(jso, json_object_userdata_to_json_string,"]
    #[doc = "       strdup(ds), json_object_free_userdata);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param d the numeric value of the double."]
    #[doc = " @param ds the string representation of the double.  This will be copied."]
    pub fn json_object_new_double_s(d: f64, ds: *const ::std::os::raw::c_char) -> *mut json_object;
}
extern "C" {
    #[doc = " Set a global or thread-local json-c option, depending on whether"]
    #[doc = "  JSON_C_OPTION_GLOBAL or JSON_C_OPTION_THREAD is passed."]
    #[doc = " Thread-local options default to undefined, and inherit from the global"]
    #[doc = "  value, even if the global value is changed after the thread is created."]
    #[doc = " Attempting to set thread-local options when threading is not compiled in"]
    #[doc = "  will result in an error.  Be sure to check the return value."]
    #[doc = ""]
    #[doc = " double_format is a \"%g\" printf format, such as \"%.20g\""]
    #[doc = ""]
    #[doc = " @return -1 on errors, 0 on success."]
    pub fn json_c_set_serialization_double_format(
        double_format: *const ::std::os::raw::c_char,
        global_or_thread: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize a json_object of type json_type_double to a string."]
    #[doc = ""]
    #[doc = " This function isn't meant to be called directly. Instead, you can set a"]
    #[doc = " custom format string for the serialization of this double using the"]
    #[doc = " following call (where \"%.17g\" actually is the default):"]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = "   jso = json_object_new_double(d);"]
    #[doc = "   json_object_set_serializer(jso, json_object_double_to_json_string,"]
    #[doc = "       \"%.17g\", NULL);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @see printf(3) man page for format strings"]
    #[doc = ""]
    #[doc = " @param jso The json_type_double object that is serialized."]
    #[doc = " @param pb The destination buffer."]
    #[doc = " @param level Ignored."]
    #[doc = " @param flags Ignored."]
    pub fn json_object_double_to_json_string(
        jso: *mut json_object,
        pb: *mut printbuf,
        level: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the double floating point value of a json_object"]
    #[doc = ""]
    #[doc = " The type is coerced to a double if the passed object is not a double."]
    #[doc = " integer objects will return their double conversion. Strings will be"]
    #[doc = " parsed as a double. If no conversion exists then 0.0 is returned and"]
    #[doc = " errno is set to EINVAL. null is equivalent to 0 (no error values set)"]
    #[doc = ""]
    #[doc = " If the value is too big to fit in a double, then the value is set to"]
    #[doc = " the closest infinity with errno set to ERANGE. If strings cannot be"]
    #[doc = " converted to their double value, then EINVAL is set & NaN is returned."]
    #[doc = ""]
    #[doc = " Arrays of length 0 are interpreted as 0 (with no error flags set)."]
    #[doc = " Arrays of length 1 are effectively cast to the equivalent object and"]
    #[doc = " converted using the above rules.  All other arrays set the error to"]
    #[doc = " EINVAL & return NaN."]
    #[doc = ""]
    #[doc = " NOTE: Set errno to 0 directly before a call to this function to"]
    #[doc = " determine whether or not conversion was successful (it does not clear"]
    #[doc = " the value for you)."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns a double floating point number"]
    pub fn json_object_get_double(obj: *const json_object) -> f64;
}
extern "C" {
    #[doc = " Set the double value of a json_object"]
    #[doc = ""]
    #[doc = " The type of obj is checked to be a json_type_double and 0 is returned"]
    #[doc = " if it is not without any further actions. If type of obj is json_type_double"]
    #[doc = " the object value is changed to new_value"]
    #[doc = ""]
    #[doc = " If the object was created with json_object_new_double_s(), the serialization"]
    #[doc = " function is reset to the default and the cached serialized value is cleared."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param new_value the value to be set"]
    #[doc = " @returns 1 if value is set correctly, 0 otherwise"]
    pub fn json_object_set_double(obj: *mut json_object, new_value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_string"]
    #[doc = ""]
    #[doc = " A copy of the string is made and the memory is managed by the json_object"]
    #[doc = ""]
    #[doc = " @param s the string"]
    #[doc = " @returns a json_object of type json_type_string"]
    #[doc = " @see json_object_new_string_len()"]
    pub fn json_object_new_string(s: *const ::std::os::raw::c_char) -> *mut json_object;
}
extern "C" {
    #[doc = " Create a new empty json_object of type json_type_string and allocate"]
    #[doc = " len characters for the new string."]
    #[doc = ""]
    #[doc = " A copy of the string is made and the memory is managed by the json_object"]
    #[doc = ""]
    #[doc = " @param s the string"]
    #[doc = " @param len max length of the new string"]
    #[doc = " @returns a json_object of type json_type_string"]
    #[doc = " @see json_object_new_string()"]
    pub fn json_object_new_string_len(
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut json_object;
}
extern "C" {
    #[doc = " Get the string value of a json_object"]
    #[doc = ""]
    #[doc = " If the passed object is of type json_type_null (i.e. obj == NULL),"]
    #[doc = " NULL is returned."]
    #[doc = ""]
    #[doc = " If the passed object of type json_type_string, the string contents"]
    #[doc = " are returned."]
    #[doc = ""]
    #[doc = " Otherwise the JSON representation of the object is returned."]
    #[doc = ""]
    #[doc = " The returned string memory is managed by the json_object and will"]
    #[doc = " be freed when the reference count of the json_object drops to zero."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns a string or NULL"]
    pub fn json_object_get_string(obj: *mut json_object) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the string length of a json_object"]
    #[doc = ""]
    #[doc = " If the passed object is not of type json_type_string then zero"]
    #[doc = " will be returned."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @returns int"]
    pub fn json_object_get_string_len(obj: *const json_object) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the string value of a json_object with zero terminated strings"]
    #[doc = " equivalent to json_object_set_string_len (obj, new_value, strlen(new_value))"]
    #[doc = " @returns 1 if value is set correctly, 0 otherwise"]
    pub fn json_object_set_string(
        obj: *mut json_object,
        new_value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the string value of a json_object str"]
    #[doc = ""]
    #[doc = " The type of obj is checked to be a json_type_string and 0 is returned"]
    #[doc = " if it is not without any further actions. If type of obj is json_type_string"]
    #[doc = " the object value is changed to new_value"]
    #[doc = ""]
    #[doc = " @param obj the json_object instance"]
    #[doc = " @param new_value the value to be set; Since string length is given in len this need not be zero terminated"]
    #[doc = " @param len the length of new_value"]
    #[doc = " @returns 1 if value is set correctly, 0 otherwise"]
    pub fn json_object_set_string_len(
        obj: *mut json_object,
        new_value: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This method exists only to provide a complementary function"]
    #[doc = " along the lines of the other json_object_new_* functions."]
    #[doc = " It always returns NULL, and it is entirely acceptable to simply use NULL directly."]
    pub fn json_object_new_null() -> *mut json_object;
}
extern "C" {
    #[doc = " Check if two json_object's are equal"]
    #[doc = ""]
    #[doc = " If the passed objects are equal 1 will be returned."]
    #[doc = " Equality is defined as follows:"]
    #[doc = " - json_objects of different types are never equal"]
    #[doc = " - json_objects of the same primitive type are equal if the"]
    #[doc = "   c-representation of their value is equal"]
    #[doc = " - json-arrays are considered equal if all values at the same"]
    #[doc = "   indices are equal (same order)"]
    #[doc = " - Complex json_objects are considered equal if all"]
    #[doc = "   contained objects referenced by their key are equal,"]
    #[doc = "   regardless their order."]
    #[doc = ""]
    #[doc = " @param obj1 the first json_object instance"]
    #[doc = " @param obj2 the second json_object instance"]
    #[doc = " @returns whether both objects are equal or not"]
    pub fn json_object_equal(
        obj1: *mut json_object,
        obj2: *mut json_object,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Perform a shallow copy of src into *dst as part of an overall json_object_deep_copy()."]
#[doc = ""]
#[doc = " If src is part of a containing object or array, parent will be non-NULL,"]
#[doc = " and key or index will be provided."]
#[doc = " When shallow_copy is called *dst will be NULL, and must be non-NULL when it returns."]
#[doc = " src will never be NULL."]
#[doc = ""]
#[doc = " If shallow_copy sets the serializer on an object, return 2 to indicate to"]
#[doc = "  json_object_deep_copy that it should not attempt to use the standard userdata"]
#[doc = "  copy function."]
#[doc = ""]
#[doc = " @return On success 1 or 2, -1 on errors"]
pub type json_c_shallow_copy_fn = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut json_object,
        parent: *mut json_object,
        key: *const ::std::os::raw::c_char,
        index: size_t,
        dst: *mut *mut json_object,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " The default shallow copy implementation for use with json_object_deep_copy()."]
    #[doc = " This simply calls the appropriate json_object_new_<type>() function and"]
    #[doc = " copies over the serializer function (_to_json_string internal field of"]
    #[doc = " the json_object structure) but not any _userdata or _user_delete values."]
    #[doc = ""]
    #[doc = " If you're writing a custom shallow_copy function, perhaps because you're using"]
    #[doc = " your own custom serializer, you can call this first to create the new object"]
    #[doc = " before customizing it with json_object_set_serializer()."]
    #[doc = ""]
    #[doc = " @return 1 on success, -1 on errors, but never 2."]
    pub fn json_c_shallow_copy_default(
        src: *mut json_object,
        parent: *mut json_object,
        key: *const ::std::os::raw::c_char,
        index: size_t,
        dst: *mut *mut json_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy the contents of the JSON object."]
    #[doc = " The destination object must be initialized to NULL,"]
    #[doc = " to make sure this function won't overwrite an existing JSON object."]
    #[doc = ""]
    #[doc = " This does roughly the same thing as"]
    #[doc = " `json_tokener_parse(json_object_get_string(src))`."]
    #[doc = ""]
    #[doc = " @param src source JSON object whose contents will be copied"]
    #[doc = " @param dst pointer to the destination object where the contents of `src`;"]
    #[doc = "            make sure this pointer is initialized to NULL"]
    #[doc = " @param shallow_copy an optional function to copy individual objects, needed"]
    #[doc = "                     when custom serializers are in use.  See also"]
    #[doc = "                     json_object set_serializer."]
    #[doc = ""]
    #[doc = " @returns 0 if the copy went well, -1 if an error occurred during copy"]
    #[doc = "          or if the destination pointer is non-NULL"]
    pub fn json_object_deep_copy(
        src: *mut json_object,
        dst: *mut *mut json_object,
        shallow_copy: json_c_shallow_copy_fn,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Forward declaration for the opaque iterator information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct json_object_iter_info_ {
    _unused: [u8; 0],
}
#[doc = " The opaque iterator that references a name/value pair within"]
#[doc = " a JSON Object instance or the \"end\" iterator value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct json_object_iterator {
    pub opaque_: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_json_object_iterator() {
    assert_eq!(
        ::std::mem::size_of::<json_object_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(json_object_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<json_object_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(json_object_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_object_iterator>())).opaque_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(json_object_iterator),
            "::",
            stringify!(opaque_)
        )
    );
}
#[doc = " forward declaration of json-c's JSON value instance structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct json_object {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initializes an iterator structure to a \"default\" value that"]
    #[doc = " is convenient for initializing an iterator variable to a"]
    #[doc = " default state (e.g., initialization list in a class'"]
    #[doc = " constructor)."]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " struct json_object_iterator iter = json_object_iter_init_default();"]
    #[doc = " MyClass() : iter_(json_object_iter_init_default())"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @note The initialized value doesn't reference any specific"]
    #[doc = "       pair, is considered an invalid iterator, and MUST NOT"]
    #[doc = "       be passed to any json-c API that expects a valid"]
    #[doc = "       iterator."]
    #[doc = ""]
    #[doc = " @note User and internal code MUST NOT make any assumptions"]
    #[doc = "       about and dependencies on the value of the \"default\""]
    #[doc = "       iterator value."]
    #[doc = ""]
    #[doc = " @return json_object_iterator"]
    pub fn json_object_iter_init_default() -> json_object_iterator;
}
extern "C" {
    #[doc = " Retrieves an iterator to the first pair of the JSON Object."]
    #[doc = ""]
    #[doc = " @warning \tAny modification of the underlying pair invalidates all"]
    #[doc = " \t\titerators to that pair."]
    #[doc = ""]
    #[doc = " @param obj\tJSON Object instance (MUST be of type json_object)"]
    #[doc = ""]
    #[doc = " @return json_object_iterator If the JSON Object has at"]
    #[doc = "              least one pair, on return, the iterator refers"]
    #[doc = "              to the first pair. If the JSON Object doesn't"]
    #[doc = "              have any pairs, the returned iterator is"]
    #[doc = "              equivalent to the \"end\" iterator for the same"]
    #[doc = "              JSON Object instance."]
    #[doc = ""]
    #[doc = " @code"]
    #[doc = " struct json_object_iterator it;"]
    #[doc = " struct json_object_iterator itEnd;"]
    #[doc = " struct json_object* obj;"]
    #[doc = ""]
    #[doc = " obj = json_tokener_parse(\"{'first':'george', 'age':100}\");"]
    #[doc = " it = json_object_iter_begin(obj);"]
    #[doc = " itEnd = json_object_iter_end(obj);"]
    #[doc = ""]
    #[doc = " while (!json_object_iter_equal(&it, &itEnd)) {"]
    #[doc = "     printf(\"%s\\n\","]
    #[doc = "            json_object_iter_peek_name(&it));"]
    #[doc = "     json_object_iter_next(&it);"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " @endcode"]
    pub fn json_object_iter_begin(obj: *mut json_object) -> json_object_iterator;
}
extern "C" {
    #[doc = " Retrieves the iterator that represents the position beyond the"]
    #[doc = "  last pair of the given JSON Object instance."]
    #[doc = ""]
    #[doc = "  @warning Do NOT write code that assumes that the \"end\""]
    #[doc = "        iterator value is NULL, even if it is so in a"]
    #[doc = "        particular instance of the implementation."]
    #[doc = ""]
    #[doc = "  @note The reason we do not (and MUST NOT) provide"]
    #[doc = "        \"json_object_iter_is_end(json_object_iterator* iter)\""]
    #[doc = "        type of API is because it would limit the underlying"]
    #[doc = "        representation of name/value containment (or force us"]
    #[doc = "        to add additional, otherwise unnecessary, fields to"]
    #[doc = "        the iterator structure). The \"end\" iterator and the"]
    #[doc = "        equality test method, on the other hand, permit us to"]
    #[doc = "        cleanly abstract pretty much any reasonable underlying"]
    #[doc = "        representation without burdening the iterator"]
    #[doc = "        structure with unnecessary data."]
    #[doc = ""]
    #[doc = "  @note For performance reasons, memorize the \"end\" iterator prior"]
    #[doc = "        to any loop."]
    #[doc = ""]
    #[doc = " @param obj JSON Object instance (MUST be of type json_object)"]
    #[doc = ""]
    #[doc = " @return json_object_iterator On return, the iterator refers"]
    #[doc = "              to the \"end\" of the Object instance's pairs"]
    #[doc = "              (i.e., NOT the last pair, but \"beyond the last"]
    #[doc = "              pair\" value)"]
    pub fn json_object_iter_end(obj: *const json_object) -> json_object_iterator;
}
extern "C" {
    #[doc = " Returns an iterator to the next pair, if any"]
    #[doc = ""]
    #[doc = " @warning\tAny modification of the underlying pair"]
    #[doc = "       \tinvalidates all iterators to that pair."]
    #[doc = ""]
    #[doc = " @param iter [IN/OUT] Pointer to iterator that references a"]
    #[doc = "         name/value pair; MUST be a valid, non-end iterator."]
    #[doc = "         WARNING: bad things will happen if invalid or \"end\""]
    #[doc = "         iterator is passed. Upon return will contain the"]
    #[doc = "         reference to the next pair if there is one; if there"]
    #[doc = "         are no more pairs, will contain the \"end\" iterator"]
    #[doc = "         value, which may be compared against the return value"]
    #[doc = "         of json_object_iter_end() for the same JSON Object"]
    #[doc = "         instance."]
    pub fn json_object_iter_next(iter: *mut json_object_iterator);
}
extern "C" {
    #[doc = " Returns a const pointer to the name of the pair referenced"]
    #[doc = "  by the given iterator."]
    #[doc = ""]
    #[doc = " @param iter pointer to iterator that references a name/value"]
    #[doc = "             pair; MUST be a valid, non-end iterator."]
    #[doc = ""]
    #[doc = " @warning\tbad things will happen if an invalid or"]
    #[doc = "             \t\"end\" iterator is passed."]
    #[doc = ""]
    #[doc = " @return const char* Pointer to the name of the referenced"]
    #[doc = "         name/value pair.  The name memory belongs to the"]
    #[doc = "         name/value pair, will be freed when the pair is"]
    #[doc = "         deleted or modified, and MUST NOT be modified or"]
    #[doc = "         freed by the user."]
    pub fn json_object_iter_peek_name(
        iter: *const json_object_iterator,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a pointer to the json-c instance representing the"]
    #[doc = "  value of the referenced name/value pair, without altering"]
    #[doc = "  the instance's reference count."]
    #[doc = ""]
    #[doc = " @param iter \tpointer to iterator that references a name/value"]
    #[doc = "             \tpair; MUST be a valid, non-end iterator."]
    #[doc = ""]
    #[doc = " @warning\tbad things will happen if invalid or"]
    #[doc = "             \"end\" iterator is passed."]
    #[doc = ""]
    #[doc = " @return struct json_object* Pointer to the json-c value"]
    #[doc = "         instance of the referenced name/value pair;  the"]
    #[doc = "         value's reference count is not changed by this"]
    #[doc = "         function: if you plan to hold on to this json-c node,"]
    #[doc = "         take a look at json_object_get() and"]
    #[doc = "         json_object_put(). IMPORTANT: json-c API represents"]
    #[doc = "         the JSON Null value as a NULL json_object instance"]
    #[doc = "         pointer."]
    pub fn json_object_iter_peek_value(iter: *const json_object_iterator) -> *mut json_object;
}
extern "C" {
    #[doc = " Tests two iterators for equality.  Typically used to test"]
    #[doc = "  for end of iteration by comparing an iterator to the"]
    #[doc = "  corresponding \"end\" iterator (that was derived from the same"]
    #[doc = "  JSON Object instance)."]
    #[doc = ""]
    #[doc = "  @note The reason we do not (and MUST NOT) provide"]
    #[doc = "        \"json_object_iter_is_end(json_object_iterator* iter)\""]
    #[doc = "        type of API is because it would limit the underlying"]
    #[doc = "        representation of name/value containment (or force us"]
    #[doc = "        to add additional, otherwise unnecessary, fields to"]
    #[doc = "        the iterator structure). The equality test method, on"]
    #[doc = "        the other hand, permits us to cleanly abstract pretty"]
    #[doc = "        much any reasonable underlying representation."]
    #[doc = ""]
    #[doc = " @param iter1 Pointer to first valid, non-NULL iterator"]
    #[doc = " @param iter2 POinter to second valid, non-NULL iterator"]
    #[doc = ""]
    #[doc = " @warning\tif a NULL iterator pointer or an uninitialized"]
    #[doc = "       \tor invalid iterator, or iterators derived from"]
    #[doc = "       \tdifferent JSON Object instances are passed, bad things"]
    #[doc = "       \twill happen!"]
    #[doc = ""]
    #[doc = " @return json_bool non-zero if iterators are equal (i.e., both"]
    #[doc = "         reference the same name/value pair or are both at"]
    #[doc = "         \"end\"); zero if they are not equal."]
    pub fn json_object_iter_equal(
        iter1: *const json_object_iterator,
        iter2: *const json_object_iterator,
    ) -> json_bool;
}
extern "C" {
    #[doc = " Retrieves a JSON sub-object from inside another JSON object"]
    #[doc = " using the JSON pointer notation as defined in RFC 6901"]
    #[doc = "   https://tools.ietf.org/html/rfc6901"]
    #[doc = ""]
    #[doc = " The returned JSON sub-object is equivalent to parsing manually the"]
    #[doc = " 'obj' JSON tree ; i.e. it's not a new object that is created, but rather"]
    #[doc = " a pointer inside the JSON tree."]
    #[doc = ""]
    #[doc = " Internally, this is equivalent to doing a series of 'json_object_object_get()'"]
    #[doc = " and 'json_object_array_get_idx()' along the given 'path'."]
    #[doc = ""]
    #[doc = " Note that the 'path' string supports 'printf()' type arguments, so, whatever"]
    #[doc = " is added after the 'res' param will be treated as an argument for 'path'"]
    #[doc = " Example: json_pointer_get(obj, \"/foo/%d/%s\", &res, 0, bar)"]
    #[doc = " This means, that you need to escape '%' with '%%' (just like in printf())"]
    #[doc = ""]
    #[doc = " @param obj the json_object instance/tree from where to retrieve sub-objects"]
    #[doc = " @param path a (RFC6901) string notation for the sub-object to retrieve"]
    #[doc = " @param res a pointer that stores a reference to the json_object"]
    #[doc = "              associated with the given path"]
    #[doc = ""]
    #[doc = " @return negative if an error (or not found), or 0 if succeeded"]
    pub fn json_pointer_get(
        obj: *mut json_object,
        path: *const ::std::os::raw::c_char,
        res: *mut *mut json_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This is a variant of 'json_pointer_get()' that supports printf() style arguments."]
    #[doc = ""]
    #[doc = " Example: json_pointer_getf(obj, res, \"/foo/%d/%s\", 0, bak)"]
    #[doc = " This also means that you need to escape '%' with '%%' (just like in printf())"]
    #[doc = ""]
    #[doc = " Please take into consideration all recommended 'printf()' format security"]
    #[doc = " aspects when using this function."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance/tree to which to add a sub-object"]
    #[doc = " @param res a pointer that stores a reference to the json_object"]
    #[doc = "              associated with the given path"]
    #[doc = " @param path_fmt a printf() style format for the path"]
    #[doc = ""]
    #[doc = " @return negative if an error (or not found), or 0 if succeeded"]
    pub fn json_pointer_getf(
        obj: *mut json_object,
        res: *mut *mut json_object,
        path_fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets JSON object 'value' in the 'obj' tree at the location specified"]
    #[doc = " by the 'path'. 'path' is JSON pointer notation as defined in RFC 6901"]
    #[doc = "   https://tools.ietf.org/html/rfc6901"]
    #[doc = ""]
    #[doc = " Note that 'obj' is a double pointer, mostly for the \"\" (empty string)"]
    #[doc = " case, where the entire JSON object would be replaced by 'value'."]
    #[doc = " In the case of the \"\" path, the object at '*obj' will have it's refcount"]
    #[doc = " decremented with 'json_object_put()' and the 'value' object will be assigned to it."]
    #[doc = ""]
    #[doc = " For other cases (JSON sub-objects) ownership of 'value' will be transferred into"]
    #[doc = " '*obj' via 'json_object_object_add()' & 'json_object_array_put_idx()', so the"]
    #[doc = " only time the refcount should be decremented for 'value' is when the return value of"]
    #[doc = " 'json_pointer_set()' is negative (meaning the 'value' object did not get set into '*obj')."]
    #[doc = ""]
    #[doc = " That also implies that 'json_pointer_set()' does not do any refcount incrementing."]
    #[doc = " (Just that single decrement that was mentioned above)."]
    #[doc = ""]
    #[doc = " Note that the 'path' string supports 'printf()' type arguments, so, whatever"]
    #[doc = " is added after the 'value' param will be treated as an argument for 'path'"]
    #[doc = " Example: json_pointer_set(obj, \"/foo/%d/%s\", value, 0, bak)"]
    #[doc = " This means, that you need to escape '%' with '%%' (just like in printf())"]
    #[doc = ""]
    #[doc = " @param obj the json_object instance/tree to which to add a sub-object"]
    #[doc = " @param path a (RFC6901) string notation for the sub-object to set in the tree"]
    #[doc = " @param value object to set at path"]
    #[doc = ""]
    #[doc = " @return negative if an error (or not found), or 0 if succeeded"]
    pub fn json_pointer_set(
        obj: *mut *mut json_object,
        path: *const ::std::os::raw::c_char,
        value: *mut json_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This is a variant of 'json_pointer_set()' that supports printf() style arguments."]
    #[doc = ""]
    #[doc = " Example: json_pointer_setf(obj, value, \"/foo/%d/%s\", 0, bak)"]
    #[doc = " This also means that you need to escape '%' with '%%' (just like in printf())"]
    #[doc = ""]
    #[doc = " Please take into consideration all recommended 'printf()' format security"]
    #[doc = " aspects when using this function."]
    #[doc = ""]
    #[doc = " @param obj the json_object instance/tree to which to add a sub-object"]
    #[doc = " @param value object to set at path"]
    #[doc = " @param path_fmt a printf() style format for the path"]
    #[doc = ""]
    #[doc = " @return negative if an error (or not found), or 0 if succeeded"]
    pub fn json_pointer_setf(
        obj: *mut *mut json_object,
        value: *mut json_object,
        path_fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const json_tokener_error_json_tokener_success: json_tokener_error = 0;
pub const json_tokener_error_json_tokener_continue: json_tokener_error = 1;
pub const json_tokener_error_json_tokener_error_depth: json_tokener_error = 2;
pub const json_tokener_error_json_tokener_error_parse_eof: json_tokener_error = 3;
pub const json_tokener_error_json_tokener_error_parse_unexpected: json_tokener_error = 4;
pub const json_tokener_error_json_tokener_error_parse_null: json_tokener_error = 5;
pub const json_tokener_error_json_tokener_error_parse_boolean: json_tokener_error = 6;
pub const json_tokener_error_json_tokener_error_parse_number: json_tokener_error = 7;
pub const json_tokener_error_json_tokener_error_parse_array: json_tokener_error = 8;
pub const json_tokener_error_json_tokener_error_parse_object_key_name: json_tokener_error = 9;
pub const json_tokener_error_json_tokener_error_parse_object_key_sep: json_tokener_error = 10;
pub const json_tokener_error_json_tokener_error_parse_object_value_sep: json_tokener_error = 11;
pub const json_tokener_error_json_tokener_error_parse_string: json_tokener_error = 12;
pub const json_tokener_error_json_tokener_error_parse_comment: json_tokener_error = 13;
pub const json_tokener_error_json_tokener_error_parse_utf8_string: json_tokener_error = 14;
pub const json_tokener_error_json_tokener_error_size: json_tokener_error = 15;
pub type json_tokener_error = ::std::os::raw::c_uint;
pub const json_tokener_state_json_tokener_state_eatws: json_tokener_state = 0;
pub const json_tokener_state_json_tokener_state_start: json_tokener_state = 1;
pub const json_tokener_state_json_tokener_state_finish: json_tokener_state = 2;
pub const json_tokener_state_json_tokener_state_null: json_tokener_state = 3;
pub const json_tokener_state_json_tokener_state_comment_start: json_tokener_state = 4;
pub const json_tokener_state_json_tokener_state_comment: json_tokener_state = 5;
pub const json_tokener_state_json_tokener_state_comment_eol: json_tokener_state = 6;
pub const json_tokener_state_json_tokener_state_comment_end: json_tokener_state = 7;
pub const json_tokener_state_json_tokener_state_string: json_tokener_state = 8;
pub const json_tokener_state_json_tokener_state_string_escape: json_tokener_state = 9;
pub const json_tokener_state_json_tokener_state_escape_unicode: json_tokener_state = 10;
pub const json_tokener_state_json_tokener_state_escape_unicode_need_escape: json_tokener_state = 11;
pub const json_tokener_state_json_tokener_state_escape_unicode_need_u: json_tokener_state = 12;
pub const json_tokener_state_json_tokener_state_boolean: json_tokener_state = 13;
pub const json_tokener_state_json_tokener_state_number: json_tokener_state = 14;
pub const json_tokener_state_json_tokener_state_array: json_tokener_state = 15;
pub const json_tokener_state_json_tokener_state_array_add: json_tokener_state = 16;
pub const json_tokener_state_json_tokener_state_array_sep: json_tokener_state = 17;
pub const json_tokener_state_json_tokener_state_object_field_start: json_tokener_state = 18;
pub const json_tokener_state_json_tokener_state_object_field: json_tokener_state = 19;
pub const json_tokener_state_json_tokener_state_object_field_end: json_tokener_state = 20;
pub const json_tokener_state_json_tokener_state_object_value: json_tokener_state = 21;
pub const json_tokener_state_json_tokener_state_object_value_add: json_tokener_state = 22;
pub const json_tokener_state_json_tokener_state_object_sep: json_tokener_state = 23;
pub const json_tokener_state_json_tokener_state_array_after_sep: json_tokener_state = 24;
pub const json_tokener_state_json_tokener_state_object_field_start_after_sep: json_tokener_state =
    25;
pub const json_tokener_state_json_tokener_state_inf: json_tokener_state = 26;
#[doc = " @deprecated Don't use this outside of json_tokener.c, it will be made private in a future release."]
pub type json_tokener_state = ::std::os::raw::c_uint;
#[doc = " @deprecated Don't use this outside of json_tokener.c, it will be made private in a future release."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct json_tokener_srec {
    pub state: json_tokener_state,
    pub saved_state: json_tokener_state,
    pub obj: *mut json_object,
    pub current: *mut json_object,
    pub obj_field_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_json_tokener_srec() {
    assert_eq!(
        ::std::mem::size_of::<json_tokener_srec>(),
        32usize,
        concat!("Size of: ", stringify!(json_tokener_srec))
    );
    assert_eq!(
        ::std::mem::align_of::<json_tokener_srec>(),
        8usize,
        concat!("Alignment of ", stringify!(json_tokener_srec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener_srec>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener_srec),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener_srec>())).saved_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener_srec),
            "::",
            stringify!(saved_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener_srec>())).obj as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener_srec),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener_srec>())).current as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener_srec),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<json_tokener_srec>())).obj_field_name as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener_srec),
            "::",
            stringify!(obj_field_name)
        )
    );
}
#[doc = " Internal state of the json parser."]
#[doc = " Do not access any fields of this structure directly."]
#[doc = " Its definition is published due to historical limitations"]
#[doc = " in the json tokener API, and will be changed to be an opaque"]
#[doc = " type in the future."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct json_tokener {
    #[doc = " @deprecated Do not access any of these fields outside of json_tokener.c"]
    pub str_: *mut ::std::os::raw::c_char,
    pub pb: *mut printbuf,
    pub max_depth: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub is_double: ::std::os::raw::c_int,
    pub st_pos: ::std::os::raw::c_int,
    #[doc = " @deprecated See json_tokener_get_parse_end() instead."]
    pub char_offset: ::std::os::raw::c_int,
    #[doc = " @deprecated See json_tokener_get_error() instead."]
    pub err: json_tokener_error,
    pub ucs_char: ::std::os::raw::c_uint,
    pub high_surrogate: ::std::os::raw::c_uint,
    pub quote_char: ::std::os::raw::c_char,
    pub stack: *mut json_tokener_srec,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_json_tokener() {
    assert_eq!(
        ::std::mem::size_of::<json_tokener>(),
        72usize,
        concat!("Size of: ", stringify!(json_tokener))
    );
    assert_eq!(
        ::std::mem::align_of::<json_tokener>(),
        8usize,
        concat!("Alignment of ", stringify!(json_tokener))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).pb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(pb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).max_depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(max_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).is_double as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(is_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).st_pos as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(st_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).char_offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(char_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).err as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).ucs_char as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(ucs_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).high_surrogate as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(high_surrogate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).quote_char as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(quote_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).stack as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<json_tokener>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(json_tokener),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Return the offset of the byte after the last byte parsed"]
    #[doc = " relative to the start of the most recent string passed in"]
    #[doc = " to json_tokener_parse_ex().  i.e. this is where parsing"]
    #[doc = " would start again if the input contains another JSON object"]
    #[doc = " after the currently parsed one."]
    #[doc = ""]
    #[doc = " Note that when multiple parse calls are issued, this is *not* the"]
    #[doc = " total number of characters parsed."]
    #[doc = ""]
    #[doc = " In the past this would have been accessed as tok->char_offset."]
    #[doc = ""]
    #[doc = " See json_tokener_parse_ex() for an example of how to use this."]
    pub fn json_tokener_get_parse_end(tok: *mut json_tokener) -> size_t;
}
extern "C" {
    #[doc = " Given an error previously returned by json_tokener_get_error(),"]
    #[doc = " return a human readable description of the error."]
    #[doc = ""]
    #[doc = " @return a generic error message is returned if an invalid error value is provided."]
    pub fn json_tokener_error_desc(jerr: json_tokener_error) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retrieve the error caused by the last call to json_tokener_parse_ex(),"]
    #[doc = " or json_tokener_success if there is no error."]
    #[doc = ""]
    #[doc = " When parsing a JSON string in pieces, if the tokener is in the middle"]
    #[doc = " of parsing this will return json_tokener_continue."]
    #[doc = ""]
    #[doc = " @see json_tokener_error_desc()."]
    pub fn json_tokener_get_error(tok: *mut json_tokener) -> json_tokener_error;
}
extern "C" {
    #[doc = " Allocate a new json_tokener."]
    #[doc = " When done using that to parse objects, free it with json_tokener_free()."]
    #[doc = " See json_tokener_parse_ex() for usage details."]
    pub fn json_tokener_new() -> *mut json_tokener;
}
extern "C" {
    #[doc = " Allocate a new json_tokener with a custom max nesting depth."]
    #[doc = " @see JSON_TOKENER_DEFAULT_DEPTH"]
    pub fn json_tokener_new_ex(depth: ::std::os::raw::c_int) -> *mut json_tokener;
}
extern "C" {
    #[doc = " Free a json_tokener previously allocated with json_tokener_new()."]
    pub fn json_tokener_free(tok: *mut json_tokener);
}
extern "C" {
    #[doc = " Reset the state of a json_tokener, to prepare to parse a"]
    #[doc = " brand new JSON object."]
    pub fn json_tokener_reset(tok: *mut json_tokener);
}
extern "C" {
    #[doc = " Parse a json_object out of the string `str`."]
    #[doc = ""]
    #[doc = " If you need more control over how the parsing occurs,"]
    #[doc = " see json_tokener_parse_ex()."]
    pub fn json_tokener_parse(str_: *const ::std::os::raw::c_char) -> *mut json_object;
}
extern "C" {
    #[doc = " Parser a json_object out of the string `str`, but if it fails"]
    #[doc = " return the error in `*error`."]
    #[doc = " @see json_tokener_parse()"]
    #[doc = " @see json_tokener_parse_ex()"]
    pub fn json_tokener_parse_verbose(
        str_: *const ::std::os::raw::c_char,
        error: *mut json_tokener_error,
    ) -> *mut json_object;
}
extern "C" {
    #[doc = " Set flags that control how parsing will be done."]
    pub fn json_tokener_set_flags(tok: *mut json_tokener, flags: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Parse a string and return a non-NULL json_object if a valid JSON value"]
    #[doc = " is found.  The string does not need to be a JSON object or array;"]
    #[doc = " it can also be a string, number or boolean value."]
    #[doc = ""]
    #[doc = " A partial JSON string can be parsed.  If the parsing is incomplete,"]
    #[doc = " NULL will be returned and json_tokener_get_error() will return"]
    #[doc = " json_tokener_continue."]
    #[doc = " json_tokener_parse_ex() can then be called with additional bytes in str"]
    #[doc = " to continue the parsing."]
    #[doc = ""]
    #[doc = " If json_tokener_parse_ex() returns NULL and the error is anything other than"]
    #[doc = " json_tokener_continue, a fatal error has occurred and parsing must be"]
    #[doc = " halted.  Then, the tok object must not be reused until json_tokener_reset()"]
    #[doc = " is called."]
    #[doc = ""]
    #[doc = " When a valid JSON value is parsed, a non-NULL json_object will be"]
    #[doc = " returned, with a reference count of one which belongs to the caller.  Also,"]
    #[doc = " json_tokener_get_error() will return json_tokener_success. Be sure to check"]
    #[doc = " the type with json_object_is_type() or json_object_get_type() before using"]
    #[doc = " the object."]
    #[doc = ""]
    #[doc = " Trailing characters after the parsed value do not automatically cause an"]
    #[doc = " error.  It is up to the caller to decide whether to treat this as an"]
    #[doc = " error or to handle the additional characters, perhaps by parsing another"]
    #[doc = " json value starting from that point."]
    #[doc = ""]
    #[doc = " If the caller knows that they are at the end of their input, the length"]
    #[doc = " passed MUST include the final '\\0' character, so values with no inherent"]
    #[doc = " end (i.e. numbers) can be properly parsed, rather than just returning"]
    #[doc = " json_tokener_continue."]
    #[doc = ""]
    #[doc = " Extra characters can be detected by comparing the value returned by"]
    #[doc = " json_tokener_get_parse_end() against"]
    #[doc = " the length of the last len parameter passed in."]
    #[doc = ""]
    #[doc = " The tokener does \\b not maintain an internal buffer so the caller is"]
    #[doc = " responsible for a subsequent call to json_tokener_parse_ex with an"]
    #[doc = " appropriate str parameter starting with the extra characters."]
    #[doc = ""]
    #[doc = " This interface is presently not 64-bit clean due to the int len argument"]
    #[doc = " so the function limits the maximum string size to INT32_MAX (2GB)."]
    #[doc = " If the function is called with len == -1 then strlen is called to check"]
    #[doc = " the string length is less than INT32_MAX (2GB)"]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = " @code"]
    #[doc = "json_object *jobj = NULL;"]
    #[doc = "const char *mystring = NULL;"]
    #[doc = "int stringlen = 0;"]
    #[doc = "enum json_tokener_error jerr;"]
    #[doc = "do {"]
    #[doc = "mystring = ...  // get JSON string, e.g. read from file, etc..."]
    #[doc = "stringlen = strlen(mystring);"]
    #[doc = "if (end_of_input)"]
    #[doc = "stringlen++;  // Include the '\\0' if we know we're at the end of input"]
    #[doc = "jobj = json_tokener_parse_ex(tok, mystring, stringlen);"]
    #[doc = "} while ((jerr = json_tokener_get_error(tok)) == json_tokener_continue);"]
    #[doc = "if (jerr != json_tokener_success)"]
    #[doc = "{"]
    #[doc = "fprintf(stderr, \"Error: %s\\n\", json_tokener_error_desc(jerr));"]
    #[doc = "}"]
    #[doc = "if (json_tokener_get_parse_end(tok) < stringlen)"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = " @param tok a json_tokener previously allocated with json_tokener_new()"]
    #[doc = " @param str an string with any valid JSON expression, or portion of.  This does not need to be null terminated."]
    #[doc = " @param len the length of str"]
    pub fn json_tokener_parse_ex(
        tok: *mut json_tokener,
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut json_object;
}
extern "C" {
    #[doc = " Read the full contents of the given file, then convert it to a"]
    #[doc = " json_object using json_tokener_parse()."]
    #[doc = ""]
    #[doc = " Returns NULL on failure.  See json_util_get_last_err() for details."]
    pub fn json_object_from_file(filename: *const ::std::os::raw::c_char) -> *mut json_object;
}
extern "C" {
    #[doc = " Create a JSON object from already opened file descriptor."]
    #[doc = ""]
    #[doc = " This function can be helpful, when you opened the file already,"]
    #[doc = " e.g. when you have a temp file."]
    #[doc = " Note, that the fd must be readable at the actual position, i.e."]
    #[doc = " use lseek(fd, 0, SEEK_SET) before."]
    #[doc = ""]
    #[doc = " The depth argument specifies the maximum object depth to pass to"]
    #[doc = " json_tokener_new_ex().  When depth == -1, JSON_TOKENER_DEFAULT_DEPTH"]
    #[doc = " is used instead."]
    #[doc = ""]
    #[doc = " Returns NULL on failure.  See json_util_get_last_err() for details."]
    pub fn json_object_from_fd_ex(
        fd: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
    ) -> *mut json_object;
}
extern "C" {
    #[doc = " Create a JSON object from an already opened file descriptor, using"]
    #[doc = " the default maximum object depth. (JSON_TOKENER_DEFAULT_DEPTH)"]
    #[doc = ""]
    #[doc = " See json_object_from_fd_ex() for details."]
    pub fn json_object_from_fd(fd: ::std::os::raw::c_int) -> *mut json_object;
}
extern "C" {
    #[doc = " Equivalent to:"]
    #[doc = "   json_object_to_file_ext(filename, obj, JSON_C_TO_STRING_PLAIN);"]
    #[doc = ""]
    #[doc = " Returns -1 if something fails.  See json_util_get_last_err() for details."]
    pub fn json_object_to_file(
        filename: *const ::std::os::raw::c_char,
        obj: *mut json_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open and truncate the given file, creating it if necessary, then"]
    #[doc = " convert the json_object to a string and write it to the file."]
    #[doc = ""]
    #[doc = " Returns -1 if something fails.  See json_util_get_last_err() for details."]
    pub fn json_object_to_file_ext(
        filename: *const ::std::os::raw::c_char,
        obj: *mut json_object,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert the json_object to a string and write it to the file descriptor."]
    #[doc = " Handles partial writes and will keep writing until done, or an error"]
    #[doc = " occurs."]
    #[doc = ""]
    #[doc = " @param fd an open, writable file descriptor to write to"]
    #[doc = " @param obj the object to serializer and write"]
    #[doc = " @param flags flags to pass to json_object_to_json_string_ext()"]
    #[doc = " @return -1 if something fails.  See json_util_get_last_err() for details."]
    pub fn json_object_to_fd(
        fd: ::std::os::raw::c_int,
        obj: *mut json_object,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the last error from various json-c functions, including:"]
    #[doc = " json_object_to_file{,_ext}, json_object_to_fd() or"]
    #[doc = " json_object_from_{file,fd}, or NULL if there is none."]
    pub fn json_util_get_last_err() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn json_parse_int64(
        buf: *const ::std::os::raw::c_char,
        retval: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn json_parse_uint64(
        buf: *const ::std::os::raw::c_char,
        retval: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @deprecated"]
    pub fn json_parse_double(
        buf: *const ::std::os::raw::c_char,
        retval: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a string describing the type of the object."]
    #[doc = " e.g. \"int\", or \"object\", etc..."]
    pub fn json_type_to_name(o_type: json_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function sets the hash function to be used for strings."]
    #[doc = " Must be one of the JSON_C_STR_HASH_* values."]
    #[doc = " @returns 0 - ok, -1 if parameter was invalid"]
    pub fn json_global_set_string_hash(h: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " callback function prototypes"]
pub type lh_entry_free_fn = ::std::option::Option<unsafe extern "C" fn(e: *mut lh_entry)>;
#[doc = " callback function prototypes"]
pub type lh_hash_fn = ::std::option::Option<
    unsafe extern "C" fn(k: *const ::std::os::raw::c_void) -> ::std::os::raw::c_ulong,
>;
#[doc = " callback function prototypes"]
pub type lh_equal_fn = ::std::option::Option<
    unsafe extern "C" fn(
        k1: *const ::std::os::raw::c_void,
        k2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " An entry in the hash table.  Outside of linkhash.c, treat this as opaque."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lh_entry {
    #[doc = " The key."]
    #[doc = " @deprecated Use lh_entry_k() instead of accessing this directly."]
    pub k: *const ::std::os::raw::c_void,
    #[doc = " A flag for users of linkhash to know whether or not they"]
    #[doc = " need to free k."]
    #[doc = " @deprecated use lh_entry_k_is_constant() instead."]
    pub k_is_constant: ::std::os::raw::c_int,
    #[doc = " The value."]
    #[doc = " @deprecated Use lh_entry_v() instead of accessing this directly."]
    pub v: *const ::std::os::raw::c_void,
    #[doc = " The next entry."]
    #[doc = " @deprecated Use lh_entry_next() instead of accessing this directly."]
    pub next: *mut lh_entry,
    #[doc = " The previous entry."]
    #[doc = " @deprecated Use lh_entry_prev() instead of accessing this directly."]
    pub prev: *mut lh_entry,
}
#[test]
fn bindgen_test_layout_lh_entry() {
    assert_eq!(
        ::std::mem::size_of::<lh_entry>(),
        40usize,
        concat!("Size of: ", stringify!(lh_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<lh_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(lh_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_entry>())).k as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_entry),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_entry>())).k_is_constant as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_entry),
            "::",
            stringify!(k_is_constant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_entry>())).v as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_entry),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_entry>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_entry),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_entry>())).prev as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_entry),
            "::",
            stringify!(prev)
        )
    );
}
#[doc = " The hash table structure.  Outside of linkhash.c, treat this as opaque."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lh_table {
    #[doc = " Size of our hash."]
    #[doc = " @deprecated do not use outside of linkhash.c"]
    pub size: ::std::os::raw::c_int,
    #[doc = " Numbers of entries."]
    #[doc = " @deprecated Use lh_table_length() instead."]
    pub count: ::std::os::raw::c_int,
    #[doc = " The first entry."]
    #[doc = " @deprecated Use lh_table_head() instead."]
    pub head: *mut lh_entry,
    #[doc = " The last entry."]
    #[doc = " @deprecated Do not use, may be removed in a future release."]
    pub tail: *mut lh_entry,
    #[doc = " Internal storage of the actual table of entries."]
    #[doc = " @deprecated do not use outside of linkhash.c"]
    pub table: *mut lh_entry,
    #[doc = " A pointer to the function responsible for freeing an entry."]
    #[doc = " @deprecated do not use outside of linkhash.c"]
    pub free_fn: lh_entry_free_fn,
    #[doc = " @deprecated do not use outside of linkhash.c"]
    pub hash_fn: lh_hash_fn,
    #[doc = " @deprecated do not use outside of linkhash.c"]
    pub equal_fn: lh_equal_fn,
}
#[test]
fn bindgen_test_layout_lh_table() {
    assert_eq!(
        ::std::mem::size_of::<lh_table>(),
        56usize,
        concat!("Size of: ", stringify!(lh_table))
    );
    assert_eq!(
        ::std::mem::align_of::<lh_table>(),
        8usize,
        concat!("Alignment of ", stringify!(lh_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_table>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_table),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_table>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_table),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_table>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_table),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_table>())).tail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_table),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_table>())).table as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_table),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_table>())).free_fn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_table),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_table>())).hash_fn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_table),
            "::",
            stringify!(hash_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lh_table>())).equal_fn as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lh_table),
            "::",
            stringify!(equal_fn)
        )
    );
}
extern "C" {
    #[doc = " Create a new linkhash table."]
    #[doc = ""]
    #[doc = " @param size initial table size. The table is automatically resized"]
    #[doc = " although this incurs a performance penalty."]
    #[doc = " @param free_fn callback function used to free memory for entries"]
    #[doc = " when lh_table_free or lh_table_delete is called."]
    #[doc = " If NULL is provided, then memory for keys and values"]
    #[doc = " must be freed by the caller."]
    #[doc = " @param hash_fn  function used to hash keys. 2 standard ones are defined:"]
    #[doc = " lh_ptr_hash and lh_char_hash for hashing pointer values"]
    #[doc = " and C strings respectively."]
    #[doc = " @param equal_fn comparison function to compare keys. 2 standard ones defined:"]
    #[doc = " lh_ptr_hash and lh_char_hash for comparing pointer values"]
    #[doc = " and C strings respectively."]
    #[doc = " @return On success, a pointer to the new linkhash table is returned."]
    #[doc = " \tOn error, a null pointer is returned."]
    pub fn lh_table_new(
        size: ::std::os::raw::c_int,
        free_fn: lh_entry_free_fn,
        hash_fn: lh_hash_fn,
        equal_fn: lh_equal_fn,
    ) -> *mut lh_table;
}
extern "C" {
    #[doc = " Convenience function to create a new linkhash table with char keys."]
    #[doc = ""]
    #[doc = " @param size initial table size."]
    #[doc = " @param free_fn callback function used to free memory for entries."]
    #[doc = " @return On success, a pointer to the new linkhash table is returned."]
    #[doc = " \tOn error, a null pointer is returned."]
    pub fn lh_kchar_table_new(
        size: ::std::os::raw::c_int,
        free_fn: lh_entry_free_fn,
    ) -> *mut lh_table;
}
extern "C" {
    #[doc = " Convenience function to create a new linkhash table with ptr keys."]
    #[doc = ""]
    #[doc = " @param size initial table size."]
    #[doc = " @param free_fn callback function used to free memory for entries."]
    #[doc = " @return On success, a pointer to the new linkhash table is returned."]
    #[doc = " \tOn error, a null pointer is returned."]
    pub fn lh_kptr_table_new(
        size: ::std::os::raw::c_int,
        free_fn: lh_entry_free_fn,
    ) -> *mut lh_table;
}
extern "C" {
    #[doc = " Free a linkhash table."]
    #[doc = ""]
    #[doc = " If a lh_entry_free_fn callback free function was provided then it is"]
    #[doc = " called for all entries in the table."]
    #[doc = ""]
    #[doc = " @param t table to free."]
    pub fn lh_table_free(t: *mut lh_table);
}
extern "C" {
    #[doc = " Insert a record into the table."]
    #[doc = ""]
    #[doc = " @param t the table to insert into."]
    #[doc = " @param k a pointer to the key to insert."]
    #[doc = " @param v a pointer to the value to insert."]
    #[doc = ""]
    #[doc = " @return On success, <code>0</code> is returned."]
    #[doc = " \tOn error, a negative value is returned."]
    pub fn lh_table_insert(
        t: *mut lh_table,
        k: *const ::std::os::raw::c_void,
        v: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Insert a record into the table using a precalculated key hash."]
    #[doc = ""]
    #[doc = " The hash h, which should be calculated with lh_get_hash() on k, is provided by"]
    #[doc = "  the caller, to allow for optimization when multiple operations with the same"]
    #[doc = "  key are known to be needed."]
    #[doc = ""]
    #[doc = " @param t the table to insert into."]
    #[doc = " @param k a pointer to the key to insert."]
    #[doc = " @param v a pointer to the value to insert."]
    #[doc = " @param h hash value of the key to insert"]
    #[doc = " @param opts if set to JSON_C_OBJECT_ADD_CONSTANT_KEY, sets lh_entry.k_is_constant"]
    #[doc = "             so t's free function knows to avoid freeing the key."]
    pub fn lh_table_insert_w_hash(
        t: *mut lh_table,
        k: *const ::std::os::raw::c_void,
        v: *const ::std::os::raw::c_void,
        h: ::std::os::raw::c_ulong,
        opts: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup a record in the table."]
    #[doc = ""]
    #[doc = " @param t the table to lookup"]
    #[doc = " @param k a pointer to the key to lookup"]
    #[doc = " @return a pointer to the record structure of the value or NULL if it does not exist."]
    pub fn lh_table_lookup_entry(
        t: *mut lh_table,
        k: *const ::std::os::raw::c_void,
    ) -> *mut lh_entry;
}
extern "C" {
    #[doc = " Lookup a record in the table using a precalculated key hash."]
    #[doc = ""]
    #[doc = " The hash h, which should be calculated with lh_get_hash() on k, is provided by"]
    #[doc = "  the caller, to allow for optimization when multiple operations with the same"]
    #[doc = "  key are known to be needed."]
    #[doc = ""]
    #[doc = " @param t the table to lookup"]
    #[doc = " @param k a pointer to the key to lookup"]
    #[doc = " @param h hash value of the key to lookup"]
    #[doc = " @return a pointer to the record structure of the value or NULL if it does not exist."]
    pub fn lh_table_lookup_entry_w_hash(
        t: *mut lh_table,
        k: *const ::std::os::raw::c_void,
        h: ::std::os::raw::c_ulong,
    ) -> *mut lh_entry;
}
extern "C" {
    #[doc = " Lookup a record in the table."]
    #[doc = ""]
    #[doc = " @param t the table to lookup"]
    #[doc = " @param k a pointer to the key to lookup"]
    #[doc = " @param v a pointer to a where to store the found value (set to NULL if it doesn't exist)."]
    #[doc = " @return whether or not the key was found"]
    pub fn lh_table_lookup_ex(
        t: *mut lh_table,
        k: *const ::std::os::raw::c_void,
        v: *mut *mut ::std::os::raw::c_void,
    ) -> json_bool;
}
extern "C" {
    #[doc = " Delete a record from the table."]
    #[doc = ""]
    #[doc = " If a callback free function is provided then it is called for the"]
    #[doc = " for the item being deleted."]
    #[doc = " @param t the table to delete from."]
    #[doc = " @param e a pointer to the entry to delete."]
    #[doc = " @return 0 if the item was deleted."]
    #[doc = " @return -1 if it was not found."]
    pub fn lh_table_delete_entry(t: *mut lh_table, e: *mut lh_entry) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a record from the table."]
    #[doc = ""]
    #[doc = " If a callback free function is provided then it is called for the"]
    #[doc = " for the item being deleted."]
    #[doc = " @param t the table to delete from."]
    #[doc = " @param k a pointer to the key to delete."]
    #[doc = " @return 0 if the item was deleted."]
    #[doc = " @return -1 if it was not found."]
    pub fn lh_table_delete(
        t: *mut lh_table,
        k: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of entries in the table."]
    pub fn lh_table_length(t: *mut lh_table) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resizes the specified table."]
    #[doc = ""]
    #[doc = " @param t Pointer to table to resize."]
    #[doc = " @param new_size New table size. Must be positive."]
    #[doc = ""]
    #[doc = " @return On success, <code>0</code> is returned."]
    #[doc = " \tOn error, a negative value is returned."]
    pub fn lh_table_resize(
        t: *mut lh_table,
        new_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type z_size_t = size_t;
pub type Byte = ::std::os::raw::c_uchar;
pub type uInt = ::std::os::raw::c_uint;
pub type uLong = ::std::os::raw::c_ulong;
pub type Bytef = Byte;
pub type charf = ::std::os::raw::c_char;
pub type intf = ::std::os::raw::c_int;
pub type uIntf = uInt;
pub type uLongf = uLong;
pub type voidpc = *const ::std::os::raw::c_void;
pub type voidpf = *mut ::std::os::raw::c_void;
pub type voidp = *mut ::std::os::raw::c_void;
pub type z_crc_t = ::std::os::raw::c_uint;
pub type alloc_func =
    ::std::option::Option<unsafe extern "C" fn(opaque: voidpf, items: uInt, size: uInt) -> voidpf>;
pub type free_func = ::std::option::Option<unsafe extern "C" fn(opaque: voidpf, address: voidpf)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct internal_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_stream_s {
    pub next_in: *mut Bytef,
    pub avail_in: uInt,
    pub total_in: uLong,
    pub next_out: *mut Bytef,
    pub avail_out: uInt,
    pub total_out: uLong,
    pub msg: *mut ::std::os::raw::c_char,
    pub state: *mut internal_state,
    pub zalloc: alloc_func,
    pub zfree: free_func,
    pub opaque: voidpf,
    pub data_type: ::std::os::raw::c_int,
    pub adler: uLong,
    pub reserved: uLong,
}
#[test]
fn bindgen_test_layout_z_stream_s() {
    assert_eq!(
        ::std::mem::size_of::<z_stream_s>(),
        112usize,
        concat!("Size of: ", stringify!(z_stream_s))
    );
    assert_eq!(
        ::std::mem::align_of::<z_stream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(z_stream_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).next_in as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(next_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).avail_in as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(avail_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).total_in as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(total_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).next_out as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(next_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).avail_out as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(avail_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).total_out as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(total_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).msg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).zalloc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(zalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).zfree as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(zfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).opaque as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).data_type as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).adler as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(adler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<z_stream_s>())).reserved as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(reserved)
        )
    );
}
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gz_header_s {
    pub text: ::std::os::raw::c_int,
    pub time: uLong,
    pub xflags: ::std::os::raw::c_int,
    pub os: ::std::os::raw::c_int,
    pub extra: *mut Bytef,
    pub extra_len: uInt,
    pub extra_max: uInt,
    pub name: *mut Bytef,
    pub name_max: uInt,
    pub comment: *mut Bytef,
    pub comm_max: uInt,
    pub hcrc: ::std::os::raw::c_int,
    pub done: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_gz_header_s() {
    assert_eq!(
        ::std::mem::size_of::<gz_header_s>(),
        80usize,
        concat!("Size of: ", stringify!(gz_header_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gz_header_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gz_header_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).text as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).xflags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(xflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).os as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(os)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).extra as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).extra_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(extra_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).extra_max as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(extra_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).name_max as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(name_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).comment as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).comm_max as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(comm_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).hcrc as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(hcrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gz_header_s>())).done as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(done)
        )
    );
}
pub type gz_header = gz_header_s;
pub type gz_headerp = *mut gz_header;
extern "C" {
    pub fn zlibVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn deflate(strm: z_streamp, flush: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateEnd(strm: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflate(strm: z_streamp, flush: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateEnd(strm: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateSetDictionary(
        strm: z_streamp,
        dictionary: *const Bytef,
        dictLength: uInt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateGetDictionary(
        strm: z_streamp,
        dictionary: *mut Bytef,
        dictLength: *mut uInt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateCopy(dest: z_streamp, source: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateReset(strm: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateParams(
        strm: z_streamp,
        level: ::std::os::raw::c_int,
        strategy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateTune(
        strm: z_streamp,
        good_length: ::std::os::raw::c_int,
        max_lazy: ::std::os::raw::c_int,
        nice_length: ::std::os::raw::c_int,
        max_chain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateBound(strm: z_streamp, sourceLen: uLong) -> uLong;
}
extern "C" {
    pub fn deflatePending(
        strm: z_streamp,
        pending: *mut ::std::os::raw::c_uint,
        bits: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflatePrime(
        strm: z_streamp,
        bits: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateSetHeader(strm: z_streamp, head: gz_headerp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateSetDictionary(
        strm: z_streamp,
        dictionary: *const Bytef,
        dictLength: uInt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateGetDictionary(
        strm: z_streamp,
        dictionary: *mut Bytef,
        dictLength: *mut uInt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateSync(strm: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateCopy(dest: z_streamp, source: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateReset(strm: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateReset2(
        strm: z_streamp,
        windowBits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflatePrime(
        strm: z_streamp,
        bits: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateMark(strm: z_streamp) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn inflateGetHeader(strm: z_streamp, head: gz_headerp) -> ::std::os::raw::c_int;
}
pub type in_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_uint,
>;
pub type out_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn inflateBack(
        strm: z_streamp,
        in_: in_func,
        in_desc: *mut ::std::os::raw::c_void,
        out: out_func,
        out_desc: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateBackEnd(strm: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zlibCompileFlags() -> uLong;
}
extern "C" {
    pub fn compress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn compress2(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn compressBound(sourceLen: uLong) -> uLong;
}
extern "C" {
    pub fn uncompress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uncompress2(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: *mut uLong,
    ) -> ::std::os::raw::c_int;
}
pub type gzFile = *mut gzFile_s;
extern "C" {
    pub fn gzdopen(fd: ::std::os::raw::c_int, mode: *const ::std::os::raw::c_char) -> gzFile;
}
extern "C" {
    pub fn gzbuffer(file: gzFile, size: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzsetparams(
        file: gzFile,
        level: ::std::os::raw::c_int,
        strategy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzread(file: gzFile, buf: voidp, len: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzfread(buf: voidp, size: z_size_t, nitems: z_size_t, file: gzFile) -> z_size_t;
}
extern "C" {
    pub fn gzwrite(file: gzFile, buf: voidpc, len: ::std::os::raw::c_uint)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzfwrite(buf: voidpc, size: z_size_t, nitems: z_size_t, file: gzFile) -> z_size_t;
}
extern "C" {
    pub fn gzprintf(
        file: gzFile,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzputs(file: gzFile, s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzgets(
        file: gzFile,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gzputc(file: gzFile, c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzgetc(file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzungetc(c: ::std::os::raw::c_int, file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzflush(file: gzFile, flush: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzrewind(file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzeof(file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzdirect(file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzclose(file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzclose_r(file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzclose_w(file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzerror(
        file: gzFile,
        errnum: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gzclearerr(file: gzFile);
}
extern "C" {
    pub fn adler32(adler: uLong, buf: *const Bytef, len: uInt) -> uLong;
}
extern "C" {
    pub fn adler32_z(adler: uLong, buf: *const Bytef, len: z_size_t) -> uLong;
}
extern "C" {
    pub fn crc32(crc: uLong, buf: *const Bytef, len: uInt) -> uLong;
}
extern "C" {
    pub fn crc32_z(crc: uLong, buf: *const Bytef, len: z_size_t) -> uLong;
}
extern "C" {
    pub fn crc32_combine_op(crc1: uLong, crc2: uLong, op: uLong) -> uLong;
}
extern "C" {
    pub fn deflateInit_(
        strm: z_streamp,
        level: ::std::os::raw::c_int,
        version: *const ::std::os::raw::c_char,
        stream_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateInit_(
        strm: z_streamp,
        version: *const ::std::os::raw::c_char,
        stream_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateInit2_(
        strm: z_streamp,
        level: ::std::os::raw::c_int,
        method: ::std::os::raw::c_int,
        windowBits: ::std::os::raw::c_int,
        memLevel: ::std::os::raw::c_int,
        strategy: ::std::os::raw::c_int,
        version: *const ::std::os::raw::c_char,
        stream_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateInit2_(
        strm: z_streamp,
        windowBits: ::std::os::raw::c_int,
        version: *const ::std::os::raw::c_char,
        stream_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateBackInit_(
        strm: z_streamp,
        windowBits: ::std::os::raw::c_int,
        window: *mut ::std::os::raw::c_uchar,
        version: *const ::std::os::raw::c_char,
        stream_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gzFile_s {
    pub have: ::std::os::raw::c_uint,
    pub next: *mut ::std::os::raw::c_uchar,
    pub pos: off_t,
}
#[test]
fn bindgen_test_layout_gzFile_s() {
    assert_eq!(
        ::std::mem::size_of::<gzFile_s>(),
        24usize,
        concat!("Size of: ", stringify!(gzFile_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gzFile_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gzFile_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gzFile_s>())).have as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gzFile_s),
            "::",
            stringify!(have)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gzFile_s>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gzFile_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gzFile_s>())).pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gzFile_s),
            "::",
            stringify!(pos)
        )
    );
}
extern "C" {
    pub fn gzgetc_(file: gzFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> gzFile;
}
extern "C" {
    pub fn gzseek(arg1: gzFile, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn gztell(arg1: gzFile) -> off_t;
}
extern "C" {
    pub fn gzoffset(arg1: gzFile) -> off_t;
}
extern "C" {
    pub fn adler32_combine(arg1: uLong, arg2: uLong, arg3: off_t) -> uLong;
}
extern "C" {
    pub fn crc32_combine(arg1: uLong, arg2: uLong, arg3: off_t) -> uLong;
}
extern "C" {
    pub fn crc32_combine_gen(arg1: off_t) -> uLong;
}
extern "C" {
    pub fn zError(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn inflateSyncPoint(arg1: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_crc_table() -> *const z_crc_t;
}
extern "C" {
    pub fn inflateUndermine(arg1: z_streamp, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateValidate(arg1: z_streamp, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inflateCodesUsed(arg1: z_streamp) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn inflateResetKeep(arg1: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn deflateResetKeep(arg1: z_streamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gzvprintf(
        file: gzFile,
        format: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_dbio {
    pub gzs: gzFile,
    pub fs: *mut FILE,
    pub size: ::std::os::raw::c_uint,
    pub bread: ::std::os::raw::c_uint,
    pub buf: *mut ::std::os::raw::c_char,
    pub bufpt: *mut ::std::os::raw::c_char,
    pub readpt: *mut ::std::os::raw::c_char,
    pub usebuf: ::std::os::raw::c_uint,
    pub bufsize: ::std::os::raw::c_uint,
    pub readsize: ::std::os::raw::c_uint,
    pub chkonly: ::std::os::raw::c_uint,
    pub hashctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cli_dbio() {
    assert_eq!(
        ::std::mem::size_of::<cli_dbio>(),
        72usize,
        concat!("Size of: ", stringify!(cli_dbio))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_dbio>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_dbio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).gzs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(gzs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).fs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).bread as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(bread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).bufpt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(bufpt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).readpt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(readpt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).usebuf as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(usebuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).bufsize as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(bufsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).readsize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(readsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).chkonly as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(chkonly)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbio>())).hashctx as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbio),
            "::",
            stringify!(hashctx)
        )
    );
}
extern "C" {
    pub fn cli_cvdload(
        fs: *mut FILE,
        engine: *mut cl_engine,
        signo: *mut ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
        dbtype: ::std::os::raw::c_uint,
        filename: *const ::std::os::raw::c_char,
        chkonly: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_cvdunpack(
        file: *const ::std::os::raw::c_char,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const _ISupper: ::std::os::raw::c_uint = 256;
pub const _ISlower: ::std::os::raw::c_uint = 512;
pub const _ISalpha: ::std::os::raw::c_uint = 1024;
pub const _ISdigit: ::std::os::raw::c_uint = 2048;
pub const _ISxdigit: ::std::os::raw::c_uint = 4096;
pub const _ISspace: ::std::os::raw::c_uint = 8192;
pub const _ISprint: ::std::os::raw::c_uint = 16384;
pub const _ISgraph: ::std::os::raw::c_uint = 32768;
pub const _ISblank: ::std::os::raw::c_uint = 1;
pub const _IScntrl: ::std::os::raw::c_uint = 2;
pub const _ISpunct: ::std::os::raw::c_uint = 4;
pub const _ISalnum: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cli_strcasestr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __cli_strndup(
        s: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __cli_strnlen(s: *const ::std::os::raw::c_char, n: size_t) -> size_t;
}
extern "C" {
    pub fn __cli_strnstr(
        s: *const ::std::os::raw::c_char,
        find: *const ::std::os::raw::c_char,
        slen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_strbcasestr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_chomp(string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_strtok(
        line: *const ::std::os::raw::c_char,
        field: ::std::os::raw::c_int,
        delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_realhex2ui(
        hex: *const ::std::os::raw::c_char,
        ptr: *mut u16,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hex2ui(hex: *const ::std::os::raw::c_char) -> *mut u16;
}
extern "C" {
    pub fn cli_hex2str_to(
        hex: *const ::std::os::raw::c_char,
        ptr: *mut ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hex2str(hex: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_hex2num(hex: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_xtoi(hex: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_str2hex(
        string: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_strtokbuf(
        input: *const ::std::os::raw::c_char,
        fieldno: ::std::os::raw::c_int,
        delim: *const ::std::os::raw::c_char,
        output: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_memstr(
        haystack: *const ::std::os::raw::c_char,
        hs: size_t,
        needle: *const ::std::os::raw::c_char,
        ns: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_strrcpy(
        dest: *mut ::std::os::raw::c_char,
        source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_strtokenize(
        buffer: *mut ::std::os::raw::c_char,
        delim: ::std::os::raw::c_char,
        token_count: size_t,
        tokens: *mut *const ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    pub fn cli_ldbtokenize(
        buffer: *mut ::std::os::raw::c_char,
        delim: ::std::os::raw::c_char,
        token_count: size_t,
        tokens: *mut *const ::std::os::raw::c_char,
        token_skip: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn cli_strntol(
        nptr: *const ::std::os::raw::c_char,
        n: size_t,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn cli_strntoul(
        nptr: *const ::std::os::raw::c_char,
        n: size_t,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn cli_strntol_wrap(
        buf: *const ::std::os::raw::c_char,
        buf_size: size_t,
        fail_at_nondigit: ::std::os::raw::c_int,
        base: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_long,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_strntoul_wrap(
        buf: *const ::std::os::raw::c_char,
        buf_size: size_t,
        fail_at_nondigit: ::std::os::raw::c_int,
        base: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_ulong,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_isnumber(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_unescape(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct text_buffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cli_textbuffer_append_normalize(
        buf: *mut text_buffer,
        str_: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hexnibbles(
        str_: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        sz: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " @brief   Get the file basename including extension from a file path."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing filebase."]
    #[doc = " An empty string will be returned if the caller inputs a directory with a trailing slash (no file)."]
    #[doc = ""]
    #[doc = " @param filepath      The filepath in question."]
    #[doc = " @param[out] filebase An allocated string containing the file basename."]
    #[doc = " @return cl_error_t   CL_SUCCESS, CL_EARG, CL_EFORMAT, or CL_EMEM"]
    pub fn cli_basename(
        filepath: *const ::std::os::raw::c_char,
        filepath_len: size_t,
        filebase: *mut *mut ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_virname(
        virname: *const ::std::os::raw::c_char,
        official: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_sigopts_handler(
        root: *mut cli_matcher,
        virname: *const ::std::os::raw::c_char,
        hexsig: *const ::std::os::raw::c_char,
        sigopts: u8,
        rtype: u16,
        type_: u16,
        offset: *const ::std::os::raw::c_char,
        target: u8,
        lsigid: *const u32,
        options: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_parse_add(
        root: *mut cli_matcher,
        virname: *const ::std::os::raw::c_char,
        hexsig: *const ::std::os::raw::c_char,
        sigopts: u8,
        rtype: u16,
        type_: u16,
        offset: *const ::std::os::raw::c_char,
        target: u8,
        lsigid: *const u32,
        options: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_load(
        filename: *const ::std::os::raw::c_char,
        engine: *mut cl_engine,
        signo: *mut ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
        dbio: *mut cli_dbio,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_dbgets(
        buff: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        fs: *mut FILE,
        dbio: *mut cli_dbio,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_initroots(engine: *mut cl_engine, options: ::std::os::raw::c_uint) -> cl_error_t;
}
extern "C" {
    pub fn cli_yara_init(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    pub fn cli_yara_free(engine: *mut cl_engine);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MP {
    _unused: [u8; 0],
}
pub type mpool_t = MP;
extern "C" {
    pub fn mpool_create() -> *mut mpool_t;
}
extern "C" {
    pub fn mpool_destroy(mpool: *mut mpool_t);
}
extern "C" {
    pub fn mpool_malloc(mpool: *mut mpool_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mpool_free(mpool: *mut mpool_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mpool_calloc(
        mpool: *mut mpool_t,
        nmemb: size_t,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mpool_realloc(
        mpool: *mut mpool_t,
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mpool_realloc2(
        mpool: *mut mpool_t,
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cli_mpool_hex2str(
        mpool: *mut mpool_t,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_mpool_strdup(
        mpool: *mut mpool_t,
        s: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_mpool_strndup(
        mpool: *mut mpool_t,
        s: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_mpool_virname(
        mpool: *mut mpool_t,
        virname: *const ::std::os::raw::c_char,
        official: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_mpool_hex2ui(mpool: *mut mpool_t, hex: *const ::std::os::raw::c_char) -> *mut u16;
}
extern "C" {
    pub fn mpool_flush(mpool: *mut mpool_t);
}
extern "C" {
    pub fn mpool_getstats(
        engine: *const cl_engine,
        used: *mut size_t,
        total: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_dconf {
    pub pe: u32,
    pub elf: u32,
    pub macho: u32,
    pub archive: u32,
    pub doc: u32,
    pub mail: u32,
    pub other: u32,
    pub phishing: u32,
    pub bytecode: u32,
    pub stats: u32,
    pub pcre: u32,
}
#[test]
fn bindgen_test_layout_cli_dconf() {
    assert_eq!(
        ::std::mem::size_of::<cli_dconf>(),
        44usize,
        concat!("Size of: ", stringify!(cli_dconf))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_dconf>(),
        4usize,
        concat!("Alignment of ", stringify!(cli_dconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).pe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(pe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).elf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(elf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).macho as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(macho)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).archive as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(archive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).doc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(doc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).mail as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(mail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).other as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(other)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).phishing as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(phishing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).bytecode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(bytecode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).stats as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dconf>())).pcre as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dconf),
            "::",
            stringify!(pcre)
        )
    );
}
extern "C" {
    pub fn cli_dconf_init(arg1: *mut mpool_t) -> *mut cli_dconf;
}
extern "C" {
    pub fn cli_dconf_print(dconf: *mut cli_dconf);
}
extern "C" {
    pub fn cli_dconf_load(
        fs: *mut FILE,
        engine: *mut cl_engine,
        options: ::std::os::raw::c_uint,
        dbio: *mut cli_dbio,
    ) -> ::std::os::raw::c_int;
}
pub type regoff_t = off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regex_t {
    pub re_magic: ::std::os::raw::c_int,
    pub re_nsub: size_t,
    pub re_endp: *const ::std::os::raw::c_char,
    pub re_g: *mut re_guts,
}
#[test]
fn bindgen_test_layout_regex_t() {
    assert_eq!(
        ::std::mem::size_of::<regex_t>(),
        32usize,
        concat!("Size of: ", stringify!(regex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<regex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(regex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<regex_t>())).re_magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(regex_t),
            "::",
            stringify!(re_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<regex_t>())).re_nsub as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(regex_t),
            "::",
            stringify!(re_nsub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<regex_t>())).re_endp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(regex_t),
            "::",
            stringify!(re_endp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<regex_t>())).re_g as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(regex_t),
            "::",
            stringify!(re_g)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regmatch_t {
    pub rm_so: regoff_t,
    pub rm_eo: regoff_t,
}
#[test]
fn bindgen_test_layout_regmatch_t() {
    assert_eq!(
        ::std::mem::size_of::<regmatch_t>(),
        16usize,
        concat!("Size of: ", stringify!(regmatch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<regmatch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(regmatch_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<regmatch_t>())).rm_so as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(regmatch_t),
            "::",
            stringify!(rm_so)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<regmatch_t>())).rm_eo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(regmatch_t),
            "::",
            stringify!(rm_eo)
        )
    );
}
extern "C" {
    pub fn cli_regcomp_real(
        arg1: *mut regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_regcomp(
        arg1: *mut regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_regerror(
        arg1: ::std::os::raw::c_int,
        arg2: *const regex_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn cli_regexec(
        arg1: *const regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut regmatch_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_regfree(arg1: *mut regex_t);
}
extern "C" {
    pub fn cli_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: size_t,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bytecode_metadata {
    pub compiler: *mut ::std::os::raw::c_char,
    pub sigmaker: *mut ::std::os::raw::c_char,
    pub timestamp: u64,
    pub formatlevel: ::std::os::raw::c_uint,
    pub minfunc: ::std::os::raw::c_uint,
    pub maxfunc: ::std::os::raw::c_uint,
    pub maxresource: ::std::os::raw::c_uint,
    pub targetExclude: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_bytecode_metadata() {
    assert_eq!(
        ::std::mem::size_of::<bytecode_metadata>(),
        48usize,
        concat!("Size of: ", stringify!(bytecode_metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<bytecode_metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(bytecode_metadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bytecode_metadata>())).compiler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bytecode_metadata),
            "::",
            stringify!(compiler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bytecode_metadata>())).sigmaker as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bytecode_metadata),
            "::",
            stringify!(sigmaker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bytecode_metadata>())).timestamp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bytecode_metadata),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bytecode_metadata>())).formatlevel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bytecode_metadata),
            "::",
            stringify!(formatlevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bytecode_metadata>())).minfunc as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bytecode_metadata),
            "::",
            stringify!(minfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bytecode_metadata>())).maxfunc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bytecode_metadata),
            "::",
            stringify!(maxfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bytecode_metadata>())).maxresource as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bytecode_metadata),
            "::",
            stringify!(maxresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bytecode_metadata>())).targetExclude as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bytecode_metadata),
            "::",
            stringify!(targetExclude)
        )
    );
}
pub const bc_opcode_OP_BC_ADD: bc_opcode = 1;
pub const bc_opcode_OP_BC_SUB: bc_opcode = 2;
pub const bc_opcode_OP_BC_MUL: bc_opcode = 3;
pub const bc_opcode_OP_BC_UDIV: bc_opcode = 4;
pub const bc_opcode_OP_BC_SDIV: bc_opcode = 5;
pub const bc_opcode_OP_BC_UREM: bc_opcode = 6;
pub const bc_opcode_OP_BC_SREM: bc_opcode = 7;
pub const bc_opcode_OP_BC_SHL: bc_opcode = 8;
pub const bc_opcode_OP_BC_LSHR: bc_opcode = 9;
pub const bc_opcode_OP_BC_ASHR: bc_opcode = 10;
pub const bc_opcode_OP_BC_AND: bc_opcode = 11;
pub const bc_opcode_OP_BC_OR: bc_opcode = 12;
pub const bc_opcode_OP_BC_XOR: bc_opcode = 13;
pub const bc_opcode_OP_BC_TRUNC: bc_opcode = 14;
pub const bc_opcode_OP_BC_SEXT: bc_opcode = 15;
pub const bc_opcode_OP_BC_ZEXT: bc_opcode = 16;
pub const bc_opcode_OP_BC_BRANCH: bc_opcode = 17;
pub const bc_opcode_OP_BC_JMP: bc_opcode = 18;
pub const bc_opcode_OP_BC_RET: bc_opcode = 19;
pub const bc_opcode_OP_BC_RET_VOID: bc_opcode = 20;
pub const bc_opcode_OP_BC_ICMP_EQ: bc_opcode = 21;
pub const bc_opcode_OP_BC_ICMP_NE: bc_opcode = 22;
pub const bc_opcode_OP_BC_ICMP_UGT: bc_opcode = 23;
pub const bc_opcode_OP_BC_ICMP_UGE: bc_opcode = 24;
pub const bc_opcode_OP_BC_ICMP_ULT: bc_opcode = 25;
pub const bc_opcode_OP_BC_ICMP_ULE: bc_opcode = 26;
pub const bc_opcode_OP_BC_ICMP_SGT: bc_opcode = 27;
pub const bc_opcode_OP_BC_ICMP_SGE: bc_opcode = 28;
pub const bc_opcode_OP_BC_ICMP_SLE: bc_opcode = 29;
pub const bc_opcode_OP_BC_ICMP_SLT: bc_opcode = 30;
pub const bc_opcode_OP_BC_SELECT: bc_opcode = 31;
pub const bc_opcode_OP_BC_CALL_DIRECT: bc_opcode = 32;
pub const bc_opcode_OP_BC_CALL_API: bc_opcode = 33;
pub const bc_opcode_OP_BC_COPY: bc_opcode = 34;
pub const bc_opcode_OP_BC_GEP1: bc_opcode = 35;
pub const bc_opcode_OP_BC_GEPZ: bc_opcode = 36;
pub const bc_opcode_OP_BC_GEPN: bc_opcode = 37;
pub const bc_opcode_OP_BC_STORE: bc_opcode = 38;
pub const bc_opcode_OP_BC_LOAD: bc_opcode = 39;
pub const bc_opcode_OP_BC_MEMSET: bc_opcode = 40;
pub const bc_opcode_OP_BC_MEMCPY: bc_opcode = 41;
pub const bc_opcode_OP_BC_MEMMOVE: bc_opcode = 42;
pub const bc_opcode_OP_BC_MEMCMP: bc_opcode = 43;
pub const bc_opcode_OP_BC_ISBIGENDIAN: bc_opcode = 44;
pub const bc_opcode_OP_BC_ABORT: bc_opcode = 45;
pub const bc_opcode_OP_BC_BSWAP16: bc_opcode = 46;
pub const bc_opcode_OP_BC_BSWAP32: bc_opcode = 47;
pub const bc_opcode_OP_BC_BSWAP64: bc_opcode = 48;
pub const bc_opcode_OP_BC_PTRDIFF32: bc_opcode = 49;
pub const bc_opcode_OP_BC_PTRTOINT64: bc_opcode = 50;
pub const bc_opcode_OP_BC_INVALID: bc_opcode = 51;
pub type bc_opcode = ::std::os::raw::c_uint;
extern "C" {
    pub static operand_counts: [::std::os::raw::c_uchar; 51usize];
}
pub const bc_global__FIRST_GLOBAL: bc_global = 32768;
pub const bc_global_GLOBAL_MATCH_COUNTS: bc_global = 32768;
pub const bc_global_GLOBAL_KIND: bc_global = 32769;
pub const bc_global_GLOBAL_VIRUSNAMES: bc_global = 32770;
pub const bc_global_GLOBAL_PEDATA: bc_global = 32771;
pub const bc_global_GLOBAL_FILESIZE: bc_global = 32772;
pub const bc_global_GLOBAL_MATCH_OFFSETS: bc_global = 32773;
pub const bc_global__LAST_GLOBAL: bc_global = 32774;
pub type bc_global = ::std::os::raw::c_uint;
pub const arch_list_arch_unknown: arch_list = 0;
pub const arch_list_arch_i386: arch_list = 1;
pub const arch_list_arch_x86_64: arch_list = 2;
pub const arch_list_arch_ppc32: arch_list = 3;
pub const arch_list_arch_ppc64: arch_list = 4;
pub const arch_list_arch_arm: arch_list = 5;
pub const arch_list_arch_sparc: arch_list = 6;
pub const arch_list_arch_sparc64: arch_list = 7;
pub const arch_list_arch_mips: arch_list = 8;
pub const arch_list_arch_mips64: arch_list = 9;
pub const arch_list_arch_alpha: arch_list = 10;
pub const arch_list_arch_hppa1: arch_list = 11;
pub const arch_list_arch_hppa2: arch_list = 12;
pub const arch_list_arch_m68k: arch_list = 13;
pub const arch_list_arch_ANY: arch_list = 15;
pub type arch_list = ::std::os::raw::c_uint;
pub const os_kind_conf_os_unknown: os_kind_conf = 0;
pub const os_kind_conf_os_aix: os_kind_conf = 1;
pub const os_kind_conf_os_beos: os_kind_conf = 2;
pub const os_kind_conf_os_bsd: os_kind_conf = 3;
pub const os_kind_conf_os_darwin: os_kind_conf = 4;
pub const os_kind_conf_os_gnu_hurd: os_kind_conf = 5;
pub const os_kind_conf_os_hpux: os_kind_conf = 6;
pub const os_kind_conf_os_interix: os_kind_conf = 7;
pub const os_kind_conf_os_irix: os_kind_conf = 8;
pub const os_kind_conf_os_kfreebsd_gnu: os_kind_conf = 9;
pub const os_kind_conf_os_linux: os_kind_conf = 10;
pub const os_kind_conf_os_os2: os_kind_conf = 11;
pub const os_kind_conf_os_osf: os_kind_conf = 12;
pub const os_kind_conf_os_qnx6: os_kind_conf = 13;
pub const os_kind_conf_os_solaris: os_kind_conf = 14;
pub const os_kind_conf_os_win32: os_kind_conf = 15;
pub const os_kind_conf_os_win64: os_kind_conf = 16;
pub const os_kind_conf_os_generic: os_kind_conf = 17;
pub const os_kind_conf_os_ANY: os_kind_conf = 255;
pub type os_kind_conf = ::std::os::raw::c_uint;
pub const os_kind_llvm_llvm_os_UnknownOS: os_kind_llvm = 0;
pub const os_kind_llvm_llvm_os_AuroraUX: os_kind_llvm = 1;
pub const os_kind_llvm_llvm_os_Cygwin: os_kind_llvm = 2;
pub const os_kind_llvm_llvm_os_Darwin: os_kind_llvm = 3;
pub const os_kind_llvm_llvm_os_DragonFly: os_kind_llvm = 4;
pub const os_kind_llvm_llvm_os_FreeBSD: os_kind_llvm = 5;
pub const os_kind_llvm_llvm_os_Linux: os_kind_llvm = 6;
pub const os_kind_llvm_llvm_os_Lv2: os_kind_llvm = 7;
pub const os_kind_llvm_llvm_os_MinGW32: os_kind_llvm = 8;
pub const os_kind_llvm_llvm_os_MinGW64: os_kind_llvm = 9;
pub const os_kind_llvm_llvm_os_NetBSD: os_kind_llvm = 10;
pub const os_kind_llvm_llvm_os_OpenBSD: os_kind_llvm = 11;
pub const os_kind_llvm_llvm_os_Psp: os_kind_llvm = 12;
pub const os_kind_llvm_llvm_os_Solaris: os_kind_llvm = 13;
pub const os_kind_llvm_llvm_os_Win32: os_kind_llvm = 14;
pub const os_kind_llvm_llvm_os_Haiku: os_kind_llvm = 15;
pub const os_kind_llvm_llvm_os_Minix: os_kind_llvm = 16;
pub const os_kind_llvm_llvm_os_ANY: os_kind_llvm = 255;
pub type os_kind_llvm = ::std::os::raw::c_uint;
pub const compiler_list_compiler_unknown: compiler_list = 0;
pub const compiler_list_compiler_gnuc: compiler_list = 1;
pub const compiler_list_compiler_llvm: compiler_list = 2;
pub const compiler_list_compiler_clang: compiler_list = 3;
pub const compiler_list_compiler_intel: compiler_list = 4;
pub const compiler_list_compiler_msc: compiler_list = 5;
pub const compiler_list_compiler_sun: compiler_list = 6;
pub const compiler_list_compiler_other: compiler_list = 7;
pub const compiler_list_compiler_ANY: compiler_list = 15;
pub type compiler_list = ::std::os::raw::c_uint;
pub const endian_list_endian_little: endian_list = 0;
pub const endian_list_endian_big: endian_list = 1;
pub const endian_list_endian_ANY: endian_list = 15;
pub type endian_list = ::std::os::raw::c_uint;
pub const os_feature_bits_feature_map_rwx: os_feature_bits = 0;
pub const os_feature_bits_feature_selinux: os_feature_bits = 1;
pub const os_feature_bits_feature_selinux_enforcing: os_feature_bits = 2;
pub const os_feature_bits_feature_pax: os_feature_bits = 3;
pub const os_feature_bits_feature_pax_mprotect: os_feature_bits = 4;
pub type os_feature_bits = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_environment {
    pub platform_id_a: u32,
    pub platform_id_b: u32,
    pub platform_id_c: u32,
    pub c_version: u32,
    pub cpp_version: u32,
    pub functionality_level: u32,
    pub dconf_level: u32,
    pub engine_version: [i8; 65usize],
    pub triple: [i8; 65usize],
    pub cpu: [i8; 65usize],
    pub sysname: [i8; 65usize],
    pub release: [i8; 65usize],
    pub version: [i8; 65usize],
    pub machine: [i8; 65usize],
    pub big_endian: u8,
    pub sizeof_ptr: u8,
    pub arch: u8,
    pub os_category: u8,
    pub os: u8,
    pub compiler: u8,
    pub has_jit_compiled: u8,
    pub os_features: u8,
    pub reserved0: u8,
}
#[test]
fn bindgen_test_layout_cli_environment() {
    assert_eq!(
        ::std::mem::size_of::<cli_environment>(),
        492usize,
        concat!("Size of: ", stringify!(cli_environment))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_environment>(),
        4usize,
        concat!("Alignment of ", stringify!(cli_environment))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).platform_id_a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(platform_id_a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).platform_id_b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(platform_id_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).platform_id_c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(platform_id_c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).c_version as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(c_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).cpp_version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(cpp_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_environment>())).functionality_level as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(functionality_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).dconf_level as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(dconf_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).engine_version as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(engine_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).triple as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(triple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).cpu as *const _ as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).sysname as *const _ as usize },
        223usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(sysname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).release as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).version as *const _ as usize },
        353usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).machine as *const _ as usize },
        418usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(machine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).big_endian as *const _ as usize },
        483usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(big_endian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).sizeof_ptr as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(sizeof_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).arch as *const _ as usize },
        485usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).os_category as *const _ as usize },
        486usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(os_category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).os as *const _ as usize },
        487usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(os)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).compiler as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(compiler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_environment>())).has_jit_compiled as *const _ as usize
        },
        489usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(has_jit_compiled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).os_features as *const _ as usize },
        490usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(os_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_environment>())).reserved0 as *const _ as usize },
        491usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_environment),
            "::",
            stringify!(reserved0)
        )
    );
}
extern "C" {
    pub fn cli_detect_env_jit(env: *mut cli_environment);
}
extern "C" {
    pub fn cli_detect_environment(env: *mut cli_environment);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_func {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_value {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_inst {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_engine {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc_dbgnode {
    _unused: [u8; 0],
}
pub const bc_state_bc_skip: bc_state = 0;
pub const bc_state_bc_loaded: bc_state = 1;
pub const bc_state_bc_jit: bc_state = 2;
pub const bc_state_bc_interp: bc_state = 3;
pub const bc_state_bc_disabled: bc_state = 4;
pub type bc_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bc {
    pub metadata: bytecode_metadata,
    pub id: ::std::os::raw::c_uint,
    pub kind: ::std::os::raw::c_uint,
    pub num_types: ::std::os::raw::c_uint,
    pub num_func: ::std::os::raw::c_uint,
    pub funcs: *mut cli_bc_func,
    pub types: *mut cli_bc_type,
    pub globals: *mut *mut u64,
    pub globaltys: *mut u16,
    pub num_globals: size_t,
    pub state: bc_state,
    pub uses_apis: *mut bitset_tag,
    pub lsig: *mut ::std::os::raw::c_char,
    pub vnameprefix: *mut ::std::os::raw::c_char,
    pub vnames: *mut *mut ::std::os::raw::c_char,
    pub vnames_cnt: ::std::os::raw::c_uint,
    pub start_tid: u16,
    pub dbgnodes: *mut cli_bc_dbgnode,
    pub dbgnode_cnt: ::std::os::raw::c_uint,
    pub hook_lsig_id: ::std::os::raw::c_uint,
    pub trusted: ::std::os::raw::c_uint,
    pub numGlobalBytes: u32,
    pub globalBytes: *mut u8,
    pub sigtime_id: u32,
    pub sigmatch_id: u32,
    pub hook_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cli_bc() {
    assert_eq!(
        ::std::mem::size_of::<cli_bc>(),
        200usize,
        concat!("Size of: ", stringify!(cli_bc))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_bc>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_bc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).metadata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).kind as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).num_types as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(num_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).num_func as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(num_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).funcs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).types as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).globals as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(globals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).globaltys as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(globaltys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).num_globals as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(num_globals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).state as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).uses_apis as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(uses_apis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).lsig as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(lsig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).vnameprefix as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(vnameprefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).vnames as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(vnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).vnames_cnt as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(vnames_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).start_tid as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(start_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).dbgnodes as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(dbgnodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).dbgnode_cnt as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(dbgnode_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).hook_lsig_id as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(hook_lsig_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).trusted as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(trusted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).numGlobalBytes as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(numGlobalBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).globalBytes as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(globalBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).sigtime_id as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(sigtime_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).sigmatch_id as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(sigmatch_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bc>())).hook_name as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bc),
            "::",
            stringify!(hook_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_all_bc {
    pub all_bcs: *mut cli_bc,
    pub count: ::std::os::raw::c_uint,
    pub engine: *mut cli_bcengine,
    pub env: cli_environment,
    pub inited: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cli_all_bc() {
    assert_eq!(
        ::std::mem::size_of::<cli_all_bc>(),
        520usize,
        concat!("Size of: ", stringify!(cli_all_bc))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_all_bc>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_all_bc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_all_bc>())).all_bcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_all_bc),
            "::",
            stringify!(all_bcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_all_bc>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_all_bc),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_all_bc>())).engine as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_all_bc),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_all_bc>())).env as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_all_bc),
            "::",
            stringify!(env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_all_bc>())).inited as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_all_bc),
            "::",
            stringify!(inited)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pe_hook_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pdf_obj {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cli_bytecode_context_alloc() -> *mut cli_bc_ctx;
}
extern "C" {
    pub fn cli_bytecode_context_setctx(ctx: *mut cli_bc_ctx, cctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cli_bytecode_context_setfuncid(
        ctx: *mut cli_bc_ctx,
        bc: *const cli_bc,
        funcid: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_context_setparam_int(
        ctx: *mut cli_bc_ctx,
        i: ::std::os::raw::c_uint,
        c: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_context_setparam_ptr(
        ctx: *mut cli_bc_ctx,
        i: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        datalen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_context_setfile(
        ctx: *mut cli_bc_ctx,
        map: *mut fmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_context_setpe(
        ctx: *mut cli_bc_ctx,
        data: *const cli_pe_hook_data,
        sections: *const cli_exe_section,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_context_setpdf(
        ctx: *mut cli_bc_ctx,
        phase: ::std::os::raw::c_uint,
        nobjs: ::std::os::raw::c_uint,
        objs: *mut *mut pdf_obj,
        pdf_flags: *mut u32,
        pdfsize: u32,
        pdfstartoff: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_context_clear(ctx: *mut cli_bc_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_context_getresult_file(
        ctx: *mut cli_bc_ctx,
        tempfilename: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_context_getresult_int(ctx: *mut cli_bc_ctx) -> u64;
}
extern "C" {
    pub fn cli_bytecode_context_destroy(ctx: *mut cli_bc_ctx);
}
extern "C" {
    pub static mut have_clamjit: ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_init(allbc: *mut cli_all_bc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_load(
        bc: *mut cli_bc,
        f: *mut FILE,
        dbio: *mut cli_dbio,
        security: ::std::os::raw::c_int,
        sigperf: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_prepare2(
        engine: *mut cl_engine,
        allbc: *mut cli_all_bc,
        dconfmask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_run(
        bcs: *const cli_all_bc,
        bc: *const cli_bc,
        ctx: *mut cli_bc_ctx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_destroy(bc: *mut cli_bc);
}
extern "C" {
    pub fn cli_bytecode_done(allbc: *mut cli_all_bc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_describe(bc: *const cli_bc);
}
extern "C" {
    pub fn cli_bytetype_describe(bc: *const cli_bc);
}
extern "C" {
    pub fn cli_bytevalue_describe(bc: *const cli_bc, funcid: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn cli_byteinst_describe(inst: *const cli_bc_inst, bbnum: *mut ::std::os::raw::c_uint);
}
extern "C" {
    pub fn cli_bytefunc_describe(bc: *const cli_bc, funcid: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn cli_bytecode_runlsig(
        ctx: *mut cli_ctx_tag,
        info: *mut cli_target_info,
        bcs: *const cli_all_bc,
        bc_idx: ::std::os::raw::c_uint,
        lsigcnt: *const u32,
        lsigsuboff: *const u32,
        map: *mut fmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_runhook(
        cctx: *mut cli_ctx_tag,
        engine: *const cl_engine,
        ctx: *mut cli_bc_ctx,
        id: ::std::os::raw::c_uint,
        map: *mut fmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bytecode_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bytecode_debug(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn cli_bytecode_printversion();
}
extern "C" {
    pub fn cli_bytecode_debug_printsrc(ctx: *const cli_bc_ctx);
}
extern "C" {
    pub fn cli_printcxxver();
}
pub type bc_dbg_callback_trace = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut cli_bc_ctx, event: ::std::os::raw::c_uint),
>;
pub type bc_dbg_callback_trace_op = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut cli_bc_ctx, op: *const ::std::os::raw::c_char),
>;
pub type bc_dbg_callback_trace_val = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut cli_bc_ctx, name: *const ::std::os::raw::c_char, value: u32),
>;
pub type bc_dbg_callback_trace_ptr = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut cli_bc_ctx, val: *const ::std::os::raw::c_void),
>;
extern "C" {
    pub fn cli_bytecode_context_set_trace(
        arg1: *mut cli_bc_ctx,
        level: ::std::os::raw::c_uint,
        arg2: bc_dbg_callback_trace,
        arg3: bc_dbg_callback_trace_op,
        arg4: bc_dbg_callback_trace_val,
        arg5: bc_dbg_callback_trace_ptr,
    );
}
extern "C" {
    pub fn cli_sigperf_print();
}
extern "C" {
    pub fn cli_sigperf_events_destroy();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISASM_RESULT {
    _unused: [u8; 0],
}
#[doc = " generic bytecode, not tied a specific hook"]
pub const BytecodeKind_BC_GENERIC: BytecodeKind = 0;
#[doc = " triggered at startup, only one is allowed per ClamAV startup"]
pub const BytecodeKind_BC_STARTUP: BytecodeKind = 1;
#[doc = " triggered at startup, only one is allowed per ClamAV startup"]
pub const BytecodeKind__BC_START_HOOKS: BytecodeKind = 256;
#[doc = " executed on a logical trigger"]
pub const BytecodeKind_BC_LOGICAL: BytecodeKind = 256;
#[doc = " specifies a PE unpacker, executed on PE files on a logical trigger"]
pub const BytecodeKind_BC_PE_UNPACKER: BytecodeKind = 257;
#[doc = " specifies a PDF hook, executes at a predetermined point of PDF parsing for PDF files"]
pub const BytecodeKind_BC_PDF: BytecodeKind = 258;
#[doc = " specifies a PE hook, executes at a predetermined point in PE parsing for PE files,"]
#[doc = " both packed and unpacked files"]
pub const BytecodeKind_BC_PE_ALL: BytecodeKind = 259;
#[doc = " specifies a PRECLASS hook, executes at the end of file property collection and"]
#[doc = " operates on the original file targeted for property collection"]
pub const BytecodeKind_BC_PRECLASS: BytecodeKind = 260;
#[doc = " specifies an ELF unpacker, executed on ELF files on a logical trigger"]
pub const BytecodeKind_BC_ELF_UNPACKER: BytecodeKind = 261;
#[doc = " specifies an Mach-O unpacker, executed on Mach-O files on a logical trigger"]
pub const BytecodeKind_BC_MACHO_UNPACKER: BytecodeKind = 262;
#[doc = " specifies an Mach-O unpacker, executed on Mach-O files on a logical trigger"]
pub const BytecodeKind__BC_LAST_HOOK: BytecodeKind = 263;
#[doc = "\\group_config"]
#[doc = " Specifies the bytecode type and how ClamAV executes it"]
pub type BytecodeKind = ::std::os::raw::c_uint;
#[doc = "< LibClamAV release 0.96.0: bytecode engine released"]
pub const FunctionalityLevels_FUNC_LEVEL_096: FunctionalityLevels = 51;
pub const FunctionalityLevels_FUNC_LEVEL_096_dev: FunctionalityLevels = 52;
#[doc = "< LibClamAV release 0.96.1: logical signature use of VI/macros"]
#[doc = " requires this minimum functionality level"]
pub const FunctionalityLevels_FUNC_LEVEL_096_1: FunctionalityLevels = 53;
pub const FunctionalityLevels_FUNC_LEVEL_096_1_dev: FunctionalityLevels = 54;
#[doc = "< LibClamAV release 0.96.2: PDF Hooks require this minimum level"]
pub const FunctionalityLevels_FUNC_LEVEL_096_2: FunctionalityLevels = 54;
pub const FunctionalityLevels_FUNC_LEVEL_096_2_dev: FunctionalityLevels = 55;
#[doc = "< LibClamAV release 0.96.3: BC_PE_ALL bytecodes require this minimum level"]
pub const FunctionalityLevels_FUNC_LEVEL_096_3: FunctionalityLevels = 55;
#[doc = "< LibClamAV release 0.96.4: minimum recommended engine version, older versions have quadratic load time"]
pub const FunctionalityLevels_FUNC_LEVEL_096_4: FunctionalityLevels = 56;
#[doc = "< LibClamAV release 0.96.5"]
pub const FunctionalityLevels_FUNC_LEVEL_096_5: FunctionalityLevels = 58;
#[doc = "< LibClamAV release 0.97.0: older bytecodes may incorrectly use 57"]
pub const FunctionalityLevels_FUNC_LEVEL_097: FunctionalityLevels = 60;
#[doc = "< LibClamAV release 0.97.1"]
pub const FunctionalityLevels_FUNC_LEVEL_097_1: FunctionalityLevels = 61;
#[doc = "< LibClamAV release 0.97.2"]
pub const FunctionalityLevels_FUNC_LEVEL_097_2: FunctionalityLevels = 62;
#[doc = "< LibClamAV release 0.97.3: last bcc changes as former team resigns"]
pub const FunctionalityLevels_FUNC_LEVEL_097_3: FunctionalityLevels = 63;
#[doc = "< LibClamAV release 0.97.4"]
pub const FunctionalityLevels_FUNC_LEVEL_097_4: FunctionalityLevels = 64;
#[doc = "< LibClamAV release 0.97.5"]
pub const FunctionalityLevels_FUNC_LEVEL_097_5: FunctionalityLevels = 65;
#[doc = "< LibClamAV release 0.97.6"]
pub const FunctionalityLevels_FUNC_LEVEL_097_6: FunctionalityLevels = 67;
#[doc = "< LibClamAV release 0.97.7"]
pub const FunctionalityLevels_FUNC_LEVEL_097_7: FunctionalityLevels = 68;
#[doc = "< LibClamAV release 0.97.8"]
pub const FunctionalityLevels_FUNC_LEVEL_097_8: FunctionalityLevels = 69;
#[doc = "< LibClamAV release 0.98.0"]
pub const FunctionalityLevels_FUNC_LEVEL_098: FunctionalityLevels = 74;
#[doc = "< LibClamAV release 0.98.1: last syncing to clamav"]
pub const FunctionalityLevels_FUNC_LEVEL_098_1: FunctionalityLevels = 76;
#[doc = "< LibClamAV release 0.98.2"]
pub const FunctionalityLevels_FUNC_LEVEL_098_2: FunctionalityLevels = 77;
#[doc = "< LibClamAV release 0.98.3"]
pub const FunctionalityLevels_FUNC_LEVEL_098_3: FunctionalityLevels = 77;
#[doc = "< LibClamAV release 0.98.4"]
pub const FunctionalityLevels_FUNC_LEVEL_098_4: FunctionalityLevels = 77;
#[doc = "< LibClamAV release 0.98.5: JSON reading API requires this minimum level"]
pub const FunctionalityLevels_FUNC_LEVEL_098_5: FunctionalityLevels = 79;
#[doc = "< LibClamAV release 0.98.6"]
pub const FunctionalityLevels_FUNC_LEVEL_098_6: FunctionalityLevels = 79;
#[doc = "< LibClamAV release 0.98.7: BC_PRECLASS bytecodes require minimum level"]
pub const FunctionalityLevels_FUNC_LEVEL_098_7: FunctionalityLevels = 80;
#[doc = "< LibClamAV release 0.99.0"]
pub const FunctionalityLevels_FUNC_LEVEL_099: FunctionalityLevels = 81;
#[doc = "< LibClamAV release 0.99.1"]
pub const FunctionalityLevels_FUNC_LEVEL_099_1: FunctionalityLevels = 82;
#[doc = "< LibClamAV release 0.99.2: not a typo, the FLEVEL did not change"]
pub const FunctionalityLevels_FUNC_LEVEL_099_2: FunctionalityLevels = 82;
#[doc = "< LibClamAV release 0.99.3"]
pub const FunctionalityLevels_FUNC_LEVEL_099_3: FunctionalityLevels = 84;
#[doc = "< LibClamAV release 0.99.4"]
pub const FunctionalityLevels_FUNC_LEVEL_099_4: FunctionalityLevels = 85;
#[doc = "< LibClamAV release 0.100.0-BETA"]
pub const FunctionalityLevels_FUNC_LEVEL_0100_BETA: FunctionalityLevels = 90;
#[doc = "< LibClamAV release 0.100.0"]
pub const FunctionalityLevels_FUNC_LEVEL_0100: FunctionalityLevels = 91;
#[doc = "< LibClamAV release 0.100.1"]
pub const FunctionalityLevels_FUNC_LEVEL_0100_1: FunctionalityLevels = 92;
#[doc = "< LibClamAV release 0.100.2"]
pub const FunctionalityLevels_FUNC_LEVEL_0100_2: FunctionalityLevels = 93;
#[doc = "< LibClamAV release 0.100.3"]
pub const FunctionalityLevels_FUNC_LEVEL_0100_3: FunctionalityLevels = 94;
#[doc = "< LibClamAV release 0.101.0-BETA"]
pub const FunctionalityLevels_FUNC_LEVEL_0101_BETA: FunctionalityLevels = 100;
#[doc = "< LibClamAV release 0.101.0"]
pub const FunctionalityLevels_FUNC_LEVEL_0101: FunctionalityLevels = 101;
#[doc = "< LibClamAV release 0.101.1"]
pub const FunctionalityLevels_FUNC_LEVEL_0101_1: FunctionalityLevels = 102;
#[doc = "< LibClamAV release 0.101.2"]
pub const FunctionalityLevels_FUNC_LEVEL_0101_2: FunctionalityLevels = 102;
#[doc = "< LibClamAV release 0.101.3"]
pub const FunctionalityLevels_FUNC_LEVEL_0101_3: FunctionalityLevels = 102;
#[doc = "< LibClamAV release 0.101.4"]
pub const FunctionalityLevels_FUNC_LEVEL_0101_4: FunctionalityLevels = 105;
#[doc = "< LibClamAV release 0.101.5"]
pub const FunctionalityLevels_FUNC_LEVEL_0101_5: FunctionalityLevels = 106;
#[doc = "< LibClamAV release 0.102.0-BETA"]
pub const FunctionalityLevels_FUNC_LEVEL_0102_BETA: FunctionalityLevels = 110;
#[doc = "< LibClamAV release 0.102.0"]
pub const FunctionalityLevels_FUNC_LEVEL_0102: FunctionalityLevels = 111;
#[doc = "< LibClamAV release 0.102.1"]
pub const FunctionalityLevels_FUNC_LEVEL_0102_1: FunctionalityLevels = 112;
#[doc = "< LibClamAV release 0.103.0-BETA"]
pub const FunctionalityLevels_FUNC_LEVEL_0103_BETA: FunctionalityLevels = 120;
#[doc = "< LibClamAV release 0.103.0"]
pub const FunctionalityLevels_FUNC_LEVEL_0103: FunctionalityLevels = 121;
#[doc = "< LibClamAV release 0.103.1"]
pub const FunctionalityLevels_FUNC_LEVEL_0103_1: FunctionalityLevels = 122;
#[doc = "< LibClamAV release 0.103.2"]
pub const FunctionalityLevels_FUNC_LEVEL_0103_2: FunctionalityLevels = 123;
#[doc = "< LibClamAV release 0.103.2"]
pub const FunctionalityLevels_FUNC_LEVEL_0103_3: FunctionalityLevels = 124;
#[doc = "< LibClamAV release 0.104.0"]
pub const FunctionalityLevels_FUNC_LEVEL_0104: FunctionalityLevels = 140;
#[doc = "< LibClamAV release 0.104.1"]
pub const FunctionalityLevels_FUNC_LEVEL_0104_1: FunctionalityLevels = 141;
#[doc = "< LibClamAV release 0.104.2"]
pub const FunctionalityLevels_FUNC_LEVEL_0104_2: FunctionalityLevels = 142;
#[doc = "< LibClamAV release 0.104.3"]
pub const FunctionalityLevels_FUNC_LEVEL_0104_3: FunctionalityLevels = 143;
#[doc = "\\group_config"]
#[doc = " LibClamAV functionality level constants"]
pub type FunctionalityLevels = ::std::os::raw::c_uint;
pub const pdf_phase_PDF_PHASE_NONE: pdf_phase = 0;
pub const pdf_phase_PDF_PHASE_PARSED: pdf_phase = 1;
pub const pdf_phase_PDF_PHASE_POSTDUMP: pdf_phase = 2;
pub const pdf_phase_PDF_PHASE_END: pdf_phase = 3;
pub const pdf_phase_PDF_PHASE_PRE: pdf_phase = 4;
#[doc = "\\group_pdf"]
#[doc = " Phase of PDF parsing used for PDF Hooks"]
pub type pdf_phase = ::std::os::raw::c_uint;
pub const pdf_flag_BAD_PDF_VERSION: pdf_flag = 0;
pub const pdf_flag_BAD_PDF_HEADERPOS: pdf_flag = 1;
pub const pdf_flag_BAD_PDF_TRAILER: pdf_flag = 2;
pub const pdf_flag_BAD_PDF_TOOMANYOBJS: pdf_flag = 3;
pub const pdf_flag_BAD_STREAM_FILTERS: pdf_flag = 4;
pub const pdf_flag_BAD_FLATE: pdf_flag = 5;
pub const pdf_flag_BAD_FLATESTART: pdf_flag = 6;
pub const pdf_flag_BAD_STREAMSTART: pdf_flag = 7;
pub const pdf_flag_BAD_ASCIIDECODE: pdf_flag = 8;
pub const pdf_flag_BAD_INDOBJ: pdf_flag = 9;
pub const pdf_flag_UNTERMINATED_OBJ_DICT: pdf_flag = 10;
pub const pdf_flag_ESCAPED_COMMON_PDFNAME: pdf_flag = 11;
pub const pdf_flag_HEX_JAVASCRIPT: pdf_flag = 12;
pub const pdf_flag_UNKNOWN_FILTER: pdf_flag = 13;
pub const pdf_flag_MANY_FILTERS: pdf_flag = 14;
pub const pdf_flag_HAS_OPENACTION: pdf_flag = 15;
pub const pdf_flag_BAD_STREAMLEN: pdf_flag = 16;
pub const pdf_flag_ENCRYPTED_PDF: pdf_flag = 17;
pub const pdf_flag_LINEARIZED_PDF: pdf_flag = 18;
pub const pdf_flag_DECRYPTABLE_PDF: pdf_flag = 19;
pub const pdf_flag_HAS_LAUNCHACTION: pdf_flag = 20;
#[doc = "\\group_pdf"]
#[doc = " PDF flags"]
pub type pdf_flag = ::std::os::raw::c_uint;
pub const pdf_objflags_OBJ_STREAM: pdf_objflags = 0;
pub const pdf_objflags_OBJ_DICT: pdf_objflags = 1;
pub const pdf_objflags_OBJ_EMBEDDED_FILE: pdf_objflags = 2;
pub const pdf_objflags_OBJ_FILTER_AH: pdf_objflags = 3;
pub const pdf_objflags_OBJ_FILTER_A85: pdf_objflags = 4;
pub const pdf_objflags_OBJ_FILTER_FLATE: pdf_objflags = 5;
pub const pdf_objflags_OBJ_FILTER_LZW: pdf_objflags = 6;
pub const pdf_objflags_OBJ_FILTER_RL: pdf_objflags = 7;
pub const pdf_objflags_OBJ_FILTER_FAX: pdf_objflags = 8;
pub const pdf_objflags_OBJ_FILTER_JBIG2: pdf_objflags = 9;
pub const pdf_objflags_OBJ_FILTER_DCT: pdf_objflags = 10;
pub const pdf_objflags_OBJ_FILTER_JPX: pdf_objflags = 11;
pub const pdf_objflags_OBJ_FILTER_CRYPT: pdf_objflags = 12;
pub const pdf_objflags_OBJ_FILTER_UNKNOWN: pdf_objflags = 13;
pub const pdf_objflags_OBJ_JAVASCRIPT: pdf_objflags = 14;
pub const pdf_objflags_OBJ_OPENACTION: pdf_objflags = 15;
pub const pdf_objflags_OBJ_HASFILTERS: pdf_objflags = 16;
pub const pdf_objflags_OBJ_SIGNED: pdf_objflags = 17;
pub const pdf_objflags_OBJ_IMAGE: pdf_objflags = 18;
pub const pdf_objflags_OBJ_TRUNCATED: pdf_objflags = 19;
pub const pdf_objflags_OBJ_FORCEDUMP: pdf_objflags = 20;
pub const pdf_objflags_OBJ_FILTER_STANDARD: pdf_objflags = 21;
pub const pdf_objflags_OBJ_LAUNCHACTION: pdf_objflags = 22;
pub const pdf_objflags_OBJ_PAGE: pdf_objflags = 23;
pub const pdf_objflags_OBJ_CONTENTS: pdf_objflags = 24;
#[doc = "\\group_pdf"]
#[doc = " PDF obj flags"]
pub type pdf_objflags = ::std::os::raw::c_uint;
pub const bc_json_type_JSON_TYPE_NULL: bc_json_type = 0;
pub const bc_json_type_JSON_TYPE_BOOLEAN: bc_json_type = 1;
pub const bc_json_type_JSON_TYPE_DOUBLE: bc_json_type = 2;
pub const bc_json_type_JSON_TYPE_INT: bc_json_type = 3;
pub const bc_json_type_JSON_TYPE_OBJECT: bc_json_type = 4;
pub const bc_json_type_JSON_TYPE_ARRAY: bc_json_type = 5;
pub const bc_json_type_JSON_TYPE_STRING: bc_json_type = 6;
#[doc = "\\group_json"]
#[doc = " JSON types"]
pub type bc_json_type = ::std::os::raw::c_uint;
pub const lzma_returncode_LZMA_RESULT_OK: lzma_returncode = 0;
pub const lzma_returncode_LZMA_RESULT_DATA_ERROR: lzma_returncode = 1;
pub const lzma_returncode_LZMA_STREAM_END: lzma_returncode = 2;
#[doc = "\\group_adt"]
#[doc = " LZMA return codes"]
pub type lzma_returncode = ::std::os::raw::c_uint;
pub const bzip2_returncode_BZIP2_OK: bzip2_returncode = 0;
pub const bzip2_returncode_BZIP2_SEQUENCE_ERROR: bzip2_returncode = -1;
pub const bzip2_returncode_BZIP2_PARAM_ERROR: bzip2_returncode = -2;
pub const bzip2_returncode_BZIP2_MEM_ERROR: bzip2_returncode = -3;
pub const bzip2_returncode_BZIP2_DATA_ERROR: bzip2_returncode = -4;
pub const bzip2_returncode_BZIP2_DATA_ERROR_MAGIC: bzip2_returncode = -5;
pub const bzip2_returncode_BZIP2_IO_ERROR: bzip2_returncode = -6;
pub const bzip2_returncode_BZIP2_UNEXPECTED_EOF: bzip2_returncode = -7;
pub const bzip2_returncode_BZIP2_OUTBUFF_FULL: bzip2_returncode = -8;
pub const bzip2_returncode_BZIP2_CONFIG_ERROR: bzip2_returncode = -9;
pub const bzip2_returncode_BZIP2_RUN_OK: bzip2_returncode = 1;
pub const bzip2_returncode_BZIP2_FLUSH_OK: bzip2_returncode = 2;
pub const bzip2_returncode_BZIP2_FINISH_OK: bzip2_returncode = 3;
pub const bzip2_returncode_BZIP2_STREAM_END: bzip2_returncode = 4;
#[doc = "\\group adt"]
#[doc = " Bzip2 return codes"]
pub type bzip2_returncode = ::std::os::raw::c_int;
pub const CL_SCAN_RAW: ::std::os::raw::c_uint = 0;
pub const CL_SCAN_ARCHIVE: ::std::os::raw::c_uint = 1;
pub const CL_SCAN_MAIL: ::std::os::raw::c_uint = 2;
pub const CL_SCAN_OLE2: ::std::os::raw::c_uint = 4;
pub const CL_SCAN_BLOCKENCRYPTED: ::std::os::raw::c_uint = 8;
pub const CL_SCAN_HTML: ::std::os::raw::c_uint = 16;
pub const CL_SCAN_PE: ::std::os::raw::c_uint = 32;
pub const CL_SCAN_BLOCKBROKEN: ::std::os::raw::c_uint = 64;
pub const CL_SCAN_MAILURL: ::std::os::raw::c_uint = 128;
pub const CL_SCAN_BLOCKMAX: ::std::os::raw::c_uint = 256;
pub const CL_SCAN_ALGORITHMIC: ::std::os::raw::c_uint = 512;
pub const CL_SCAN_PHISHING_BLOCKSSL: ::std::os::raw::c_uint = 2048;
pub const CL_SCAN_PHISHING_BLOCKCLOAK: ::std::os::raw::c_uint = 4096;
pub const CL_SCAN_ELF: ::std::os::raw::c_uint = 8192;
pub const CL_SCAN_PDF: ::std::os::raw::c_uint = 16384;
pub const CL_SCAN_STRUCTURED: ::std::os::raw::c_uint = 32768;
pub const CL_SCAN_STRUCTURED_SSN_NORMAL: ::std::os::raw::c_uint = 65536;
pub const CL_SCAN_STRUCTURED_SSN_STRIPPED: ::std::os::raw::c_uint = 131072;
pub const CL_SCAN_PARTIAL_MESSAGE: ::std::os::raw::c_uint = 262144;
pub const CL_SCAN_HEURISTIC_PRECEDENCE: ::std::os::raw::c_uint = 524288;
pub const CL_SCAN_BLOCKMACROS: ::std::os::raw::c_uint = 1048576;
pub const CL_SCAN_ALLMATCHES: ::std::os::raw::c_uint = 2097152;
pub const CL_SCAN_SWF: ::std::os::raw::c_uint = 4194304;
pub const CL_SCAN_PARTITION_INTXN: ::std::os::raw::c_uint = 8388608;
pub const CL_SCAN_XMLDOCS: ::std::os::raw::c_uint = 16777216;
pub const CL_SCAN_HWP3: ::std::os::raw::c_uint = 33554432;
pub const CL_SCAN_FILE_PROPERTIES: ::std::os::raw::c_uint = 268435456;
pub const CL_SCAN_PERFORMANCE_INFO: ::std::os::raw::c_uint = 1073741824;
pub const CL_SCAN_INTERNAL_COLLECT_SHA: ::std::os::raw::c_uint = 2147483648;
#[doc = "\\group_engine"]
#[doc = " Scan option flag values for engine_scan_options(). *DEPRECATED*"]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_events {
    _unused: [u8; 0],
}
pub type cli_events_t = cli_events;
extern "C" {
    pub fn cli_events_new(max_event: ::std::os::raw::c_uint) -> *mut cli_events_t;
}
extern "C" {
    pub fn cli_events_free(arg1: *mut cli_events_t);
}
pub const ev_type_ev_none: ev_type = 0;
pub const ev_type_ev_string: ev_type = 1;
pub const ev_type_ev_data: ev_type = 2;
pub const ev_type_ev_data_fast: ev_type = 3;
pub const ev_type_ev_int: ev_type = 4;
pub const ev_type_ev_time: ev_type = 5;
pub type ev_type = ::std::os::raw::c_uint;
pub const multiple_handling_multiple_last: multiple_handling = 0;
pub const multiple_handling_multiple_chain: multiple_handling = 1;
pub const multiple_handling_multiple_sum: multiple_handling = 2;
pub const multiple_handling_multiple_concat: multiple_handling = 3;
pub type multiple_handling = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ev_val {
    pub v_string: *const ::std::os::raw::c_char,
    pub v_data: *mut ::std::os::raw::c_void,
    pub v_int: u64,
    pub v_chain: *mut ev_val,
}
#[test]
fn bindgen_test_layout_ev_val() {
    assert_eq!(
        ::std::mem::size_of::<ev_val>(),
        8usize,
        concat!("Size of: ", stringify!(ev_val))
    );
    assert_eq!(
        ::std::mem::align_of::<ev_val>(),
        8usize,
        concat!("Alignment of ", stringify!(ev_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ev_val>())).v_string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ev_val),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ev_val>())).v_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ev_val),
            "::",
            stringify!(v_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ev_val>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ev_val),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ev_val>())).v_chain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ev_val),
            "::",
            stringify!(v_chain)
        )
    );
}
extern "C" {
    pub fn cli_event_define(
        ctx: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        type_: ev_type,
        multiple: multiple_handling,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_event_error_str(ctx: *mut cli_events_t, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cli_event_error_oom(ctx: *mut cli_events_t, amount: u32);
}
extern "C" {
    pub fn cli_event_int(ctx: *mut cli_events_t, id: ::std::os::raw::c_uint, arg: u64);
}
extern "C" {
    pub fn cli_event_string(
        ctx: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn cli_event_data(
        ctx: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
        data: *const ::std::os::raw::c_void,
        len: u32,
    );
}
extern "C" {
    pub fn cli_event_fastdata(
        ctx: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
        data: *const ::std::os::raw::c_void,
        len: u32,
    );
}
extern "C" {
    pub fn cli_event_time_start(ctx: *mut cli_events_t, id: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn cli_event_time_stop(ctx: *mut cli_events_t, id: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn cli_event_time_nested_start(
        ctx: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
        nestedid: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn cli_event_time_nested_stop(
        ctx: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
        nestedid: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn cli_event_count(ctx: *mut cli_events_t, id: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn cli_event_get(
        ctx: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
        val: *mut ev_val,
        count: *mut u32,
    );
}
extern "C" {
    pub fn cli_event_get_name(
        ctx: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_event_debug_all(ctx: *mut cli_events_t);
}
extern "C" {
    pub fn cli_event_debug(ctx: *mut cli_events_t, id: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn cli_event_diff(
        ctx1: *mut cli_events_t,
        ctx2: *mut cli_events_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type compare_filter_t = ::std::option::Option<
    unsafe extern "C" fn(id: ::std::os::raw::c_uint, type_: ev_type) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn cli_event_diff_all(
        ctx1: *mut cli_events_t,
        ctx2: *mut cli_events_t,
        filter: compare_filter_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_event_errors(ctx: *mut cli_events_t) -> ::std::os::raw::c_int;
}
pub const perfev_PERFT_SCAN: perfev = 0;
pub const perfev_PERFT_PRECB: perfev = 1;
pub const perfev_PERFT_POSTCB: perfev = 2;
pub const perfev_PERFT_CACHE: perfev = 3;
pub const perfev_PERFT_FT: perfev = 4;
pub const perfev_PERFT_CONTAINER: perfev = 5;
pub const perfev_PERFT_SCRIPT: perfev = 6;
pub const perfev_PERFT_PE: perfev = 7;
pub const perfev_PERFT_RAW: perfev = 8;
pub const perfev_PERFT_RAWTYPENO: perfev = 9;
pub const perfev_PERFT_MAP: perfev = 10;
pub const perfev_PERFT_BYTECODE: perfev = 11;
pub const perfev_PERFT_KTIME: perfev = 12;
pub const perfev_PERFT_UTIME: perfev = 13;
pub const perfev_PERFT_ELF: perfev = 14;
pub const perfev_PERFT_MACHO: perfev = 15;
pub const perfev_PERFT_LAST: perfev = 16;
pub type perfev = ::std::os::raw::c_uint;
pub type ulong64 = ::std::os::raw::c_ulong;
pub type fp_digit = ulong64;
pub type fp_word = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fp_int {
    pub dp: [fp_digit; 136usize],
    pub used: ::std::os::raw::c_int,
    pub sign: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fp_int() {
    assert_eq!(
        ::std::mem::size_of::<fp_int>(),
        1096usize,
        concat!("Size of: ", stringify!(fp_int))
    );
    assert_eq!(
        ::std::mem::align_of::<fp_int>(),
        8usize,
        concat!("Alignment of ", stringify!(fp_int))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fp_int>())).dp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fp_int),
            "::",
            stringify!(dp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fp_int>())).used as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(fp_int),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fp_int>())).sign as *const _ as usize },
        1092usize,
        concat!(
            "Offset of field: ",
            stringify!(fp_int),
            "::",
            stringify!(sign)
        )
    );
}
extern "C" {
    pub fn fp_ident() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fp_set(a: *mut fp_int, b: fp_digit);
}
extern "C" {
    pub fn fp_rshd(a: *mut fp_int, x: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fp_lshd(a: *mut fp_int, x: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fp_cmp(a: *mut fp_int, b: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_cmp_mag(a: *mut fp_int, b: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_div_2d(a: *mut fp_int, b: ::std::os::raw::c_int, c: *mut fp_int, d: *mut fp_int);
}
extern "C" {
    pub fn fp_mod_2d(a: *mut fp_int, b: ::std::os::raw::c_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_mul_2d(a: *mut fp_int, b: ::std::os::raw::c_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_2expt(a: *mut fp_int, b: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fp_mul_2(a: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_div_2(a: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_cnt_lsb(a: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_add(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_sub(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_mul(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_sqr(a: *mut fp_int, b: *mut fp_int);
}
extern "C" {
    pub fn fp_div(
        a: *mut fp_int,
        b: *mut fp_int,
        c: *mut fp_int,
        d: *mut fp_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_mod(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_cmp_d(a: *mut fp_int, b: fp_digit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_add_d(a: *mut fp_int, b: fp_digit, c: *mut fp_int);
}
extern "C" {
    pub fn fp_sub_d(a: *mut fp_int, b: fp_digit, c: *mut fp_int);
}
extern "C" {
    pub fn fp_mul_d(a: *mut fp_int, b: fp_digit, c: *mut fp_int);
}
extern "C" {
    pub fn fp_div_d(
        a: *mut fp_int,
        b: fp_digit,
        c: *mut fp_int,
        d: *mut fp_digit,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_mod_d(a: *mut fp_int, b: fp_digit, c: *mut fp_digit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_addmod(
        a: *mut fp_int,
        b: *mut fp_int,
        c: *mut fp_int,
        d: *mut fp_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_submod(
        a: *mut fp_int,
        b: *mut fp_int,
        c: *mut fp_int,
        d: *mut fp_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_mulmod(
        a: *mut fp_int,
        b: *mut fp_int,
        c: *mut fp_int,
        d: *mut fp_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_sqrmod(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_invmod(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_gcd(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_lcm(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_montgomery_setup(a: *mut fp_int, mp: *mut fp_digit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_montgomery_calc_normalization(a: *mut fp_int, b: *mut fp_int);
}
extern "C" {
    pub fn fp_montgomery_reduce(a: *mut fp_int, m: *mut fp_int, mp: fp_digit);
}
extern "C" {
    pub fn fp_exptmod(
        a: *mut fp_int,
        b: *mut fp_int,
        c: *mut fp_int,
        d: *mut fp_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_prime_miller_rabin(
        a: *mut fp_int,
        b: *mut fp_int,
        result: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fp_isprime(a: *mut fp_int) -> ::std::os::raw::c_int;
}
pub type tfm_prime_callback = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        dat: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn fp_prime_random_ex(
        a: *mut fp_int,
        t: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        cb: tfm_prime_callback,
        dat: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_count_bits(a: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_unsigned_bin_size(a: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_read_unsigned_bin(
        a: *mut fp_int,
        b: *const ::std::os::raw::c_uchar,
        c: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fp_to_unsigned_bin(a: *mut fp_int, b: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn fp_signed_bin_size(a: *mut fp_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_read_signed_bin(
        a: *mut fp_int,
        b: *mut ::std::os::raw::c_uchar,
        c: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fp_to_signed_bin(a: *mut fp_int, b: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn fp_read_radix(
        a: *mut fp_int,
        str_: *const ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_toradix(
        a: *mut fp_int,
        str_: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fp_toradix_n(
        a: *mut fp_int,
        str_: *mut ::std::os::raw::c_char,
        radix: ::std::os::raw::c_int,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn s_fp_add(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn s_fp_sub(a: *mut fp_int, b: *mut fp_int, c: *mut fp_int);
}
extern "C" {
    pub fn fp_reverse(s: *mut ::std::os::raw::c_uchar, len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fp_mul_comba(A: *mut fp_int, B: *mut fp_int, C: *mut fp_int);
}
extern "C" {
    pub fn fp_mul_comba_small(A: *mut fp_int, B: *mut fp_int, C: *mut fp_int);
}
extern "C" {
    pub fn fp_mul_comba20(A: *mut fp_int, B: *mut fp_int, C: *mut fp_int);
}
extern "C" {
    pub fn fp_mul_comba24(A: *mut fp_int, B: *mut fp_int, C: *mut fp_int);
}
extern "C" {
    pub fn fp_mul_comba28(A: *mut fp_int, B: *mut fp_int, C: *mut fp_int);
}
extern "C" {
    pub fn fp_mul_comba32(A: *mut fp_int, B: *mut fp_int, C: *mut fp_int);
}
extern "C" {
    pub fn fp_sqr_comba(A: *mut fp_int, B: *mut fp_int);
}
extern "C" {
    pub fn fp_sqr_comba_small(A: *mut fp_int, B: *mut fp_int);
}
extern "C" {
    pub fn fp_sqr_comba20(A: *mut fp_int, B: *mut fp_int);
}
extern "C" {
    pub fn fp_sqr_comba24(A: *mut fp_int, B: *mut fp_int);
}
extern "C" {
    pub fn fp_sqr_comba28(A: *mut fp_int, B: *mut fp_int);
}
extern "C" {
    pub fn fp_sqr_comba32(A: *mut fp_int, B: *mut fp_int);
}
extern "C" {
    pub static mut fp_s_rmap: *const ::std::os::raw::c_char;
}
pub type mp_int = fp_int;
pub const cli_crt_hashtype_CLI_HASHTYPE_ANY: cli_crt_hashtype = 0;
pub const cli_crt_hashtype_CLI_SHA1RSA: cli_crt_hashtype = 1;
pub const cli_crt_hashtype_CLI_MD5RSA: cli_crt_hashtype = 2;
pub const cli_crt_hashtype_CLI_MD2RSA: cli_crt_hashtype = 3;
pub const cli_crt_hashtype_CLI_RSA: cli_crt_hashtype = 4;
pub const cli_crt_hashtype_CLI_SHA256RSA: cli_crt_hashtype = 5;
pub const cli_crt_hashtype_CLI_SHA384RSA: cli_crt_hashtype = 6;
pub const cli_crt_hashtype_CLI_SHA512RSA: cli_crt_hashtype = 7;
pub type cli_crt_hashtype = ::std::os::raw::c_uint;
pub const cli_vrfy_type_VRFY_CODE: cli_vrfy_type = 0;
pub const cli_vrfy_type_VRFY_TIME: cli_vrfy_type = 1;
pub type cli_vrfy_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_crt_t {
    pub name: *mut ::std::os::raw::c_char,
    pub raw_subject: [u8; 64usize],
    pub raw_issuer: [u8; 64usize],
    pub raw_serial: [u8; 64usize],
    pub subject: [u8; 20usize],
    pub issuer: [u8; 20usize],
    pub serial: [u8; 20usize],
    pub ignore_serial: ::std::os::raw::c_int,
    pub tbshash: [u8; 64usize],
    pub n: mp_int,
    pub e: mp_int,
    pub sig: mp_int,
    pub not_before: time_t,
    pub not_after: time_t,
    pub hashtype: cli_crt_hashtype,
    pub certSign: ::std::os::raw::c_int,
    pub codeSign: ::std::os::raw::c_int,
    pub timeSign: ::std::os::raw::c_int,
    pub isBlocked: ::std::os::raw::c_int,
    pub prev: *mut cli_crt_t,
    pub next: *mut cli_crt_t,
}
#[test]
fn bindgen_test_layout_cli_crt_t() {
    assert_eq!(
        ::std::mem::size_of::<cli_crt_t>(),
        3672usize,
        concat!("Size of: ", stringify!(cli_crt_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_crt_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_crt_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).raw_subject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(raw_subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).raw_issuer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(raw_issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).raw_serial as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(raw_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).subject as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).issuer as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).serial as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).ignore_serial as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(ignore_serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).tbshash as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(tbshash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).n as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).e as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).sig as *const _ as usize },
        2520usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).not_before as *const _ as usize },
        3616usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(not_before)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).not_after as *const _ as usize },
        3624usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(not_after)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).hashtype as *const _ as usize },
        3632usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(hashtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).certSign as *const _ as usize },
        3636usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(certSign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).codeSign as *const _ as usize },
        3640usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(codeSign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).timeSign as *const _ as usize },
        3644usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(timeSign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).isBlocked as *const _ as usize },
        3648usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(isBlocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).prev as *const _ as usize },
        3656usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_crt_t>())).next as *const _ as usize },
        3664usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_crt_t),
            "::",
            stringify!(next)
        )
    );
}
pub type cli_crt = cli_crt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crtmgr {
    pub crts: *mut cli_crt,
    pub items: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_crtmgr() {
    assert_eq!(
        ::std::mem::size_of::<crtmgr>(),
        16usize,
        concat!("Size of: ", stringify!(crtmgr))
    );
    assert_eq!(
        ::std::mem::align_of::<crtmgr>(),
        8usize,
        concat!("Alignment of ", stringify!(crtmgr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crtmgr>())).crts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crtmgr),
            "::",
            stringify!(crts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crtmgr>())).items as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crtmgr),
            "::",
            stringify!(items)
        )
    );
}
extern "C" {
    pub fn cli_crt_init(x509: *mut cli_crt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_crt_clear(x509: *mut cli_crt);
}
extern "C" {
    pub fn crtmgr_init(m: *mut crtmgr);
}
extern "C" {
    pub fn crtmgr_free(m: *mut crtmgr);
}
extern "C" {
    pub fn crtmgr_add(m: *mut crtmgr, x509: *mut cli_crt) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crtmgr_lookup(m: *mut crtmgr, x509: *mut cli_crt) -> *mut cli_crt;
}
extern "C" {
    pub fn crtmgr_block_list_lookup(m: *mut crtmgr, x509: *mut cli_crt) -> *mut cli_crt;
}
extern "C" {
    pub fn crtmgr_trust_list_lookup(
        m: *mut crtmgr,
        x509: *mut cli_crt,
        crb_crts_only: ::std::os::raw::c_int,
    ) -> *mut cli_crt;
}
extern "C" {
    pub fn crtmgr_del(m: *mut crtmgr, x509: *mut cli_crt);
}
extern "C" {
    pub fn crtmgr_verify_crt(m: *mut crtmgr, x509: *mut cli_crt) -> *mut cli_crt;
}
extern "C" {
    pub fn crtmgr_verify_pkcs7(
        m: *mut crtmgr,
        issuer: *const u8,
        serial: *const u8,
        signature: *const ::std::os::raw::c_void,
        signature_len: ::std::os::raw::c_uint,
        hashtype: cli_crt_hashtype,
        refhash: *const u8,
        vrfytype: cli_vrfy_type,
    ) -> *mut cli_crt;
}
extern "C" {
    pub fn crtmgr_add_roots(
        engine: *mut cl_engine,
        m: *mut crtmgr,
        exclude_bl_crts: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const cl_unrar_error_tag_UNRAR_OK: cl_unrar_error_tag = 0;
pub const cl_unrar_error_tag_UNRAR_BREAK: cl_unrar_error_tag = 1;
pub const cl_unrar_error_tag_UNRAR_ENCRYPTED: cl_unrar_error_tag = 2;
pub const cl_unrar_error_tag_UNRAR_EMEM: cl_unrar_error_tag = 3;
pub const cl_unrar_error_tag_UNRAR_ERR: cl_unrar_error_tag = 4;
pub const cl_unrar_error_tag_UNRAR_EOPEN: cl_unrar_error_tag = 5;
pub type cl_unrar_error_tag = ::std::os::raw::c_uint;
pub use self::cl_unrar_error_tag as cl_unrar_error_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrar_metadata_tag {
    pub pack_size: u64,
    pub unpack_size: u64,
    pub filename: *mut ::std::os::raw::c_char,
    pub crc: u32,
    pub encrypted: ::std::os::raw::c_uint,
    pub method: u8,
    pub is_dir: u32,
}
#[test]
fn bindgen_test_layout_unrar_metadata_tag() {
    assert_eq!(
        ::std::mem::size_of::<unrar_metadata_tag>(),
        40usize,
        concat!("Size of: ", stringify!(unrar_metadata_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<unrar_metadata_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(unrar_metadata_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unrar_metadata_tag>())).pack_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unrar_metadata_tag),
            "::",
            stringify!(pack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unrar_metadata_tag>())).unpack_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unrar_metadata_tag),
            "::",
            stringify!(unpack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unrar_metadata_tag>())).filename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(unrar_metadata_tag),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unrar_metadata_tag>())).crc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(unrar_metadata_tag),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unrar_metadata_tag>())).encrypted as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(unrar_metadata_tag),
            "::",
            stringify!(encrypted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unrar_metadata_tag>())).method as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(unrar_metadata_tag),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unrar_metadata_tag>())).is_dir as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(unrar_metadata_tag),
            "::",
            stringify!(is_dir)
        )
    );
}
pub type unrar_metadata_t = unrar_metadata_tag;
extern "C" {
    pub fn libclamunrar_iface_LTX_unrar_open(
        filename: *const ::std::os::raw::c_char,
        hArchive: *mut *mut ::std::os::raw::c_void,
        comment: *mut *mut ::std::os::raw::c_char,
        comment_size: *mut u32,
        debug_flag: u8,
    ) -> cl_unrar_error_t;
}
extern "C" {
    pub fn libclamunrar_iface_LTX_unrar_peek_file_header(
        hArchive: *mut ::std::os::raw::c_void,
        file_metadata: *mut unrar_metadata_t,
    ) -> cl_unrar_error_t;
}
extern "C" {
    pub fn libclamunrar_iface_LTX_unrar_extract_file(
        hArchive: *mut ::std::os::raw::c_void,
        destPath: *const ::std::os::raw::c_char,
        outputBuffer: *mut ::std::os::raw::c_char,
    ) -> cl_unrar_error_t;
}
extern "C" {
    pub fn libclamunrar_iface_LTX_unrar_skip_file(
        hArchive: *mut ::std::os::raw::c_void,
    ) -> cl_unrar_error_t;
}
extern "C" {
    pub fn libclamunrar_iface_LTX_unrar_close(hArchive: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_HASH_TABLE_ENTRY {
    pub key: *mut ::std::os::raw::c_char,
    pub ns: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_void,
    pub next: *mut _YR_HASH_TABLE_ENTRY,
}
#[test]
fn bindgen_test_layout__YR_HASH_TABLE_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_YR_HASH_TABLE_ENTRY>(),
        32usize,
        concat!("Size of: ", stringify!(_YR_HASH_TABLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_HASH_TABLE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_HASH_TABLE_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_HASH_TABLE_ENTRY>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_HASH_TABLE_ENTRY),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_HASH_TABLE_ENTRY>())).ns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_HASH_TABLE_ENTRY),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_HASH_TABLE_ENTRY>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_HASH_TABLE_ENTRY),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_HASH_TABLE_ENTRY>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_HASH_TABLE_ENTRY),
            "::",
            stringify!(next)
        )
    );
}
pub type YR_HASH_TABLE_ENTRY = _YR_HASH_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug)]
pub struct _YR_HASH_TABLE {
    pub size: ::std::os::raw::c_int,
    pub buckets: __IncompleteArrayField<*mut YR_HASH_TABLE_ENTRY>,
}
#[test]
fn bindgen_test_layout__YR_HASH_TABLE() {
    assert_eq!(
        ::std::mem::size_of::<_YR_HASH_TABLE>(),
        8usize,
        concat!("Size of: ", stringify!(_YR_HASH_TABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_HASH_TABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_HASH_TABLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_HASH_TABLE>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_HASH_TABLE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_HASH_TABLE>())).buckets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_HASH_TABLE),
            "::",
            stringify!(buckets)
        )
    );
}
pub type YR_HASH_TABLE = _YR_HASH_TABLE;
pub type YR_HASH_TABLE_FREE_VALUE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(value: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn yr_hash_table_create(
        size: ::std::os::raw::c_int,
        table: *mut *mut YR_HASH_TABLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_hash_table_destroy(
        table: *mut YR_HASH_TABLE,
        free_value: YR_HASH_TABLE_FREE_VALUE_FUNC,
    );
}
extern "C" {
    pub fn yr_hash_table_lookup(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_hash_table_add(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_OBJECT {
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub parent: *mut _YR_OBJECT,
}
#[test]
fn bindgen_test_layout__YR_OBJECT() {
    assert_eq!(
        ::std::mem::size_of::<_YR_OBJECT>(),
        32usize,
        concat!("Size of: ", stringify!(_YR_OBJECT))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_OBJECT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT>())).identifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT),
            "::",
            stringify!(parent)
        )
    );
}
pub type YR_OBJECT = _YR_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_OBJECT_INTEGER {
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub parent: *mut _YR_OBJECT,
    pub value: i64,
}
#[test]
fn bindgen_test_layout__YR_OBJECT_INTEGER() {
    assert_eq!(
        ::std::mem::size_of::<_YR_OBJECT_INTEGER>(),
        40usize,
        concat!("Size of: ", stringify!(_YR_OBJECT_INTEGER))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_OBJECT_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_OBJECT_INTEGER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_INTEGER>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_INTEGER),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_INTEGER>())).identifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_INTEGER),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_INTEGER>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_INTEGER),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_INTEGER>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_INTEGER),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_INTEGER>())).value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_INTEGER),
            "::",
            stringify!(value)
        )
    );
}
pub type YR_OBJECT_INTEGER = _YR_OBJECT_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_OBJECT_STRING {
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub parent: *mut _YR_OBJECT,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__YR_OBJECT_STRING() {
    assert_eq!(
        ::std::mem::size_of::<_YR_OBJECT_STRING>(),
        40usize,
        concat!("Size of: ", stringify!(_YR_OBJECT_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_OBJECT_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_OBJECT_STRING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_STRING>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_STRING),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_STRING>())).identifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_STRING),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_STRING>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_STRING),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_STRING>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_STRING),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_STRING>())).value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_STRING),
            "::",
            stringify!(value)
        )
    );
}
pub type YR_OBJECT_STRING = _YR_OBJECT_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_OBJECT_ARRAY {
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub parent: *mut _YR_OBJECT,
    pub items: *mut _YR_ARRAY_ITEMS,
}
#[test]
fn bindgen_test_layout__YR_OBJECT_ARRAY() {
    assert_eq!(
        ::std::mem::size_of::<_YR_OBJECT_ARRAY>(),
        40usize,
        concat!("Size of: ", stringify!(_YR_OBJECT_ARRAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_OBJECT_ARRAY>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_OBJECT_ARRAY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_ARRAY>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_ARRAY),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_ARRAY>())).identifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_ARRAY),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_ARRAY>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_ARRAY),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_ARRAY>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_ARRAY),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_ARRAY>())).items as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_ARRAY),
            "::",
            stringify!(items)
        )
    );
}
pub type YR_OBJECT_ARRAY = _YR_OBJECT_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_SCAN_CONTEXT {
    pub file_size: u64,
    pub entry_point: u64,
    pub flags: ::std::os::raw::c_int,
    pub user_data: *mut ::std::os::raw::c_void,
    pub objects_table: *mut YR_HASH_TABLE,
    pub fmap: *mut fmap_t,
}
#[test]
fn bindgen_test_layout__YR_SCAN_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<_YR_SCAN_CONTEXT>(),
        48usize,
        concat!("Size of: ", stringify!(_YR_SCAN_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_SCAN_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_SCAN_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_SCAN_CONTEXT>())).file_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_SCAN_CONTEXT),
            "::",
            stringify!(file_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_SCAN_CONTEXT>())).entry_point as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_SCAN_CONTEXT),
            "::",
            stringify!(entry_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_SCAN_CONTEXT>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_SCAN_CONTEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_SCAN_CONTEXT>())).user_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_SCAN_CONTEXT),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_SCAN_CONTEXT>())).objects_table as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_SCAN_CONTEXT),
            "::",
            stringify!(objects_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_SCAN_CONTEXT>())).fmap as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_SCAN_CONTEXT),
            "::",
            stringify!(fmap)
        )
    );
}
pub type YR_SCAN_CONTEXT = _YR_SCAN_CONTEXT;
pub type YR_MODULE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        args: *mut ::std::os::raw::c_void,
        context: *mut YR_SCAN_CONTEXT,
        function_obj: *mut _YR_OBJECT_FUNCTION,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_OBJECT_FUNCTION {
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub parent: *mut _YR_OBJECT,
    pub arguments_fmt: *const ::std::os::raw::c_char,
    pub return_obj: *mut YR_OBJECT,
    pub code: YR_MODULE_FUNC,
}
#[test]
fn bindgen_test_layout__YR_OBJECT_FUNCTION() {
    assert_eq!(
        ::std::mem::size_of::<_YR_OBJECT_FUNCTION>(),
        56usize,
        concat!("Size of: ", stringify!(_YR_OBJECT_FUNCTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_OBJECT_FUNCTION>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_OBJECT_FUNCTION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_FUNCTION>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_FUNCTION),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_FUNCTION>())).identifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_FUNCTION),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_FUNCTION>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_FUNCTION),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_FUNCTION>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_FUNCTION),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_OBJECT_FUNCTION>())).arguments_fmt as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_FUNCTION),
            "::",
            stringify!(arguments_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_FUNCTION>())).return_obj as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_FUNCTION),
            "::",
            stringify!(return_obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_OBJECT_FUNCTION>())).code as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_OBJECT_FUNCTION),
            "::",
            stringify!(code)
        )
    );
}
pub type YR_OBJECT_FUNCTION = _YR_OBJECT_FUNCTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_ARRAY_ITEMS {
    pub count: ::std::os::raw::c_int,
    pub objects: [*mut YR_OBJECT; 1usize],
}
#[test]
fn bindgen_test_layout__YR_ARRAY_ITEMS() {
    assert_eq!(
        ::std::mem::size_of::<_YR_ARRAY_ITEMS>(),
        16usize,
        concat!("Size of: ", stringify!(_YR_ARRAY_ITEMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_ARRAY_ITEMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_ARRAY_ITEMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_ARRAY_ITEMS>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_ARRAY_ITEMS),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_ARRAY_ITEMS>())).objects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_ARRAY_ITEMS),
            "::",
            stringify!(objects)
        )
    );
}
pub type YR_ARRAY_ITEMS = _YR_ARRAY_ITEMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SIZED_STRING {
    pub length: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub c_string: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout__SIZED_STRING() {
    assert_eq!(
        ::std::mem::size_of::<_SIZED_STRING>(),
        12usize,
        concat!("Size of: ", stringify!(_SIZED_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<_SIZED_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(_SIZED_STRING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SIZED_STRING>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SIZED_STRING),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SIZED_STRING>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SIZED_STRING),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SIZED_STRING>())).c_string as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SIZED_STRING),
            "::",
            stringify!(c_string)
        )
    );
}
pub type SIZED_STRING = _SIZED_STRING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _YR_META {
    pub type_: i32,
    pub integer: i32,
    pub __bindgen_anon_1: _YR_META__bindgen_ty_1,
    pub __bindgen_anon_2: _YR_META__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _YR_META__bindgen_ty_1 {
    pub identifier: *mut ::std::os::raw::c_char,
    pub identifier_: i64,
}
#[test]
fn bindgen_test_layout__YR_META__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_YR_META__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_YR_META__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_META__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_META__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_META__bindgen_ty_1>())).identifier as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_META__bindgen_ty_1),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_META__bindgen_ty_1>())).identifier_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_META__bindgen_ty_1),
            "::",
            stringify!(identifier_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _YR_META__bindgen_ty_2 {
    pub string: *mut ::std::os::raw::c_char,
    pub string_: i64,
}
#[test]
fn bindgen_test_layout__YR_META__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_YR_META__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_YR_META__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_META__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_META__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_META__bindgen_ty_2>())).string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_META__bindgen_ty_2),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_META__bindgen_ty_2>())).string_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_META__bindgen_ty_2),
            "::",
            stringify!(string_)
        )
    );
}
#[test]
fn bindgen_test_layout__YR_META() {
    assert_eq!(
        ::std::mem::size_of::<_YR_META>(),
        24usize,
        concat!("Size of: ", stringify!(_YR_META))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_META>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_META))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_META>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_META),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_META>())).integer as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_META),
            "::",
            stringify!(integer)
        )
    );
}
pub type YR_META = _YR_META;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _YR_EXTERNAL_VARIABLE {
    pub type_: i32,
    pub integer: i64,
    pub __bindgen_anon_1: _YR_EXTERNAL_VARIABLE__bindgen_ty_1,
    pub __bindgen_anon_2: _YR_EXTERNAL_VARIABLE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _YR_EXTERNAL_VARIABLE__bindgen_ty_1 {
    pub identifier: *mut ::std::os::raw::c_char,
    pub identifier_: i64,
}
#[test]
fn bindgen_test_layout__YR_EXTERNAL_VARIABLE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_YR_EXTERNAL_VARIABLE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_YR_EXTERNAL_VARIABLE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_EXTERNAL_VARIABLE__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_YR_EXTERNAL_VARIABLE__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_EXTERNAL_VARIABLE__bindgen_ty_1>())).identifier as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_EXTERNAL_VARIABLE__bindgen_ty_1),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_EXTERNAL_VARIABLE__bindgen_ty_1>())).identifier_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_EXTERNAL_VARIABLE__bindgen_ty_1),
            "::",
            stringify!(identifier_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _YR_EXTERNAL_VARIABLE__bindgen_ty_2 {
    pub string: *mut ::std::os::raw::c_char,
    pub string_: i64,
}
#[test]
fn bindgen_test_layout__YR_EXTERNAL_VARIABLE__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_YR_EXTERNAL_VARIABLE__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_YR_EXTERNAL_VARIABLE__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_EXTERNAL_VARIABLE__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_YR_EXTERNAL_VARIABLE__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_EXTERNAL_VARIABLE__bindgen_ty_2>())).string as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_EXTERNAL_VARIABLE__bindgen_ty_2),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_EXTERNAL_VARIABLE__bindgen_ty_2>())).string_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_EXTERNAL_VARIABLE__bindgen_ty_2),
            "::",
            stringify!(string_)
        )
    );
}
#[test]
fn bindgen_test_layout__YR_EXTERNAL_VARIABLE() {
    assert_eq!(
        ::std::mem::size_of::<_YR_EXTERNAL_VARIABLE>(),
        32usize,
        concat!("Size of: ", stringify!(_YR_EXTERNAL_VARIABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_EXTERNAL_VARIABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_EXTERNAL_VARIABLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_EXTERNAL_VARIABLE>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_EXTERNAL_VARIABLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_YR_EXTERNAL_VARIABLE>())).integer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_EXTERNAL_VARIABLE),
            "::",
            stringify!(integer)
        )
    );
}
pub type YR_EXTERNAL_VARIABLE = _YR_EXTERNAL_VARIABLE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _YR_NAMESPACE {
    pub __bindgen_anon_1: _YR_NAMESPACE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _YR_NAMESPACE__bindgen_ty_1 {
    pub name: *mut ::std::os::raw::c_char,
    pub name_: i64,
}
#[test]
fn bindgen_test_layout__YR_NAMESPACE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_YR_NAMESPACE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_YR_NAMESPACE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_NAMESPACE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_NAMESPACE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_NAMESPACE__bindgen_ty_1>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_NAMESPACE__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_YR_NAMESPACE__bindgen_ty_1>())).name_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_YR_NAMESPACE__bindgen_ty_1),
            "::",
            stringify!(name_)
        )
    );
}
#[test]
fn bindgen_test_layout__YR_NAMESPACE() {
    assert_eq!(
        ::std::mem::size_of::<_YR_NAMESPACE>(),
        8usize,
        concat!("Size of: ", stringify!(_YR_NAMESPACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_NAMESPACE>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_NAMESPACE))
    );
}
pub type YR_NAMESPACE = _YR_NAMESPACE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RE_NODE {
    pub type_: ::std::os::raw::c_int,
    pub __bindgen_anon_1: RE_NODE__bindgen_ty_1,
    pub __bindgen_anon_2: RE_NODE__bindgen_ty_2,
    pub greedy: ::std::os::raw::c_int,
    pub class_vector: *mut u8,
    pub left: *mut RE_NODE,
    pub right: *mut RE_NODE,
    pub forward_code: *mut ::std::os::raw::c_void,
    pub backward_code: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RE_NODE__bindgen_ty_1 {
    pub value: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub start: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RE_NODE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RE_NODE__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RE_NODE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_NODE__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RE_NODE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE__bindgen_ty_1>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE__bindgen_ty_1>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE__bindgen_ty_1>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE__bindgen_ty_1),
            "::",
            stringify!(start)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RE_NODE__bindgen_ty_2 {
    pub mask: ::std::os::raw::c_int,
    pub end: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RE_NODE__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<RE_NODE__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(RE_NODE__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_NODE__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(RE_NODE__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE__bindgen_ty_2>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE__bindgen_ty_2),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE__bindgen_ty_2>())).end as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE__bindgen_ty_2),
            "::",
            stringify!(end)
        )
    );
}
#[test]
fn bindgen_test_layout_RE_NODE() {
    assert_eq!(
        ::std::mem::size_of::<RE_NODE>(),
        56usize,
        concat!("Size of: ", stringify!(RE_NODE))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_NODE>(),
        8usize,
        concat!("Alignment of ", stringify!(RE_NODE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE>())).greedy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE),
            "::",
            stringify!(greedy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE>())).class_vector as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE),
            "::",
            stringify!(class_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE>())).left as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE>())).right as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE>())).forward_code as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE),
            "::",
            stringify!(forward_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE_NODE>())).backward_code as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RE_NODE),
            "::",
            stringify!(backward_code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RE {
    pub flags: u32,
    pub root_node: *mut RE_NODE,
    pub error_message: *const ::std::os::raw::c_char,
    pub error_code: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RE() {
    assert_eq!(
        ::std::mem::size_of::<RE>(),
        32usize,
        concat!("Size of: ", stringify!(RE))
    );
    assert_eq!(
        ::std::mem::align_of::<RE>(),
        8usize,
        concat!("Alignment of ", stringify!(RE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE>())).flags as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(RE), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE>())).root_node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RE),
            "::",
            stringify!(root_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE>())).error_message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RE),
            "::",
            stringify!(error_message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RE>())).error_code as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RE),
            "::",
            stringify!(error_code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _yc_rule {
    pub link: _yc_rule__bindgen_ty_1,
    pub strings: _yc_rule_sq,
    pub identifier: *mut ::std::os::raw::c_char,
    pub g_flags: u32,
    pub cl_flags: u32,
    pub code_start: *mut u8,
    pub lsigid: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _yc_rule__bindgen_ty_1 {
    pub stqe_next: *mut _yc_rule,
}
#[test]
fn bindgen_test_layout__yc_rule__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_yc_rule__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_yc_rule__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_yc_rule__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_yc_rule__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_yc_rule__bindgen_ty_1>())).stqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _yc_rule_sq {
    pub stqh_first: *mut _yc_string,
    pub stqh_last: *mut *mut _yc_string,
}
#[test]
fn bindgen_test_layout__yc_rule_sq() {
    assert_eq!(
        ::std::mem::size_of::<_yc_rule_sq>(),
        16usize,
        concat!("Size of: ", stringify!(_yc_rule_sq))
    );
    assert_eq!(
        ::std::mem::align_of::<_yc_rule_sq>(),
        8usize,
        concat!("Alignment of ", stringify!(_yc_rule_sq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule_sq>())).stqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule_sq),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule_sq>())).stqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule_sq),
            "::",
            stringify!(stqh_last)
        )
    );
}
#[test]
fn bindgen_test_layout__yc_rule() {
    assert_eq!(
        ::std::mem::size_of::<_yc_rule>(),
        56usize,
        concat!("Size of: ", stringify!(_yc_rule))
    );
    assert_eq!(
        ::std::mem::align_of::<_yc_rule>(),
        8usize,
        concat!("Alignment of ", stringify!(_yc_rule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule>())).strings as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule>())).identifier as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule>())).g_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule),
            "::",
            stringify!(g_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule>())).cl_flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule),
            "::",
            stringify!(cl_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule>())).code_start as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule),
            "::",
            stringify!(code_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_rule>())).lsigid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_rule),
            "::",
            stringify!(lsigid)
        )
    );
}
pub type yc_rule = _yc_rule;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _yc_string {
    pub link: _yc_string__bindgen_ty_1,
    pub g_flags: i32,
    pub length: i32,
    pub __bindgen_anon_1: _yc_string__bindgen_ty_2,
    pub __bindgen_anon_2: _yc_string__bindgen_ty_3,
    pub __bindgen_anon_3: _yc_string__bindgen_ty_4,
    pub subsig_id: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _yc_string__bindgen_ty_1 {
    pub stqe_next: *mut _yc_string,
}
#[test]
fn bindgen_test_layout__yc_string__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_yc_string__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_yc_string__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_yc_string__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_yc_string__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_yc_string__bindgen_ty_1>())).stqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _yc_string__bindgen_ty_2 {
    pub identifier: *mut ::std::os::raw::c_char,
    pub identifier_: i64,
}
#[test]
fn bindgen_test_layout__yc_string__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_yc_string__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_yc_string__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_yc_string__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_yc_string__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_yc_string__bindgen_ty_2>())).identifier as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string__bindgen_ty_2),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_yc_string__bindgen_ty_2>())).identifier_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string__bindgen_ty_2),
            "::",
            stringify!(identifier_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _yc_string__bindgen_ty_3 {
    pub string: *mut u8,
    pub string_: i64,
}
#[test]
fn bindgen_test_layout__yc_string__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<_yc_string__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(_yc_string__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_yc_string__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(_yc_string__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_string__bindgen_ty_3>())).string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string__bindgen_ty_3),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_yc_string__bindgen_ty_3>())).string_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string__bindgen_ty_3),
            "::",
            stringify!(string_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _yc_string__bindgen_ty_4 {
    pub chained_to: *mut _YR_STRING,
    pub chained_to_: i64,
}
#[test]
fn bindgen_test_layout__yc_string__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<_yc_string__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(_yc_string__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<_yc_string__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(_yc_string__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_yc_string__bindgen_ty_4>())).chained_to as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string__bindgen_ty_4),
            "::",
            stringify!(chained_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_yc_string__bindgen_ty_4>())).chained_to_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string__bindgen_ty_4),
            "::",
            stringify!(chained_to_)
        )
    );
}
#[test]
fn bindgen_test_layout__yc_string() {
    assert_eq!(
        ::std::mem::size_of::<_yc_string>(),
        48usize,
        concat!("Size of: ", stringify!(_yc_string))
    );
    assert_eq!(
        ::std::mem::align_of::<_yc_string>(),
        8usize,
        concat!("Alignment of ", stringify!(_yc_string))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_string>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_string>())).g_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string),
            "::",
            stringify!(g_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_string>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_yc_string>())).subsig_id as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_yc_string),
            "::",
            stringify!(subsig_id)
        )
    );
}
pub type yc_string = _yc_string;
pub type YR_RULE = yc_rule;
pub type YR_STRING = yc_string;
extern "C" {
    pub static mut cli_debug_flag: u8;
}
extern "C" {
    pub static mut cli_always_gen_section_hash: u8;
}
extern "C" {
    pub fn __sigismember(
        arg1: *const __sigset_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type sigval_t = sigval;
pub type __sigchld_clock_t = __clock_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_tid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __sigchld_clock_t,
    pub si_stime: __sigchld_clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_utime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_stime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub si_addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._lower
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._upper
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_lsb
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_bnd
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_bnd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_fd as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigchld as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigfault as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigpoll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
pub const SI_ASYNCNL: ::std::os::raw::c_int = -60;
pub const SI_TKILL: ::std::os::raw::c_int = -6;
pub const SI_SIGIO: ::std::os::raw::c_int = -5;
pub const SI_ASYNCIO: ::std::os::raw::c_int = -4;
pub const SI_MESGQ: ::std::os::raw::c_int = -3;
pub const SI_TIMER: ::std::os::raw::c_int = -2;
pub const SI_QUEUE: ::std::os::raw::c_int = -1;
pub const SI_USER: ::std::os::raw::c_int = 0;
pub const SI_KERNEL: ::std::os::raw::c_int = 128;
pub type _bindgen_ty_17 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 2;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 3;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 4;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 3;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 4;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 5;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 6;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 7;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const BUS_MCEERR_AR: ::std::os::raw::c_uint = 4;
pub const BUS_MCEERR_AO: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 0;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 2;
pub const SIGEV_THREAD_ID: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub padding: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).padding as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).fpstate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).__fpstate_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rcx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eflags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__pad0 as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub reserved1: [__uint64_t; 2usize],
    pub reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(
        ::std::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).xstate_bv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: size_t,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type stack_t = sigaltstack;
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(padding)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: _libc_fpstate,
}
#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<ucontext>(),
        936usize,
        concat!("Size of: ", stringify!(ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_mcontext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).uc_sigmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext>())).__fpregs_mem as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext),
            "::",
            stringify!(__fpregs_mem)
        )
    );
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(__ss: *const sigaltstack, __oss: *mut sigaltstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitset_tag {
    pub bitset: *mut ::std::os::raw::c_uchar,
    pub length: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_bitset_tag() {
    assert_eq!(
        ::std::mem::size_of::<bitset_tag>(),
        16usize,
        concat!("Size of: ", stringify!(bitset_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<bitset_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(bitset_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitset_tag>())).bitset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bitset_tag),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitset_tag>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bitset_tag),
            "::",
            stringify!(length)
        )
    );
}
pub type bitset_t = bitset_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct recursion_level_tag {
    pub type_: cli_file_t,
    pub size: size_t,
    pub fmap: *mut cl_fmap_t,
    pub recursion_level_buffer: u32,
    pub recursion_level_buffer_fmap: u32,
    pub is_normalized_layer: bool,
}
#[test]
fn bindgen_test_layout_recursion_level_tag() {
    assert_eq!(
        ::std::mem::size_of::<recursion_level_tag>(),
        40usize,
        concat!("Size of: ", stringify!(recursion_level_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<recursion_level_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(recursion_level_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<recursion_level_tag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(recursion_level_tag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<recursion_level_tag>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(recursion_level_tag),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<recursion_level_tag>())).fmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(recursion_level_tag),
            "::",
            stringify!(fmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<recursion_level_tag>())).recursion_level_buffer as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(recursion_level_tag),
            "::",
            stringify!(recursion_level_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<recursion_level_tag>())).recursion_level_buffer_fmap as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(recursion_level_tag),
            "::",
            stringify!(recursion_level_buffer_fmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<recursion_level_tag>())).is_normalized_layer as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(recursion_level_tag),
            "::",
            stringify!(is_normalized_layer)
        )
    );
}
pub type recursion_level_t = recursion_level_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ctx_tag {
    #[doc = "< (optional) The filepath of the original scan target."]
    pub target_filepath: *mut ::std::os::raw::c_char,
    #[doc = "< (optional) The filepath of the current file being parsed. May be a temp file."]
    pub sub_filepath: *const ::std::os::raw::c_char,
    #[doc = "< The directory to store tmp files at this recursion depth."]
    pub sub_tmpdir: *mut ::std::os::raw::c_char,
    pub virname: *mut *const ::std::os::raw::c_char,
    pub num_viruses: ::std::os::raw::c_uint,
    pub scanned: *mut ::std::os::raw::c_ulong,
    pub root: *const cli_matcher,
    pub engine: *const cl_engine,
    pub scansize: u64,
    pub options: *mut cl_scan_options,
    pub scannedfiles: ::std::os::raw::c_uint,
    pub found_possibly_unwanted: ::std::os::raw::c_uint,
    pub corrupted_input: ::std::os::raw::c_uint,
    pub img_validate: ::std::os::raw::c_uint,
    pub recursion_stack: *mut recursion_level_t,
    pub recursion_stack_size: u32,
    pub recursion_level: u32,
    pub fmap: *mut fmap_t,
    pub next_layer_is_normalized: bool,
    pub handlertype_hash: [::std::os::raw::c_uchar; 16usize],
    pub dconf: *mut cli_dconf,
    pub hook_lsig_matches: *mut bitset_t,
    pub cb_ctx: *mut ::std::os::raw::c_void,
    pub perf: *mut cli_events_t,
    pub properties: *mut json_object,
    pub wrkproperty: *mut json_object,
    pub time_limit: timeval,
    pub limit_exceeded: bool,
    pub abort_scan: bool,
}
#[test]
fn bindgen_test_layout_cli_ctx_tag() {
    assert_eq!(
        ::std::mem::size_of::<cli_ctx_tag>(),
        216usize,
        concat!("Size of: ", stringify!(cli_ctx_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ctx_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ctx_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).target_filepath as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(target_filepath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).sub_filepath as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(sub_filepath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).sub_tmpdir as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(sub_tmpdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).virname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(virname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).num_viruses as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(num_viruses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).scanned as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(scanned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).root as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).engine as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).scansize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(scansize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).options as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).scannedfiles as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(scannedfiles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_ctx_tag>())).found_possibly_unwanted as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(found_possibly_unwanted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).corrupted_input as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(corrupted_input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).img_validate as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(img_validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).recursion_stack as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(recursion_stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_ctx_tag>())).recursion_stack_size as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(recursion_stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).recursion_level as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(recursion_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).fmap as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(fmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_ctx_tag>())).next_layer_is_normalized as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(next_layer_is_normalized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).handlertype_hash as *const _ as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(handlertype_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).dconf as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(dconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).hook_lsig_matches as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(hook_lsig_matches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).cb_ctx as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(cb_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).perf as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(perf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).properties as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).wrkproperty as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(wrkproperty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).time_limit as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(time_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).limit_exceeded as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(limit_exceeded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ctx_tag>())).abort_scan as *const _ as usize },
        209usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ctx_tag),
            "::",
            stringify!(abort_scan)
        )
    );
}
pub type cli_ctx = cli_ctx_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_flagged_sample {
    pub virus_name: *mut *mut ::std::os::raw::c_char,
    pub md5: [::std::os::raw::c_char; 16usize],
    pub size: u32,
    pub hits: u32,
    pub sections: *mut stats_section_t,
    pub prev: *mut cli_flagged_sample,
    pub next: *mut cli_flagged_sample,
}
#[test]
fn bindgen_test_layout_cli_flagged_sample() {
    assert_eq!(
        ::std::mem::size_of::<cli_flagged_sample>(),
        56usize,
        concat!("Size of: ", stringify!(cli_flagged_sample))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_flagged_sample>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_flagged_sample))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_flagged_sample>())).virus_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_flagged_sample),
            "::",
            stringify!(virus_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_flagged_sample>())).md5 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_flagged_sample),
            "::",
            stringify!(md5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_flagged_sample>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_flagged_sample),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_flagged_sample>())).hits as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_flagged_sample),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_flagged_sample>())).sections as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_flagged_sample),
            "::",
            stringify!(sections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_flagged_sample>())).prev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_flagged_sample),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_flagged_sample>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_flagged_sample),
            "::",
            stringify!(next)
        )
    );
}
pub type cli_flagged_sample_t = cli_flagged_sample;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_clamav_intel {
    pub hostid: *mut ::std::os::raw::c_char,
    pub host_info: *mut ::std::os::raw::c_char,
    pub samples: *mut cli_flagged_sample_t,
    pub nsamples: u32,
    pub maxsamples: u32,
    pub maxmem: u32,
    pub timeout: u32,
    pub nextupdate: time_t,
    pub engine: *mut cl_engine,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_cli_clamav_intel() {
    assert_eq!(
        ::std::mem::size_of::<cli_clamav_intel>(),
        96usize,
        concat!("Size of: ", stringify!(cli_clamav_intel))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_clamav_intel>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_clamav_intel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).hostid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(hostid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).host_info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(host_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).samples as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).nsamples as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(nsamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).maxsamples as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(maxsamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).maxmem as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(maxmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).timeout as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).nextupdate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(nextupdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).engine as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_clamav_intel>())).mutex as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_clamav_intel),
            "::",
            stringify!(mutex)
        )
    );
}
pub type cli_intel_t = cli_clamav_intel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icon_groupset {
    pub v: [[u64; 4usize]; 2usize],
}
#[test]
fn bindgen_test_layout_icon_groupset() {
    assert_eq!(
        ::std::mem::size_of::<icon_groupset>(),
        64usize,
        concat!("Size of: ", stringify!(icon_groupset))
    );
    assert_eq!(
        ::std::mem::align_of::<icon_groupset>(),
        8usize,
        concat!("Alignment of ", stringify!(icon_groupset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icon_groupset>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icon_groupset),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icomtr {
    pub group: [::std::os::raw::c_uint; 2usize],
    pub color_avg: [::std::os::raw::c_uint; 3usize],
    pub color_x: [::std::os::raw::c_uint; 3usize],
    pub color_y: [::std::os::raw::c_uint; 3usize],
    pub gray_avg: [::std::os::raw::c_uint; 3usize],
    pub gray_x: [::std::os::raw::c_uint; 3usize],
    pub gray_y: [::std::os::raw::c_uint; 3usize],
    pub bright_avg: [::std::os::raw::c_uint; 3usize],
    pub bright_x: [::std::os::raw::c_uint; 3usize],
    pub bright_y: [::std::os::raw::c_uint; 3usize],
    pub dark_avg: [::std::os::raw::c_uint; 3usize],
    pub dark_x: [::std::os::raw::c_uint; 3usize],
    pub dark_y: [::std::os::raw::c_uint; 3usize],
    pub edge_avg: [::std::os::raw::c_uint; 3usize],
    pub edge_x: [::std::os::raw::c_uint; 3usize],
    pub edge_y: [::std::os::raw::c_uint; 3usize],
    pub noedge_avg: [::std::os::raw::c_uint; 3usize],
    pub noedge_x: [::std::os::raw::c_uint; 3usize],
    pub noedge_y: [::std::os::raw::c_uint; 3usize],
    pub rsum: ::std::os::raw::c_uint,
    pub gsum: ::std::os::raw::c_uint,
    pub bsum: ::std::os::raw::c_uint,
    pub ccount: ::std::os::raw::c_uint,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_icomtr() {
    assert_eq!(
        ::std::mem::size_of::<icomtr>(),
        248usize,
        concat!("Size of: ", stringify!(icomtr))
    );
    assert_eq!(
        ::std::mem::align_of::<icomtr>(),
        8usize,
        concat!("Alignment of ", stringify!(icomtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).color_avg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(color_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).color_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(color_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).color_y as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(color_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).gray_avg as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(gray_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).gray_x as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(gray_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).gray_y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(gray_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).bright_avg as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(bright_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).bright_x as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(bright_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).bright_y as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(bright_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).dark_avg as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(dark_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).dark_x as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(dark_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).dark_y as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(dark_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).edge_avg as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(edge_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).edge_x as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(edge_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).edge_y as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(edge_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).noedge_avg as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(noedge_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).noedge_x as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(noedge_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).noedge_y as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(noedge_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).rsum as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(rsum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).gsum as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(gsum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).bsum as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(bsum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).ccount as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(ccount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icomtr>())).name as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(icomtr),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icon_matcher {
    pub group_names: [*mut *mut ::std::os::raw::c_char; 2usize],
    pub group_counts: [::std::os::raw::c_uint; 2usize],
    pub icons: [*mut icomtr; 3usize],
    pub icon_counts: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_icon_matcher() {
    assert_eq!(
        ::std::mem::size_of::<icon_matcher>(),
        64usize,
        concat!("Size of: ", stringify!(icon_matcher))
    );
    assert_eq!(
        ::std::mem::align_of::<icon_matcher>(),
        8usize,
        concat!("Alignment of ", stringify!(icon_matcher))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icon_matcher>())).group_names as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icon_matcher),
            "::",
            stringify!(group_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icon_matcher>())).group_counts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(icon_matcher),
            "::",
            stringify!(group_counts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icon_matcher>())).icons as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(icon_matcher),
            "::",
            stringify!(icons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icon_matcher>())).icon_counts as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(icon_matcher),
            "::",
            stringify!(icon_counts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_dbinfo {
    pub name: *mut ::std::os::raw::c_char,
    pub hash: *mut ::std::os::raw::c_char,
    pub size: size_t,
    pub cvd: *mut cl_cvd,
    pub next: *mut cli_dbinfo,
}
#[test]
fn bindgen_test_layout_cli_dbinfo() {
    assert_eq!(
        ::std::mem::size_of::<cli_dbinfo>(),
        40usize,
        concat!("Size of: ", stringify!(cli_dbinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_dbinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_dbinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbinfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbinfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbinfo>())).hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbinfo),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbinfo>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbinfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbinfo>())).cvd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbinfo),
            "::",
            stringify!(cvd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_dbinfo>())).next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_dbinfo),
            "::",
            stringify!(next)
        )
    );
}
pub const cl_pwdb_t_CLI_PWDB_ANY: cl_pwdb_t = 0;
pub const cl_pwdb_t_CLI_PWDB_ZIP: cl_pwdb_t = 1;
pub const cl_pwdb_t_CLI_PWDB_RAR: cl_pwdb_t = 2;
pub type cl_pwdb_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pwdb {
    pub name: *mut ::std::os::raw::c_char,
    pub passwd: *mut ::std::os::raw::c_char,
    pub length: u16,
    pub next: *mut cli_pwdb,
}
#[test]
fn bindgen_test_layout_cli_pwdb() {
    assert_eq!(
        ::std::mem::size_of::<cli_pwdb>(),
        32usize,
        concat!("Size of: ", stringify!(cli_pwdb))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_pwdb>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_pwdb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pwdb>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pwdb),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pwdb>())).passwd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pwdb),
            "::",
            stringify!(passwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pwdb>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pwdb),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pwdb>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pwdb),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_engine {
    pub refcount: u32,
    pub sdb: u32,
    pub dboptions: u32,
    pub dbversion: [u32; 2usize],
    pub ac_only: u32,
    pub ac_mindepth: u32,
    pub ac_maxdepth: u32,
    pub tmpdir: *mut ::std::os::raw::c_char,
    pub keeptmp: u32,
    pub engine_options: u64,
    pub maxscantime: u32,
    pub maxscansize: u64,
    pub maxfilesize: u64,
    pub max_recursion_level: u32,
    pub maxfiles: u32,
    pub min_cc_count: u32,
    pub min_ssn_count: u32,
    pub root: *mut *mut cli_matcher,
    pub hm_hdb: *mut cli_matcher,
    pub hm_mdb: *mut cli_matcher,
    pub hm_imp: *mut cli_matcher,
    pub hm_fp: *mut cli_matcher,
    pub cdb: *mut cli_cdb,
    pub allow_list_matcher: *mut regex_matcher,
    pub domain_list_matcher: *mut regex_matcher,
    pub phishcheck: *mut phishcheck,
    pub dconf: *mut cli_dconf,
    pub ftypes: *mut cli_ftype,
    pub ptypes: *mut cli_ftype,
    pub pwdbs: *mut *mut cli_pwdb,
    pub test_root: *mut cli_matcher,
    pub ignored: *mut cli_matcher,
    pub pua_cats: *mut ::std::os::raw::c_char,
    pub iconcheck: *mut icon_matcher,
    pub cache: *mut CACHE,
    pub dbinfo: *mut cli_dbinfo,
    pub num_total_signatures: size_t,
    pub mempool: *mut mpool_t,
    pub cmgr: crtmgr,
    pub cb_pre_cache: clcb_pre_cache,
    pub cb_pre_scan: clcb_pre_scan,
    pub cb_post_scan: clcb_post_scan,
    pub cb_virus_found: clcb_virus_found,
    pub cb_sigload: clcb_sigload,
    pub cb_sigload_ctx: *mut ::std::os::raw::c_void,
    pub cb_hash: clcb_hash,
    pub cb_meta: clcb_meta,
    pub cb_file_props: clcb_file_props,
    pub cb_sigload_progress: clcb_progress,
    pub cb_sigload_progress_ctx: *mut ::std::os::raw::c_void,
    pub cb_engine_compile_progress: clcb_progress,
    pub cb_engine_compile_progress_ctx: *mut ::std::os::raw::c_void,
    pub cb_engine_free_progress: clcb_progress,
    pub cb_engine_free_progress_ctx: *mut ::std::os::raw::c_void,
    pub bcs: cli_all_bc,
    pub hooks: [*mut ::std::os::raw::c_uint; 7usize],
    pub hooks_cnt: [::std::os::raw::c_uint; 7usize],
    pub hook_lsig_ids: ::std::os::raw::c_uint,
    pub bytecode_security: bytecode_security,
    pub bytecode_timeout: u32,
    pub bytecode_mode: bytecode_mode,
    pub maxembeddedpe: u64,
    pub maxhtmlnormalize: u64,
    pub maxhtmlnotags: u64,
    pub maxscriptnormalize: u64,
    pub maxziptypercg: u64,
    pub stats_data: *mut ::std::os::raw::c_void,
    pub cb_stats_add_sample: clcb_stats_add_sample,
    pub cb_stats_remove_sample: clcb_stats_remove_sample,
    pub cb_stats_decrement_count: clcb_stats_decrement_count,
    pub cb_stats_submit: clcb_stats_submit,
    pub cb_stats_flush: clcb_stats_flush,
    pub cb_stats_get_num: clcb_stats_get_num,
    pub cb_stats_get_size: clcb_stats_get_size,
    pub cb_stats_get_hostid: clcb_stats_get_hostid,
    pub maxpartitions: u32,
    pub maxiconspe: u32,
    pub maxrechwp3: u32,
    pub pcre_match_limit: u64,
    pub pcre_recmatch_limit: u64,
    pub pcre_max_filesize: u64,
    pub yara_global: *mut _yara_global,
}
#[test]
fn bindgen_test_layout_cl_engine() {
    assert_eq!(
        ::std::mem::size_of::<cl_engine>(),
        1184usize,
        concat!("Size of: ", stringify!(cl_engine))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_engine>(),
        8usize,
        concat!("Alignment of ", stringify!(cl_engine))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).sdb as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(sdb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).dboptions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(dboptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).dbversion as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(dbversion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).ac_only as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(ac_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).ac_mindepth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(ac_mindepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).ac_maxdepth as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(ac_maxdepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).tmpdir as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(tmpdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).keeptmp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(keeptmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).engine_options as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(engine_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxscantime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxscantime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxscansize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxscansize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxfilesize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxfilesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).max_recursion_level as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(max_recursion_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxfiles as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxfiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).min_cc_count as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(min_cc_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).min_ssn_count as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(min_ssn_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).root as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).hm_hdb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(hm_hdb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).hm_mdb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(hm_mdb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).hm_imp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(hm_imp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).hm_fp as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(hm_fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cdb as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cdb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).allow_list_matcher as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(allow_list_matcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).domain_list_matcher as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(domain_list_matcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).phishcheck as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(phishcheck)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).dconf as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(dconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).ftypes as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(ftypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).ptypes as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(ptypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).pwdbs as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(pwdbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).test_root as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(test_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).ignored as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(ignored)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).pua_cats as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(pua_cats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).iconcheck as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(iconcheck)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cache as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).dbinfo as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(dbinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).num_total_signatures as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(num_total_signatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).mempool as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(mempool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cmgr as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cmgr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_pre_cache as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_pre_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_pre_scan as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_pre_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_post_scan as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_post_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_virus_found as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_virus_found)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_sigload as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_sigload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_sigload_ctx as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_sigload_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_hash as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_meta as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_file_props as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_file_props)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_sigload_progress as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_sigload_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_engine>())).cb_sigload_progress_ctx as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_sigload_progress_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_engine>())).cb_engine_compile_progress as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_engine_compile_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_engine>())).cb_engine_compile_progress_ctx as *const _
                as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_engine_compile_progress_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_engine>())).cb_engine_free_progress as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_engine_free_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_engine>())).cb_engine_free_progress_ctx as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_engine_free_progress_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).bcs as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(bcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).hooks as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).hooks_cnt as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(hooks_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).hook_lsig_ids as *const _ as usize },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(hook_lsig_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).bytecode_security as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(bytecode_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).bytecode_timeout as *const _ as usize },
        1012usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(bytecode_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).bytecode_mode as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(bytecode_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxembeddedpe as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxembeddedpe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxhtmlnormalize as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxhtmlnormalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxhtmlnotags as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxhtmlnotags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxscriptnormalize as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxscriptnormalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxziptypercg as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxziptypercg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).stats_data as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(stats_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_stats_add_sample as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_stats_add_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_engine>())).cb_stats_remove_sample as *const _ as usize
        },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_stats_remove_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_engine>())).cb_stats_decrement_count as *const _ as usize
        },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_stats_decrement_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_stats_submit as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_stats_submit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_stats_flush as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_stats_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_stats_get_num as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_stats_get_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_stats_get_size as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_stats_get_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).cb_stats_get_hostid as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(cb_stats_get_hostid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxpartitions as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxpartitions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxiconspe as *const _ as usize },
        1140usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxiconspe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).maxrechwp3 as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(maxrechwp3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).pcre_match_limit as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(pcre_match_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).pcre_recmatch_limit as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(pcre_recmatch_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).pcre_max_filesize as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(pcre_max_filesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_engine>())).yara_global as *const _ as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_engine),
            "::",
            stringify!(yara_global)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_settings {
    pub ac_only: u32,
    pub ac_mindepth: u32,
    pub ac_maxdepth: u32,
    pub tmpdir: *mut ::std::os::raw::c_char,
    pub keeptmp: u32,
    pub maxscantime: u32,
    pub maxscansize: u64,
    pub maxfilesize: u64,
    pub max_recursion_level: u32,
    pub maxfiles: u32,
    pub min_cc_count: u32,
    pub min_ssn_count: u32,
    pub bytecode_security: bytecode_security,
    pub bytecode_timeout: u32,
    pub bytecode_mode: bytecode_mode,
    pub pua_cats: *mut ::std::os::raw::c_char,
    pub engine_options: u64,
    pub cb_pre_cache: clcb_pre_cache,
    pub cb_pre_scan: clcb_pre_scan,
    pub cb_post_scan: clcb_post_scan,
    pub cb_virus_found: clcb_virus_found,
    pub cb_sigload: clcb_sigload,
    pub cb_sigload_ctx: *mut ::std::os::raw::c_void,
    pub cb_msg: clcb_msg,
    pub cb_hash: clcb_hash,
    pub cb_meta: clcb_meta,
    pub cb_file_props: clcb_file_props,
    pub cb_sigload_progress: clcb_progress,
    pub cb_sigload_progress_ctx: *mut ::std::os::raw::c_void,
    pub cb_engine_compile_progress: clcb_progress,
    pub cb_engine_compile_progress_ctx: *mut ::std::os::raw::c_void,
    pub cb_engine_free_progress: clcb_progress,
    pub cb_engine_free_progress_ctx: *mut ::std::os::raw::c_void,
    pub maxembeddedpe: u64,
    pub maxhtmlnormalize: u64,
    pub maxhtmlnotags: u64,
    pub maxscriptnormalize: u64,
    pub maxziptypercg: u64,
    pub stats_data: *mut ::std::os::raw::c_void,
    pub cb_stats_add_sample: clcb_stats_add_sample,
    pub cb_stats_remove_sample: clcb_stats_remove_sample,
    pub cb_stats_decrement_count: clcb_stats_decrement_count,
    pub cb_stats_submit: clcb_stats_submit,
    pub cb_stats_flush: clcb_stats_flush,
    pub cb_stats_get_num: clcb_stats_get_num,
    pub cb_stats_get_size: clcb_stats_get_size,
    pub cb_stats_get_hostid: clcb_stats_get_hostid,
    pub maxpartitions: u32,
    pub maxiconspe: u32,
    pub maxrechwp3: u32,
    pub pcre_match_limit: u64,
    pub pcre_recmatch_limit: u64,
    pub pcre_max_filesize: u64,
}
#[test]
fn bindgen_test_layout_cl_settings() {
    assert_eq!(
        ::std::mem::size_of::<cl_settings>(),
        376usize,
        concat!("Size of: ", stringify!(cl_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_settings>(),
        8usize,
        concat!("Alignment of ", stringify!(cl_settings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).ac_only as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(ac_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).ac_mindepth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(ac_mindepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).ac_maxdepth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(ac_maxdepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).tmpdir as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(tmpdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).keeptmp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(keeptmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxscantime as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxscantime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxscansize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxscansize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxfilesize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxfilesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).max_recursion_level as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(max_recursion_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxfiles as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxfiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).min_cc_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(min_cc_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).min_ssn_count as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(min_ssn_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).bytecode_security as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(bytecode_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).bytecode_timeout as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(bytecode_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).bytecode_mode as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(bytecode_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).pua_cats as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(pua_cats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).engine_options as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(engine_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_pre_cache as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_pre_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_pre_scan as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_pre_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_post_scan as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_post_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_virus_found as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_virus_found)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_sigload as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_sigload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_sigload_ctx as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_sigload_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_msg as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_hash as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_meta as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_meta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_file_props as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_file_props)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_sigload_progress as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_sigload_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_settings>())).cb_sigload_progress_ctx as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_sigload_progress_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_settings>())).cb_engine_compile_progress as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_engine_compile_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_settings>())).cb_engine_compile_progress_ctx as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_engine_compile_progress_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_settings>())).cb_engine_free_progress as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_engine_free_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_settings>())).cb_engine_free_progress_ctx as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_engine_free_progress_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxembeddedpe as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxembeddedpe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxhtmlnormalize as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxhtmlnormalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxhtmlnotags as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxhtmlnotags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxscriptnormalize as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxscriptnormalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxziptypercg as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxziptypercg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).stats_data as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(stats_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_stats_add_sample as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_stats_add_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_settings>())).cb_stats_remove_sample as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_stats_remove_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cl_settings>())).cb_stats_decrement_count as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_stats_decrement_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_stats_submit as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_stats_submit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_stats_flush as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_stats_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_stats_get_num as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_stats_get_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_stats_get_size as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_stats_get_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).cb_stats_get_hostid as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(cb_stats_get_hostid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxpartitions as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxpartitions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxiconspe as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxiconspe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).maxrechwp3 as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(maxrechwp3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).pcre_match_limit as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(pcre_match_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).pcre_recmatch_limit as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(pcre_recmatch_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_settings>())).pcre_max_filesize as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_settings),
            "::",
            stringify!(pcre_max_filesize)
        )
    );
}
extern "C" {
    pub static mut cli_unrar_open: ::std::option::Option<
        unsafe extern "C" fn(
            filename: *const ::std::os::raw::c_char,
            hArchive: *mut *mut ::std::os::raw::c_void,
            comment: *mut *mut ::std::os::raw::c_char,
            comment_size: *mut u32,
            debug_flag: u8,
        ) -> cl_unrar_error_t,
    >;
}
extern "C" {
    pub static mut cli_unrar_peek_file_header: ::std::option::Option<
        unsafe extern "C" fn(
            hArchive: *mut ::std::os::raw::c_void,
            file_metadata: *mut unrar_metadata_t,
        ) -> cl_unrar_error_t,
    >;
}
extern "C" {
    pub static mut cli_unrar_extract_file: ::std::option::Option<
        unsafe extern "C" fn(
            hArchive: *mut ::std::os::raw::c_void,
            destPath: *const ::std::os::raw::c_char,
            outputBuffer: *mut ::std::os::raw::c_char,
        ) -> cl_unrar_error_t,
    >;
}
extern "C" {
    pub static mut cli_unrar_skip_file: ::std::option::Option<
        unsafe extern "C" fn(hArchive: *mut ::std::os::raw::c_void) -> cl_unrar_error_t,
    >;
}
extern "C" {
    pub static mut cli_unrar_close:
        ::std::option::Option<unsafe extern "C" fn(hArchive: *mut ::std::os::raw::c_void)>;
}
extern "C" {
    pub static mut have_rar: ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union unaligned_64 {
    pub una_u64: u64,
    pub una_s64: i64,
}
#[test]
fn bindgen_test_layout_unaligned_64() {
    assert_eq!(
        ::std::mem::size_of::<unaligned_64>(),
        8usize,
        concat!("Size of: ", stringify!(unaligned_64))
    );
    assert_eq!(
        ::std::mem::align_of::<unaligned_64>(),
        1usize,
        concat!("Alignment of ", stringify!(unaligned_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unaligned_64>())).una_u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_64),
            "::",
            stringify!(una_u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unaligned_64>())).una_s64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_64),
            "::",
            stringify!(una_s64)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union unaligned_32 {
    pub una_u32: u32,
    pub una_s32: i32,
}
#[test]
fn bindgen_test_layout_unaligned_32() {
    assert_eq!(
        ::std::mem::size_of::<unaligned_32>(),
        4usize,
        concat!("Size of: ", stringify!(unaligned_32))
    );
    assert_eq!(
        ::std::mem::align_of::<unaligned_32>(),
        1usize,
        concat!("Alignment of ", stringify!(unaligned_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unaligned_32>())).una_u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_32),
            "::",
            stringify!(una_u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unaligned_32>())).una_s32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_32),
            "::",
            stringify!(una_s32)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union unaligned_16 {
    pub una_u16: u16,
    pub una_s16: i16,
}
#[test]
fn bindgen_test_layout_unaligned_16() {
    assert_eq!(
        ::std::mem::size_of::<unaligned_16>(),
        2usize,
        concat!("Size of: ", stringify!(unaligned_16))
    );
    assert_eq!(
        ::std::mem::align_of::<unaligned_16>(),
        1usize,
        concat!("Alignment of ", stringify!(unaligned_16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unaligned_16>())).una_u16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_16),
            "::",
            stringify!(una_u16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unaligned_16>())).una_s16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_16),
            "::",
            stringify!(una_s16)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct unaligned_ptr {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_unaligned_ptr() {
    assert_eq!(
        ::std::mem::size_of::<unaligned_ptr>(),
        8usize,
        concat!("Size of: ", stringify!(unaligned_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<unaligned_ptr>(),
        1usize,
        concat!("Alignment of ", stringify!(unaligned_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unaligned_ptr>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unaligned_ptr),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " @brief Append an alert."]
    #[doc = ""]
    #[doc = " An FP-check will verify that the file is not allowed."]
    #[doc = " The allow list check does not happen before the scan because allowing files"]
    #[doc = " is so infrequent that such action would be detrimental to performance."]
    #[doc = ""]
    #[doc = " TODO: Replace implementation with severity scale, and severity threshold"]
    #[doc = " wherein signatures that do not meet the threshold are documented in JSON"]
    #[doc = " metadata but do not halt the scan."]
    #[doc = ""]
    #[doc = " @param ctx       The scan context."]
    #[doc = " @param virname   The alert name."]
    #[doc = " @return cl_error_t CL_VIRUS if scan should be halted due to an alert, CL_CLEAN if scan should continue."]
    pub fn cli_append_virus(
        ctx: *mut cli_ctx,
        virname: *const ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Append a PUA (low severity) alert."]
    #[doc = ""]
    #[doc = " This function will return CLEAN unless in all-match or Heuristic-precedence"]
    #[doc = " modes. The intention is for the scan to continue in case something more"]
    #[doc = " malicious is found."]
    #[doc = ""]
    #[doc = " TODO: Replace implementation with severity scale, and severity threshold"]
    #[doc = " wherein signatures that do not meet the threshold are documented in JSON"]
    #[doc = " metadata but do not halt the scan."]
    #[doc = ""]
    #[doc = " BUG: In normal scan mode (see above), the alert is not FP-checked!"]
    #[doc = ""]
    #[doc = " @param ctx       The scan context."]
    #[doc = " @param virname   The alert name."]
    #[doc = " @return cl_error_t CL_VIRUS if scan should be halted due to an alert, CL_CLEAN if scan should continue."]
    pub fn cli_append_possibly_unwanted(
        ctx: *mut cli_ctx,
        virname: *const ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_get_last_virus(ctx: *const cli_ctx) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_get_last_virus_str(ctx: *const cli_ctx) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_virus_found_cb(ctx: *mut cli_ctx);
}
extern "C" {
    #[doc = " @brief Push a new fmap onto our scan recursion stack."]
    #[doc = ""]
    #[doc = " May fail if we exceed max recursion depth."]
    #[doc = ""]
    #[doc = " @param ctx           The scanning context."]
    #[doc = " @param map           The fmap for the new layer."]
    #[doc = " @param type          The file type. May be CL_TYPE_ANY if unknown. Can change it later with cli_recursion_stack_change_type()."]
    #[doc = " @param is_new_buffer true if the fmap represents a new buffer/file, and not some window into an existing fmap."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful, else CL_EMAXREC if exceeding the max recursion depth."]
    pub fn cli_recursion_stack_push(
        ctx: *mut cli_ctx,
        map: *mut cl_fmap_t,
        type_: cli_file_t,
        is_new_buffer: bool,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Pop off a layer of our scan recursion stack."]
    #[doc = ""]
    #[doc = " Returns the fmap for the popped layer. Does NOT funmap() the fmap for you."]
    #[doc = ""]
    #[doc = " @param ctx           The scanning context."]
    #[doc = " @return cl_fmap_t*   A pointer to the fmap for the popped layer, may return NULL instead if the stack is empty."]
    pub fn cli_recursion_stack_pop(ctx: *mut cli_ctx) -> *mut cl_fmap_t;
}
extern "C" {
    #[doc = " @brief Re-assign the type for the current layer."]
    #[doc = ""]
    #[doc = " @param ctx   The scanning context."]
    #[doc = " @param type  The new file type."]
    pub fn cli_recursion_stack_change_type(ctx: *mut cli_ctx, type_: cli_file_t);
}
extern "C" {
    #[doc = " @brief Get the type of a specific layer."]
    #[doc = ""]
    #[doc = " Ignores normalized layers internally."]
    #[doc = ""]
    #[doc = " For index:"]
    #[doc = "  0 == the outermost (bottom) layer of the stack."]
    #[doc = "  1 == the first layer (probably never explicitly used)."]
    #[doc = " -1 == the present innermost (top) layer of the stack."]
    #[doc = " -2 == the parent layer (or \"container\"). That is, the second from the top of the stack."]
    #[doc = ""]
    #[doc = " @param ctx           The scanning context."]
    #[doc = " @param index         Desired index, will be converted internally as though the normalized layers were stripped out. Don't think too had about it. Or do. \\_()_/"]
    #[doc = " @return cli_file_t   The type of the requested layer,"]
    #[doc = "                      or returns CL_TYPE_ANY if a negative layer is requested,"]
    #[doc = "                      or returns CL_TYPE_IGNORED if requested layer too high."]
    pub fn cli_recursion_stack_get_type(
        ctx: *mut cli_ctx,
        index: ::std::os::raw::c_int,
    ) -> cli_file_t;
}
extern "C" {
    #[doc = " @brief Get the size of a specific layer."]
    #[doc = ""]
    #[doc = " Ignores normalized layers internally."]
    #[doc = ""]
    #[doc = " For index:"]
    #[doc = "  0 == the outermost (bottom) layer of the stack."]
    #[doc = "  1 == the first layer (probably never explicitly used)."]
    #[doc = " -1 == the present innermost (top) layer of the stack."]
    #[doc = " -2 == the parent layer (or \"container\"). That is, the second from the top of the stack."]
    #[doc = ""]
    #[doc = " @param ctx           The scanning context."]
    #[doc = " @param index         Desired index, will be converted internally as though the normalized layers were stripped out. Don't think too had about it. Or do. \\_()_/"]
    #[doc = " @return cli_file_t   The size of the requested layer,"]
    #[doc = "                      or returns the size of the whole file if a negative layer is requested,"]
    #[doc = "                      or returns 0 if requested layer too high."]
    pub fn cli_recursion_stack_get_size(ctx: *mut cli_ctx, index: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn cli_warnmsg(str_: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cli_errmsg(str_: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cli_infomsg(ctx: *const cli_ctx, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cli_logg_setup(ctx: *const cli_ctx);
}
extern "C" {
    pub fn cli_logg_unsetup();
}
extern "C" {
    pub fn cli_dbgmsg_internal(str_: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cli_malloc(nmemb: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cli_calloc(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Wrapper around realloc that limits how much may be allocated to CLI_MAX_ALLOCATION."]
    #[doc = ""]
    #[doc = " Please use CLI_REALLOC() with `goto done;` error handling instead."]
    #[doc = ""]
    #[doc = " IMPORTANT: This differs from realloc() in that if size==0, it will NOT free the ptr."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = " @param size"]
    #[doc = " @return void*"]
    pub fn cli_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Wrapper around realloc that limits how much may be allocated to CLI_MAX_ALLOCATION."]
    #[doc = ""]
    #[doc = " Please use CLI_REALLOC() with `goto done;` error handling instead."]
    #[doc = ""]
    #[doc = " IMPORTANT: This differs from realloc() in that if size==0, it will NOT free the ptr."]
    #[doc = ""]
    #[doc = " WARNING: This differs from cli_realloc() in that it will free the ptr if the allocation fails."]
    #[doc = " If you're using `goto done;` error handling, this may result in a double-free!!"]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = " @param size"]
    #[doc = " @return void*"]
    pub fn cli_realloc2(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cli_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_rmdirs(dirname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashstream(
        fs: *mut FILE,
        digcpy: *mut ::std::os::raw::c_uchar,
        type_: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_hashfile(
        filename: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_unlink(pathname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_readn(
        fd: ::std::os::raw::c_int,
        buff: *mut ::std::os::raw::c_void,
        count: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn cli_writen(
        fd: ::std::os::raw::c_int,
        buff: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn cli_gettmpdir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sanitize a relative path, so it cannot have a negative depth."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing the sanitized filepath."]
    #[doc = " The optioal sanitized_filebase output param is a pointer into the filepath,"]
    #[doc = " if set, and does not need to be freed."]
    #[doc = ""]
    #[doc = " @param filepath                  The filepath to sanitize"]
    #[doc = " @param filepath_len              The length of the filepath"]
    #[doc = " @param[out] sanitized_filebase   Pointer to the basename portion of the sanitized filepath. (optional)"]
    #[doc = " @return char*"]
    pub fn cli_sanitize_filepath(
        filepath: *const ::std::os::raw::c_char,
        filepath_len: size_t,
        sanitized_filebase: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Generate tempfile filename (no path) with a random MD5 hash."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing the filename."]
    #[doc = ""]
    #[doc = " @return char* filename or NULL."]
    pub fn cli_genfname(prefix: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Generate a full tempfile filepath with a provided the name."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing the filename."]
    #[doc = " If the dir is not provided, the engine->tmpdir will be used."]
    #[doc = ""]
    #[doc = " @param dir \t Alternative directory. (optional)"]
    #[doc = " @return char* filename or NULL."]
    pub fn cli_newfilepath(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Generate a full tempfile filepath with a provided the name."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing the filename."]
    #[doc = " If the dir is not provided, the engine->tmpdir will be used."]
    #[doc = ""]
    #[doc = " @param dir        Alternative temp directory (optional)."]
    #[doc = " @param fname  \t Filename for new file."]
    #[doc = " @param[out] name  Allocated filepath, must be freed by caller."]
    #[doc = " @param[out] fd    File descriptor of open temp file."]
    pub fn cli_newfilepathfd(
        dir: *const ::std::os::raw::c_char,
        fname: *mut ::std::os::raw::c_char,
        name: *mut *mut ::std::os::raw::c_char,
        fd: *mut ::std::os::raw::c_int,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Generate a full tempfile filepath with a random MD5 hash and prefix the name, if provided."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing the filename."]
    #[doc = ""]
    #[doc = " @param dir \t Alternative temp directory. (optional)"]
    #[doc = " @param prefix (Optional) Prefix for new file tempfile."]
    #[doc = " @return char* filename or NULL."]
    pub fn cli_gentemp_with_prefix(
        dir: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Generate a full tempfile filepath with a random MD5 hash."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing the filename."]
    #[doc = ""]
    #[doc = " @param dir \t Alternative temp directory. (optional)"]
    #[doc = " @return char* filename or NULL."]
    pub fn cli_gentemp(dir: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Create a temp filename, create the file, open it, and pass back the filepath and open file descriptor."]
    #[doc = ""]
    #[doc = " @param dir        Alternative temp directory (optional)."]
    #[doc = " @param[out] name  Allocated filepath, must be freed by caller."]
    #[doc = " @param[out] fd    File descriptor of open temp file."]
    #[doc = " @return cl_error_t CL_SUCCESS, CL_ECREAT, or CL_EMEM."]
    pub fn cli_gentempfd(
        dir: *const ::std::os::raw::c_char,
        name: *mut *mut ::std::os::raw::c_char,
        fd: *mut ::std::os::raw::c_int,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Create a temp filename, create the file, open it, and pass back the filepath and open file descriptor."]
    #[doc = ""]
    #[doc = " @param dir        Alternative temp directory (optional)."]
    #[doc = " @param prefix  \t (Optional) Prefix for new file tempfile."]
    #[doc = " @param[out] name  Allocated filepath, must be freed by caller."]
    #[doc = " @param[out] fd    File descriptor of open temp file."]
    #[doc = " @return cl_error_t CL_SUCCESS, CL_ECREAT, or CL_EMEM."]
    pub fn cli_gentempfd_with_prefix(
        dir: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
        name: *mut *mut ::std::os::raw::c_char,
        fd: *mut ::std::os::raw::c_int,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_rndnum(max: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cli_filecopy(
        src: *const ::std::os::raw::c_char,
        dest: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bitset_init() -> *mut bitset_t;
}
extern "C" {
    pub fn cli_bitset_free(bs: *mut bitset_t);
}
extern "C" {
    pub fn cli_bitset_set(
        bs: *mut bitset_t,
        bit_offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_bitset_test(
        bs: *mut bitset_t,
        bit_offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_ctime(
        timep: *const time_t,
        buf: *mut ::std::os::raw::c_char,
        bufsize: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cli_append_virus_if_heur_exceedsmax(
        arg1: *mut cli_ctx,
        arg2: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn cli_checklimits(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cli_ctx,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_ulong,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Call before scanning a file to determine if we should scan it, skip it, or abort the entire scanning process."]
    #[doc = ""]
    #[doc = " If the verdict is CL_SUCCESS, then this function increments the # of scanned files, and increments the amount of scanned data."]
    #[doc = " If the verdict is that a limit has been exceeded, then ctx->"]
    #[doc = ""]
    #[doc = " @param ctx       The scanning context."]
    #[doc = " @param needed    The size of the file we're considering scanning."]
    #[doc = " @return cl_error_t CL_SUCCESS if we're good to keep scanning else an error status."]
    pub fn cli_updatelimits(ctx: *mut cli_ctx, needed: size_t) -> cl_error_t;
}
extern "C" {
    pub fn cli_getsizelimit(
        arg1: *mut cli_ctx,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn cli_matchregex(
        str_: *const ::std::os::raw::c_char,
        regex: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_qsort(
        a: *mut ::std::os::raw::c_void,
        n: size_t,
        es: size_t,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn cli_qsort_r(
        a: *mut ::std::os::raw::c_void,
        n: size_t,
        es: size_t,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn cli_checktimelimit(ctx: *mut cli_ctx) -> cl_error_t;
}
pub const cli_ftw_reason_visit_file: cli_ftw_reason = 0;
pub const cli_ftw_reason_visit_directory_toplev: cli_ftw_reason = 1;
pub const cli_ftw_reason_error_mem: cli_ftw_reason = 2;
pub const cli_ftw_reason_error_stat: cli_ftw_reason = 3;
pub const cli_ftw_reason_warning_skipped_link: cli_ftw_reason = 4;
pub const cli_ftw_reason_warning_skipped_special: cli_ftw_reason = 5;
pub const cli_ftw_reason_warning_skipped_dir: cli_ftw_reason = 6;
pub type cli_ftw_reason = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ftw_cbdata {
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cli_ftw_cbdata() {
    assert_eq!(
        ::std::mem::size_of::<cli_ftw_cbdata>(),
        8usize,
        concat!("Size of: ", stringify!(cli_ftw_cbdata))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ftw_cbdata>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ftw_cbdata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ftw_cbdata>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ftw_cbdata),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @brief Callback to process each file in a file tree walk (FTW)."]
#[doc = ""]
#[doc = " The callback is responsible for freeing filename when it is done using it."]
#[doc = ""]
#[doc = " Note that callback decides if directory traversal should continue"]
#[doc = " after an error, we call the callback with reason == error,"]
#[doc = " and if it returns CL_BREAK we break."]
#[doc = ""]
#[doc = " Return:"]
#[doc = " - CL_BREAK to break out without an error,"]
#[doc = " - CL_SUCCESS to continue,"]
#[doc = " - any CL_E* to break out due to error."]
pub type cli_ftw_cb = ::std::option::Option<
    unsafe extern "C" fn(
        stat_buf: *mut stat,
        filename: *mut ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
        reason: cli_ftw_reason,
        data: *mut cli_ftw_cbdata,
    ) -> cl_error_t,
>;
#[doc = " @brief Callback to determine if a path in a file tree walk (FTW) should be skipped."]
#[doc = " Has access to the same callback data as the main FTW callback function (above)."]
#[doc = ""]
#[doc = " Return:"]
#[doc = " - 1 if the path should be skipped (i.e. to not call the callback for the given path),"]
#[doc = " - 0 if the path should be processed (i.e. to call the callback for the given path)."]
pub type cli_ftw_pathchk = ::std::option::Option<
    unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        data: *mut cli_ftw_cbdata,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Traverse a file path, calling the callback function on each file"]
    #[doc = " within if the pathchk() check allows for it. Will skip certain file types:"]
    #[doc = " -"]
    #[doc = ""]
    #[doc = " This is regardless of virus found/not, that is the callback's job to store."]
    #[doc = " Note that the callback may dispatch async the scan, so that when cli_ftw"]
    #[doc = " returns we don't know the infected/notinfected status of the directory yet!"]
    #[doc = ""]
    #[doc = " Due to this if the callback scans synchronously it should store the infected"]
    #[doc = " status in its cbdata."]
    #[doc = " This works for both files and directories. It stats the path to determine"]
    #[doc = " which one it is."]
    #[doc = " If it is a file, it simply calls the callback once, otherwise recurses."]
    #[doc = ""]
    #[doc = " @param base      The top level directory (or file) path to be processed"]
    #[doc = " @param flags     A bitflag field for the CLI_FTW_* flag options (see above)"]
    #[doc = " @param maxdepth  The max recursion depth."]
    #[doc = " @param callback  The cli_ftw_cb callback to invoke on each file AND directory."]
    #[doc = " @param data      Callback data for the callback function."]
    #[doc = " @param pathchk   A function used to determine if the callback should be run on the given file."]
    #[doc = " @return cl_error_t CL_SUCCESS if it traversed all files and subdirs"]
    #[doc = " @return cl_error_t CL_BREAK if traversal has stopped at some point"]
    #[doc = " @return cl_error_t CL_E* if error encountered during traversal and we had to break out"]
    pub fn cli_ftw(
        base: *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        callback: cli_ftw_cb,
        data: *mut cli_ftw_cbdata,
        pathchk: cli_ftw_pathchk,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_strerror(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief   Attempt to get a filename from an open file descriptor."]
    #[doc = ""]
    #[doc = " Caller is responsible for free'ing the filename."]
    #[doc = " Should work on Linux, macOS, Windows."]
    #[doc = ""]
    #[doc = " @param desc           File descriptor"]
    #[doc = " @param[out] filepath  Will be set to file path if found, or NULL."]
    #[doc = " @return cl_error_t    CL_SUCCESS if found, else an error code."]
    pub fn cli_get_filepath_from_filedesc(
        desc: ::std::os::raw::c_int,
        filepath: *mut *mut ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief   Attempt to get the real path of a provided path (evaluating symlinks)."]
    #[doc = ""]
    #[doc = " Caller is responsible for free'ing the file path."]
    #[doc = " On posix systems this just calls realpath() under the hood."]
    #[doc = " On Win32, it opens a handle and uses cli_get_filepath_from_filedesc()"]
    #[doc = " to get the real path."]
    #[doc = ""]
    #[doc = " @param desc          A file path to evaluate."]
    #[doc = " @param[out] char*    A malloced string containing the real path."]
    #[doc = " @return cl_error_t   CL_SUCCESS if found, else an error code."]
    pub fn cli_realpath(
        file_name: *const ::std::os::raw::c_char,
        real_filename: *mut *mut ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief   Get the libclamav debug flag (e.g. if debug logging is enabled)"]
    #[doc = ""]
    #[doc = " This is required for unit tests to be able to link with clamav.dll and not"]
    #[doc = " directly manipulate libclamav global variables."]
    pub fn cli_get_debug_flag() -> u8;
}
extern "C" {
    #[doc = " @brief   Set the libclamav debug flag to a specific value."]
    #[doc = ""]
    #[doc = " The public cl_debug() API will only ever enable debug mode, it won't disable debug mode."]
    #[doc = ""]
    #[doc = " This is required for unit tests to be able to link with clamav.dll and not"]
    #[doc = " directly manipulate libclamav global variables."]
    pub fn cli_set_debug_flag(debug_flag: u8) -> u8;
}
pub type cli_element_data = size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_element {
    pub key: *const ::std::os::raw::c_char,
    pub data: cli_element_data,
    pub len: size_t,
}
#[test]
fn bindgen_test_layout_cli_element() {
    assert_eq!(
        ::std::mem::size_of::<cli_element>(),
        24usize,
        concat!("Size of: ", stringify!(cli_element))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_element>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_element))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_element>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_element),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_element>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_element),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_element>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_element),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_hashtable {
    pub htable: *mut cli_element,
    pub capacity: size_t,
    pub used: size_t,
    pub maxfill: size_t,
}
#[test]
fn bindgen_test_layout_cli_hashtable() {
    assert_eq!(
        ::std::mem::size_of::<cli_hashtable>(),
        32usize,
        concat!("Size of: ", stringify!(cli_hashtable))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_hashtable>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_hashtable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashtable>())).htable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashtable),
            "::",
            stringify!(htable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashtable>())).capacity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashtable),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashtable>())).used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashtable),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashtable>())).maxfill as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashtable),
            "::",
            stringify!(maxfill)
        )
    );
}
extern "C" {
    pub fn cli_hashtab_generate_c(
        s: *const cli_hashtable,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashtab_find(
        s: *const cli_hashtable,
        key: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> *mut cli_element;
}
extern "C" {
    pub fn cli_hashtab_init(s: *mut cli_hashtable, capacity: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashtab_insert(
        s: *mut cli_hashtable,
        key: *const ::std::os::raw::c_char,
        len: size_t,
        data: cli_element_data,
    ) -> *const cli_element;
}
extern "C" {
    pub fn cli_hashtab_delete(
        s: *mut cli_hashtable,
        key: *const ::std::os::raw::c_char,
        len: size_t,
    );
}
extern "C" {
    pub fn cli_hashtab_clear(s: *mut cli_hashtable);
}
extern "C" {
    pub fn cli_hashtab_free(s: *mut cli_hashtable);
}
extern "C" {
    pub fn cli_hashtab_load(in_: *mut FILE, s: *mut cli_hashtable) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashtab_store(s: *const cli_hashtable, out: *mut FILE) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_htu32_element {
    pub key: u32,
    pub data: cli_htu32_element__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_htu32_element__bindgen_ty_1 {
    pub as_size_t: size_t,
    pub as_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cli_htu32_element__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cli_htu32_element__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cli_htu32_element__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_htu32_element__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_htu32_element__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_htu32_element__bindgen_ty_1>())).as_size_t as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_htu32_element__bindgen_ty_1),
            "::",
            stringify!(as_size_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_htu32_element__bindgen_ty_1>())).as_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_htu32_element__bindgen_ty_1),
            "::",
            stringify!(as_ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_cli_htu32_element() {
    assert_eq!(
        ::std::mem::size_of::<cli_htu32_element>(),
        16usize,
        concat!("Size of: ", stringify!(cli_htu32_element))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_htu32_element>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_htu32_element))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_htu32_element>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_htu32_element),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_htu32_element>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_htu32_element),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_htu32 {
    pub htable: *mut cli_htu32_element,
    pub capacity: size_t,
    pub used: size_t,
    pub maxfill: size_t,
}
#[test]
fn bindgen_test_layout_cli_htu32() {
    assert_eq!(
        ::std::mem::size_of::<cli_htu32>(),
        32usize,
        concat!("Size of: ", stringify!(cli_htu32))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_htu32>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_htu32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_htu32>())).htable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_htu32),
            "::",
            stringify!(htable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_htu32>())).capacity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_htu32),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_htu32>())).used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_htu32),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_htu32>())).maxfill as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_htu32),
            "::",
            stringify!(maxfill)
        )
    );
}
extern "C" {
    pub fn cli_htu32_init(
        s: *mut cli_htu32,
        capacity: size_t,
        mempool: *mut mpool_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_htu32_insert(
        s: *mut cli_htu32,
        item: *const cli_htu32_element,
        mempool: *mut mpool_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_htu32_find(s: *const cli_htu32, key: u32) -> *const cli_htu32_element;
}
extern "C" {
    pub fn cli_htu32_delete(s: *mut cli_htu32, key: u32);
}
extern "C" {
    pub fn cli_htu32_clear(s: *mut cli_htu32);
}
extern "C" {
    pub fn cli_htu32_free(s: *mut cli_htu32, mempool: *mut mpool_t);
}
extern "C" {
    pub fn cli_htu32_next(
        s: *const cli_htu32,
        current: *const cli_htu32_element,
    ) -> *const cli_htu32_element;
}
extern "C" {
    pub fn cli_htu32_numitems(s: *mut cli_htu32) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_map_value {
    pub value: *mut ::std::os::raw::c_void,
    pub valuesize: i32,
}
#[test]
fn bindgen_test_layout_cli_map_value() {
    assert_eq!(
        ::std::mem::size_of::<cli_map_value>(),
        16usize,
        concat!("Size of: ", stringify!(cli_map_value))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_map_value>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_map_value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map_value>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map_value),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map_value>())).valuesize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map_value),
            "::",
            stringify!(valuesize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_map {
    pub htab: cli_hashtable,
    pub u: cli_map__bindgen_ty_1,
    pub nvalues: u32,
    pub keysize: i32,
    pub valuesize: i32,
    pub last_insert: i32,
    pub last_find: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_map__bindgen_ty_1 {
    pub unsized_values: *mut cli_map_value,
    pub sized_values: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cli_map__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cli_map__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cli_map__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_map__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_map__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_map__bindgen_ty_1>())).unsized_values as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map__bindgen_ty_1),
            "::",
            stringify!(unsized_values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_map__bindgen_ty_1>())).sized_values as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map__bindgen_ty_1),
            "::",
            stringify!(sized_values)
        )
    );
}
#[test]
fn bindgen_test_layout_cli_map() {
    assert_eq!(
        ::std::mem::size_of::<cli_map>(),
        64usize,
        concat!("Size of: ", stringify!(cli_map))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_map>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map>())).htab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map),
            "::",
            stringify!(htab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map>())).u as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map>())).nvalues as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map),
            "::",
            stringify!(nvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map>())).keysize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map),
            "::",
            stringify!(keysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map>())).valuesize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map),
            "::",
            stringify!(valuesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map>())).last_insert as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map),
            "::",
            stringify!(last_insert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_map>())).last_find as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_map),
            "::",
            stringify!(last_find)
        )
    );
}
extern "C" {
    pub fn cli_map_init(
        m: *mut cli_map,
        keysize: i32,
        valuesize: i32,
        capacity: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_map_addkey(
        m: *mut cli_map,
        key: *const ::std::os::raw::c_void,
        keysize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_map_removekey(
        m: *mut cli_map,
        key: *const ::std::os::raw::c_void,
        keysize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_map_setvalue(
        m: *mut cli_map,
        value: *const ::std::os::raw::c_void,
        valuesize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_map_find(
        m: *mut cli_map,
        key: *const ::std::os::raw::c_void,
        keysize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_map_getvalue_size(m: *mut cli_map) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_map_getvalue(m: *mut cli_map) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cli_map_delete(m: *mut cli_map);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_hashset {
    pub keys: *mut u32,
    pub bitmap: *mut u32,
    pub mempool: *mut mpool_t,
    pub capacity: u32,
    pub mask: u32,
    pub count: u32,
    pub limit: u32,
}
#[test]
fn bindgen_test_layout_cli_hashset() {
    assert_eq!(
        ::std::mem::size_of::<cli_hashset>(),
        40usize,
        concat!("Size of: ", stringify!(cli_hashset))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_hashset>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_hashset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashset>())).keys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashset),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashset>())).bitmap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashset),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashset>())).mempool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashset),
            "::",
            stringify!(mempool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashset>())).capacity as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashset),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashset>())).mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashset),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashset>())).count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashset),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hashset>())).limit as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hashset),
            "::",
            stringify!(limit)
        )
    );
}
extern "C" {
    pub fn cli_hashset_init(
        hs: *mut cli_hashset,
        initial_capacity: size_t,
        load_factor: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashset_init_pool(
        hs: *mut cli_hashset,
        initial_capacity: size_t,
        load_factor: u8,
        mempool: *mut mpool_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashset_addkey(hs: *mut cli_hashset, key: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashset_removekey(hs: *mut cli_hashset, key: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashset_contains(hs: *const cli_hashset, key: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashset_clear(hs: *mut cli_hashset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hashset_destroy(hs: *mut cli_hashset);
}
extern "C" {
    pub fn cli_hashset_toarray(hs: *const cli_hashset, array: *mut *mut u32) -> ssize_t;
}
extern "C" {
    pub fn cli_hashset_init_noalloc(hs: *mut cli_hashset);
}
extern "C" {
    pub fn cli_hashset_contains_maybe_noalloc(
        hs: *const cli_hashset,
        key: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @file */"]
#[doc = " \\group_pe"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pe_image_file_hdr {
    #[doc = "< PE magic header: PE\\\\0\\\\0"]
    pub Magic: u32,
    #[doc = "< CPU this executable runs on, see libclamav/pe.c for possible values"]
    pub Machine: u16,
    #[doc = "< Number of sections in this executable"]
    pub NumberOfSections: u16,
    #[doc = "< Unreliable"]
    pub TimeDateStamp: u32,
    #[doc = "< debug"]
    pub PointerToSymbolTable: u32,
    #[doc = "< debug"]
    pub NumberOfSymbols: u32,
    #[doc = "< == 224"]
    pub SizeOfOptionalHeader: u16,
    pub Characteristics: u16,
}
#[test]
fn bindgen_test_layout_pe_image_file_hdr() {
    assert_eq!(
        ::std::mem::size_of::<pe_image_file_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(pe_image_file_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<pe_image_file_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(pe_image_file_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_image_file_hdr>())).Magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_file_hdr),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_image_file_hdr>())).Machine as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_file_hdr),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_file_hdr>())).NumberOfSections as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_file_hdr),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_image_file_hdr>())).TimeDateStamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_file_hdr),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_file_hdr>())).PointerToSymbolTable as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_file_hdr),
            "::",
            stringify!(PointerToSymbolTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_file_hdr>())).NumberOfSymbols as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_file_hdr),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_file_hdr>())).SizeOfOptionalHeader as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_file_hdr),
            "::",
            stringify!(SizeOfOptionalHeader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_file_hdr>())).Characteristics as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_file_hdr),
            "::",
            stringify!(Characteristics)
        )
    );
}
#[doc = " PE data directory header"]
#[doc = " \\group_pe"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pe_image_data_dir {
    pub VirtualAddress: u32,
    pub Size: u32,
}
#[test]
fn bindgen_test_layout_pe_image_data_dir() {
    assert_eq!(
        ::std::mem::size_of::<pe_image_data_dir>(),
        8usize,
        concat!("Size of: ", stringify!(pe_image_data_dir))
    );
    assert_eq!(
        ::std::mem::align_of::<pe_image_data_dir>(),
        4usize,
        concat!("Alignment of ", stringify!(pe_image_data_dir))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_data_dir>())).VirtualAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_data_dir),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_image_data_dir>())).Size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_data_dir),
            "::",
            stringify!(Size)
        )
    );
}
#[doc = " 32-bit PE optional header"]
#[doc = " \\group_pe"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pe_image_optional_hdr32 {
    pub Magic: u16,
    #[doc = "< unreliable"]
    pub MajorLinkerVersion: u8,
    #[doc = "< unreliable"]
    pub MinorLinkerVersion: u8,
    #[doc = "< unreliable"]
    pub SizeOfCode: u32,
    #[doc = "< unreliable"]
    pub SizeOfInitializedData: u32,
    #[doc = "< unreliable"]
    pub SizeOfUninitializedData: u32,
    pub AddressOfEntryPoint: u32,
    pub BaseOfCode: u32,
    pub BaseOfData: u32,
    #[doc = "< multiple of 64 KB"]
    pub ImageBase: u32,
    #[doc = "< usually 32 or 4096"]
    pub SectionAlignment: u32,
    #[doc = "< usually 32 or 512"]
    pub FileAlignment: u32,
    #[doc = "< not used"]
    pub MajorOperatingSystemVersion: u16,
    #[doc = "< not used"]
    pub MinorOperatingSystemVersion: u16,
    #[doc = "< unreliable"]
    pub MajorImageVersion: u16,
    #[doc = "< unreliable"]
    pub MinorImageVersion: u16,
    pub MajorSubsystemVersion: u16,
    pub MinorSubsystemVersion: u16,
    pub Win32VersionValue: u32,
    pub SizeOfImage: u32,
    pub SizeOfHeaders: u32,
    #[doc = "< NT drivers only"]
    pub CheckSum: u32,
    pub Subsystem: u16,
    pub DllCharacteristics: u16,
    pub SizeOfStackReserve: u32,
    pub SizeOfStackCommit: u32,
    pub SizeOfHeapReserve: u32,
    pub SizeOfHeapCommit: u32,
    pub LoaderFlags: u32,
    pub NumberOfRvaAndSizes: u32,
}
#[test]
fn bindgen_test_layout_pe_image_optional_hdr32() {
    assert_eq!(
        ::std::mem::size_of::<pe_image_optional_hdr32>(),
        96usize,
        concat!("Size of: ", stringify!(pe_image_optional_hdr32))
    );
    assert_eq!(
        ::std::mem::align_of::<pe_image_optional_hdr32>(),
        4usize,
        concat!("Alignment of ", stringify!(pe_image_optional_hdr32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_image_optional_hdr32>())).Magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).MajorLinkerVersion as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).MinorLinkerVersion as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfInitializedData as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfUninitializedData as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).AddressOfEntryPoint as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).BaseOfCode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).BaseOfData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(BaseOfData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).ImageBase as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SectionAlignment as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).FileAlignment as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(FileAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).MajorOperatingSystemVersion
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(MajorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).MinorOperatingSystemVersion
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(MinorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).MajorImageVersion as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(MajorImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).MinorImageVersion as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(MinorImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).MajorSubsystemVersion as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(MajorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).MinorSubsystemVersion as *const _
                as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(MinorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).Win32VersionValue as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(Win32VersionValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfImage as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfHeaders as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfHeaders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).CheckSum as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).Subsystem as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(Subsystem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).DllCharacteristics as *const _
                as usize
        },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(DllCharacteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfStackReserve as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfStackReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfStackCommit as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfStackCommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfHeapReserve as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfHeapReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).SizeOfHeapCommit as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(SizeOfHeapCommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).LoaderFlags as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(LoaderFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr32>())).NumberOfRvaAndSizes as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr32),
            "::",
            stringify!(NumberOfRvaAndSizes)
        )
    );
}
#[doc = " PE 64-bit optional header"]
#[doc = " \\group_pe"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pe_image_optional_hdr64 {
    pub Magic: u16,
    #[doc = "< unreliable"]
    pub MajorLinkerVersion: u8,
    #[doc = "< unreliable"]
    pub MinorLinkerVersion: u8,
    #[doc = "< unreliable"]
    pub SizeOfCode: u32,
    #[doc = "< unreliable"]
    pub SizeOfInitializedData: u32,
    #[doc = "< unreliable"]
    pub SizeOfUninitializedData: u32,
    pub AddressOfEntryPoint: u32,
    pub BaseOfCode: u32,
    #[doc = "< multiple of 64 KB"]
    pub ImageBase: u64,
    #[doc = "< usually 32 or 4096"]
    pub SectionAlignment: u32,
    #[doc = "< usually 32 or 512"]
    pub FileAlignment: u32,
    #[doc = "< not used"]
    pub MajorOperatingSystemVersion: u16,
    #[doc = "< not used"]
    pub MinorOperatingSystemVersion: u16,
    #[doc = "< unreliable"]
    pub MajorImageVersion: u16,
    #[doc = "< unreliable"]
    pub MinorImageVersion: u16,
    pub MajorSubsystemVersion: u16,
    pub MinorSubsystemVersion: u16,
    pub Win32VersionValue: u32,
    pub SizeOfImage: u32,
    pub SizeOfHeaders: u32,
    #[doc = "< NT drivers only"]
    pub CheckSum: u32,
    pub Subsystem: u16,
    pub DllCharacteristics: u16,
    pub SizeOfStackReserve: u64,
    pub SizeOfStackCommit: u64,
    pub SizeOfHeapReserve: u64,
    pub SizeOfHeapCommit: u64,
    pub LoaderFlags: u32,
    pub NumberOfRvaAndSizes: u32,
}
#[test]
fn bindgen_test_layout_pe_image_optional_hdr64() {
    assert_eq!(
        ::std::mem::size_of::<pe_image_optional_hdr64>(),
        112usize,
        concat!("Size of: ", stringify!(pe_image_optional_hdr64))
    );
    assert_eq!(
        ::std::mem::align_of::<pe_image_optional_hdr64>(),
        8usize,
        concat!("Alignment of ", stringify!(pe_image_optional_hdr64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_image_optional_hdr64>())).Magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).MajorLinkerVersion as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).MinorLinkerVersion as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfInitializedData as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfUninitializedData as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).AddressOfEntryPoint as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).BaseOfCode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).ImageBase as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SectionAlignment as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).FileAlignment as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(FileAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).MajorOperatingSystemVersion
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(MajorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).MinorOperatingSystemVersion
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(MinorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).MajorImageVersion as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(MajorImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).MinorImageVersion as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(MinorImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).MajorSubsystemVersion as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(MajorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).MinorSubsystemVersion as *const _
                as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(MinorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).Win32VersionValue as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(Win32VersionValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfImage as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfHeaders as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfHeaders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).CheckSum as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).Subsystem as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(Subsystem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).DllCharacteristics as *const _
                as usize
        },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(DllCharacteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfStackReserve as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfStackReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfStackCommit as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfStackCommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfHeapReserve as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfHeapReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).SizeOfHeapCommit as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(SizeOfHeapCommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).LoaderFlags as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(LoaderFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_optional_hdr64>())).NumberOfRvaAndSizes as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_optional_hdr64),
            "::",
            stringify!(NumberOfRvaAndSizes)
        )
    );
}
#[doc = " PE section header"]
#[doc = " \\group_pe"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pe_image_section_hdr {
    #[doc = "< may not end with NULL"]
    pub Name: [u8; 8usize],
    pub VirtualSize: u32,
    pub VirtualAddress: u32,
    #[doc = "< multiple of FileAlignment"]
    pub SizeOfRawData: u32,
    #[doc = "< offset to the section's data"]
    pub PointerToRawData: u32,
    #[doc = "< object files only"]
    pub PointerToRelocations: u32,
    #[doc = "< object files only"]
    pub PointerToLinenumbers: u32,
    #[doc = "< object files only"]
    pub NumberOfRelocations: u16,
    #[doc = "< object files only"]
    pub NumberOfLinenumbers: u16,
    pub Characteristics: u32,
}
#[test]
fn bindgen_test_layout_pe_image_section_hdr() {
    assert_eq!(
        ::std::mem::size_of::<pe_image_section_hdr>(),
        40usize,
        concat!("Size of: ", stringify!(pe_image_section_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<pe_image_section_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(pe_image_section_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_image_section_hdr>())).Name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).VirtualSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(VirtualSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).VirtualAddress as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).SizeOfRawData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(SizeOfRawData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).PointerToRawData as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(PointerToRawData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).PointerToRelocations as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(PointerToRelocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).PointerToLinenumbers as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(PointerToLinenumbers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).NumberOfRelocations as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(NumberOfRelocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).NumberOfLinenumbers as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(NumberOfLinenumbers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pe_image_section_hdr>())).Characteristics as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_image_section_hdr),
            "::",
            stringify!(Characteristics)
        )
    );
}
#[doc = " PE authenticode data header"]
#[doc = " \\group_pe"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pe_certificate_hdr {
    pub length: u32,
    #[doc = " length of the certificate data, including the header"]
    pub revision: u16,
    pub type_: u16,
}
#[test]
fn bindgen_test_layout_pe_certificate_hdr() {
    assert_eq!(
        ::std::mem::size_of::<pe_certificate_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(pe_certificate_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<pe_certificate_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(pe_certificate_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_certificate_hdr>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_certificate_hdr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_certificate_hdr>())).revision as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_certificate_hdr),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pe_certificate_hdr>())).type_ as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pe_certificate_hdr),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " @file */"]
#[doc = " \\group_pe"]
#[doc = "  NOTE: This is used to store PE, MachO, and ELF section information. Not"]
#[doc = "  all members are populated by the respective parsing functions."]
#[doc = ""]
#[doc = "  NOTE: This header file originates in the clamav-devel source and gets"]
#[doc = "  copied into the clamav-bytecode-compiler source through a script"]
#[doc = "  (sync-clamav.sh). This is done because an array of this structure is"]
#[doc = "  allocated by libclamav and passed to the bytecode sig runtime."]
#[doc = ""]
#[doc = "  If you need to make changes to this structure, you will need to update"]
#[doc = "  it in both repos.  Also, I'm not sure whether changing this structure"]
#[doc = "  would require a recompile of all previous bytecode sigs.  This should"]
#[doc = "  be investigated before changes are made."]
#[doc = ""]
#[doc = "  TODO Modify this structure to also include the section name (in both"]
#[doc = "  repos).  Then, populate this field in the libclamav PE/MachO/ELF header"]
#[doc = "  parsing functions.  Choose a length that's reasonable for all platforms"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_exe_section {
    #[doc = "< Relative VirtualAddress"]
    pub rva: u32,
    #[doc = "< VirtualSize"]
    pub vsz: u32,
    #[doc = "< Raw offset (in file)"]
    pub raw: u32,
    #[doc = "< Raw size (in file)"]
    pub rsz: u32,
    #[doc = "< Section characteristics"]
    pub chr: u32,
    #[doc = "< PE - unaligned VirtualAddress"]
    pub urva: u32,
    #[doc = "< PE - unaligned VirtualSize"]
    pub uvsz: u32,
    #[doc = "< PE - unaligned PointerToRawData"]
    pub uraw: u32,
    #[doc = "< PE - unaligned SizeOfRawData"]
    pub ursz: u32,
}
#[test]
fn bindgen_test_layout_cli_exe_section() {
    assert_eq!(
        ::std::mem::size_of::<cli_exe_section>(),
        36usize,
        concat!("Size of: ", stringify!(cli_exe_section))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_exe_section>(),
        4usize,
        concat!("Alignment of ", stringify!(cli_exe_section))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).rva as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(rva)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).vsz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(vsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).raw as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).rsz as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(rsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).chr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(chr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).urva as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(urva)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).uvsz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(uvsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).uraw as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(uraw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_section>())).ursz as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_section),
            "::",
            stringify!(ursz)
        )
    );
}
#[doc = " Executable file information"]
#[doc = "  NOTE: This is used to store PE, MachO, and ELF executable information,"]
#[doc = "  but it predominantly has fields for PE info.  Not all members are"]
#[doc = "  populated by the respective parsing functions."]
#[doc = ""]
#[doc = "  NOTE: This header file originates in the clamav-devel source and gets"]
#[doc = "  copied into the clamav-bytecode-compiler source through a script"]
#[doc = "  (sync-clamav.sh). This is done because an array of cli_exe_section"]
#[doc = "  structs is allocated by libclamav and passed to the bytecode sig"]
#[doc = "  runtime."]
#[doc = ""]
#[doc = "  This structure is not used by the bytecode sig runtime, so it can be"]
#[doc = "  modified in the clamav-devel repo without requiring the changes to"]
#[doc = "  be propagated to the clamav-bytecode-compile repo and that code rebuilt."]
#[doc = "  It'd be nice to keep them in sync if possible, though."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_exe_info {
    #[doc = " Information about all the sections of this file."]
    #[doc = " This array has \\p nsection elements"]
    pub sections: *mut cli_exe_section,
    #[doc = " Offset where this executable starts in file (nonzero if embedded)"]
    pub offset: u32,
    #[doc = " File offset to the entrypoint of the executable."]
    pub ep: u32,
    #[doc = " Number of sections."]
    #[doc = "  NOTE: If a section is determined to be invalid (exists outside of the"]
    #[doc = "  file) then it will not be included in this count (at least for PE)."]
    pub nsections: u16,
    #[doc = " Resources RVA"]
    pub res_addr: u32,
    #[doc = " Size of the  header (aligned). This corresponds to"]
    #[doc = "  SizeOfHeaders in the optional header"]
    pub hdr_size: u32,
    #[doc = " Hashset for versioninfo matching"]
    pub vinfo: cli_hashset,
    #[doc = " Entry point RVA"]
    pub vep: u32,
    #[doc = " Number of data directory entries at the end of the optional header."]
    #[doc = "  This also corresponds to the number of entries in dirs that has"]
    #[doc = "  been populated with information."]
    pub ndatadirs: u32,
    #[doc = " Whether this file is a DLL"]
    pub is_dll: u32,
    #[doc = " Whether this file is a PE32+ exe (64-bit)"]
    pub is_pe32plus: u32,
    pub e_lfanew: u32,
    #[doc = " The lowest section RVA"]
    pub min: u32,
    #[doc = " The RVA of the highest byte contained within a section"]
    pub max: u32,
    #[doc = " Offset of any file overlays, as determined by parsing the PE header"]
    pub overlay_start: u32,
    pub overlay_size: u32,
    #[doc = " Image File Header for this PE file"]
    pub file_hdr: pe_image_file_hdr,
    pub pe_opt: cli_exe_info__bindgen_ty_1,
    pub dirs: [pe_image_data_dir; 16usize],
}
#[doc = " PE optional header. Use is_pe32plus to determine whether the 32-bit"]
#[doc = "  or 64-bit union member should be used."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_exe_info__bindgen_ty_1 {
    pub opt64: pe_image_optional_hdr64,
    pub opt32: pe_image_optional_hdr32,
}
#[test]
fn bindgen_test_layout_cli_exe_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cli_exe_info__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(cli_exe_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_exe_info__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_exe_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_exe_info__bindgen_ty_1>())).opt64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info__bindgen_ty_1),
            "::",
            stringify!(opt64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_exe_info__bindgen_ty_1>())).opt32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info__bindgen_ty_1),
            "::",
            stringify!(opt32)
        )
    );
}
#[test]
fn bindgen_test_layout_cli_exe_info() {
    assert_eq!(
        ::std::mem::size_of::<cli_exe_info>(),
        376usize,
        concat!("Size of: ", stringify!(cli_exe_info))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_exe_info>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_exe_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).sections as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(sections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).ep as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(ep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).nsections as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(nsections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).res_addr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(res_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).hdr_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(hdr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).vinfo as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(vinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).vep as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(vep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).ndatadirs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(ndatadirs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).is_dll as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(is_dll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).is_pe32plus as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(is_pe32plus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).e_lfanew as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(e_lfanew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).min as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).max as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).overlay_start as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(overlay_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).overlay_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(overlay_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).file_hdr as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(file_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).pe_opt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(pe_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_exe_info>())).dirs as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_exe_info),
            "::",
            stringify!(dirs)
        )
    );
}
extern "C" {
    #[doc = " Initialize a struct cli_exe_info so that it's ready to be populated"]
    #[doc = " by the EXE header parsing functions (cli_peheader, cli_elfheader, and"]
    #[doc = " cli_machoheader) and/or cli_exe_info_destroy."]
    #[doc = ""]
    #[doc = " @param exeinfo a pointer to the struct cli_exe_info to initialize"]
    #[doc = " @param offset the file offset corresponding to the start of the"]
    #[doc = "               executable that exeinfo stores information about"]
    pub fn cli_exe_info_init(exeinfo: *mut cli_exe_info, offset: u32);
}
extern "C" {
    #[doc = " Free resources associated with a struct cli_exe_info initialized"]
    #[doc = " via cli_exe_info_init"]
    #[doc = ""]
    #[doc = " @param exeinfo a pointer to the struct cli_exe_info to destroy"]
    pub fn cli_exe_info_destroy(exeinfo: *mut cli_exe_info);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_target_info {
    pub fsize: off_t,
    pub exeinfo: cli_exe_info,
    pub status: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cli_target_info() {
    assert_eq!(
        ::std::mem::size_of::<cli_target_info>(),
        392usize,
        concat!("Size of: ", stringify!(cli_target_info))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_target_info>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_target_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_target_info>())).fsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_target_info),
            "::",
            stringify!(fsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_target_info>())).exeinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_target_info),
            "::",
            stringify!(exeinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_target_info>())).status as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_target_info),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    #[doc = " Initialize a struct cli_target_info so that it's ready to have its exeinfo"]
    #[doc = " populated by the call to cli_targetinfo and/or destroyed by"]
    #[doc = " cli_targetinfo_destroy."]
    #[doc = ""]
    #[doc = " @param info a pointer to the struct cli_target_info to initialize"]
    pub fn cli_targetinfo_init(info: *mut cli_target_info);
}
extern "C" {
    #[doc = " Free resources associated with a struct cli_target_info initialized"]
    #[doc = " via cli_targetinfo_init"]
    #[doc = ""]
    #[doc = " @param info a pointer to the struct cli_target_info to destroy"]
    pub fn cli_targetinfo_destroy(info: *mut cli_target_info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_subsig_matches {
    pub last: u32,
    pub next: u32,
    pub offsets: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_cli_subsig_matches() {
    assert_eq!(
        ::std::mem::size_of::<cli_subsig_matches>(),
        72usize,
        concat!("Size of: ", stringify!(cli_subsig_matches))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_subsig_matches>(),
        4usize,
        concat!("Alignment of ", stringify!(cli_subsig_matches))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_subsig_matches>())).last as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_subsig_matches),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_subsig_matches>())).next as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_subsig_matches),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_subsig_matches>())).offsets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_subsig_matches),
            "::",
            stringify!(offsets)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_lsig_matches {
    pub subsigs: u32,
    pub matches: [*mut cli_subsig_matches; 1usize],
}
#[test]
fn bindgen_test_layout_cli_lsig_matches() {
    assert_eq!(
        ::std::mem::size_of::<cli_lsig_matches>(),
        16usize,
        concat!("Size of: ", stringify!(cli_lsig_matches))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_lsig_matches>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_lsig_matches))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_matches>())).subsigs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_matches),
            "::",
            stringify!(subsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_matches>())).matches as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_matches),
            "::",
            stringify!(matches)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ac_data {
    pub offmatrix: *mut *mut *mut u32,
    pub partsigs: u32,
    pub lsigs: u32,
    pub reloffsigs: u32,
    pub lsigcnt: *mut *mut u32,
    pub lsigsuboff_last: *mut *mut u32,
    pub lsigsuboff_first: *mut *mut u32,
    pub lsig_matches: *mut *mut cli_lsig_matches,
    pub yr_matches: *mut u8,
    pub offset: *mut u32,
    pub macro_lastmatch: [u32; 32usize],
    #[doc = " Hashset for versioninfo matching"]
    pub vinfo: *const cli_hashset,
    pub min_partno: u32,
}
#[test]
fn bindgen_test_layout_cli_ac_data() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_data>(),
        216usize,
        concat!("Size of: ", stringify!(cli_ac_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_data>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).offmatrix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(offmatrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).partsigs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(partsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).lsigs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(lsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).reloffsigs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(reloffsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).lsigcnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(lsigcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).lsigsuboff_last as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(lsigsuboff_last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).lsigsuboff_first as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(lsigsuboff_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).lsig_matches as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(lsig_matches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).yr_matches as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(yr_matches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).offset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).macro_lastmatch as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(macro_lastmatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).vinfo as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(vinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_data>())).min_partno as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_data),
            "::",
            stringify!(min_partno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_alt_node {
    pub str_: *mut u16,
    pub len: u16,
    pub unique: u8,
    pub next: *mut cli_alt_node,
}
#[test]
fn bindgen_test_layout_cli_alt_node() {
    assert_eq!(
        ::std::mem::size_of::<cli_alt_node>(),
        24usize,
        concat!("Size of: ", stringify!(cli_alt_node))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_alt_node>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_alt_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_alt_node>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_alt_node),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_alt_node>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_alt_node),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_alt_node>())).unique as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_alt_node),
            "::",
            stringify!(unique)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_alt_node>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_alt_node),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_ac_special {
    pub alt: cli_ac_special__bindgen_ty_1,
    pub len: [u16; 2usize],
    pub num: u16,
    pub type_: u16,
    pub negative: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_ac_special__bindgen_ty_1 {
    pub byte: *mut ::std::os::raw::c_uchar,
    pub f_str: *mut *mut ::std::os::raw::c_uchar,
    pub v_str: *mut cli_alt_node,
}
#[test]
fn bindgen_test_layout_cli_ac_special__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_special__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cli_ac_special__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_special__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_special__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_ac_special__bindgen_ty_1>())).byte as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_special__bindgen_ty_1),
            "::",
            stringify!(byte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_ac_special__bindgen_ty_1>())).f_str as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_special__bindgen_ty_1),
            "::",
            stringify!(f_str)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_ac_special__bindgen_ty_1>())).v_str as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_special__bindgen_ty_1),
            "::",
            stringify!(v_str)
        )
    );
}
#[test]
fn bindgen_test_layout_cli_ac_special() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_special>(),
        24usize,
        concat!("Size of: ", stringify!(cli_ac_special))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_special>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_special))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_special>())).alt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_special),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_special>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_special),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_special>())).num as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_special),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_special>())).type_ as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_special),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_special>())).negative as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_special),
            "::",
            stringify!(negative)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ac_patt {
    pub pattern: *mut u16,
    pub prefix: *mut u16,
    pub length: [u16; 3usize],
    pub prefix_length: [u16; 3usize],
    pub mindist: u32,
    pub maxdist: u32,
    pub sigid: u32,
    pub lsigid: [u32; 3usize],
    pub ch: [u16; 2usize],
    pub virname: *mut ::std::os::raw::c_char,
    pub customdata: *mut ::std::os::raw::c_void,
    pub ch_mindist: [u16; 2usize],
    pub ch_maxdist: [u16; 2usize],
    pub parts: u16,
    pub partno: u16,
    pub special: u16,
    pub special_pattern: u16,
    pub special_table: *mut *mut cli_ac_special,
    pub rtype: u16,
    pub type_: u16,
    pub offdata: [u32; 4usize],
    pub offset_min: u32,
    pub offset_max: u32,
    pub boundary: u32,
    pub depth: u8,
    pub sigopts: u8,
}
#[test]
fn bindgen_test_layout_cli_ac_patt() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_patt>(),
        136usize,
        concat!("Size of: ", stringify!(cli_ac_patt))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_patt>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_patt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).pattern as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).prefix as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).prefix_length as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(prefix_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).mindist as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(mindist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).maxdist as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(maxdist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).sigid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(sigid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).lsigid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(lsigid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).ch as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).virname as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(virname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).customdata as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(customdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).ch_mindist as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(ch_mindist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).ch_maxdist as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(ch_maxdist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).parts as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(parts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).partno as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(partno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).special as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(special)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).special_pattern as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(special_pattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).special_table as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(special_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).rtype as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(rtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).type_ as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).offdata as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(offdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).offset_min as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(offset_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).offset_max as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(offset_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).boundary as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(boundary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).depth as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_patt>())).sigopts as *const _ as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_patt),
            "::",
            stringify!(sigopts)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_ac_list {
    pub me: *mut cli_ac_patt,
    pub __bindgen_anon_1: cli_ac_list__bindgen_ty_1,
    pub next_same: *mut cli_ac_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_ac_list__bindgen_ty_1 {
    pub node: *mut cli_ac_node,
    pub next: *mut cli_ac_list,
}
#[test]
fn bindgen_test_layout_cli_ac_list__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_list__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cli_ac_list__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_list__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_list__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_list__bindgen_ty_1>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_list__bindgen_ty_1),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_list__bindgen_ty_1>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_list__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
#[test]
fn bindgen_test_layout_cli_ac_list() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_list>(),
        24usize,
        concat!("Size of: ", stringify!(cli_ac_list))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_list>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_list>())).me as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_list),
            "::",
            stringify!(me)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_list>())).next_same as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_list),
            "::",
            stringify!(next_same)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ac_node {
    pub list: *mut cli_ac_list,
    pub trans: *mut *mut cli_ac_node,
    pub fail: *mut cli_ac_node,
}
#[test]
fn bindgen_test_layout_cli_ac_node() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_node>(),
        24usize,
        concat!("Size of: ", stringify!(cli_ac_node))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_node>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_node>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_node),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_node>())).trans as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_node),
            "::",
            stringify!(trans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_node>())).fail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_node),
            "::",
            stringify!(fail)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_ac_result {
    pub virname: *const ::std::os::raw::c_char,
    pub customdata: *mut ::std::os::raw::c_void,
    pub offset: off_t,
    pub next: *mut cli_ac_result,
}
#[test]
fn bindgen_test_layout_cli_ac_result() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_result>(),
        32usize,
        concat!("Size of: ", stringify!(cli_ac_result))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_result>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_result>())).virname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_result),
            "::",
            stringify!(virname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_result>())).customdata as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_result),
            "::",
            stringify!(customdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_result>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_result),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_result>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_result),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn cli_ac_addpatt(root: *mut cli_matcher, pattern: *mut cli_ac_patt) -> cl_error_t;
}
extern "C" {
    pub fn cli_ac_initdata(
        data: *mut cli_ac_data,
        partsigs: u32,
        lsigs: u32,
        reloffsigs: u32,
        tracklen: u8,
    ) -> cl_error_t;
}
extern "C" {
    pub fn lsig_sub_matched(
        root: *const cli_matcher,
        mdata: *mut cli_ac_data,
        lsigid1: u32,
        lsigid2: u32,
        realoff: u32,
        partial: ::std::os::raw::c_int,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_ac_chkmacro(
        root: *mut cli_matcher,
        data: *mut cli_ac_data,
        lsigid1: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_ac_chklsig(
        expr: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        lsigcnt: *mut u32,
        cnt: *mut ::std::os::raw::c_uint,
        ids: *mut u64,
        parse_only: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_ac_freedata(data: *mut cli_ac_data);
}
extern "C" {
    pub fn cli_ac_scanbuff(
        buffer: *const ::std::os::raw::c_uchar,
        length: u32,
        virname: *mut *const ::std::os::raw::c_char,
        customdata: *mut *mut ::std::os::raw::c_void,
        res: *mut *mut cli_ac_result,
        root: *const cli_matcher,
        mdata: *mut cli_ac_data,
        offset: u32,
        ftype: cli_file_t,
        ftoffset: *mut *mut cli_matched_type,
        mode: ::std::os::raw::c_uint,
        ctx: *mut cli_ctx,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_ac_buildtrie(root: *mut cli_matcher) -> cl_error_t;
}
extern "C" {
    pub fn cli_ac_init(
        root: *mut cli_matcher,
        mindepth: u8,
        maxdepth: u8,
        dconf_prefiltering: u8,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_ac_caloff(
        root: *const cli_matcher,
        data: *mut cli_ac_data,
        info: *const cli_target_info,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_ac_free(root: *mut cli_matcher);
}
extern "C" {
    pub fn cli_ac_addsig(
        root: *mut cli_matcher,
        virname: *const ::std::os::raw::c_char,
        hexsig: *const ::std::os::raw::c_char,
        sigopts: u8,
        sigid: u32,
        parts: u16,
        partno: u16,
        rtype: u16,
        type_: u16,
        mindist: u32,
        maxdist: u32,
        offset: *const ::std::os::raw::c_char,
        lsigid: *const u32,
        options: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bm_patt {
    pub pattern: *mut ::std::os::raw::c_uchar,
    pub prefix: *mut ::std::os::raw::c_uchar,
    pub virname: *mut ::std::os::raw::c_char,
    pub offdata: [u32; 4usize],
    pub offset_min: u32,
    pub offset_max: u32,
    pub next: *mut cli_bm_patt,
    pub length: u16,
    pub prefix_length: u16,
    pub cnt: u16,
    pub pattern0: ::std::os::raw::c_uchar,
    pub boundary: u32,
    pub filesize: u32,
}
#[test]
fn bindgen_test_layout_cli_bm_patt() {
    assert_eq!(
        ::std::mem::size_of::<cli_bm_patt>(),
        72usize,
        concat!("Size of: ", stringify!(cli_bm_patt))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_bm_patt>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_bm_patt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).pattern as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).prefix as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).virname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(virname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).offdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(offdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).offset_min as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(offset_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).offset_max as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(offset_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).length as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).prefix_length as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(prefix_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).cnt as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).pattern0 as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(pattern0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).boundary as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(boundary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_patt>())).filesize as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_patt),
            "::",
            stringify!(filesize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bm_off {
    pub offset: *mut u32,
    pub offtab: *mut u32,
    pub cnt: u32,
    pub pos: u32,
}
#[test]
fn bindgen_test_layout_cli_bm_off() {
    assert_eq!(
        ::std::mem::size_of::<cli_bm_off>(),
        24usize,
        concat!("Size of: ", stringify!(cli_bm_off))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_bm_off>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_bm_off))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_off>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_off),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_off>())).offtab as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_off),
            "::",
            stringify!(offtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_off>())).cnt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_off),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bm_off>())).pos as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bm_off),
            "::",
            stringify!(pos)
        )
    );
}
extern "C" {
    pub fn cli_bm_addpatt(
        root: *mut cli_matcher,
        pattern: *mut cli_bm_patt,
        offset: *const ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_bm_init(root: *mut cli_matcher) -> cl_error_t;
}
extern "C" {
    pub fn cli_bm_initoff(
        root: *const cli_matcher,
        data: *mut cli_bm_off,
        info: *const cli_target_info,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_bm_freeoff(data: *mut cli_bm_off);
}
extern "C" {
    pub fn cli_bm_scanbuff(
        buffer: *const ::std::os::raw::c_uchar,
        length: u32,
        virname: *mut *const ::std::os::raw::c_char,
        patt: *mut *const cli_bm_patt,
        root: *const cli_matcher,
        offset: u32,
        info: *const cli_target_info,
        offdata: *mut cli_bm_off,
        ctx: *mut cli_ctx,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_bm_free(root: *mut cli_matcher);
}
pub const CLI_HASH_TYPE_CLI_HASH_MD5: CLI_HASH_TYPE = 0;
pub const CLI_HASH_TYPE_CLI_HASH_SHA1: CLI_HASH_TYPE = 1;
pub const CLI_HASH_TYPE_CLI_HASH_SHA256: CLI_HASH_TYPE = 2;
pub const CLI_HASH_TYPE_CLI_HASH_AVAIL_TYPES: CLI_HASH_TYPE = 3;
pub type CLI_HASH_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_sz_hash {
    pub hash_array: *mut u8,
    pub virusnames: *mut *const ::std::os::raw::c_char,
    pub items: u32,
}
#[test]
fn bindgen_test_layout_cli_sz_hash() {
    assert_eq!(
        ::std::mem::size_of::<cli_sz_hash>(),
        24usize,
        concat!("Size of: ", stringify!(cli_sz_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_sz_hash>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_sz_hash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_sz_hash>())).hash_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_sz_hash),
            "::",
            stringify!(hash_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_sz_hash>())).virusnames as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_sz_hash),
            "::",
            stringify!(virusnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_sz_hash>())).items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_sz_hash),
            "::",
            stringify!(items)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_hash_patt {
    pub sizehashes: [cli_htu32; 3usize],
}
#[test]
fn bindgen_test_layout_cli_hash_patt() {
    assert_eq!(
        ::std::mem::size_of::<cli_hash_patt>(),
        96usize,
        concat!("Size of: ", stringify!(cli_hash_patt))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_hash_patt>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_hash_patt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hash_patt>())).sizehashes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hash_patt),
            "::",
            stringify!(sizehashes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_hash_wild {
    pub hashes: [cli_sz_hash; 3usize],
}
#[test]
fn bindgen_test_layout_cli_hash_wild() {
    assert_eq!(
        ::std::mem::size_of::<cli_hash_wild>(),
        72usize,
        concat!("Size of: ", stringify!(cli_hash_wild))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_hash_wild>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_hash_wild))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_hash_wild>())).hashes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_hash_wild),
            "::",
            stringify!(hashes)
        )
    );
}
extern "C" {
    pub fn hm_addhash_str(
        root: *mut cli_matcher,
        strhash: *const ::std::os::raw::c_char,
        size: u32,
        virusname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hm_addhash_bin(
        root: *mut cli_matcher,
        binhash: *const ::std::os::raw::c_void,
        type_: CLI_HASH_TYPE,
        size: u32,
        virusname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hm_flush(root: *mut cli_matcher);
}
extern "C" {
    pub fn cli_hm_scan(
        digest: *const ::std::os::raw::c_uchar,
        size: u32,
        virname: *mut *const ::std::os::raw::c_char,
        root: *const cli_matcher,
        type_: CLI_HASH_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hm_scan_wild(
        digest: *const ::std::os::raw::c_uchar,
        virname: *mut *const ::std::os::raw::c_char,
        root: *const cli_matcher,
        type_: CLI_HASH_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hm_have_size(
        root: *const cli_matcher,
        type_: CLI_HASH_TYPE,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hm_have_wild(
        root: *const cli_matcher,
        type_: CLI_HASH_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_hm_have_any(root: *const cli_matcher, type_: CLI_HASH_TYPE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hm_free(root: *mut cli_matcher);
}
pub type PCRE2_UCHAR8 = u8;
pub type PCRE2_UCHAR16 = u16;
pub type PCRE2_UCHAR32 = u32;
pub type PCRE2_SPTR8 = *const PCRE2_UCHAR8;
pub type PCRE2_SPTR16 = *const PCRE2_UCHAR16;
pub type PCRE2_SPTR32 = *const PCRE2_UCHAR32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_general_context_8 {
    _unused: [u8; 0],
}
pub type pcre2_general_context_8 = pcre2_real_general_context_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_compile_context_8 {
    _unused: [u8; 0],
}
pub type pcre2_compile_context_8 = pcre2_real_compile_context_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_match_context_8 {
    _unused: [u8; 0],
}
pub type pcre2_match_context_8 = pcre2_real_match_context_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_convert_context_8 {
    _unused: [u8; 0],
}
pub type pcre2_convert_context_8 = pcre2_real_convert_context_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_code_8 {
    _unused: [u8; 0],
}
pub type pcre2_code_8 = pcre2_real_code_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_match_data_8 {
    _unused: [u8; 0],
}
pub type pcre2_match_data_8 = pcre2_real_match_data_8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_jit_stack_8 {
    _unused: [u8; 0],
}
pub type pcre2_jit_stack_8 = pcre2_real_jit_stack_8;
pub type pcre2_jit_callback_8 = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut pcre2_jit_stack_8,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_callout_block_8 {
    pub version: u32,
    pub callout_number: u32,
    pub capture_top: u32,
    pub capture_last: u32,
    pub offset_vector: *mut size_t,
    pub mark: PCRE2_SPTR8,
    pub subject: PCRE2_SPTR8,
    pub subject_length: size_t,
    pub start_match: size_t,
    pub current_position: size_t,
    pub pattern_position: size_t,
    pub next_item_length: size_t,
    pub callout_string_offset: size_t,
    pub callout_string_length: size_t,
    pub callout_string: PCRE2_SPTR8,
    pub callout_flags: u32,
}
#[test]
fn bindgen_test_layout_pcre2_callout_block_8() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_callout_block_8>(),
        112usize,
        concat!("Size of: ", stringify!(pcre2_callout_block_8))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_callout_block_8>(),
        8usize,
        concat!("Alignment of ", stringify!(pcre2_callout_block_8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_8>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).callout_number as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(callout_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).capture_top as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(capture_top)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).capture_last as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(capture_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).offset_vector as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(offset_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_8>())).mark as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_8>())).subject as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).subject_length as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(subject_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).start_match as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(start_match)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).current_position as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(current_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).pattern_position as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(pattern_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).next_item_length as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(next_item_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).callout_string_offset as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(callout_string_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).callout_string_length as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(callout_string_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).callout_string as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(callout_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_8>())).callout_flags as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_8),
            "::",
            stringify!(callout_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_callout_enumerate_block_8 {
    pub version: u32,
    pub pattern_position: size_t,
    pub next_item_length: size_t,
    pub callout_number: u32,
    pub callout_string_offset: size_t,
    pub callout_string_length: size_t,
    pub callout_string: PCRE2_SPTR8,
}
#[test]
fn bindgen_test_layout_pcre2_callout_enumerate_block_8() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_callout_enumerate_block_8>(),
        56usize,
        concat!("Size of: ", stringify!(pcre2_callout_enumerate_block_8))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_callout_enumerate_block_8>(),
        8usize,
        concat!("Alignment of ", stringify!(pcre2_callout_enumerate_block_8))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_8>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_8),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_8>())).pattern_position as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_8),
            "::",
            stringify!(pattern_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_8>())).next_item_length as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_8),
            "::",
            stringify!(next_item_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_8>())).callout_number as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_8),
            "::",
            stringify!(callout_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_8>())).callout_string_offset
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_8),
            "::",
            stringify!(callout_string_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_8>())).callout_string_length
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_8),
            "::",
            stringify!(callout_string_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_8>())).callout_string as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_8),
            "::",
            stringify!(callout_string)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_substitute_callout_block_8 {
    pub version: u32,
    pub input: PCRE2_SPTR8,
    pub output: PCRE2_SPTR8,
    pub output_offsets: [size_t; 2usize],
    pub ovector: *mut size_t,
    pub oveccount: u32,
    pub subscount: u32,
}
#[test]
fn bindgen_test_layout_pcre2_substitute_callout_block_8() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_substitute_callout_block_8>(),
        56usize,
        concat!("Size of: ", stringify!(pcre2_substitute_callout_block_8))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_substitute_callout_block_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pcre2_substitute_callout_block_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_8>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_8),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_8>())).input as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_8),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_8>())).output as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_8),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_8>())).output_offsets as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_8),
            "::",
            stringify!(output_offsets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_8>())).ovector as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_8),
            "::",
            stringify!(ovector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_8>())).oveccount as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_8),
            "::",
            stringify!(oveccount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_8>())).subscount as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_8),
            "::",
            stringify!(subscount)
        )
    );
}
extern "C" {
    pub fn pcre2_config_8(arg1: u32, arg2: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_general_context_copy_8(
        arg1: *mut pcre2_general_context_8,
    ) -> *mut pcre2_general_context_8;
}
extern "C" {
    pub fn pcre2_general_context_create_8(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut pcre2_general_context_8;
}
extern "C" {
    pub fn pcre2_general_context_free_8(arg1: *mut pcre2_general_context_8);
}
extern "C" {
    pub fn pcre2_compile_context_copy_8(
        arg1: *mut pcre2_compile_context_8,
    ) -> *mut pcre2_compile_context_8;
}
extern "C" {
    pub fn pcre2_compile_context_create_8(
        arg1: *mut pcre2_general_context_8,
    ) -> *mut pcre2_compile_context_8;
}
extern "C" {
    pub fn pcre2_compile_context_free_8(arg1: *mut pcre2_compile_context_8);
}
extern "C" {
    pub fn pcre2_set_bsr_8(arg1: *mut pcre2_compile_context_8, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_character_tables_8(
        arg1: *mut pcre2_compile_context_8,
        arg2: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_compile_extra_options_8(
        arg1: *mut pcre2_compile_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_max_pattern_length_8(
        arg1: *mut pcre2_compile_context_8,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_newline_8(
        arg1: *mut pcre2_compile_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_parens_nest_limit_8(
        arg1: *mut pcre2_compile_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_compile_recursion_guard_8(
        arg1: *mut pcre2_compile_context_8,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: u32,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_convert_context_copy_8(
        arg1: *mut pcre2_convert_context_8,
    ) -> *mut pcre2_convert_context_8;
}
extern "C" {
    pub fn pcre2_convert_context_create_8(
        arg1: *mut pcre2_general_context_8,
    ) -> *mut pcre2_convert_context_8;
}
extern "C" {
    pub fn pcre2_convert_context_free_8(arg1: *mut pcre2_convert_context_8);
}
extern "C" {
    pub fn pcre2_set_glob_escape_8(
        arg1: *mut pcre2_convert_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_glob_separator_8(
        arg1: *mut pcre2_convert_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_pattern_convert_8(
        arg1: PCRE2_SPTR8,
        arg2: size_t,
        arg3: u32,
        arg4: *mut *mut PCRE2_UCHAR8,
        arg5: *mut size_t,
        arg6: *mut pcre2_convert_context_8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_converted_pattern_free_8(arg1: *mut PCRE2_UCHAR8);
}
extern "C" {
    pub fn pcre2_match_context_copy_8(
        arg1: *mut pcre2_match_context_8,
    ) -> *mut pcre2_match_context_8;
}
extern "C" {
    pub fn pcre2_match_context_create_8(
        arg1: *mut pcre2_general_context_8,
    ) -> *mut pcre2_match_context_8;
}
extern "C" {
    pub fn pcre2_match_context_free_8(arg1: *mut pcre2_match_context_8);
}
extern "C" {
    pub fn pcre2_set_callout_8(
        arg1: *mut pcre2_match_context_8,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_callout_block_8,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_substitute_callout_8(
        arg1: *mut pcre2_match_context_8,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_substitute_callout_block_8,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_depth_limit_8(
        arg1: *mut pcre2_match_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_heap_limit_8(
        arg1: *mut pcre2_match_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_match_limit_8(
        arg1: *mut pcre2_match_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_offset_limit_8(
        arg1: *mut pcre2_match_context_8,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_recursion_limit_8(
        arg1: *mut pcre2_match_context_8,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_recursion_memory_management_8(
        arg1: *mut pcre2_match_context_8,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_compile_8(
        arg1: PCRE2_SPTR8,
        arg2: size_t,
        arg3: u32,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut size_t,
        arg6: *mut pcre2_compile_context_8,
    ) -> *mut pcre2_code_8;
}
extern "C" {
    pub fn pcre2_code_free_8(arg1: *mut pcre2_code_8);
}
extern "C" {
    pub fn pcre2_code_copy_8(arg1: *const pcre2_code_8) -> *mut pcre2_code_8;
}
extern "C" {
    pub fn pcre2_code_copy_with_tables_8(arg1: *const pcre2_code_8) -> *mut pcre2_code_8;
}
extern "C" {
    pub fn pcre2_pattern_info_8(
        arg1: *const pcre2_code_8,
        arg2: u32,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_callout_enumerate_8(
        arg1: *const pcre2_code_8,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_callout_enumerate_block_8,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_data_create_8(
        arg1: u32,
        arg2: *mut pcre2_general_context_8,
    ) -> *mut pcre2_match_data_8;
}
extern "C" {
    pub fn pcre2_match_data_create_from_pattern_8(
        arg1: *const pcre2_code_8,
        arg2: *mut pcre2_general_context_8,
    ) -> *mut pcre2_match_data_8;
}
extern "C" {
    pub fn pcre2_dfa_match_8(
        arg1: *const pcre2_code_8,
        arg2: PCRE2_SPTR8,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_8,
        arg7: *mut pcre2_match_context_8,
        arg8: *mut ::std::os::raw::c_int,
        arg9: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_8(
        arg1: *const pcre2_code_8,
        arg2: PCRE2_SPTR8,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_8,
        arg7: *mut pcre2_match_context_8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_data_free_8(arg1: *mut pcre2_match_data_8);
}
extern "C" {
    pub fn pcre2_get_mark_8(arg1: *mut pcre2_match_data_8) -> PCRE2_SPTR8;
}
extern "C" {
    pub fn pcre2_get_match_data_size_8(arg1: *mut pcre2_match_data_8) -> size_t;
}
extern "C" {
    pub fn pcre2_get_ovector_count_8(arg1: *mut pcre2_match_data_8) -> u32;
}
extern "C" {
    pub fn pcre2_get_ovector_pointer_8(arg1: *mut pcre2_match_data_8) -> *mut size_t;
}
extern "C" {
    pub fn pcre2_get_startchar_8(arg1: *mut pcre2_match_data_8) -> size_t;
}
extern "C" {
    pub fn pcre2_substring_copy_byname_8(
        arg1: *mut pcre2_match_data_8,
        arg2: PCRE2_SPTR8,
        arg3: *mut PCRE2_UCHAR8,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_copy_bynumber_8(
        arg1: *mut pcre2_match_data_8,
        arg2: u32,
        arg3: *mut PCRE2_UCHAR8,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_free_8(arg1: *mut PCRE2_UCHAR8);
}
extern "C" {
    pub fn pcre2_substring_get_byname_8(
        arg1: *mut pcre2_match_data_8,
        arg2: PCRE2_SPTR8,
        arg3: *mut *mut PCRE2_UCHAR8,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_get_bynumber_8(
        arg1: *mut pcre2_match_data_8,
        arg2: u32,
        arg3: *mut *mut PCRE2_UCHAR8,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_length_byname_8(
        arg1: *mut pcre2_match_data_8,
        arg2: PCRE2_SPTR8,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_length_bynumber_8(
        arg1: *mut pcre2_match_data_8,
        arg2: u32,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_nametable_scan_8(
        arg1: *const pcre2_code_8,
        arg2: PCRE2_SPTR8,
        arg3: *mut PCRE2_SPTR8,
        arg4: *mut PCRE2_SPTR8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_number_from_name_8(
        arg1: *const pcre2_code_8,
        arg2: PCRE2_SPTR8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_list_free_8(arg1: *mut PCRE2_SPTR8);
}
extern "C" {
    pub fn pcre2_substring_list_get_8(
        arg1: *mut pcre2_match_data_8,
        arg2: *mut *mut *mut PCRE2_UCHAR8,
        arg3: *mut *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_serialize_encode_8(
        arg1: *mut *const pcre2_code_8,
        arg2: i32,
        arg3: *mut *mut u8,
        arg4: *mut size_t,
        arg5: *mut pcre2_general_context_8,
    ) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_decode_8(
        arg1: *mut *mut pcre2_code_8,
        arg2: i32,
        arg3: *const u8,
        arg4: *mut pcre2_general_context_8,
    ) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_get_number_of_codes_8(arg1: *const u8) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_free_8(arg1: *mut u8);
}
extern "C" {
    pub fn pcre2_substitute_8(
        arg1: *const pcre2_code_8,
        arg2: PCRE2_SPTR8,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_8,
        arg7: *mut pcre2_match_context_8,
        arg8: PCRE2_SPTR8,
        arg9: size_t,
        arg10: *mut PCRE2_UCHAR8,
        arg11: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_compile_8(arg1: *mut pcre2_code_8, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_match_8(
        arg1: *const pcre2_code_8,
        arg2: PCRE2_SPTR8,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_8,
        arg7: *mut pcre2_match_context_8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_free_unused_memory_8(arg1: *mut pcre2_general_context_8);
}
extern "C" {
    pub fn pcre2_jit_stack_create_8(
        arg1: size_t,
        arg2: size_t,
        arg3: *mut pcre2_general_context_8,
    ) -> *mut pcre2_jit_stack_8;
}
extern "C" {
    pub fn pcre2_jit_stack_assign_8(
        arg1: *mut pcre2_match_context_8,
        arg2: pcre2_jit_callback_8,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pcre2_jit_stack_free_8(arg1: *mut pcre2_jit_stack_8);
}
extern "C" {
    pub fn pcre2_get_error_message_8(
        arg1: ::std::os::raw::c_int,
        arg2: *mut PCRE2_UCHAR8,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_maketables_8(arg1: *mut pcre2_general_context_8) -> *const u8;
}
extern "C" {
    pub fn pcre2_maketables_free_8(arg1: *mut pcre2_general_context_8, arg2: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_general_context_16 {
    _unused: [u8; 0],
}
pub type pcre2_general_context_16 = pcre2_real_general_context_16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_compile_context_16 {
    _unused: [u8; 0],
}
pub type pcre2_compile_context_16 = pcre2_real_compile_context_16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_match_context_16 {
    _unused: [u8; 0],
}
pub type pcre2_match_context_16 = pcre2_real_match_context_16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_convert_context_16 {
    _unused: [u8; 0],
}
pub type pcre2_convert_context_16 = pcre2_real_convert_context_16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_code_16 {
    _unused: [u8; 0],
}
pub type pcre2_code_16 = pcre2_real_code_16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_match_data_16 {
    _unused: [u8; 0],
}
pub type pcre2_match_data_16 = pcre2_real_match_data_16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_jit_stack_16 {
    _unused: [u8; 0],
}
pub type pcre2_jit_stack_16 = pcre2_real_jit_stack_16;
pub type pcre2_jit_callback_16 = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut pcre2_jit_stack_16,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_callout_block_16 {
    pub version: u32,
    pub callout_number: u32,
    pub capture_top: u32,
    pub capture_last: u32,
    pub offset_vector: *mut size_t,
    pub mark: PCRE2_SPTR16,
    pub subject: PCRE2_SPTR16,
    pub subject_length: size_t,
    pub start_match: size_t,
    pub current_position: size_t,
    pub pattern_position: size_t,
    pub next_item_length: size_t,
    pub callout_string_offset: size_t,
    pub callout_string_length: size_t,
    pub callout_string: PCRE2_SPTR16,
    pub callout_flags: u32,
}
#[test]
fn bindgen_test_layout_pcre2_callout_block_16() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_callout_block_16>(),
        112usize,
        concat!("Size of: ", stringify!(pcre2_callout_block_16))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_callout_block_16>(),
        8usize,
        concat!("Alignment of ", stringify!(pcre2_callout_block_16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_16>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).callout_number as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(callout_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).capture_top as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(capture_top)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).capture_last as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(capture_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).offset_vector as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(offset_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_16>())).mark as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_16>())).subject as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).subject_length as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(subject_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).start_match as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(start_match)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).current_position as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(current_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).pattern_position as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(pattern_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).next_item_length as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(next_item_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).callout_string_offset as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(callout_string_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).callout_string_length as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(callout_string_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).callout_string as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(callout_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_16>())).callout_flags as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_16),
            "::",
            stringify!(callout_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_callout_enumerate_block_16 {
    pub version: u32,
    pub pattern_position: size_t,
    pub next_item_length: size_t,
    pub callout_number: u32,
    pub callout_string_offset: size_t,
    pub callout_string_length: size_t,
    pub callout_string: PCRE2_SPTR16,
}
#[test]
fn bindgen_test_layout_pcre2_callout_enumerate_block_16() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_callout_enumerate_block_16>(),
        56usize,
        concat!("Size of: ", stringify!(pcre2_callout_enumerate_block_16))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_callout_enumerate_block_16>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pcre2_callout_enumerate_block_16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_16>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_16),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_16>())).pattern_position
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_16),
            "::",
            stringify!(pattern_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_16>())).next_item_length
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_16),
            "::",
            stringify!(next_item_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_16>())).callout_number as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_16),
            "::",
            stringify!(callout_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_16>())).callout_string_offset
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_16),
            "::",
            stringify!(callout_string_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_16>())).callout_string_length
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_16),
            "::",
            stringify!(callout_string_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_16>())).callout_string as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_16),
            "::",
            stringify!(callout_string)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_substitute_callout_block_16 {
    pub version: u32,
    pub input: PCRE2_SPTR16,
    pub output: PCRE2_SPTR16,
    pub output_offsets: [size_t; 2usize],
    pub ovector: *mut size_t,
    pub oveccount: u32,
    pub subscount: u32,
}
#[test]
fn bindgen_test_layout_pcre2_substitute_callout_block_16() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_substitute_callout_block_16>(),
        56usize,
        concat!("Size of: ", stringify!(pcre2_substitute_callout_block_16))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_substitute_callout_block_16>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pcre2_substitute_callout_block_16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_16>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_16),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_16>())).input as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_16),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_16>())).output as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_16),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_16>())).output_offsets as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_16),
            "::",
            stringify!(output_offsets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_16>())).ovector as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_16),
            "::",
            stringify!(ovector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_16>())).oveccount as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_16),
            "::",
            stringify!(oveccount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_16>())).subscount as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_16),
            "::",
            stringify!(subscount)
        )
    );
}
extern "C" {
    pub fn pcre2_config_16(arg1: u32, arg2: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_general_context_copy_16(
        arg1: *mut pcre2_general_context_16,
    ) -> *mut pcre2_general_context_16;
}
extern "C" {
    pub fn pcre2_general_context_create_16(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut pcre2_general_context_16;
}
extern "C" {
    pub fn pcre2_general_context_free_16(arg1: *mut pcre2_general_context_16);
}
extern "C" {
    pub fn pcre2_compile_context_copy_16(
        arg1: *mut pcre2_compile_context_16,
    ) -> *mut pcre2_compile_context_16;
}
extern "C" {
    pub fn pcre2_compile_context_create_16(
        arg1: *mut pcre2_general_context_16,
    ) -> *mut pcre2_compile_context_16;
}
extern "C" {
    pub fn pcre2_compile_context_free_16(arg1: *mut pcre2_compile_context_16);
}
extern "C" {
    pub fn pcre2_set_bsr_16(
        arg1: *mut pcre2_compile_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_character_tables_16(
        arg1: *mut pcre2_compile_context_16,
        arg2: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_compile_extra_options_16(
        arg1: *mut pcre2_compile_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_max_pattern_length_16(
        arg1: *mut pcre2_compile_context_16,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_newline_16(
        arg1: *mut pcre2_compile_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_parens_nest_limit_16(
        arg1: *mut pcre2_compile_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_compile_recursion_guard_16(
        arg1: *mut pcre2_compile_context_16,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: u32,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_convert_context_copy_16(
        arg1: *mut pcre2_convert_context_16,
    ) -> *mut pcre2_convert_context_16;
}
extern "C" {
    pub fn pcre2_convert_context_create_16(
        arg1: *mut pcre2_general_context_16,
    ) -> *mut pcre2_convert_context_16;
}
extern "C" {
    pub fn pcre2_convert_context_free_16(arg1: *mut pcre2_convert_context_16);
}
extern "C" {
    pub fn pcre2_set_glob_escape_16(
        arg1: *mut pcre2_convert_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_glob_separator_16(
        arg1: *mut pcre2_convert_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_pattern_convert_16(
        arg1: PCRE2_SPTR16,
        arg2: size_t,
        arg3: u32,
        arg4: *mut *mut PCRE2_UCHAR16,
        arg5: *mut size_t,
        arg6: *mut pcre2_convert_context_16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_converted_pattern_free_16(arg1: *mut PCRE2_UCHAR16);
}
extern "C" {
    pub fn pcre2_match_context_copy_16(
        arg1: *mut pcre2_match_context_16,
    ) -> *mut pcre2_match_context_16;
}
extern "C" {
    pub fn pcre2_match_context_create_16(
        arg1: *mut pcre2_general_context_16,
    ) -> *mut pcre2_match_context_16;
}
extern "C" {
    pub fn pcre2_match_context_free_16(arg1: *mut pcre2_match_context_16);
}
extern "C" {
    pub fn pcre2_set_callout_16(
        arg1: *mut pcre2_match_context_16,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_callout_block_16,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_substitute_callout_16(
        arg1: *mut pcre2_match_context_16,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_substitute_callout_block_16,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_depth_limit_16(
        arg1: *mut pcre2_match_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_heap_limit_16(
        arg1: *mut pcre2_match_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_match_limit_16(
        arg1: *mut pcre2_match_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_offset_limit_16(
        arg1: *mut pcre2_match_context_16,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_recursion_limit_16(
        arg1: *mut pcre2_match_context_16,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_recursion_memory_management_16(
        arg1: *mut pcre2_match_context_16,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_compile_16(
        arg1: PCRE2_SPTR16,
        arg2: size_t,
        arg3: u32,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut size_t,
        arg6: *mut pcre2_compile_context_16,
    ) -> *mut pcre2_code_16;
}
extern "C" {
    pub fn pcre2_code_free_16(arg1: *mut pcre2_code_16);
}
extern "C" {
    pub fn pcre2_code_copy_16(arg1: *const pcre2_code_16) -> *mut pcre2_code_16;
}
extern "C" {
    pub fn pcre2_code_copy_with_tables_16(arg1: *const pcre2_code_16) -> *mut pcre2_code_16;
}
extern "C" {
    pub fn pcre2_pattern_info_16(
        arg1: *const pcre2_code_16,
        arg2: u32,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_callout_enumerate_16(
        arg1: *const pcre2_code_16,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_callout_enumerate_block_16,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_data_create_16(
        arg1: u32,
        arg2: *mut pcre2_general_context_16,
    ) -> *mut pcre2_match_data_16;
}
extern "C" {
    pub fn pcre2_match_data_create_from_pattern_16(
        arg1: *const pcre2_code_16,
        arg2: *mut pcre2_general_context_16,
    ) -> *mut pcre2_match_data_16;
}
extern "C" {
    pub fn pcre2_dfa_match_16(
        arg1: *const pcre2_code_16,
        arg2: PCRE2_SPTR16,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_16,
        arg7: *mut pcre2_match_context_16,
        arg8: *mut ::std::os::raw::c_int,
        arg9: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_16(
        arg1: *const pcre2_code_16,
        arg2: PCRE2_SPTR16,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_16,
        arg7: *mut pcre2_match_context_16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_data_free_16(arg1: *mut pcre2_match_data_16);
}
extern "C" {
    pub fn pcre2_get_mark_16(arg1: *mut pcre2_match_data_16) -> PCRE2_SPTR16;
}
extern "C" {
    pub fn pcre2_get_match_data_size_16(arg1: *mut pcre2_match_data_16) -> size_t;
}
extern "C" {
    pub fn pcre2_get_ovector_count_16(arg1: *mut pcre2_match_data_16) -> u32;
}
extern "C" {
    pub fn pcre2_get_ovector_pointer_16(arg1: *mut pcre2_match_data_16) -> *mut size_t;
}
extern "C" {
    pub fn pcre2_get_startchar_16(arg1: *mut pcre2_match_data_16) -> size_t;
}
extern "C" {
    pub fn pcre2_substring_copy_byname_16(
        arg1: *mut pcre2_match_data_16,
        arg2: PCRE2_SPTR16,
        arg3: *mut PCRE2_UCHAR16,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_copy_bynumber_16(
        arg1: *mut pcre2_match_data_16,
        arg2: u32,
        arg3: *mut PCRE2_UCHAR16,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_free_16(arg1: *mut PCRE2_UCHAR16);
}
extern "C" {
    pub fn pcre2_substring_get_byname_16(
        arg1: *mut pcre2_match_data_16,
        arg2: PCRE2_SPTR16,
        arg3: *mut *mut PCRE2_UCHAR16,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_get_bynumber_16(
        arg1: *mut pcre2_match_data_16,
        arg2: u32,
        arg3: *mut *mut PCRE2_UCHAR16,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_length_byname_16(
        arg1: *mut pcre2_match_data_16,
        arg2: PCRE2_SPTR16,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_length_bynumber_16(
        arg1: *mut pcre2_match_data_16,
        arg2: u32,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_nametable_scan_16(
        arg1: *const pcre2_code_16,
        arg2: PCRE2_SPTR16,
        arg3: *mut PCRE2_SPTR16,
        arg4: *mut PCRE2_SPTR16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_number_from_name_16(
        arg1: *const pcre2_code_16,
        arg2: PCRE2_SPTR16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_list_free_16(arg1: *mut PCRE2_SPTR16);
}
extern "C" {
    pub fn pcre2_substring_list_get_16(
        arg1: *mut pcre2_match_data_16,
        arg2: *mut *mut *mut PCRE2_UCHAR16,
        arg3: *mut *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_serialize_encode_16(
        arg1: *mut *const pcre2_code_16,
        arg2: i32,
        arg3: *mut *mut u8,
        arg4: *mut size_t,
        arg5: *mut pcre2_general_context_16,
    ) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_decode_16(
        arg1: *mut *mut pcre2_code_16,
        arg2: i32,
        arg3: *const u8,
        arg4: *mut pcre2_general_context_16,
    ) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_get_number_of_codes_16(arg1: *const u8) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_free_16(arg1: *mut u8);
}
extern "C" {
    pub fn pcre2_substitute_16(
        arg1: *const pcre2_code_16,
        arg2: PCRE2_SPTR16,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_16,
        arg7: *mut pcre2_match_context_16,
        arg8: PCRE2_SPTR16,
        arg9: size_t,
        arg10: *mut PCRE2_UCHAR16,
        arg11: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_compile_16(arg1: *mut pcre2_code_16, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_match_16(
        arg1: *const pcre2_code_16,
        arg2: PCRE2_SPTR16,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_16,
        arg7: *mut pcre2_match_context_16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_free_unused_memory_16(arg1: *mut pcre2_general_context_16);
}
extern "C" {
    pub fn pcre2_jit_stack_create_16(
        arg1: size_t,
        arg2: size_t,
        arg3: *mut pcre2_general_context_16,
    ) -> *mut pcre2_jit_stack_16;
}
extern "C" {
    pub fn pcre2_jit_stack_assign_16(
        arg1: *mut pcre2_match_context_16,
        arg2: pcre2_jit_callback_16,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pcre2_jit_stack_free_16(arg1: *mut pcre2_jit_stack_16);
}
extern "C" {
    pub fn pcre2_get_error_message_16(
        arg1: ::std::os::raw::c_int,
        arg2: *mut PCRE2_UCHAR16,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_maketables_16(arg1: *mut pcre2_general_context_16) -> *const u8;
}
extern "C" {
    pub fn pcre2_maketables_free_16(arg1: *mut pcre2_general_context_16, arg2: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_general_context_32 {
    _unused: [u8; 0],
}
pub type pcre2_general_context_32 = pcre2_real_general_context_32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_compile_context_32 {
    _unused: [u8; 0],
}
pub type pcre2_compile_context_32 = pcre2_real_compile_context_32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_match_context_32 {
    _unused: [u8; 0],
}
pub type pcre2_match_context_32 = pcre2_real_match_context_32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_convert_context_32 {
    _unused: [u8; 0],
}
pub type pcre2_convert_context_32 = pcre2_real_convert_context_32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_code_32 {
    _unused: [u8; 0],
}
pub type pcre2_code_32 = pcre2_real_code_32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_match_data_32 {
    _unused: [u8; 0],
}
pub type pcre2_match_data_32 = pcre2_real_match_data_32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_real_jit_stack_32 {
    _unused: [u8; 0],
}
pub type pcre2_jit_stack_32 = pcre2_real_jit_stack_32;
pub type pcre2_jit_callback_32 = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut pcre2_jit_stack_32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_callout_block_32 {
    pub version: u32,
    pub callout_number: u32,
    pub capture_top: u32,
    pub capture_last: u32,
    pub offset_vector: *mut size_t,
    pub mark: PCRE2_SPTR32,
    pub subject: PCRE2_SPTR32,
    pub subject_length: size_t,
    pub start_match: size_t,
    pub current_position: size_t,
    pub pattern_position: size_t,
    pub next_item_length: size_t,
    pub callout_string_offset: size_t,
    pub callout_string_length: size_t,
    pub callout_string: PCRE2_SPTR32,
    pub callout_flags: u32,
}
#[test]
fn bindgen_test_layout_pcre2_callout_block_32() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_callout_block_32>(),
        112usize,
        concat!("Size of: ", stringify!(pcre2_callout_block_32))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_callout_block_32>(),
        8usize,
        concat!("Alignment of ", stringify!(pcre2_callout_block_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_32>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).callout_number as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(callout_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).capture_top as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(capture_top)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).capture_last as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(capture_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).offset_vector as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(offset_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_32>())).mark as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcre2_callout_block_32>())).subject as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).subject_length as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(subject_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).start_match as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(start_match)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).current_position as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(current_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).pattern_position as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(pattern_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).next_item_length as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(next_item_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).callout_string_offset as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(callout_string_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).callout_string_length as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(callout_string_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).callout_string as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(callout_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_block_32>())).callout_flags as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_block_32),
            "::",
            stringify!(callout_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_callout_enumerate_block_32 {
    pub version: u32,
    pub pattern_position: size_t,
    pub next_item_length: size_t,
    pub callout_number: u32,
    pub callout_string_offset: size_t,
    pub callout_string_length: size_t,
    pub callout_string: PCRE2_SPTR32,
}
#[test]
fn bindgen_test_layout_pcre2_callout_enumerate_block_32() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_callout_enumerate_block_32>(),
        56usize,
        concat!("Size of: ", stringify!(pcre2_callout_enumerate_block_32))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_callout_enumerate_block_32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pcre2_callout_enumerate_block_32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_32>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_32),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_32>())).pattern_position
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_32),
            "::",
            stringify!(pattern_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_32>())).next_item_length
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_32),
            "::",
            stringify!(next_item_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_32>())).callout_number as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_32),
            "::",
            stringify!(callout_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_32>())).callout_string_offset
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_32),
            "::",
            stringify!(callout_string_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_32>())).callout_string_length
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_32),
            "::",
            stringify!(callout_string_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_callout_enumerate_block_32>())).callout_string as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_callout_enumerate_block_32),
            "::",
            stringify!(callout_string)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre2_substitute_callout_block_32 {
    pub version: u32,
    pub input: PCRE2_SPTR32,
    pub output: PCRE2_SPTR32,
    pub output_offsets: [size_t; 2usize],
    pub ovector: *mut size_t,
    pub oveccount: u32,
    pub subscount: u32,
}
#[test]
fn bindgen_test_layout_pcre2_substitute_callout_block_32() {
    assert_eq!(
        ::std::mem::size_of::<pcre2_substitute_callout_block_32>(),
        56usize,
        concat!("Size of: ", stringify!(pcre2_substitute_callout_block_32))
    );
    assert_eq!(
        ::std::mem::align_of::<pcre2_substitute_callout_block_32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pcre2_substitute_callout_block_32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_32>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_32),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_32>())).input as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_32),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_32>())).output as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_32),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_32>())).output_offsets as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_32),
            "::",
            stringify!(output_offsets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_32>())).ovector as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_32),
            "::",
            stringify!(ovector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_32>())).oveccount as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_32),
            "::",
            stringify!(oveccount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pcre2_substitute_callout_block_32>())).subscount as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(pcre2_substitute_callout_block_32),
            "::",
            stringify!(subscount)
        )
    );
}
extern "C" {
    pub fn pcre2_config_32(arg1: u32, arg2: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_general_context_copy_32(
        arg1: *mut pcre2_general_context_32,
    ) -> *mut pcre2_general_context_32;
}
extern "C" {
    pub fn pcre2_general_context_create_32(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut pcre2_general_context_32;
}
extern "C" {
    pub fn pcre2_general_context_free_32(arg1: *mut pcre2_general_context_32);
}
extern "C" {
    pub fn pcre2_compile_context_copy_32(
        arg1: *mut pcre2_compile_context_32,
    ) -> *mut pcre2_compile_context_32;
}
extern "C" {
    pub fn pcre2_compile_context_create_32(
        arg1: *mut pcre2_general_context_32,
    ) -> *mut pcre2_compile_context_32;
}
extern "C" {
    pub fn pcre2_compile_context_free_32(arg1: *mut pcre2_compile_context_32);
}
extern "C" {
    pub fn pcre2_set_bsr_32(
        arg1: *mut pcre2_compile_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_character_tables_32(
        arg1: *mut pcre2_compile_context_32,
        arg2: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_compile_extra_options_32(
        arg1: *mut pcre2_compile_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_max_pattern_length_32(
        arg1: *mut pcre2_compile_context_32,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_newline_32(
        arg1: *mut pcre2_compile_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_parens_nest_limit_32(
        arg1: *mut pcre2_compile_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_compile_recursion_guard_32(
        arg1: *mut pcre2_compile_context_32,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: u32,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_convert_context_copy_32(
        arg1: *mut pcre2_convert_context_32,
    ) -> *mut pcre2_convert_context_32;
}
extern "C" {
    pub fn pcre2_convert_context_create_32(
        arg1: *mut pcre2_general_context_32,
    ) -> *mut pcre2_convert_context_32;
}
extern "C" {
    pub fn pcre2_convert_context_free_32(arg1: *mut pcre2_convert_context_32);
}
extern "C" {
    pub fn pcre2_set_glob_escape_32(
        arg1: *mut pcre2_convert_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_glob_separator_32(
        arg1: *mut pcre2_convert_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_pattern_convert_32(
        arg1: PCRE2_SPTR32,
        arg2: size_t,
        arg3: u32,
        arg4: *mut *mut PCRE2_UCHAR32,
        arg5: *mut size_t,
        arg6: *mut pcre2_convert_context_32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_converted_pattern_free_32(arg1: *mut PCRE2_UCHAR32);
}
extern "C" {
    pub fn pcre2_match_context_copy_32(
        arg1: *mut pcre2_match_context_32,
    ) -> *mut pcre2_match_context_32;
}
extern "C" {
    pub fn pcre2_match_context_create_32(
        arg1: *mut pcre2_general_context_32,
    ) -> *mut pcre2_match_context_32;
}
extern "C" {
    pub fn pcre2_match_context_free_32(arg1: *mut pcre2_match_context_32);
}
extern "C" {
    pub fn pcre2_set_callout_32(
        arg1: *mut pcre2_match_context_32,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_callout_block_32,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_substitute_callout_32(
        arg1: *mut pcre2_match_context_32,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_substitute_callout_block_32,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_depth_limit_32(
        arg1: *mut pcre2_match_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_heap_limit_32(
        arg1: *mut pcre2_match_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_match_limit_32(
        arg1: *mut pcre2_match_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_offset_limit_32(
        arg1: *mut pcre2_match_context_32,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_recursion_limit_32(
        arg1: *mut pcre2_match_context_32,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_set_recursion_memory_management_32(
        arg1: *mut pcre2_match_context_32,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: size_t,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_compile_32(
        arg1: PCRE2_SPTR32,
        arg2: size_t,
        arg3: u32,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut size_t,
        arg6: *mut pcre2_compile_context_32,
    ) -> *mut pcre2_code_32;
}
extern "C" {
    pub fn pcre2_code_free_32(arg1: *mut pcre2_code_32);
}
extern "C" {
    pub fn pcre2_code_copy_32(arg1: *const pcre2_code_32) -> *mut pcre2_code_32;
}
extern "C" {
    pub fn pcre2_code_copy_with_tables_32(arg1: *const pcre2_code_32) -> *mut pcre2_code_32;
}
extern "C" {
    pub fn pcre2_pattern_info_32(
        arg1: *const pcre2_code_32,
        arg2: u32,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_callout_enumerate_32(
        arg1: *const pcre2_code_32,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pcre2_callout_enumerate_block_32,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_data_create_32(
        arg1: u32,
        arg2: *mut pcre2_general_context_32,
    ) -> *mut pcre2_match_data_32;
}
extern "C" {
    pub fn pcre2_match_data_create_from_pattern_32(
        arg1: *const pcre2_code_32,
        arg2: *mut pcre2_general_context_32,
    ) -> *mut pcre2_match_data_32;
}
extern "C" {
    pub fn pcre2_dfa_match_32(
        arg1: *const pcre2_code_32,
        arg2: PCRE2_SPTR32,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_32,
        arg7: *mut pcre2_match_context_32,
        arg8: *mut ::std::os::raw::c_int,
        arg9: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_32(
        arg1: *const pcre2_code_32,
        arg2: PCRE2_SPTR32,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_32,
        arg7: *mut pcre2_match_context_32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_match_data_free_32(arg1: *mut pcre2_match_data_32);
}
extern "C" {
    pub fn pcre2_get_mark_32(arg1: *mut pcre2_match_data_32) -> PCRE2_SPTR32;
}
extern "C" {
    pub fn pcre2_get_match_data_size_32(arg1: *mut pcre2_match_data_32) -> size_t;
}
extern "C" {
    pub fn pcre2_get_ovector_count_32(arg1: *mut pcre2_match_data_32) -> u32;
}
extern "C" {
    pub fn pcre2_get_ovector_pointer_32(arg1: *mut pcre2_match_data_32) -> *mut size_t;
}
extern "C" {
    pub fn pcre2_get_startchar_32(arg1: *mut pcre2_match_data_32) -> size_t;
}
extern "C" {
    pub fn pcre2_substring_copy_byname_32(
        arg1: *mut pcre2_match_data_32,
        arg2: PCRE2_SPTR32,
        arg3: *mut PCRE2_UCHAR32,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_copy_bynumber_32(
        arg1: *mut pcre2_match_data_32,
        arg2: u32,
        arg3: *mut PCRE2_UCHAR32,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_free_32(arg1: *mut PCRE2_UCHAR32);
}
extern "C" {
    pub fn pcre2_substring_get_byname_32(
        arg1: *mut pcre2_match_data_32,
        arg2: PCRE2_SPTR32,
        arg3: *mut *mut PCRE2_UCHAR32,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_get_bynumber_32(
        arg1: *mut pcre2_match_data_32,
        arg2: u32,
        arg3: *mut *mut PCRE2_UCHAR32,
        arg4: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_length_byname_32(
        arg1: *mut pcre2_match_data_32,
        arg2: PCRE2_SPTR32,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_length_bynumber_32(
        arg1: *mut pcre2_match_data_32,
        arg2: u32,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_nametable_scan_32(
        arg1: *const pcre2_code_32,
        arg2: PCRE2_SPTR32,
        arg3: *mut PCRE2_SPTR32,
        arg4: *mut PCRE2_SPTR32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_number_from_name_32(
        arg1: *const pcre2_code_32,
        arg2: PCRE2_SPTR32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_substring_list_free_32(arg1: *mut PCRE2_SPTR32);
}
extern "C" {
    pub fn pcre2_substring_list_get_32(
        arg1: *mut pcre2_match_data_32,
        arg2: *mut *mut *mut PCRE2_UCHAR32,
        arg3: *mut *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_serialize_encode_32(
        arg1: *mut *const pcre2_code_32,
        arg2: i32,
        arg3: *mut *mut u8,
        arg4: *mut size_t,
        arg5: *mut pcre2_general_context_32,
    ) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_decode_32(
        arg1: *mut *mut pcre2_code_32,
        arg2: i32,
        arg3: *const u8,
        arg4: *mut pcre2_general_context_32,
    ) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_get_number_of_codes_32(arg1: *const u8) -> i32;
}
extern "C" {
    pub fn pcre2_serialize_free_32(arg1: *mut u8);
}
extern "C" {
    pub fn pcre2_substitute_32(
        arg1: *const pcre2_code_32,
        arg2: PCRE2_SPTR32,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_32,
        arg7: *mut pcre2_match_context_32,
        arg8: PCRE2_SPTR32,
        arg9: size_t,
        arg10: *mut PCRE2_UCHAR32,
        arg11: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_compile_32(arg1: *mut pcre2_code_32, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_match_32(
        arg1: *const pcre2_code_32,
        arg2: PCRE2_SPTR32,
        arg3: size_t,
        arg4: size_t,
        arg5: u32,
        arg6: *mut pcre2_match_data_32,
        arg7: *mut pcre2_match_context_32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_jit_free_unused_memory_32(arg1: *mut pcre2_general_context_32);
}
extern "C" {
    pub fn pcre2_jit_stack_create_32(
        arg1: size_t,
        arg2: size_t,
        arg3: *mut pcre2_general_context_32,
    ) -> *mut pcre2_jit_stack_32;
}
extern "C" {
    pub fn pcre2_jit_stack_assign_32(
        arg1: *mut pcre2_match_context_32,
        arg2: pcre2_jit_callback_32,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pcre2_jit_stack_free_32(arg1: *mut pcre2_jit_stack_32);
}
extern "C" {
    pub fn pcre2_get_error_message_32(
        arg1: ::std::os::raw::c_int,
        arg2: *mut PCRE2_UCHAR32,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcre2_maketables_32(arg1: *mut pcre2_general_context_32) -> *const u8;
}
extern "C" {
    pub fn pcre2_maketables_free_32(arg1: *mut pcre2_general_context_32, arg2: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pcre_data {
    pub re: *mut pcre2_code_8,
    pub mctx: *mut pcre2_match_context_8,
    pub options: ::std::os::raw::c_int,
    pub expression: *mut ::std::os::raw::c_char,
    pub search_offset: u32,
}
#[test]
fn bindgen_test_layout_cli_pcre_data() {
    assert_eq!(
        ::std::mem::size_of::<cli_pcre_data>(),
        40usize,
        concat!("Size of: ", stringify!(cli_pcre_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_pcre_data>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_pcre_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_data>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_data),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_data>())).mctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_data),
            "::",
            stringify!(mctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_data>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_data),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_data>())).expression as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_data),
            "::",
            stringify!(expression)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_data>())).search_offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_data),
            "::",
            stringify!(search_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pcre_results {
    pub err: ::std::os::raw::c_int,
    pub match_: [u32; 2usize],
    pub match_data: *mut pcre2_match_data_8,
}
#[test]
fn bindgen_test_layout_cli_pcre_results() {
    assert_eq!(
        ::std::mem::size_of::<cli_pcre_results>(),
        24usize,
        concat!("Size of: ", stringify!(cli_pcre_results))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_pcre_results>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_pcre_results))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_results>())).err as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_results),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_results>())).match_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_results),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_results>())).match_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_results),
            "::",
            stringify!(match_data)
        )
    );
}
extern "C" {
    pub fn cli_pcre_init_internal() -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_addoptions(
        pd: *mut cli_pcre_data,
        opt: *mut *const ::std::os::raw::c_char,
        errout: ::std::os::raw::c_int,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_compile(
        pd: *mut cli_pcre_data,
        match_limit: ::std::os::raw::c_ulonglong,
        match_limit_recursion: ::std::os::raw::c_ulonglong,
        options: ::std::os::raw::c_uint,
        opt_override: ::std::os::raw::c_int,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_match(
        pd: *mut cli_pcre_data,
        buffer: *const ::std::os::raw::c_uchar,
        buflen: size_t,
        override_offset: size_t,
        options: ::std::os::raw::c_int,
        results: *mut cli_pcre_results,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cli_pcre_report(
        pd: *const cli_pcre_data,
        buffer: *const ::std::os::raw::c_uchar,
        buflen: size_t,
        rc: ::std::os::raw::c_int,
        results: *mut cli_pcre_results,
    );
}
extern "C" {
    pub fn cli_pcre_results_reset(
        results: *mut cli_pcre_results,
        pd: *const cli_pcre_data,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_results_free(results: *mut cli_pcre_results);
}
extern "C" {
    pub fn cli_pcre_free_single(pd: *mut cli_pcre_data);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pcre_off {
    pub offset: *mut u32,
    pub shift: *mut u32,
}
#[test]
fn bindgen_test_layout_cli_pcre_off() {
    assert_eq!(
        ::std::mem::size_of::<cli_pcre_off>(),
        16usize,
        concat!("Size of: ", stringify!(cli_pcre_off))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_pcre_off>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_pcre_off))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_off>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_off),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_off>())).shift as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_off),
            "::",
            stringify!(shift)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_pcre_meta {
    pub trigger: *mut ::std::os::raw::c_char,
    pub virname: *mut ::std::os::raw::c_char,
    pub lsigid: [u32; 3usize],
    pub pdata: cli_pcre_data,
    pub offdata: [u32; 4usize],
    pub offset_min: u32,
    pub offset_max: u32,
    pub flags: u32,
    pub statname: *mut ::std::os::raw::c_char,
    pub sigtime_id: u32,
    pub sigmatch_id: u32,
}
#[test]
fn bindgen_test_layout_cli_pcre_meta() {
    assert_eq!(
        ::std::mem::size_of::<cli_pcre_meta>(),
        120usize,
        concat!("Size of: ", stringify!(cli_pcre_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_pcre_meta>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_pcre_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).trigger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).virname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(virname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).lsigid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(lsigid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).pdata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).offdata as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(offdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).offset_min as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(offset_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).offset_max as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(offset_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).flags as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).statname as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(statname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).sigtime_id as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(sigtime_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_pcre_meta>())).sigmatch_id as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_pcre_meta),
            "::",
            stringify!(sigmatch_id)
        )
    );
}
extern "C" {
    pub fn cli_pcre_addpatt(
        root: *mut cli_matcher,
        virname: *const ::std::os::raw::c_char,
        trigger: *const ::std::os::raw::c_char,
        pattern: *const ::std::os::raw::c_char,
        cflags: *const ::std::os::raw::c_char,
        offset: *const ::std::os::raw::c_char,
        lsigid: *const u32,
        options: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_freemeta(root: *mut cli_matcher, pm: *mut cli_pcre_meta);
}
extern "C" {
    pub fn cli_pcre_freetable(root: *mut cli_matcher);
}
extern "C" {
    pub fn cli_pcre_init() -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_build(
        root: *mut cli_matcher,
        match_limit: ::std::os::raw::c_ulonglong,
        recmatch_limit: ::std::os::raw::c_ulonglong,
        dconf: *const cli_dconf,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_scanbuf(
        buffer: *const ::std::os::raw::c_uchar,
        length: u32,
        virname: *mut *const ::std::os::raw::c_char,
        res: *mut *mut cli_ac_result,
        root: *const cli_matcher,
        mdata: *mut cli_ac_data,
        data: *const cli_pcre_off,
        ctx: *mut cli_ctx,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_recaloff(
        root: *mut cli_matcher,
        data: *mut cli_pcre_off,
        info: *mut cli_target_info,
        ctx: *mut cli_ctx,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_pcre_freeoff(data: *mut cli_pcre_off);
}
extern "C" {
    pub fn cli_pcre_perf_print();
}
extern "C" {
    pub fn cli_pcre_perf_events_destroy();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bcomp_meta {
    pub virname: *mut ::std::os::raw::c_char,
    pub ref_subsigid: u16,
    pub lsigid: [u32; 3usize],
    pub offset: ssize_t,
    pub options: u16,
    pub byte_len: size_t,
    pub comps: *mut *mut cli_bcomp_comp,
    pub comp_count: u32,
}
#[test]
fn bindgen_test_layout_cli_bcomp_meta() {
    assert_eq!(
        ::std::mem::size_of::<cli_bcomp_meta>(),
        64usize,
        concat!("Size of: ", stringify!(cli_bcomp_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_bcomp_meta>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_bcomp_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_meta>())).virname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_meta),
            "::",
            stringify!(virname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_meta>())).ref_subsigid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_meta),
            "::",
            stringify!(ref_subsigid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_meta>())).lsigid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_meta),
            "::",
            stringify!(lsigid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_meta>())).offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_meta),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_meta>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_meta),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_meta>())).byte_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_meta),
            "::",
            stringify!(byte_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_meta>())).comps as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_meta),
            "::",
            stringify!(comps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_meta>())).comp_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_meta),
            "::",
            stringify!(comp_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bcomp_comp {
    pub comp_symbol: ::std::os::raw::c_char,
    pub comp_value: i64,
}
#[test]
fn bindgen_test_layout_cli_bcomp_comp() {
    assert_eq!(
        ::std::mem::size_of::<cli_bcomp_comp>(),
        16usize,
        concat!("Size of: ", stringify!(cli_bcomp_comp))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_bcomp_comp>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_bcomp_comp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_comp>())).comp_symbol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_comp),
            "::",
            stringify!(comp_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_bcomp_comp>())).comp_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_bcomp_comp),
            "::",
            stringify!(comp_value)
        )
    );
}
extern "C" {
    pub fn cli_bcomp_addpatt(
        root: *mut cli_matcher,
        virname: *const ::std::os::raw::c_char,
        hexsig: *const ::std::os::raw::c_char,
        lsigid: *const u32,
        options: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_bcomp_scanbuf(
        buffer: *const ::std::os::raw::c_uchar,
        buffer_length: size_t,
        res: *mut *mut cli_ac_result,
        root: *const cli_matcher,
        mdata: *mut cli_ac_data,
        ctx: *mut cli_ctx,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_bcomp_compare_check(
        f_buffer: *const ::std::os::raw::c_uchar,
        buffer_length: size_t,
        offset: ::std::os::raw::c_int,
        bm: *mut cli_bcomp_meta,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_bcomp_freemeta(root: *mut cli_matcher, bm: *mut cli_bcomp_meta);
}
extern "C" {
    pub fn cli_bcomp_chk_hex(
        buffer: *const ::std::os::raw::c_uchar,
        opt: u16,
        len: u32,
        check_only: u32,
    ) -> u16;
}
extern "C" {
    pub fn cli_bcomp_normalize_buffer(
        buffer: *const ::std::os::raw::c_uchar,
        byte_len: u32,
        pad_len: *mut u32,
        opt: u16,
        whitespace_only: u16,
    ) -> *mut ::std::os::raw::c_uchar;
}
pub const tdb_type_CLI_TDB_UINT: tdb_type = 0;
pub const tdb_type_CLI_TDB_RANGE: tdb_type = 1;
pub const tdb_type_CLI_TDB_STR: tdb_type = 2;
pub const tdb_type_CLI_TDB_RANGE2: tdb_type = 3;
pub const tdb_type_CLI_TDB_FTYPE: tdb_type = 4;
pub const tdb_type_CLI_TDB_FTYPE_EXPR: tdb_type = 5;
pub type tdb_type = ::std::os::raw::c_uint;
pub use self::tdb_type as tdb_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_lsig_tdb {
    pub val: *mut u32,
    pub range: *mut u32,
    pub str_: *mut ::std::os::raw::c_char,
    pub cnt: [tdb_type_t; 3usize],
    pub subsigs: u32,
    pub target: *const u32,
    pub engine: *const u32,
    pub nos: *const u32,
    pub ep: *const u32,
    pub filesize: *const u32,
    pub container: *const u32,
    pub handlertype: *const u32,
    pub intermediates: *const u32,
    pub icongrp1: *const ::std::os::raw::c_char,
    pub icongrp2: *const ::std::os::raw::c_char,
    pub macro_ptids: *mut u32,
    pub mempool: *mut mpool_t,
}
#[test]
fn bindgen_test_layout_cli_lsig_tdb() {
    assert_eq!(
        ::std::mem::size_of::<cli_lsig_tdb>(),
        136usize,
        concat!("Size of: ", stringify!(cli_lsig_tdb))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_lsig_tdb>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_lsig_tdb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).range as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).str_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).cnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).subsigs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(subsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).target as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).engine as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(engine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).nos as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(nos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).ep as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(ep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).filesize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(filesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).container as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(container)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).handlertype as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(handlertype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).intermediates as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(intermediates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).icongrp1 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(icongrp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).icongrp2 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(icongrp2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).macro_ptids as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(macro_ptids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_lsig_tdb>())).mempool as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_lsig_tdb),
            "::",
            stringify!(mempool)
        )
    );
}
pub const lsig_type_CLI_LSIG_NORMAL: lsig_type = 0;
pub const lsig_type_CLI_YARA_NORMAL: lsig_type = 1;
pub const lsig_type_CLI_YARA_OFFSET: lsig_type = 2;
pub type lsig_type = ::std::os::raw::c_uint;
pub use self::lsig_type as lsig_type_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cli_ac_lsig {
    pub id: u32,
    pub bc_idx: ::std::os::raw::c_uint,
    pub type_: lsig_type_t,
    pub flag: u8,
    pub u: cli_ac_lsig__bindgen_ty_1,
    pub virname: *const ::std::os::raw::c_char,
    pub tdb: cli_lsig_tdb,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cli_ac_lsig__bindgen_ty_1 {
    pub logic: *mut ::std::os::raw::c_char,
    pub code_start: *mut u8,
}
#[test]
fn bindgen_test_layout_cli_ac_lsig__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_lsig__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cli_ac_lsig__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_lsig__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_lsig__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_lsig__bindgen_ty_1>())).logic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig__bindgen_ty_1),
            "::",
            stringify!(logic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cli_ac_lsig__bindgen_ty_1>())).code_start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig__bindgen_ty_1),
            "::",
            stringify!(code_start)
        )
    );
}
#[test]
fn bindgen_test_layout_cli_ac_lsig() {
    assert_eq!(
        ::std::mem::size_of::<cli_ac_lsig>(),
        168usize,
        concat!("Size of: ", stringify!(cli_ac_lsig))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_ac_lsig>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_ac_lsig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_lsig>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_lsig>())).bc_idx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig),
            "::",
            stringify!(bc_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_lsig>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_lsig>())).flag as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_lsig>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_lsig>())).virname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig),
            "::",
            stringify!(virname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_ac_lsig>())).tdb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_ac_lsig),
            "::",
            stringify!(tdb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_matcher {
    pub type_: ::std::os::raw::c_uint,
    pub bm_shift: *mut u8,
    pub bm_suffix: *mut *mut cli_bm_patt,
    pub bm_pattab: *mut *mut cli_bm_patt,
    pub soff: *mut u32,
    pub soff_len: u32,
    pub bm_offmode: u32,
    pub bm_patterns: u32,
    pub bm_reloff_num: u32,
    pub bm_absoff_num: u32,
    pub hm: cli_hash_patt,
    pub hwild: cli_hash_wild,
    pub ac_partsigs: u32,
    pub ac_nodes: u32,
    pub ac_lists: u32,
    pub ac_patterns: u32,
    pub ac_lsigs: u32,
    pub ac_lsigtable: *mut *mut cli_ac_lsig,
    pub ac_root: *mut cli_ac_node,
    pub ac_nodetable: *mut *mut cli_ac_node,
    pub ac_listtable: *mut *mut cli_ac_list,
    pub ac_pattable: *mut *mut cli_ac_patt,
    pub ac_reloff: *mut *mut cli_ac_patt,
    pub ac_reloff_num: u32,
    pub ac_absoff_num: u32,
    pub ac_mindepth: u8,
    pub ac_maxdepth: u8,
    pub filter: *mut filter,
    pub maxpatlen: u16,
    pub ac_only: u8,
    pub pcre_metas: u32,
    pub pcre_metatable: *mut *mut cli_pcre_meta,
    pub pcre_reloff_num: u32,
    pub pcre_absoff_num: u32,
    pub bcomp_metas: u32,
    pub bcomp_metatable: *mut *mut cli_bcomp_meta,
    pub linked_bcs: u32,
    pub mempool: *mut mpool_t,
}
#[test]
fn bindgen_test_layout_cli_matcher() {
    assert_eq!(
        ::std::mem::size_of::<cli_matcher>(),
        384usize,
        concat!("Size of: ", stringify!(cli_matcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_matcher>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_matcher))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bm_shift as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bm_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bm_suffix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bm_suffix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bm_pattab as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bm_pattab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).soff as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(soff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).soff_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(soff_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bm_offmode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bm_offmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bm_patterns as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bm_patterns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bm_reloff_num as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bm_reloff_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bm_absoff_num as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bm_absoff_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).hm as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(hm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).hwild as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(hwild)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_partsigs as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_partsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_nodes as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_lists as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_lists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_patterns as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_patterns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_lsigs as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_lsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_lsigtable as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_lsigtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_root as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_nodetable as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_nodetable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_listtable as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_listtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_pattable as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_pattable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_reloff as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_reloff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_reloff_num as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_reloff_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_absoff_num as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_absoff_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_mindepth as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_mindepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_maxdepth as *const _ as usize },
        313usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_maxdepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).filter as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).maxpatlen as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(maxpatlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).ac_only as *const _ as usize },
        330usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(ac_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).pcre_metas as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(pcre_metas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).pcre_metatable as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(pcre_metatable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).pcre_reloff_num as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(pcre_reloff_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).pcre_absoff_num as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(pcre_absoff_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bcomp_metas as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bcomp_metas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).bcomp_metatable as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(bcomp_metatable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).linked_bcs as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(linked_bcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_matcher>())).mempool as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_matcher),
            "::",
            stringify!(mempool)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_cdb {
    pub virname: *mut ::std::os::raw::c_char,
    pub ctype: cli_file_t,
    pub name: regex_t,
    pub csize: [size_t; 2usize],
    pub fsizec: [size_t; 2usize],
    pub fsizer: [size_t; 2usize],
    pub encrypted: ::std::os::raw::c_int,
    pub filepos: [::std::os::raw::c_uint; 2usize],
    pub res1: ::std::os::raw::c_int,
    pub res2: *mut ::std::os::raw::c_void,
    pub next: *mut cli_cdb,
}
#[test]
fn bindgen_test_layout_cli_cdb() {
    assert_eq!(
        ::std::mem::size_of::<cli_cdb>(),
        128usize,
        concat!("Size of: ", stringify!(cli_cdb))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_cdb>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_cdb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).virname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(virname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).ctype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(ctype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).csize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(csize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).fsizec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(fsizec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).fsizer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(fsizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).encrypted as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(encrypted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).filepos as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(filepos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).res1 as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(res1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).res2 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(res2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_cdb>())).next as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_cdb),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_mtarget {
    pub target: [cli_file_t; 10usize],
    pub name: *const ::std::os::raw::c_char,
    pub idx: u8,
    pub ac_only: u8,
    pub enable_prefiltering: u8,
    pub target_count: u8,
}
#[test]
fn bindgen_test_layout_cli_mtarget() {
    assert_eq!(
        ::std::mem::size_of::<cli_mtarget>(),
        56usize,
        concat!("Size of: ", stringify!(cli_mtarget))
    );
    assert_eq!(
        ::std::mem::align_of::<cli_mtarget>(),
        8usize,
        concat!("Alignment of ", stringify!(cli_mtarget))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_mtarget>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_mtarget),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_mtarget>())).name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_mtarget),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_mtarget>())).idx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_mtarget),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_mtarget>())).ac_only as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_mtarget),
            "::",
            stringify!(ac_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_mtarget>())).enable_prefiltering as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_mtarget),
            "::",
            stringify!(enable_prefiltering)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cli_mtarget>())).target_count as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(cli_mtarget),
            "::",
            stringify!(target_count)
        )
    );
}
extern "C" {
    pub static cli_mtargets: [cli_mtarget; 15usize];
}
extern "C" {
    #[doc = " @brief Non-magic scan matching using a file buffer for input.  Older API"]
    #[doc = ""]
    #[doc = " This function is lower-level, requiring a call to `cli_exp_eval()` after the"]
    #[doc = " match to evaluate logical signatures and yara rules."]
    #[doc = ""]
    #[doc = " This function does not perform file type magic identification and does not use"]
    #[doc = " the file format scanners."]
    #[doc = ""]
    #[doc = " @param buffer            The buffer to be matched."]
    #[doc = " @param length            The length of the buffer or amount of bytets to match."]
    #[doc = " @param offset            Offset into the buffer from which to start matching."]
    #[doc = " @param ctx               The scanning context."]
    #[doc = " @param ftype             If specified, may limit signature matching trie by target type corresponding with the specified CL_TYPE"]
    #[doc = " @param[in,out] acdata    A list of pattern maching data structs to contain match results, one for each pattern matching trie."]
    #[doc = " @return cl_error_t"]
    pub fn cli_scan_buff(
        buffer: *const ::std::os::raw::c_uchar,
        length: u32,
        offset: u32,
        ctx: *mut cli_ctx,
        ftype: cli_file_t,
        acdata: *mut *mut cli_ac_data,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Non-magic scan matching using a file descriptor for input."]
    #[doc = ""]
    #[doc = " This function does not perform file type magic identification and does not use"]
    #[doc = " the file format scanners."]
    #[doc = ""]
    #[doc = " This function uses the newer cli_scan_fmap() scanning API."]
    #[doc = ""]
    #[doc = " @param desc          File descriptor to be used for input"]
    #[doc = " @param ctx           The scanning context."]
    #[doc = " @param ftype         If specified, may limit signature matching trie by target type corresponding with the specified CL_TYPE"]
    #[doc = " @param ftonly        Boolean indicating if the scan is for file-type detection only."]
    #[doc = " @param[out] ftoffset A list of file type signature matches with their corresponding offsets."]
    #[doc = " @param acmode        Use AC_SCAN_VIR and AC_SCAN_FT to set scanning modes."]
    #[doc = " @param[out] acres    A list of cli_ac_result AC pattern matching results."]
    #[doc = " @param name          (optional) Original name of the file (to set fmap name metadata)"]
    #[doc = " @return cl_error_t"]
    pub fn cli_scan_desc(
        desc: ::std::os::raw::c_int,
        ctx: *mut cli_ctx,
        ftype: cli_file_t,
        ftonly: u8,
        ftoffset: *mut *mut cli_matched_type,
        acmode: ::std::os::raw::c_uint,
        acres: *mut *mut cli_ac_result,
        name: *const ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Non-magic scan matching of the current fmap in the scan context.  Newer API."]
    #[doc = ""]
    #[doc = " This API will invoke cli_exp_eval() for you."]
    #[doc = ""]
    #[doc = " @param ctx           The scanning context."]
    #[doc = " @param ftype         If specified, may limit signature matching trie by target type corresponding with the specified CL_TYPE"]
    #[doc = " @param ftonly        Boolean indicating if the scan is for file-type detection only."]
    #[doc = " @param[out] ftoffset A list of file type signature matches with their corresponding offsets."]
    #[doc = " @param acmode        Use AC_SCAN_VIR and AC_SCAN_FT to set scanning modes."]
    #[doc = " @param[out] acres    A list of cli_ac_result AC pattern matching results."]
    #[doc = " @param refhash       MD5 hash of the current file, used to save time creating hashes and to limit scan recursion for the HandlerType logical signature FTM feature."]
    #[doc = " @return cl_error_t"]
    pub fn cli_scan_fmap(
        ctx: *mut cli_ctx,
        ftype: cli_file_t,
        ftonly: u8,
        ftoffset: *mut *mut cli_matched_type,
        acmode: ::std::os::raw::c_uint,
        acres: *mut *mut cli_ac_result,
        refhash: *mut ::std::os::raw::c_uchar,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Evaluate logical signatures and yara rules given the AC matching results"]
    #[doc = " from cli_scan_buff() / matcher_run()."]
    #[doc = ""]
    #[doc = " @param ctx           The scanning context."]
    #[doc = " @param root          The AC trie root to match with."]
    #[doc = " @param acdata        AC match results for a specific AC trie."]
    #[doc = " @param target_info   File metadata used to evaluate logical sig and yara rule options."]
    #[doc = " @param hash          Reference hash of the current file, used to limit recursion for the HandlerType logical signature FTM feature."]
    #[doc = " @return cl_error_t"]
    pub fn cli_exp_eval(
        ctx: *mut cli_ctx,
        root: *mut cli_matcher,
        acdata: *mut cli_ac_data,
        target_info: *mut cli_target_info,
        hash: *const ::std::os::raw::c_char,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cli_caloff(
        offstr: *const ::std::os::raw::c_char,
        info: *const cli_target_info,
        target: ::std::os::raw::c_uint,
        offdata: *mut u32,
        offset_min: *mut u32,
        offset_max: *mut u32,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Determine if an alert is a known false positive, using each fmap in the the ctx->container stack to check MD5, SHA1, and SHA256 hashes."]
    #[doc = ""]
    #[doc = " @param ctx           The scanning context."]
    #[doc = " @param vname         (Optional) The name of the signature alert."]
    #[doc = " @return cl_error_t   CL_CLEAN If an allow-list hash matches with one of the fmap hashes in the scan recursion stack."]
    #[doc = "                      CL_VIRUS If no allow-list hash matches."]
    pub fn cli_check_fp(ctx: *mut cli_ctx, vname: *const ::std::os::raw::c_char) -> cl_error_t;
}
extern "C" {
    pub fn cli_matchmeta(
        ctx: *mut cli_ctx,
        fname: *const ::std::os::raw::c_char,
        fsizec: size_t,
        fsizer: size_t,
        encrypted: ::std::os::raw::c_int,
        filepos: ::std::os::raw::c_uint,
        res1: ::std::os::raw::c_int,
        res2: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " Parse the executable headers and, if successful, populate exeinfo"]
    #[doc = ""]
    #[doc = " If target refers to a supported executable file type, the exe header"]
    #[doc = " will be parsed and, if successful, info->status will be set to 1."]
    #[doc = " If parsing the exe header fails, info->status will be set to -1."]
    #[doc = " The caller MUST destroy info via a call to cli_targetinfo_destroy"]
    #[doc = " regardless of what info->status is set to."]
    #[doc = ""]
    #[doc = " @param info A structure to populate with info from the exe header. This"]
    #[doc = "             MUST be initialized via cli_targetinfo_init prior to calling"]
    #[doc = " @param target the target executable file type. Possible values are:"]
    #[doc = "               - 1 - PE32 / PE32+"]
    #[doc = "               - 6 - ELF"]
    #[doc = "               - 9 - MachO"]
    #[doc = " @param ctx The current scan context"]
    pub fn cli_targetinfo(
        info: *mut cli_target_info,
        target: ::std::os::raw::c_uint,
        ctx: *mut cli_ctx,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_guts {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli_bcengine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_STRING {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regex_matcher {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phishcheck {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CACHE {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _yara_global {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filter {
    pub _address: u8,
}
