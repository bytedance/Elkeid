/* automatically generated by rust-bindgen 0.59.2 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

pub const CL_DB_DIRECTORY: u32 = 2048;
pub const CL_SCAN_GENERAL_YARAHIT: u32 = 32;
pub const CL_SCAN_PARSE_ELF: u32 = 2;
pub const CL_INIT_DEFAULT: u32 = 0;
pub type size_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub const cl_error_t_CL_CLEAN: cl_error_t = 0;
pub const cl_error_t_CL_SUCCESS: cl_error_t = 0;
pub const cl_error_t_CL_VIRUS: cl_error_t = 1;
pub const cl_error_t_CL_ENULLARG: cl_error_t = 2;
pub const cl_error_t_CL_EARG: cl_error_t = 3;
pub const cl_error_t_CL_EMALFDB: cl_error_t = 4;
pub const cl_error_t_CL_ECVD: cl_error_t = 5;
pub const cl_error_t_CL_EVERIFY: cl_error_t = 6;
pub const cl_error_t_CL_EUNPACK: cl_error_t = 7;
pub const cl_error_t_CL_EOPEN: cl_error_t = 8;
pub const cl_error_t_CL_ECREAT: cl_error_t = 9;
pub const cl_error_t_CL_EUNLINK: cl_error_t = 10;
pub const cl_error_t_CL_ESTAT: cl_error_t = 11;
pub const cl_error_t_CL_EREAD: cl_error_t = 12;
pub const cl_error_t_CL_ESEEK: cl_error_t = 13;
pub const cl_error_t_CL_EWRITE: cl_error_t = 14;
pub const cl_error_t_CL_EDUP: cl_error_t = 15;
pub const cl_error_t_CL_EACCES: cl_error_t = 16;
pub const cl_error_t_CL_ETMPFILE: cl_error_t = 17;
pub const cl_error_t_CL_ETMPDIR: cl_error_t = 18;
pub const cl_error_t_CL_EMAP: cl_error_t = 19;
pub const cl_error_t_CL_EMEM: cl_error_t = 20;
pub const cl_error_t_CL_ETIMEOUT: cl_error_t = 21;
pub const cl_error_t_CL_BREAK: cl_error_t = 22;
pub const cl_error_t_CL_EMAXREC: cl_error_t = 23;
pub const cl_error_t_CL_EMAXSIZE: cl_error_t = 24;
pub const cl_error_t_CL_EMAXFILES: cl_error_t = 25;
pub const cl_error_t_CL_EFORMAT: cl_error_t = 26;
pub const cl_error_t_CL_EPARSE: cl_error_t = 27;
pub const cl_error_t_CL_EBYTECODE: cl_error_t = 28;
pub const cl_error_t_CL_EBYTECODE_TESTFAIL: cl_error_t = 29;
pub const cl_error_t_CL_ELOCK: cl_error_t = 30;
pub const cl_error_t_CL_EBUSY: cl_error_t = 31;
pub const cl_error_t_CL_ESTATE: cl_error_t = 32;
pub const cl_error_t_CL_VERIFIED: cl_error_t = 33;
pub const cl_error_t_CL_ERROR: cl_error_t = 34;
pub const cl_error_t_CL_ELAST_ERROR: cl_error_t = 35;
pub type cl_error_t = ::std::os::raw::c_uint;
#[doc = " scan options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_scan_options {
    pub general: u32,
    pub parse: u32,
    pub heuristic: u32,
    pub mail: u32,
    pub dev: u32,
}
#[test]
fn bindgen_test_layout_cl_scan_options() {
    assert_eq!(
        ::std::mem::size_of::<cl_scan_options>(),
        20usize,
        concat!("Size of: ", stringify!(cl_scan_options))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_scan_options>(),
        4usize,
        concat!("Alignment of ", stringify!(cl_scan_options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).general as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(general)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).parse as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).heuristic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(heuristic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).mail as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(mail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cl_scan_options>())).dev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_scan_options),
            "::",
            stringify!(dev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_engine {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Initialize the ClamAV library."]
    #[doc = ""]
    #[doc = " @param initoptions   Unused."]
    #[doc = " @return cl_error_t   CL_SUCCESS if everything initalized correctly."]
    pub fn cl_init(initoptions: ::std::os::raw::c_uint) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Allocate a new scanning engine and initialize default settings."]
    #[doc = ""]
    #[doc = " The engine should be freed with `cl_engine_free()`."]
    #[doc = ""]
    #[doc = " @return struct cl_engine* Pointer to the scanning engine."]
    pub fn cl_engine_new() -> *mut cl_engine;
}
pub const cl_engine_field_CL_ENGINE_MAX_SCANSIZE: cl_engine_field = 0;
pub const cl_engine_field_CL_ENGINE_MAX_FILESIZE: cl_engine_field = 1;
pub const cl_engine_field_CL_ENGINE_MAX_RECURSION: cl_engine_field = 2;
pub const cl_engine_field_CL_ENGINE_MAX_FILES: cl_engine_field = 3;
pub const cl_engine_field_CL_ENGINE_MIN_CC_COUNT: cl_engine_field = 4;
pub const cl_engine_field_CL_ENGINE_MIN_SSN_COUNT: cl_engine_field = 5;
pub const cl_engine_field_CL_ENGINE_PUA_CATEGORIES: cl_engine_field = 6;
pub const cl_engine_field_CL_ENGINE_DB_OPTIONS: cl_engine_field = 7;
pub const cl_engine_field_CL_ENGINE_DB_VERSION: cl_engine_field = 8;
pub const cl_engine_field_CL_ENGINE_DB_TIME: cl_engine_field = 9;
pub const cl_engine_field_CL_ENGINE_AC_ONLY: cl_engine_field = 10;
pub const cl_engine_field_CL_ENGINE_AC_MINDEPTH: cl_engine_field = 11;
pub const cl_engine_field_CL_ENGINE_AC_MAXDEPTH: cl_engine_field = 12;
pub const cl_engine_field_CL_ENGINE_TMPDIR: cl_engine_field = 13;
pub const cl_engine_field_CL_ENGINE_KEEPTMP: cl_engine_field = 14;
pub const cl_engine_field_CL_ENGINE_BYTECODE_SECURITY: cl_engine_field = 15;
pub const cl_engine_field_CL_ENGINE_BYTECODE_TIMEOUT: cl_engine_field = 16;
pub const cl_engine_field_CL_ENGINE_BYTECODE_MODE: cl_engine_field = 17;
pub const cl_engine_field_CL_ENGINE_MAX_EMBEDDEDPE: cl_engine_field = 18;
pub const cl_engine_field_CL_ENGINE_MAX_HTMLNORMALIZE: cl_engine_field = 19;
pub const cl_engine_field_CL_ENGINE_MAX_HTMLNOTAGS: cl_engine_field = 20;
pub const cl_engine_field_CL_ENGINE_MAX_SCRIPTNORMALIZE: cl_engine_field = 21;
pub const cl_engine_field_CL_ENGINE_MAX_ZIPTYPERCG: cl_engine_field = 22;
pub const cl_engine_field_CL_ENGINE_FORCETODISK: cl_engine_field = 23;
pub const cl_engine_field_CL_ENGINE_DISABLE_CACHE: cl_engine_field = 24;
pub const cl_engine_field_CL_ENGINE_DISABLE_PE_STATS: cl_engine_field = 25;
pub const cl_engine_field_CL_ENGINE_STATS_TIMEOUT: cl_engine_field = 26;
pub const cl_engine_field_CL_ENGINE_MAX_PARTITIONS: cl_engine_field = 27;
pub const cl_engine_field_CL_ENGINE_MAX_ICONSPE: cl_engine_field = 28;
pub const cl_engine_field_CL_ENGINE_MAX_RECHWP3: cl_engine_field = 29;
pub const cl_engine_field_CL_ENGINE_MAX_SCANTIME: cl_engine_field = 30;
pub const cl_engine_field_CL_ENGINE_PCRE_MATCH_LIMIT: cl_engine_field = 31;
pub const cl_engine_field_CL_ENGINE_PCRE_RECMATCH_LIMIT: cl_engine_field = 32;
pub const cl_engine_field_CL_ENGINE_PCRE_MAX_FILESIZE: cl_engine_field = 33;
pub const cl_engine_field_CL_ENGINE_DISABLE_PE_CERTS: cl_engine_field = 34;
pub const cl_engine_field_CL_ENGINE_PE_DUMPCERTS: cl_engine_field = 35;
pub type cl_engine_field = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct yr_hit_cb_ctx {
    pub hits: *mut *mut ::std::os::raw::c_char,
    pub hit_cnt: u32,
}
#[test]
fn bindgen_test_layout_yr_hit_cb_ctx() {
    assert_eq!(
        ::std::mem::size_of::<yr_hit_cb_ctx>(),
        16usize,
        concat!("Size of: ", stringify!(yr_hit_cb_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<yr_hit_cb_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(yr_hit_cb_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<yr_hit_cb_ctx>())).hits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(yr_hit_cb_ctx),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<yr_hit_cb_ctx>())).hit_cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(yr_hit_cb_ctx),
            "::",
            stringify!(hit_cnt)
        )
    );
}
pub type yr_hit_ctx = yr_hit_cb_ctx;
extern "C" {
    #[doc = " @brief Free a yara hit data pointer."]
    #[doc = ""]
    #[doc = " @param ctx      The hit data struct pointer."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_yr_hit_cb_ctx_free(ctx: *mut yr_hit_ctx) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Init a yara hit data pointer."]
    #[doc = ""]
    #[doc = " @return ctx   The hit data struct pointer."]
    pub fn cl_yr_hit_cb_ctx_init() -> *mut yr_hit_ctx;
}
extern "C" {
    #[doc = " @brief Set a numerical engine option."]
    #[doc = ""]
    #[doc = " Caution: changing options for an engine that is in-use is not thread-safe!"]
    #[doc = ""]
    #[doc = " @param engine            An initialized scan engine."]
    #[doc = " @param cl_engine_field   A CL_ENGINE option."]
    #[doc = " @param num               The new engine option value."]
    #[doc = " @return cl_error_t       CL_SUCCESS if successfully set."]
    #[doc = " @return cl_error_t       CL_EARG if the field number was incorrect."]
    #[doc = " @return cl_error_t       CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_set_num(
        engine: *mut cl_engine,
        field: cl_engine_field,
        num: ::std::os::raw::c_longlong,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Prepare the scanning engine."]
    #[doc = ""]
    #[doc = " Called this after all required databases have been loaded and settings have"]
    #[doc = " been applied."]
    #[doc = ""]
    #[doc = " @param engine        A scan engine."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_compile(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Add a reference count to the engine."]
    #[doc = ""]
    #[doc = " Thread safety mechanism so that the engine is not free'd by another thread."]
    #[doc = ""]
    #[doc = " The engine is initialized with refcount = 1, so this only needs to be called"]
    #[doc = " for additional scanning threads."]
    #[doc = ""]
    #[doc = " @param engine        A scan engine."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_addref(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Free an engine."]
    #[doc = ""]
    #[doc = " Will lower the reference count on an engine. If the reference count hits"]
    #[doc = " zero, the engine will be freed."]
    #[doc = ""]
    #[doc = " @param engine        A scan engine."]
    #[doc = " @return cl_error_t   CL_SUCCESS if successful."]
    #[doc = " @return cl_error_t   CL_ENULLARG null arguments were provided."]
    pub fn cl_engine_free(engine: *mut cl_engine) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a filename."]
    #[doc = ""]
    #[doc = " @param filename          Filepath of the file to be scanned."]
    #[doc = " @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature."]
    #[doc = " @param[out] scanned      The number of bytes scanned."]
    #[doc = " @param engine            The scanning engine."]
    #[doc = " @param scanoptions       Scanning options."]
    #[doc = " @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occured during the scan."]
    pub fn cl_scanfile(
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Scan a file, given a filename."]
    #[doc = ""]
    #[doc = " This callback variant allows the caller to provide a context structure that caller provided callback functions can interpret."]
    #[doc = ""]
    #[doc = " @param filename          Filepath of the file to be scanned."]
    #[doc = " @param[out] virname      Will be set to a statically allocated (i.e. needs not be freed) signature name if the scan matches against a signature."]
    #[doc = " @param[out] scanned      The number of bytes scanned."]
    #[doc = " @param engine            The scanning engine."]
    #[doc = " @param scanoptions       Scanning options."]
    #[doc = " @param[in,out] context   An opaque context structure allowing the caller to record details about the sample being scanned."]
    #[doc = " @return cl_error_t       CL_CLEAN, CL_VIRUS, or an error code if an error occured during the scan."]
    pub fn cl_scanfile_callback(
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
extern "C" {
    #[doc = " @brief Load the signature databases found at the path."]
    #[doc = ""]
    #[doc = " @param path          May be a file or directory."]
    #[doc = " @param engine        The engine to load the signatures into"]
    #[doc = " @param[out] signo    The number of signatures loaded"]
    #[doc = " @param dboptions     Database load bitflag field. See the CL_DB_* defines, above."]
    #[doc = " @return cl_error_t"]
    pub fn cl_load(
        path: *const ::std::os::raw::c_char,
        engine: *mut cl_engine,
        signo: *mut ::std::os::raw::c_uint,
        dboptions: ::std::os::raw::c_uint,
    ) -> cl_error_t;
}
extern "C" {
    pub fn cl_strerror(clerror: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_fmap {
    _unused: [u8; 0],
}
pub type cl_fmap_t = cl_fmap;
extern "C" {
    #[doc = " @brief Open a map given a buffer."]
    #[doc = ""]
    #[doc = " Open a map for scanning custom data, where the data is already in memory,"]
    #[doc = " either in the form of a buffer, a memory mapped file, etc."]
    #[doc = " Note that the memory [start, start+len) must be the _entire_ file,"]
    #[doc = " you can't give it parts of a file and expect detection to work."]
    #[doc = ""]
    #[doc = " @param start         Pointer to a buffer of data."]
    #[doc = " @param len           Length in bytes of the data."]
    #[doc = " @return cl_fmap_t*   A map representing the buffer."]
    pub fn cl_fmap_open_memory(start: *const ::std::os::raw::c_void, len: size_t)
        -> *mut cl_fmap_t;
}
extern "C" {
    #[doc = " @brief Releases resources associated with the map."]
    #[doc = ""]
    #[doc = " You should release any resources you hold only after (handles, maps) calling"]
    #[doc = " this function."]
    #[doc = ""]
    #[doc = " @param map           Map to be closed."]
    pub fn cl_fmap_close(arg1: *mut cl_fmap_t);
}
extern "C" {
    #[doc = " @brief Scan custom data."]
    #[doc = ""]
    #[doc = " @param map           Buffer to be scanned, in form of a cl_fmap_t."]
    #[doc = " @param filename      Name of data origin. Does not need to be an actual"]
    #[doc = "                      file on disk. May be NULL if a name is not available."]
    #[doc = " @param[out] virname  Pointer to receive the signature match name name if a"]
    #[doc = "                      signature matched."]
    #[doc = " @param[out] scanned  Number of bytes scanned."]
    #[doc = " @param engine        The scanning engine."]
    #[doc = " @param scanoptions   The scanning options struct."]
    #[doc = " @param context       An application-defined context struct, opaque to"]
    #[doc = "                      libclamav. May be used within your callback functions."]
    #[doc = " @return cl_error_t   CL_CLEAN if no signature matched. CL_VIRUS if a"]
    #[doc = "                      signature matched. Another CL_E* error code if an"]
    #[doc = "                      error occured."]
    pub fn cl_scanmap_callback(
        map: *mut cl_fmap_t,
        filename: *const ::std::os::raw::c_char,
        virname: *mut *const ::std::os::raw::c_char,
        scanned: *mut ::std::os::raw::c_ulong,
        engine: *const cl_engine,
        scanoptions: *mut cl_scan_options,
        context: *mut ::std::os::raw::c_void,
    ) -> cl_error_t;
}
